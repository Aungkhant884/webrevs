{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=panama\n@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,executable,symlink,message,whitespace\n@@ -10,2 +10,1 @@\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\\\.(?:0|[1-9][0-9]*)){0,4})(?:\\\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\\\d{1,3})?-(?:(?:b\\\\d{2,3})|(?:ga)))|(?:hs\\\\d\\\\d(?:\\\\.\\\\d{1,2})?-b\\\\d\\\\d)\n@@ -18,5 +17,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n-ignore-tabs=.*\\.gmk|Makefile\n-\n-[checks \"merge\"]\n-message=Merge\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java\n@@ -25,2 +20,1 @@\n-reviewers=1\n-ignore=duke\n+committers=1\n@@ -30,6 +24,0 @@\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2460,0 +2460,2 @@\n+    case Op_CompressV:\n+    case Op_CompressM:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5748,0 +5748,65 @@\n+\n+\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct mcompress(pReg dst, pReg mask, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM mask));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $mask\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($mask$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (CompressV src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -3220,1 +3220,65 @@\n-%}dnl\n+%}\n+\n+\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct mcompress(pReg dst, pReg mask, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM mask));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $mask\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($mask$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (CompressV src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":65,"deletions":1,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -3663,1 +3663,2 @@\n-  \/\/ SVE create index starting from and incremented by immediate\n+  \/\/ SVE Index Generation:\n+  \/\/ Create index starting from and incremented by immediate\n@@ -3666,0 +3667,1 @@\n+    assert(T != Q, \"invalid size\");\n@@ -3671,0 +3673,10 @@\n+  \/\/ SVE Index Generation:\n+  \/\/ Create index starting from general-purpose register and incremented by immediate\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T, Register Rn, int imm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(0b1, 21);\n+    sf(imm, 20, 16), f(0b010001, 15, 10);\n+    zrf(Rn, 5), rf(Zd, 0);\n+  }\n+\n@@ -3679,0 +3691,8 @@\n+  \/\/ Shuffle active elements of vector to the right and fill with zero\n+  void sve_compact(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, PRegister Pg) {\n+    starti;\n+    assert(T == S || T == D, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b100001100, 21, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1270,0 +1270,113 @@\n+\n+\/\/ Pack active elements of src, under the control of mask, into the lowest-numbered elements of dst.\n+\/\/ Any remaining elements of dst will be filled with zero.\n+\/\/ Clobbers: rscratch1\n+\/\/ Preserves: src, mask\n+void C2_MacroAssembler::sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                                           FloatRegister vtmp1, FloatRegister vtmp2,\n+                                           PRegister pgtmp) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+  assert_different_registers(dst, src, vtmp1, vtmp2);\n+  assert_different_registers(mask, pgtmp);\n+\n+  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n+  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n+  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_dup(vtmp2, H, 0);\n+\n+  \/\/ Extend lowest half to type INT.\n+  \/\/ dst = 00004444 00003333 00002222 00001111\n+  sve_uunpklo(dst, S, src);\n+  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n+  sve_punpklo(pgtmp, mask);\n+  \/\/ Pack the active elements in size of type INT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 00000000 00004444 00002222 00001111\n+  sve_compact(dst, S, dst, pgtmp);\n+  \/\/ Narrow the result back to type SHORT.\n+  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n+  sve_uzp1(dst, H, dst, vtmp2);\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch1 = 3\n+  sve_cntp(rscratch1, S, ptrue, pgtmp);\n+\n+  \/\/ Repeat to the highest half.\n+  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n+  sve_punpkhi(pgtmp, mask);\n+  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n+  sve_uunpkhi(vtmp1, S, src);\n+  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n+  sve_compact(vtmp1, S, vtmp1, pgtmp);\n+  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n+  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n+  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch1, rscratch1);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, H, rscratch1, 1);\n+  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n+  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_orr(dst, dst, vtmp1);\n+}\n+\n+\/\/ Clobbers: rscratch1, rscratch2\n+\/\/ Preserves: src, mask\n+void C2_MacroAssembler::sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                                          FloatRegister vtmp3, FloatRegister vtmp4,\n+                                          PRegister ptmp, PRegister pgtmp) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n+  assert_different_registers(mask, ptmp, pgtmp);\n+  \/\/ Example input:   src   = 88 77 66 45 44 33 22 11\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01\n+  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ Extend lowest half to type SHORT.\n+  \/\/ vtmp1 = 0044 0033 0022 0011\n+  sve_uunpklo(vtmp1, H, src);\n+  \/\/ ptmp = 0001 0000 0001 0001\n+  sve_punpklo(ptmp, mask);\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch2 = 3\n+  sve_cntp(rscratch2, H, ptrue, ptmp);\n+  \/\/ Pack the active elements in size of type SHORT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 0000 0044 0022 0011\n+  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ Narrow the result back to type BYTE.\n+  \/\/ dst = 00 00 00 00 00 44 22 11\n+  sve_uzp1(dst, B, dst, vtmp4);\n+\n+  \/\/ Repeat to the highest half.\n+  \/\/ ptmp = 0001 0000 0000 0001\n+  sve_punpkhi(ptmp, mask);\n+  \/\/ vtmp1 = 0088 0077 0066 0055\n+  sve_uunpkhi(vtmp2, H, src);\n+  \/\/ vtmp1 = 0000 0000 0088 0055\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n+  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n+\n+  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n+  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch2, rscratch2);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, B, rscratch2, 1);\n+  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n+  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 00 00 00 88 55 44 22 11\n+  sve_orr(dst, dst, vtmp1);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -114,0 +114,12 @@\n+  \/\/ Pack active elements of src, under the control of mask, into the\n+  \/\/ lowest-numbered elements of dst. Any remaining elements of dst will\n+  \/\/ be filled with zero.\n+  void sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                         FloatRegister vtmp1, FloatRegister vtmp2,\n+                         FloatRegister vtmp3, FloatRegister vtmp4,\n+                         PRegister ptmp, PRegister pgtmp);\n+\n+  void sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                          PRegister pgtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7911,0 +7911,78 @@\n+void Assembler::evexpandps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n+void Assembler::evexpandpd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x89, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x89, (0xC0 | encode));\n+}\n+\n@@ -7954,1 +8032,1 @@\n-  assert(VM_Version::supports_avx(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8013,1 +8091,1 @@\n-  assert(VM_Version::supports_avx2(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8026,1 +8104,1 @@\n-  assert(VM_Version::supports_avx(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -11516,0 +11594,73 @@\n+\n+void Assembler::evpcompressb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x63, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x63, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8B, (0xC0 | encode));\n+}\n+\n+void Assembler::evcompressps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcompresspd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8A, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":154,"deletions":3,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2191,1 +2191,0 @@\n-  void pdep(Register dst, Register src1, Register src2);\n@@ -2193,1 +2192,1 @@\n-\n+  void pdep(Register dst, Register src1, Register src2);\n@@ -2566,0 +2565,15 @@\n+  \/\/ Vector compress\/expand instructions.\n+  void evpcompressb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evcompressps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evcompresspd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n+  void evpexpandb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evexpandps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evexpandpd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n@@ -2722,0 +2736,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4303,0 +4303,65 @@\n+\n+void C2_MacroAssembler::vector_mask_compress(KRegister dst, KRegister src, Register rtmp1,\n+                                             Register rtmp2, int mask_len) {\n+  kmov(rtmp1, src);\n+  andq(rtmp1, (0xFFFFFFFFFFFFFFFFUL >> (64 - mask_len)));\n+  mov64(rtmp2, -1L);\n+  pext(rtmp2, rtmp2, rtmp1);\n+  kmov(dst, rtmp2);\n+}\n+\n+void C2_MacroAssembler::vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,\n+                                               bool merge, BasicType bt, int vec_enc) {\n+  if (opcode == Op_CompressV) {\n+    switch(bt) {\n+    case T_BYTE:\n+      evpcompressb(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evpcompressw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evpcompressd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_FLOAT:\n+      evcompressps(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_LONG:\n+      evpcompressq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_DOUBLE:\n+      evcompresspd(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+    }\n+  } else {\n+    assert(opcode == Op_ExpandV, \"\");\n+    switch(bt) {\n+    case T_BYTE:\n+      evpexpandb(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evpexpandw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evpexpandd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_FLOAT:\n+      evexpandps(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_LONG:\n+      evpexpandq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_DOUBLE:\n+      evexpandpd(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -95,0 +95,5 @@\n+  void vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,\n+                              bool merge, BasicType bt, int vec_enc);\n+\n+  void vector_mask_compress(KRegister dst, KRegister src, Register rtmp1, Register rtmp2, int mask_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1608,0 +1608,11 @@\n+    case Op_CompressM:\n+      if (!VM_Version::supports_avx512vl() || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (!VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1829,1 +1840,1 @@\n-      if(is_subword_type(bt)) {\n+      if (is_subword_type(bt)) {\n@@ -1856,0 +1867,17 @@\n+    case Op_CompressM:\n+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512_vbmi2()) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 ) {\n+        return false;\n+      }\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -8874,0 +8902,28 @@\n+\n+\/\/ --------------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct vcompress_expand_reg_evex(vec dst, vec src, kReg mask) %{\n+  match(Set dst (CompressV src mask));\n+  match(Set dst (ExpandV src mask));\n+  format %{ \"vector_compress_expand $dst, $src, $mask\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vector_len = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    __ vector_compress_expand(opcode, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, false, bt, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcompress_mask_reg_evex(kReg dst, kReg mask, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n+  match(Set dst (CompressM mask));\n+  effect(TEMP rtmp1, TEMP rtmp2, KILL cr);\n+  format %{ \"mask_compress_evex $dst, $mask\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    assert(this->in(1)->bottom_type()->isa_vectmask(), \"\");\n+    int mask_len = Matcher::vector_length(this);\n+    __ vector_mask_compress($dst$$KRegister, $mask$$KRegister, $rtmp1$$Register, $rtmp2$$Register, mask_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -4219,0 +4219,1 @@\n+    \"CompressV\", \"ExpandV\", \"CompressM\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                          \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                                   \\\n@@ -1110,0 +1110,11 @@\n+  do_intrinsic(_VectorComExp, jdk_internal_vm_vector_VectorSupport, vector_comexp_op_name, vector_comexp_op_sig, F_S)                           \\\n+   do_signature(vector_comexp_op_sig, \"(I\"                                                                                                     \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"I\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                          \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$ComExpOperation;)\"                                                \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\")                                                  \\\n+   do_name(vector_comexp_op_name,     \"comExpOp\")                                                                                              \\\n@@ -1218,1 +1229,1 @@\n-  LAST_COMPILER_INLINE = _VectorMaskOp,\n+  LAST_COMPILER_INLINE = _VectorComExp,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -509,0 +509,4 @@\n+  case vmIntrinsics::_VectorComExp:\n+    if (!Matcher::match_rule_supported(Op_CompressM)) return false;\n+    if (!Matcher::match_rule_supported(Op_CompressV)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -417,0 +417,3 @@\n+macro(CompressV)\n+macro(CompressM)\n+macro(ExpandV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -693,0 +693,2 @@\n+  case vmIntrinsics::_VectorComExp:\n+    return inline_vector_compress_expand();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,0 +333,2 @@\n+  bool inline_vector_compress_expand();\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2266,0 +2266,3 @@\n+    case Op_CompressV:\n+    case Op_CompressM:\n+    case Op_ExpandV:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,0 +179,3 @@\n+class ExpandVNode;\n+class CompressVNode;\n+class CompressMNode;\n@@ -716,0 +719,3 @@\n+        DEFINE_CLASS_ID(CompressV, Vector, 4)\n+        DEFINE_CLASS_ID(ExpandV, Vector, 5)\n+        DEFINE_CLASS_ID(CompressM, Vector, 6)\n@@ -946,1 +952,4 @@\n-  DEFINE_CLASS_QUERY(VectorReinterpret);\n+  DEFINE_CLASS_QUERY(VectorReinterpret)\n+  DEFINE_CLASS_QUERY(CompressV)\n+  DEFINE_CLASS_QUERY(ExpandV)\n+  DEFINE_CLASS_QUERY(CompressM)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-      if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, elem_bt)) {\n+      if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, elem_bt) ||\n+          !Matcher::match_rule_supported_vector(Op_LoadVector, num_elem, T_BOOLEAN)) {\n@@ -255,1 +256,2 @@\n-    if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, type)) {\n+    if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, type) ||\n+        !Matcher::match_rule_supported_vector(Op_LoadVector, num_elem, T_BOOLEAN)) {\n@@ -268,1 +270,2 @@\n-    if (!Matcher::match_rule_supported_vector(Op_VectorStoreMask, num_elem, type)) {\n+    if (!Matcher::match_rule_supported_vector(Op_VectorStoreMask, num_elem, type) ||\n+        !Matcher::match_rule_supported_vector(Op_StoreVector, num_elem, T_BOOLEAN)) {\n@@ -680,8 +683,0 @@\n-  if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n-                    Op_LoadVector, num_elem, type2name(T_BOOLEAN));\n-    }\n-    return false; \/\/ not supported\n-  }\n-\n@@ -689,1 +684,1 @@\n-  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskUseLoad)) {\n@@ -1034,10 +1029,0 @@\n-    if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s\/mask vlen=%d etype=bit ismask=no\",\n-                      is_store, is_store ? \"store\" : \"load\",\n-                      num_elem);\n-      }\n-      set_map(old_map);\n-      set_sp(old_sp);\n-      return false; \/\/ not supported\n-    }\n@@ -1081,1 +1066,3 @@\n-\n+    if (is_mask) {\n+      val = gvn().transform(VectorStoreMaskNode::make(gvn(), val, elem_bt, num_elem));\n+    }\n@@ -2721,0 +2708,94 @@\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  M extends VectorMask<E>,\n+\/\/  E>\n+\/\/  V comExpOp(int opr,\n+\/\/             Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+\/\/             int length, V v, M m,\n+\/\/             CmpExpOperation<V, M> defaultImpl)\n+bool LibraryCallKit::inline_vector_compress_expand() {\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || mask_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || mask_klass->const_oop() == NULL ||\n+      elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt);\n+\n+  if (!arch_supports_vector(opc, num_elem, elem_bt, VecMaskUseLoad)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+                    opc, num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  Node* opd1 = NULL;\n+  const TypeInstPtr* vbox_type = NULL;\n+  if (opc != Op_CompressM) {\n+    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+    vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+    opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    if (opd1 == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** unbox failed vector=%s\",\n+                      NodeClassNames[argument(5)->Opcode()]);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  assert(is_vector_mask(mbox_klass), \"argument(6) should be a mask class\");\n+  const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);\n+\n+  Node* mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+  if (mask == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed mask=%s\",\n+                    NodeClassNames[argument(6)->Opcode()]);\n+    }\n+    return false;\n+  }\n+\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, opc == Op_CompressM);\n+  Node* operation = gvn().transform(VectorNode::make(opc, opd1, mask, vt));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  const TypeInstPtr* box_type = opc == Op_CompressM ? mbox_type : vbox_type;\n+  Node* vbox = box_vector(operation, box_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":104,"deletions":23,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -572,0 +572,4 @@\n+\n+  case Op_ExpandV: return new ExpandVNode(n1, n2, vt);\n+  case Op_CompressV: return new CompressVNode(n1, n2, vt);\n+  case Op_CompressM: assert(n1 == NULL, \"\"); return new CompressMNode(n2, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -749,0 +749,31 @@\n+\/\/------------------------------CompressVNode--------------------------------------\n+\/\/ Vector compress\n+class CompressVNode: public VectorNode {\n+ public:\n+  CompressVNode(Node* vec, Node* mask, const TypeVect* vt) :\n+      VectorNode(vec, mask, vt) {\n+    init_class_id(Class_CompressV);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class CompressMNode: public VectorNode {\n+ public:\n+  CompressMNode(Node* mask, const TypeVect* vt) :\n+      VectorNode(mask, vt) {\n+    init_class_id(Class_CompressM);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------ExpandVNode--------------------------------------\n+\/\/ Vector expand\n+class ExpandVNode: public VectorNode {\n+ public:\n+  ExpandVNode(Node* vec, Node* mask, const TypeVect* vt) :\n+      VectorNode(vec, mask, vt) {\n+    init_class_id(Class_ExpandV);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -1376,1 +1407,0 @@\n-    \/\/ assert(mask->is_VectorMask(), \"VectorBlendNode requires that third argument be a mask\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -446,0 +446,46 @@\n+    case VECTOR_OP_EXPAND: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   \/\/ fall-through\n+        case T_LONG:  \/\/ fall-through\n+        case T_FLOAT: \/\/ fall-through\n+        case T_DOUBLE: return Op_ExpandV;\n+        default: fatal(\"EXPAND: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_COMPRESS: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   \/\/ fall-through\n+        case T_LONG:  \/\/ fall-through\n+        case T_FLOAT: \/\/ fall-through\n+        case T_DOUBLE: return Op_CompressV;\n+        default: fatal(\"COMPRESS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_MASK_COMPRESS: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   \/\/ fall-through\n+        case T_LONG:  \/\/ fall-through\n+        case T_FLOAT: \/\/ fall-through\n+        case T_DOUBLE: return Op_CompressM;\n+        default: fatal(\"MASK_COMPRESS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_BIT_COUNT: {\n+     switch (bt) {\n+        case T_BYTE:  \/\/ Returning Op_PopCountI\n+        case T_SHORT: \/\/ for byte and short types temporarily\n+        case T_INT:   return Op_PopCountI;\n+        case T_LONG:  return Op_PopCountL;\n+        default: fatal(\"BIT_COUNT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    VECTOR_OP_BIT_COUNT = 3,\n@@ -92,0 +93,4 @@\n+    VECTOR_OP_COMPRESS = 26,\n+    VECTOR_OP_EXPAND = 27,\n+    VECTOR_OP_MASK_COMPRESS = 28,\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1767,0 +1767,2 @@\n+  declare_c2_type(CompressVNode, VectorNode)                              \\\n+  declare_c2_type(ExpandVNode, VectorNode)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    public static final int VECTOR_OP_BIT_COUNT = 3;\n@@ -79,0 +80,5 @@\n+    \/\/ Compression expansion operations\n+    public static final int VECTOR_OP_COMPRESS = 26;\n+    public static final int VECTOR_OP_EXPAND = 27;\n+    public static final int VECTOR_OP_MASK_COMPRESS = 28;\n+\n@@ -440,1 +446,1 @@\n-                                          V extends Vector<?>> {\n+                                          V extends VectorPayload> {\n@@ -447,1 +453,1 @@\n-     V extends Vector<?>>\n+     V extends VectorPayload>\n@@ -629,0 +635,20 @@\n+    public interface ComExpOperation<V extends Vector<?>,\n+                                     M extends VectorMask<?>> {\n+        VectorPayload apply(V v, M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     M extends VectorMask<E>,\n+     E>\n+    VectorPayload comExpOp(int opr,\n+                           Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                           int length, V v, M m,\n+                           ComExpOperation<V, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v, m);\n+    }\n+\n+    \/* ============================================================================ *\/\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import jdk.internal.misc.Unsafe;\n+\n+import jdk.internal.vm.vector.VectorSupport;\n+\n@@ -80,1 +84,9 @@\n-        System.arraycopy(getBits(), 0, bits, i, length());\n+        AbstractSpecies<E> vsp = (AbstractSpecies<E>) vectorSpecies();\n+        int laneCount = vsp.laneCount();\n+        i = VectorIntrinsics.checkFromIndexSize(i, laneCount, bits.length);\n+        VectorSupport.store(\n+            vsp.maskType(), vsp.elementType(), laneCount,\n+            bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,\n+            this, bits, i,\n+            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, idx, s.length()));\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte128Vector compress(VectorMask<Byte> m) {\n+        return (Byte128Vector)\n+            super.compressTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte128Vector expand(VectorMask<Byte> m) {\n+        return (Byte128Vector)\n+            super.expandTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -674,0 +690,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte128Mask compress() {\n+            return (Byte128Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte128Vector.class, Byte128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte256Vector compress(VectorMask<Byte> m) {\n+        return (Byte256Vector)\n+            super.compressTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte256Vector expand(VectorMask<Byte> m) {\n+        return (Byte256Vector)\n+            super.expandTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -706,0 +722,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte256Mask compress() {\n+            return (Byte256Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte256Vector.class, Byte256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte512Vector compress(VectorMask<Byte> m) {\n+        return (Byte512Vector)\n+            super.compressTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte512Vector expand(VectorMask<Byte> m) {\n+        return (Byte512Vector)\n+            super.expandTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -770,0 +786,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte512Mask compress() {\n+            return (Byte512Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte512Vector.class, Byte512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte64Vector compress(VectorMask<Byte> m) {\n+        return (Byte64Vector)\n+            super.compressTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte64Vector expand(VectorMask<Byte> m) {\n+        return (Byte64Vector)\n+            super.expandTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -658,0 +674,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte64Mask compress() {\n+            return (Byte64Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte64Vector.class, Byte64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector compress(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.compressTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector expand(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.expandTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -644,0 +660,9 @@\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask compress() {\n+            return (ByteMaxMask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -354,0 +354,30 @@\n+    static ByteVector expandHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ByteVector compressHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -628,0 +658,3 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) bitCount(a));\n+\n@@ -1754,0 +1787,4 @@\n+    static int bitCount(byte a) {\n+        return Integer.bitCount((int)a & 0xFF);\n+    }\n+\n@@ -2361,0 +2398,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector compress(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Byte>>\n+    ByteVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ByteVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   byte.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector expand(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Byte>>\n+    ByteVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ByteVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   byte.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Double128Vector compress(VectorMask<Double> m) {\n+        return (Double128Vector)\n+            super.compressTemplate(Double128Mask.class,\n+                                   (Double128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector expand(VectorMask<Double> m) {\n+        return (Double128Vector)\n+            super.expandTemplate(Double128Mask.class,\n+                                   (Double128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -635,0 +651,9 @@\n+        @Override\n+        @ForceInline\n+        public Double128Mask compress() {\n+            return (Double128Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double128Vector.class, Double128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Double256Vector compress(VectorMask<Double> m) {\n+        return (Double256Vector)\n+            super.compressTemplate(Double256Mask.class,\n+                                   (Double256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double256Vector expand(VectorMask<Double> m) {\n+        return (Double256Vector)\n+            super.expandTemplate(Double256Mask.class,\n+                                   (Double256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -639,0 +655,9 @@\n+        @Override\n+        @ForceInline\n+        public Double256Mask compress() {\n+            return (Double256Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double256Vector.class, Double256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Double512Vector compress(VectorMask<Double> m) {\n+        return (Double512Vector)\n+            super.compressTemplate(Double512Mask.class,\n+                                   (Double512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double512Vector expand(VectorMask<Double> m) {\n+        return (Double512Vector)\n+            super.expandTemplate(Double512Mask.class,\n+                                   (Double512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -647,0 +663,9 @@\n+        @Override\n+        @ForceInline\n+        public Double512Mask compress() {\n+            return (Double512Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double512Vector.class, Double512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Double64Vector compress(VectorMask<Double> m) {\n+        return (Double64Vector)\n+            super.compressTemplate(Double64Mask.class,\n+                                   (Double64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double64Vector expand(VectorMask<Double> m) {\n+        return (Double64Vector)\n+            super.expandTemplate(Double64Mask.class,\n+                                   (Double64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -633,0 +649,9 @@\n+        @Override\n+        @ForceInline\n+        public Double64Mask compress() {\n+            return (Double64Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double64Vector.class, Double64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector compress(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.compressTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector expand(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.expandTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -632,0 +648,9 @@\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask compress() {\n+            return (DoubleMaxMask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -354,0 +354,30 @@\n+    static DoubleVector expandHelper(Vector<Double> v, VectorMask<Double> m) {\n+        VectorSpecies<Double> vsp = m.vectorSpecies();\n+        DoubleVector r  = (DoubleVector) vsp.zero();\n+        DoubleVector vi = (DoubleVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static DoubleVector compressHelper(Vector<Double> v, VectorMask<Double> m) {\n+        VectorSpecies<Double> vsp = m.vectorSpecies();\n+        DoubleVector r  = (DoubleVector) vsp.zero();\n+        DoubleVector vi = (DoubleVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -606,0 +636,1 @@\n+\n@@ -1597,0 +1628,1 @@\n+\n@@ -2207,0 +2239,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector compress(VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Double>>\n+    DoubleVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (DoubleVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   double.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector expand(VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Double>>\n+    DoubleVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (DoubleVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   double.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Float128Vector compress(VectorMask<Float> m) {\n+        return (Float128Vector)\n+            super.compressTemplate(Float128Mask.class,\n+                                   (Float128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float128Vector expand(VectorMask<Float> m) {\n+        return (Float128Vector)\n+            super.expandTemplate(Float128Mask.class,\n+                                   (Float128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -639,0 +655,9 @@\n+        @Override\n+        @ForceInline\n+        public Float128Mask compress() {\n+            return (Float128Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float128Vector.class, Float128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Float256Vector compress(VectorMask<Float> m) {\n+        return (Float256Vector)\n+            super.compressTemplate(Float256Mask.class,\n+                                   (Float256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float256Vector expand(VectorMask<Float> m) {\n+        return (Float256Vector)\n+            super.expandTemplate(Float256Mask.class,\n+                                   (Float256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -647,0 +663,9 @@\n+        @Override\n+        @ForceInline\n+        public Float256Mask compress() {\n+            return (Float256Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float256Vector.class, Float256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Float512Vector compress(VectorMask<Float> m) {\n+        return (Float512Vector)\n+            super.compressTemplate(Float512Mask.class,\n+                                   (Float512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float512Vector expand(VectorMask<Float> m) {\n+        return (Float512Vector)\n+            super.expandTemplate(Float512Mask.class,\n+                                   (Float512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -663,0 +679,9 @@\n+        @Override\n+        @ForceInline\n+        public Float512Mask compress() {\n+            return (Float512Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float512Vector.class, Float512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public Float64Vector compress(VectorMask<Float> m) {\n+        return (Float64Vector)\n+            super.compressTemplate(Float64Mask.class,\n+                                   (Float64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float64Vector expand(VectorMask<Float> m) {\n+        return (Float64Vector)\n+            super.expandTemplate(Float64Mask.class,\n+                                   (Float64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -635,0 +651,9 @@\n+        @Override\n+        @ForceInline\n+        public Float64Mask compress() {\n+            return (Float64Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float64Vector.class, Float64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,0 +458,16 @@\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector compress(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.compressTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector expand(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.expandTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -632,0 +648,9 @@\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask compress() {\n+            return (FloatMaxMask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -354,0 +354,30 @@\n+    static FloatVector expandHelper(Vector<Float> v, VectorMask<Float> m) {\n+        VectorSpecies<Float> vsp = m.vectorSpecies();\n+        FloatVector r  = (FloatVector) vsp.zero();\n+        FloatVector vi = (FloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static FloatVector compressHelper(Vector<Float> v, VectorMask<Float> m) {\n+        VectorSpecies<Float> vsp = m.vectorSpecies();\n+        FloatVector r  = (FloatVector) vsp.zero();\n+        FloatVector vi = (FloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -606,0 +636,1 @@\n+\n@@ -1605,0 +1636,1 @@\n+\n@@ -2219,0 +2251,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector compress(VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float>>\n+    FloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (FloatVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   float.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector expand(VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float>>\n+    FloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (FloatVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   float.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Int128Vector compress(VectorMask<Integer> m) {\n+        return (Int128Vector)\n+            super.compressTemplate(Int128Mask.class,\n+                                   (Int128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int128Vector expand(VectorMask<Integer> m) {\n+        return (Int128Vector)\n+            super.expandTemplate(Int128Mask.class,\n+                                   (Int128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -650,0 +666,9 @@\n+        @Override\n+        @ForceInline\n+        public Int128Mask compress() {\n+            return (Int128Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int128Vector.class, Int128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Int256Vector compress(VectorMask<Integer> m) {\n+        return (Int256Vector)\n+            super.compressTemplate(Int256Mask.class,\n+                                   (Int256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int256Vector expand(VectorMask<Integer> m) {\n+        return (Int256Vector)\n+            super.expandTemplate(Int256Mask.class,\n+                                   (Int256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -658,0 +674,9 @@\n+        @Override\n+        @ForceInline\n+        public Int256Mask compress() {\n+            return (Int256Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int256Vector.class, Int256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Int512Vector compress(VectorMask<Integer> m) {\n+        return (Int512Vector)\n+            super.compressTemplate(Int512Mask.class,\n+                                   (Int512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int512Vector expand(VectorMask<Integer> m) {\n+        return (Int512Vector)\n+            super.expandTemplate(Int512Mask.class,\n+                                   (Int512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -674,0 +690,9 @@\n+        @Override\n+        @ForceInline\n+        public Int512Mask compress() {\n+            return (Int512Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int512Vector.class, Int512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Int64Vector compress(VectorMask<Integer> m) {\n+        return (Int64Vector)\n+            super.compressTemplate(Int64Mask.class,\n+                                   (Int64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int64Vector expand(VectorMask<Integer> m) {\n+        return (Int64Vector)\n+            super.expandTemplate(Int64Mask.class,\n+                                   (Int64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -646,0 +662,9 @@\n+        @Override\n+        @ForceInline\n+        public Int64Mask compress() {\n+            return (Int64Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int64Vector.class, Int64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public IntMaxVector compress(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.compressTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector expand(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.expandTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -644,0 +660,9 @@\n+        @Override\n+        @ForceInline\n+        public IntMaxMask compress() {\n+            return (IntMaxMask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -354,0 +354,30 @@\n+    static IntVector expandHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static IntVector compressHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -628,0 +658,3 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.bitCount(a));\n+\n@@ -1753,0 +1786,1 @@\n+\n@@ -2360,0 +2394,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector compress(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Integer>>\n+    IntVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (IntVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   int.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector expand(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Integer>>\n+    IntVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (IntVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   int.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -461,0 +461,16 @@\n+    @Override\n+    @ForceInline\n+    public Long128Vector compress(VectorMask<Long> m) {\n+        return (Long128Vector)\n+            super.compressTemplate(Long128Mask.class,\n+                                   (Long128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long128Vector expand(VectorMask<Long> m) {\n+        return (Long128Vector)\n+            super.expandTemplate(Long128Mask.class,\n+                                   (Long128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -636,0 +652,9 @@\n+        @Override\n+        @ForceInline\n+        public Long128Mask compress() {\n+            return (Long128Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long128Vector.class, Long128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -461,0 +461,16 @@\n+    @Override\n+    @ForceInline\n+    public Long256Vector compress(VectorMask<Long> m) {\n+        return (Long256Vector)\n+            super.compressTemplate(Long256Mask.class,\n+                                   (Long256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long256Vector expand(VectorMask<Long> m) {\n+        return (Long256Vector)\n+            super.expandTemplate(Long256Mask.class,\n+                                   (Long256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -640,0 +656,9 @@\n+        @Override\n+        @ForceInline\n+        public Long256Mask compress() {\n+            return (Long256Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long256Vector.class, Long256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -461,0 +461,16 @@\n+    @Override\n+    @ForceInline\n+    public Long512Vector compress(VectorMask<Long> m) {\n+        return (Long512Vector)\n+            super.compressTemplate(Long512Mask.class,\n+                                   (Long512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long512Vector expand(VectorMask<Long> m) {\n+        return (Long512Vector)\n+            super.expandTemplate(Long512Mask.class,\n+                                   (Long512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -648,0 +664,9 @@\n+        @Override\n+        @ForceInline\n+        public Long512Mask compress() {\n+            return (Long512Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long512Vector.class, Long512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -461,0 +461,16 @@\n+    @Override\n+    @ForceInline\n+    public Long64Vector compress(VectorMask<Long> m) {\n+        return (Long64Vector)\n+            super.compressTemplate(Long64Mask.class,\n+                                   (Long64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long64Vector expand(VectorMask<Long> m) {\n+        return (Long64Vector)\n+            super.expandTemplate(Long64Mask.class,\n+                                   (Long64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -634,0 +650,9 @@\n+        @Override\n+        @ForceInline\n+        public Long64Mask compress() {\n+            return (Long64Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long64Vector.class, Long64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -461,0 +461,16 @@\n+    @Override\n+    @ForceInline\n+    public LongMaxVector compress(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.compressTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector expand(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.expandTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -634,0 +650,9 @@\n+        @Override\n+        @ForceInline\n+        public LongMaxMask compress() {\n+            return (LongMaxMask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -354,0 +354,30 @@\n+    static LongVector expandHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static LongVector compressHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -586,0 +616,3 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.bitCount(a));\n+\n@@ -1666,0 +1699,1 @@\n+\n@@ -2226,0 +2260,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector compress(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Long>>\n+    LongVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (LongVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   long.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector expand(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Long>>\n+    LongVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (LongVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   long.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Short128Vector compress(VectorMask<Short> m) {\n+        return (Short128Vector)\n+            super.compressTemplate(Short128Mask.class,\n+                                   (Short128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short128Vector expand(VectorMask<Short> m) {\n+        return (Short128Vector)\n+            super.expandTemplate(Short128Mask.class,\n+                                   (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -658,0 +674,9 @@\n+        @Override\n+        @ForceInline\n+        public Short128Mask compress() {\n+            return (Short128Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short128Vector.class, Short128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Short256Vector compress(VectorMask<Short> m) {\n+        return (Short256Vector)\n+            super.compressTemplate(Short256Mask.class,\n+                                   (Short256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short256Vector expand(VectorMask<Short> m) {\n+        return (Short256Vector)\n+            super.expandTemplate(Short256Mask.class,\n+                                   (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -674,0 +690,9 @@\n+        @Override\n+        @ForceInline\n+        public Short256Mask compress() {\n+            return (Short256Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short256Vector.class, Short256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Short512Vector compress(VectorMask<Short> m) {\n+        return (Short512Vector)\n+            super.compressTemplate(Short512Mask.class,\n+                                   (Short512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short512Vector expand(VectorMask<Short> m) {\n+        return (Short512Vector)\n+            super.expandTemplate(Short512Mask.class,\n+                                   (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -706,0 +722,9 @@\n+        @Override\n+        @ForceInline\n+        public Short512Mask compress() {\n+            return (Short512Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short512Vector.class, Short512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public Short64Vector compress(VectorMask<Short> m) {\n+        return (Short64Vector)\n+            super.compressTemplate(Short64Mask.class,\n+                                   (Short64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector expand(VectorMask<Short> m) {\n+        return (Short64Vector)\n+            super.expandTemplate(Short64Mask.class,\n+                                   (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -650,0 +666,9 @@\n+        @Override\n+        @ForceInline\n+        public Short64Mask compress() {\n+            return (Short64Mask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short64Vector.class, Short64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -471,0 +471,16 @@\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector compress(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.compressTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector expand(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.expandTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -644,0 +660,9 @@\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask compress() {\n+            return (ShortMaxMask)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -354,0 +354,30 @@\n+    static ShortVector expandHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ShortVector compressHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -628,0 +658,3 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) bitCount(a));\n+\n@@ -1754,0 +1787,4 @@\n+    static int bitCount(short a) {\n+        return Integer.bitCount((int)a & 0xFFFF);\n+    }\n+\n@@ -2361,0 +2398,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector compress(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Short>>\n+    ShortVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ShortVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   short.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector expand(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Short>>\n+    ShortVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ShortVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   short.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1042,0 +1042,6 @@\n+ * <li>The {@link #compress(VectorMask)} and {@link #expand(VectorMask)}\n+ * methods, which select up to {@code VLENGTH} lanes from an\n+ * input vector, and assemble them in lane order.  The selection of lanes\n+ * is controlled by a {@code VectorMask}, with set lane elements mapping, by\n+ * compression or expansion in lane order, source lanes to destination lanes.\n+ *\n@@ -2692,0 +2698,38 @@\n+    \/**\n+     * Compresses the lane elements of this vector selecting lanes\n+     * under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that compresses the lane\n+     * elements of this vector as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the element at lane {@code N}\n+     * of input vector is selected and stored into the output\n+     * vector contiguously starting from the lane {@code 0}.\n+     * All the upper remaining lanes, if any, of the output\n+     * vector are set to zero.\n+     *\n+     * @param m the mask controlling the compression\n+     * @return the compressed lane elements of this vector\n+     *\/\n+    public abstract Vector<E> compress(VectorMask<E> m);\n+\n+    \/**\n+     * Expands the lane elements of this vector\n+     * under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that expands the contiguous lane\n+     * elements of this vector into lanes of an output vector\n+     * as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the next contiguous element of input vector\n+     * starting from lane {@code 0} is selected and stored into the output\n+     * vector at lane {@code N}.\n+     * All the remaining lanes, if any, of the output vector are set to zero.\n+     *\n+     * @param m the mask controlling the compression\n+     * @return the expanded lane elements of this vector\n+     *\/\n+    public abstract Vector<E> expand(VectorMask<E> m);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -624,0 +624,11 @@\n+    \/**\n+     * Compresses set lanes from this mask.\n+     *\n+     * Returns a mask which is a series of {@code N} set lanes\n+     * followed by a series of unset lanes, where {@code N} is\n+     * the true count of this mask.\n+     *\n+     * @return the compressed mask of this mask\n+     *\/\n+    public abstract VectorMask<E> compress();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -453,0 +453,2 @@\n+    \/** Produce {@code bitCount(a)} *\/\n+    public static final Unary BIT_COUNT = unary(\"BIT_COUNT\", \"bitCount\", VectorSupport.VECTOR_OP_BIT_COUNT, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,0 +358,30 @@\n+    static $abstractvectortype$ expandHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0,j = 0; i < vsp.length(); i++) {\n+            if(m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static $abstractvectortype$ compressHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for(int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -654,0 +684,9 @@\n+#if[!FP]\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+#if[intOrLong]\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n+#else[intOrLong]\n+                    v0.uOp(m, (i, a) -> ($type$) bitCount(a));\n+#end[intOrLong]\n+#end[!FP]\n+\n@@ -1995,0 +2034,12 @@\n+#if[!FP]\n+#if[!intOrLong]\n+    static int bitCount($type$ a) {\n+#if[short]\n+        return Integer.bitCount((int)a & 0xFFFF);\n+#else[short]\n+        return Integer.bitCount((int)a & 0xFF);\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+\n@@ -2658,0 +2709,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector compress(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<$Boxtype$>>\n+    $Type$Vector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return ($Type$Vector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   $type$.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector expand(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<$Boxtype$>>\n+    $Type$Vector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return ($Type$Vector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   $type$.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public $vectortype$ compress(VectorMask<$Boxtype$> m) {\n+        return ($vectortype$)\n+            super.compressTemplate($masktype$.class,\n+                                   ($masktype$) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public $vectortype$ expand(VectorMask<$Boxtype$> m) {\n+        return ($vectortype$)\n+            super.expandTemplate($masktype$.class,\n+                                   ($masktype$) m);  \/\/ specialize\n+    }\n+\n@@ -917,0 +933,9 @@\n+        @Override\n+        @ForceInline\n+        public $masktype$ compress() {\n+            return ($masktype$)VectorSupport.comExpOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                $vectortype$.class, $masktype$.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1711,0 +1711,4 @@\n+                        [\"index\",   \"__ sve_index(z6, __ B, r5, 2);\",                     \"index\\tz6.b, w5, #2\"],\n+                        [\"index\",   \"__ sve_index(z6, __ H, r5, 3);\",                     \"index\\tz6.h, w5, #3\"],\n+                        [\"index\",   \"__ sve_index(z6, __ S, r5, 4);\",                     \"index\\tz6.s, w5, #4\"],\n+                        [\"index\",   \"__ sve_index(z7, __ D, r5, 5);\",                     \"index\\tz7.d, x5, #5\"],\n@@ -1753,0 +1757,2 @@\n+                        [\"compact\", \"__ sve_compact(z16, __ S, z16, p1);\",                \"compact\\tz16.s, p1, z16.s\"],\n+                        [\"compact\", \"__ sve_compact(z16, __ D, z16, p1);\",                \"compact\\tz16.d, p1, z16.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -852,0 +852,4 @@\n+    __ sve_index(z6, __ B, r5, 2);                     \/\/       index   z6.b, w5, #2\n+    __ sve_index(z6, __ H, r5, 3);                     \/\/       index   z6.h, w5, #3\n+    __ sve_index(z6, __ S, r5, 4);                     \/\/       index   z6.s, w5, #4\n+    __ sve_index(z7, __ D, r5, 5);                     \/\/       index   z7.d, x5, #5\n@@ -894,0 +898,2 @@\n+    __ sve_compact(z16, __ S, z16, p1);                \/\/       compact z16.s, p1, z16.s\n+    __ sve_compact(z16, __ D, z16, p1);                \/\/       compact z16.d, p1, z16.d\n@@ -1321,1 +1327,2 @@\n-    0x04a14026,     0x0568aca7,     0x05b23230,     0x853040af,\n+    0x04a14026,     0x042244a6,     0x046344a6,     0x04a444a6,\n+    0x04e544a7,     0x0568aca7,     0x05b23230,     0x853040af,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+% Benchmarking Vector API\n+\n+Benchmarks are generted from scripts in this directory to `test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation`\n+\n+## Test selection\n+Run benchmarks from the top level git dir using:\n+\n+``` shell\n+make test TEST=\"micro:<benchmark-name>\" CONF=linux-x86_64-server-release\n+\n+### One Test\n+make test TEST=\"micro:Int64Vector\" CONF=linux-x86_64-server-release\n+\n+### Run all tests -- WARNING requires ~4-5 hours\n+make test TEST=\"micro:org.openjdk.bench.jdk.incubator.vector\" CONF=linux-x86_64-server-release\n+```\n+\n+### JMH Configuration\n+See `https:\/\/github.com\/openjdk\/jdk\/blob\/master\/doc\/testing.md` or `doc\/testing.md` dir in this git repo for more detailed steps on running the benchmarks for Vector API at `test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation`.\n+\n+From doc\/testing.md:\n+To be able to run microbenchmarks, `configure` needs to know where to find the\n+JMH dependency. Use `--with-jmh=<path to JMH jars>` to point to a directory\n+containing the core JMH and transitive dependencies. The recommended\n+dependencies can be retrieved by running `sh make\/devkit\/createJMHBundle.sh`,\n+after which `--with-jmh=build\/jmh\/jars` should work.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BENCHMARKS.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4317,0 +4366,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5179,0 +5264,49 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n@@ -5591,0 +5725,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4317,0 +4366,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5179,0 +5264,49 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n@@ -5591,0 +5725,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4317,0 +4366,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5179,0 +5264,49 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n@@ -5591,0 +5725,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4317,0 +4366,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5179,0 +5264,49 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n@@ -5591,0 +5725,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -267,0 +267,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4322,0 +4371,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5184,0 +5269,49 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n@@ -5596,0 +5730,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3267,0 +3316,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4579,0 +4664,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4970,0 +5064,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3267,0 +3316,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4579,0 +4664,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4970,0 +5064,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3267,0 +3316,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4579,0 +4664,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4970,0 +5064,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3267,0 +3316,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4579,0 +4664,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4970,0 +5064,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -267,0 +267,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3272,0 +3321,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4584,0 +4669,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4975,0 +5069,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3277,0 +3326,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4547,0 +4632,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4948,0 +5042,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3277,0 +3326,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4547,0 +4632,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4948,0 +5042,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3277,0 +3326,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4547,0 +4632,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4948,0 +5042,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3277,0 +3326,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4547,0 +4632,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4948,0 +5042,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -267,0 +267,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3282,0 +3331,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4552,0 +4637,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -4953,0 +5047,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4282,0 +4331,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5144,0 +5229,49 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5545,0 +5679,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4282,0 +4331,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5144,0 +5229,49 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5545,0 +5679,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4282,0 +4331,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5144,0 +5229,49 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5545,0 +5679,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4282,0 +4331,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5144,0 +5229,49 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5545,0 +5679,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -267,0 +267,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4287,0 +4336,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5149,0 +5234,49 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5550,0 +5684,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -219,0 +219,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4232,0 +4281,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5094,0 +5179,49 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5429,0 +5563,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -219,0 +219,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4232,0 +4281,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5094,0 +5179,49 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5429,0 +5563,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -219,0 +219,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4232,0 +4281,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5094,0 +5179,49 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5429,0 +5563,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -219,0 +219,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4232,0 +4281,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5094,0 +5179,49 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5429,0 +5563,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -224,0 +224,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4237,0 +4286,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5099,0 +5184,49 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5434,0 +5568,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4307,0 +4356,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5169,0 +5254,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::BIT_COUNT);\n+    }\n+\n+\n@@ -5570,0 +5704,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4307,0 +4356,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5169,0 +5254,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::BIT_COUNT);\n+    }\n+\n+\n@@ -5570,0 +5704,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4307,0 +4356,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5169,0 +5254,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::BIT_COUNT);\n+    }\n+\n+\n@@ -5570,0 +5704,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -262,0 +262,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4307,0 +4356,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5169,0 +5254,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::BIT_COUNT);\n+    }\n+\n+\n@@ -5570,0 +5704,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -267,0 +267,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4312,0 +4361,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5174,0 +5259,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n@@ -5575,0 +5709,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-VECTORTESTS_HOME=\"$(pwd)\"\n-JDK_SRC_HOME=\".\/..\/..\/..\/..\/..\/\"\n+JDK_SRC_HOME=\"$(git rev-parse --show-toplevel)\"\n+VECTORTESTS_HOME=\"$JDK_SRC_HOME\/test\/jdk\/jdk\/incubator\/vector\/\"\n@@ -38,0 +38,3 @@\n+TESTNG_JAR=\"${TESTNG_PLUGIN}\/plugins\/org.testng.source_6.13.1.r201712040515.jar\"\n+TESTNG_RUN_JAR=\"${TESTNG_PLUGIN}\/plugins\/org.testng_6.13.1.r201712040515.jar\"\n+JCOMMANDER_JAR=\"${TESTNG_PLUGIN}\/plugins\/com.beust.jcommander_1.72.0.jar\"\n@@ -42,1 +45,2 @@\n-PERF_DEST=\"benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/\"\n+PERF_DEST=\"$JDK_SRC_HOME\/test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/config.sh","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+compressexpand_template=\"CompressExpand\"\n@@ -494,0 +495,3 @@\n+# Compress\/Expand\n+gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n+\n@@ -548,0 +552,3 @@\n+gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n+gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n+gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -254,1 +254,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+\n+    @Benchmark\n+    public Object [[TEST]][[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.[[TEST]], bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Compare.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\n+    @Benchmark\n+    public Object compress[[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand[[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress[[TEST_TYPE]][[OP_NAME]]() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-CompressExpand.template","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.max(ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-Max-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.min(ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-Min-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.max(ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Max-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.min(ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Min-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]]);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)([[TEST_OP]]);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-Masked-op.template","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-op-math.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Blend-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < ms.length; i++) {\n+                r [[TEST_OP]]= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-BoolReduction-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+    void broadcastShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Broadcast.template","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= [[TEST_OP]](as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Compare.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\n+    @Benchmark\n+    public void compressScalar[[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = new $type$[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar[[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = new $type$[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar[[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-CompressExpand.template","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+    void rearrangeShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    $type$ a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Rearrange.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = ($type$)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-Max-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = ($type$)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-Min-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r [[TEST_OP]]= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r = ($type$)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Max-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r = ($type$)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Min-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r [[TEST_OP]]= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Masked-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)([[TEST_OP]]);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Ternary-Masked-op.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Ternary-op.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= ([[TEST_OP]]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Test.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-Masked-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-math.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op-math.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = ($type$)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Zero.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-footer.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","status":"copied"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $Type$Scalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static $bitstype$ bits($type$ e) {\n+        return {#if[FP]?$Type$.$type$To$Bitstype$Bits(e):e};\n+    }\n+\n+    $type$[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> ($type$)(2*i));\n+        bs = fill(i -> ($type$)(i+1));\n+        cs = fill(i -> ($type$)(i+5));\n+        rs = fill(i -> ($type$)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> as;\n+    final IntFunction<$type$[]> fb = vl -> bs;\n+    final IntFunction<$type$[]> fc = vl -> cs;\n+    final IntFunction<$type$[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n+\n+#if[BITWISE]\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+\n+    @Benchmark\n+    public Object [[TEST]][[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.[[TEST]]));\n+            }\n+        }\n+\n+        return m;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Test.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-footer.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","status":"copied"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.$Type$Vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $vectorbenchtype$ extends AbstractVectorBenchmark {\n+#if[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_MAX;\n+#else[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_$bits$;\n+#end[MaxBit]\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+#if[BITWISE]\n+    static void replaceZero($type$[] a, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero($type$[] a, boolean[] mask, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+#end[BITWISE]\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    $type$[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> ($type$)(2*i));\n+        b = fill(i -> ($type$)(i+1));\n+        c = fill(i -> ($type$)(i+5));\n+        r = fill(i -> ($type$)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> a;\n+    final IntFunction<$type$[]> fb = vl -> b;\n+    final IntFunction<$type$[]> fc = vl -> c;\n+    final IntFunction<$type$[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-wrapper.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void compress$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void expand$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-CompressExpand.template","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -487,0 +487,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompress$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -293,0 +293,49 @@\n+    static void assertcompressArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], ($type$)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  ByteBuffer directInRo, directOutRo;\n+  ByteBuffer heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+\n+    directInRo = directIn.asReadOnlyBuffer();\n+    directOutRo = directOut.asReadOnlyBuffer();\n+\n+    heapInRo = heapIn.asReadOnlyBuffer();\n+    heapOutRo = heapOut.asReadOnlyBuffer();\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers2() {\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers3() {\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(directInRo, directOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers4() {\n+    copyIntoNotInlined(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, directOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedBuffers5() {\n+    copyIntoNotInlined(directIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, directIn);\n+    copyIntoNotInlined(heapIn, directOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyIntoNotInlined(heapIn, directOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = heapIn.array();\n+    byte[] out = heapOut.array();\n+\n+    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyIntoNotInlined(ByteBuffer in, ByteBuffer out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class MaskCastOperationsBenchmark {\n+    VectorMask<Byte> bmask64;\n+    VectorMask<Byte> bmask128;\n+    VectorMask<Byte> bmask256;\n+\n+    VectorMask<Short> smask64;\n+    VectorMask<Short> smask128;\n+    VectorMask<Short> smask256;\n+    VectorMask<Short> smask512;\n+\n+    VectorMask<Integer> imask64;\n+    VectorMask<Integer> imask128;\n+    VectorMask<Integer> imask256;\n+    VectorMask<Integer> imask512;\n+\n+    VectorMask<Long> lmask128;\n+    VectorMask<Long> lmask256;\n+    VectorMask<Long> lmask512;\n+\n+    static final boolean [] mask_arr = {\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false,\n+       true, true, true, true, true, true, true, true,\n+       true, true, true, true, true, true, true, true,\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false\n+    };\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        bmask64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        bmask128 = VectorMask.fromArray(ByteVector.SPECIES_128, mask_arr, 0);\n+        bmask256 = VectorMask.fromArray(ByteVector.SPECIES_256, mask_arr, 0);\n+\n+        smask64 = VectorMask.fromArray(ShortVector.SPECIES_64, mask_arr, 0);\n+        smask128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        smask256 = VectorMask.fromArray(ShortVector.SPECIES_256, mask_arr, 0);\n+        smask512 = VectorMask.fromArray(ShortVector.SPECIES_512, mask_arr, 0);\n+\n+        imask64 = VectorMask.fromArray(IntVector.SPECIES_64, mask_arr, 0);\n+        imask128 = VectorMask.fromArray(IntVector.SPECIES_128, mask_arr, 0);\n+        imask256 = VectorMask.fromArray(IntVector.SPECIES_256, mask_arr, 0);\n+        imask512 = VectorMask.fromArray(IntVector.SPECIES_512, mask_arr, 0);\n+\n+        lmask128 = VectorMask.fromArray(LongVector.SPECIES_128, mask_arr, 0);\n+        lmask256 = VectorMask.fromArray(LongVector.SPECIES_256, mask_arr, 0);\n+        lmask512 = VectorMask.fromArray(LongVector.SPECIES_512, mask_arr, 0);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastByte64ToShort128() {\n+        return bmask64.cast(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastByte64ToInteger256() {\n+        return bmask64.cast(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastByte64ToLong512() {\n+        return bmask64.cast(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastByte128ToShort256() {\n+        return bmask128.cast(ShortVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastByte128ToInteger512() {\n+        return bmask128.cast(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastByte256ToShort512() {\n+        return bmask256.cast(ShortVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastShort64ToInteger128() {\n+        return smask64.cast(IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastShort64ToLong256() {\n+        return smask64.cast(LongVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastShort128ToByte64() {\n+        return smask128.cast(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastShort128ToInteger256() {\n+        return smask128.cast(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastShort128ToLong512() {\n+        return smask128.cast(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastShort256ToByte128() {\n+        return smask256.cast(ByteVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastShort256ToInteger512() {\n+        return smask256.cast(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastShort512ToByte256() {\n+        return smask512.cast(ByteVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastInteger64ToLong128() {\n+        return imask64.cast(LongVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastInteger128ToShort64() {\n+        return imask128.cast(ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastInteger128ToLong256() {\n+        return imask128.cast(LongVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastInteger256ToByte64() {\n+        return imask256.cast(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastInteger256ToShort128() {\n+        return imask256.cast(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastInteger256ToLong512() {\n+        return imask256.cast(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastInteger512ToByte128() {\n+        return imask512.cast(ByteVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastInteger512ToShort256() {\n+        return imask512.cast(ShortVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastLong128ToInteger64() {\n+        return lmask128.cast(IntVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastLong256ToShort64() {\n+        return lmask256.cast(ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastLong256ToInteger128() {\n+        return lmask256.cast(IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastLong512ToByte64() {\n+        return lmask512.cast(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastLong512ToShort128() {\n+        return lmask512.cast(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastLong512ToInteger256() {\n+        return lmask512.cast(IntVector.SPECIES_256);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCastOperationsBenchmark.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -158,0 +158,19 @@\n+\n+    @Benchmark\n+    public long testToLongByte(Blackhole bh) {\n+        return bmask.toLong();\n+    }\n+\n+    @Benchmark\n+    public long testToLongShort(Blackhole bh) {\n+        return smask.toLong();\n+    }\n+    @Benchmark\n+    public long testToLongInt(Blackhole bh) {\n+        return imask.toLong();\n+    }\n+    @Benchmark\n+    public long testToLongLong(Blackhole bh) {\n+        return lmask.toLong();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskQueryOperationsBenchmark.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class BooleanArrayCheck {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_PREFERRED;\n+\n+  private boolean[] bitsArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"SPECIES's length: \" + SPECIES.length());\n+\n+    bitsArray = new boolean[ARRAY_LENGTH];\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      bitsArray[i] = true;\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll_vec() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos += SPECIES.length()) {\n+      VectorMask<Byte> mask = VectorMask.fromArray(SPECIES, bitsArray, filterPos);\n+      if (!mask.allTrue()) {\n+        return false;\n+      }\n+    }\n+\n+    for (filterPos -= SPECIES.length(); filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/BooleanArrayCheck.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SelectiveStore {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  private static final VectorSpecies<Integer> INT_64_SPECIES =\n+    IntVector.SPECIES_64;\n+  private static final VectorSpecies<Integer> INT_128_SPECIES =\n+    IntVector.SPECIES_128;\n+  private static final VectorSpecies<Integer> INT_256_SPECIES =\n+    IntVector.SPECIES_256;\n+  private static final VectorSpecies<Integer> INT_512_SPECIES =\n+    IntVector.SPECIES_512;\n+  private static final VectorSpecies<Integer> INT_PREFERRED_SPECIES =\n+    IntVector.SPECIES_PREFERRED;\n+\n+  private int conflict_cnt;\n+  private int[] index;\n+  private int[] input1;\n+  private int[] input2;\n+  private int[] conflict_array;\n+\n+  @Setup\n+  public void init() {\n+    index = new int[ARRAY_LENGTH];\n+    input1 = new int[ARRAY_LENGTH];\n+    input2 = new int[ARRAY_LENGTH];\n+    conflict_array = new int[ARRAY_LENGTH];\n+\n+    RandomGenerator rng = RandomGenerator.getDefault();\n+    int conflict_id_each_5_elements = rng.nextInt(5);\n+\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      index[i] = rng.nextInt(ARRAY_LENGTH);\n+      input1[i] = rng.nextInt();\n+      \/\/ Generate 20% conflict data\n+      int remainder = i % 5;\n+      if (remainder == conflict_id_each_5_elements) {\n+        input2[i] = rng.nextInt();\n+      } else {\n+        input2[i] = input1[i];\n+      }\n+      conflict_array[i] = 0;\n+    }\n+  }\n+\n+  private void selectiveStore(VectorSpecies<Integer> species) {\n+    conflict_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += species.length()) {\n+      IntVector av = IntVector.fromArray(species, input1, i);\n+      IntVector bv = IntVector.fromArray(species, input2, i);\n+      IntVector cv = IntVector.fromArray(species, index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      IntVector dv = cv.compress(mask);\n+      dv.intoArray(conflict_array, conflict_cnt, mask.compress());\n+      conflict_cnt += mask.trueCount();\n+    }\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_scalar() {\n+    conflict_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      if (input1[i] != input2[i]) {\n+        conflict_array[conflict_cnt] = index[i];\n+        conflict_cnt++;\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_64() {\n+    selectiveStore(INT_64_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_128() {\n+    selectiveStore(INT_128_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_256() {\n+    selectiveStore(INT_256_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_512() {\n+    selectiveStore(INT_512_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_preferred() {\n+    selectiveStore(INT_PREFERRED_SPECIES);\n+  }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/SelectiveStore.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ValueRangeCheckAndCastL2I {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  private long min = Integer.MIN_VALUE;\n+  private long max = Integer.MAX_VALUE;\n+\n+  private static final VectorSpecies<Long> LONG_SPECIES =\n+    LongVector.SPECIES_PREFERRED;\n+  private static final VectorSpecies<Integer> INT_SPECIES =\n+    VectorSpecies.of(int.class, VectorShape.forBitSize(LONG_SPECIES.vectorBitSize() \/ 2));\n+\n+  private int[] intResult;\n+  private long[] longArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"LONG_SPECIES's length: \" + LONG_SPECIES.length());\n+    System.out.println(\"INT_SPECIES's length: \" + INT_SPECIES.length());\n+    System.out.println(\"Min is: \" + min + \". Max is: \" + max);\n+\n+    longArray = new long[ARRAY_LENGTH];\n+    intResult = new int[ARRAY_LENGTH];\n+\n+    Random rand = new Random();\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      intResult[i] = 0;\n+      longArray[i] = rand.nextInt(Integer.MAX_VALUE);\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I() {\n+    for (int i = 0; i < longArray.length; i++) {\n+      if (longArray[i] >= min && longArray[i] <= max) {\n+        intResult[i] = (int)(longArray[i]);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I_vec() {\n+    for (int i = 0; i < longArray.length; i += LONG_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_SPECIES, longArray, i);\n+      if (av.compare(VectorOperators.GE, min).and(av.compare(VectorOperators.LE, max)).allTrue()) {\n+        ((IntVector) av.castShape(INT_SPECIES, 0)).intoArray(intResult, i);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/ValueRangeCheckAndCastL2I.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,583 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorDistance {\n+\n+    static final VectorSpecies<Float> SPECIES_FLOAT_128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_256 = FloatVector.SPECIES_256;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_MAX = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_256 = DoubleVector.SPECIES_256;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_MAX = DoubleVector.SPECIES_MAX;\n+\n+\n+    static long num = 0;\n+    private static String x1 = \"L5GSwXhHpEH05mNBHnmcQMTw3EBnagFCW1DGQHe\/nUFO1B1BlJOpwCBJ9j\" +\n+                \"+RkY1BzqKeQSglN0Gy7krB5CSfQFzxB8Djn5nB2KNFwKcSRMGYzRQ7qMGWQZ0FF0FTceDAIKjxv\/zhdkHFZMHB6hU4QZbo2cCAryRB+7OOQCxbfEHRtBlBxPG6P0BYSD+Pgz9BqzOLv\/nVO8C9x5\/BQOY\/wTTIx0GfW1BBGv2lQQwdDcGCqBfB12t\/QKUBoEEejIXBPN9kQWsFbEGsGcnBkqJkwKhLgr\/IQZxAelAWQfcYpcFQv0HBeiGCQWExhEDrKAnBpAwBQV4bVcFpGNjAyDsNQVOc+0CSc4nBgG\/ZQQGRccEXts9BKhYzQNK5+MAlU0DBzPGWwPGRCcEZC5\/ADxOcv7lUkEBomM5BuqKiwV2MU8HNGHDBSB84QZRSyMB8RZlBVFdZQXSVgcBTQQBCdWa\/QBQ0qkGILUW\/6NA9QQnkmsG+5PPBj0UowT6nYD9cwpjAS\/w5wTbX2UH8Gb5AR\/HUQMTNAMJ9MN9AgHoqPbbUyUFbe47BBHANQWZJBsGBuPlBy94EQADeXsG5eOtBnA+yQCRka8EMcGLBjuoRwb4k7sAasB5Bmk\/UwaI1akErp6xBq5G5wNo1E8KHa7tB3IiKQTCffcHphK1BTgJzwVY3JEEip\/VAlmgXQSeKCsLEABs\/n1\/xwL5u58CgQY49ahUWQoAJjj1hhqBASXrrQb6nM0H2fY+\/thtbQAQobMAohvXAxM3xv7xyqD+MvpDBrlDiQfBvPcGA8X5AQE4SwXhGx7+uLA1AxY8xu2mVjEE7KlFBArveQFNMtUD3N7DB12BbQcyH4cFhSw3Bu5VWQeTW0z9o03TBxtMlQctp\/8E\/lLVAGUtTwZsGJMKv\/R5A1HKVQV6RhsC1Ji5AcXLFQJd6f0HbB+e+ZDi8wV9tQ0FwCN\/B+A89v2DrU0Bcpc5BglTeQH5dT0HePS9Al4XPwdA6YEFlueXAbWKSQSBWzkBy2RnCt9Yawl9b77+xgxBC9eCqQd8f0kFoBG9BVxrkQZh2QkHNW\/zBEQiawLJEocDhutTA8zEYwbIvEUIO1T9BmlOTwIhbNEDhrtlAVk9BQARQaj89NQNC6usGwDfQrkBSJrlAON7FQQ8FqsEEc\/TAY3zeQYsqUEHV8QPBHJoYQQdn5kGyCiJBlDMYQBBNoUFrxbw\/NlmPP3B24j6ChIdBXk2bwdxdDMFQw1rA4hybQXTchr8d9wvBuCbLQSMKmMBH4RpBQIXePa5DT8IjgvtBgAetQZgGgMEprc1BAOeSPJ5XpEEMa0NBgX4uwX7XIsG2Ie0688iqQSpJPsCAy9LBAGHkPw==\";\n+    private static String x2 = \"5R3ZwGPrxEFMKyNBLFSeQdYav0BQtDFCur7WQAgRYEGHFYC\/MKZtvkiFUT+RNXfBVsGBP2KWSUCmAUTBIf+EQG57kMCtXo7BV1DuwLd98r+YzRQ7qKXNwBMSPUFNQffBPrxeQYw1t7\/7JjFAKNaXP+cMSEG6GI5BuEx0wUANDMEvDqdAT9YEworQTEEiVBZBiMejQP7t67+iRwzB3HadQB1be0Ei5g5BMt+cQXvYTUHwZsLAuoy3QfrR6EFrIiHB5X8Dwc8XbUH8Yr8\/AvGEwa5GkUH3F5tAP8YJQTiDyz+gKsRAFl\/rwDxJuUAPyyxBvg2gQU6bjMEPEa7Bz6wYQpQy7MDF5LvB8HP+QCJdicHQDjpC6RpWQcGeY8FMK6vBoeUjQcPYmUG2QmRBBI0nwScESsGMAcxBvRmawRL2A8IByKNAgTQBQuxdDEGq8JBBHJWmQSBDfz8sLe9BE3gFwTdCPkHEaMxBhX8Xwe7BCcE\/783Bt6EHwdpbpkHc5L\/BCPzRwUdIQUEd\/k3AoGNcQQwNmMEyuKRBtnWlwdCBAUI5Y5DBwOZYvdI+MsEu\/ixBnpMrwRtYt8FECytC6JjEQW3RHcBtfn3B+sgQQcyQKcEI5ytByvw2wPZdaUH+aqLAQFQ+QPi4REBF\/9lBCvJNQTdlEcIAMbzBtD+hwZWufsAEjus\/YRyjwR1YuMHj0ZhBa4w+QORAhMEq9qdB\/L8JQrjhyUAJBeBAKqoIQUnAq0GsLFdBkfrvQHc1zMHH6THBeggSwaJIOsAawwBBDDWqPwrAlkBYDqe\/maUcQabhwsFF2VBBxY8xu5aMQUFDkHVBKhRRwHhgWsEA5jXBlh9NQVMaT0CWlhTAroaFQRyciUHQlp7BF4trQa8unsE4TfI+9XLJQDNpLcIXLZdAuX2MwShiTsFcQh5BrHMqQVI1+UBWe4fBAzi0wfe11UFAIjq9Y1iAQDxrTsEY6plB\/JiXQfjFwkHkYGRBVNOhwCMxtEFbqZTA378WQeA\/Sb+FrSXCqlYywtb5SsDcqlZBk1EtQZ\/RREHZIxG\/kcv8QekDIkHPsDXCBL4VQHN8CMGtNvvAC3YwweUuAkKkJCnANEtVQG9z\/0DrwyTBQ9hnwWX3kMEdLB1CvIlKwQ0IO0HK1ErBvdRQQVpjMMCJDI\/Bb4X8QYVipEGpG2nBeLGUvmBlBT7ISgRB4iGAQUunkkFDFLm\/HNaqPzKTVkCITJG\/XzlYwbj0XcGD60PBbpLwQbvrs8Az8RXB4ubxQXh\/HEDtXLU\/kONrwVBs4MGc2X1BJaHkQd0ByEAKXLJBTq7JwPPkJUGJIIRBlh57wX3FjcC2Ie060Qc6Qal5xcCfqQrCl7edQQ==\";\n+    static float[] queryVectorFloat = parseBase64ToVector(x1);\n+    static float[] inputVectorFloat = parseBase64ToVector(x2);\n+    static double[] queryVectorDouble;\n+    static double[] inputVectorDouble;\n+\n+    static float normQueryVectorFloat;\n+    static double normQueryVectorDouble;\n+\n+    public static float[] parseArray(byte[] input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        float[] floatArr = new float[input.length \/ 4];\n+        for (int i = 0; i < floatArr.length; i++) {\n+            int l;\n+            l = input[i << 2];\n+            l &= 0xff;\n+            l |= ((long) input[(i << 2) + 1] << 8);\n+            l &= 0xffff;\n+            l |= ((long) input[(i << 2) + 2] << 16);\n+            l &= 0xffffff;\n+            l |= ((long) input[(i << 2) + 3] << 24);\n+            floatArr[i] = Float.intBitsToFloat(l);\n+        }\n+        return floatArr;\n+    }\n+\n+    public static float[] parseBase64ToVector(String vectorBase64) {\n+        return parseArray(Base64.getDecoder().decode(vectorBase64));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        queryVectorDouble = new double[queryVectorFloat.length];\n+        inputVectorDouble = new double[inputVectorFloat.length];\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            queryVectorDouble[i] = (double)(queryVectorFloat[i]);\n+        }\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            inputVectorDouble[i] = (double)(inputVectorFloat[i]);\n+        }\n+        float xSquare = 0;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            xSquare += (float)(queryVectorFloat[i] * queryVectorFloat[i]);\n+        }\n+        normQueryVectorFloat = xSquare;\n+        normQueryVectorDouble = (double)xSquare;\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normQueryVectorFloat = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedScalarDouble() {\n+        double dotProduct = 0.0;\n+        double normInputVector = 0.0;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return dotProduct \/ (Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilScalarDouble() {\n+        double dotProduct = 0.0f;\n+        double normQueryVectorDouble = 0.0f;\n+        double normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    \/\/ l2Squared is used to compute Euclidean distance\n+    @Benchmark\n+    public float l2SquaredVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredScalar() {\n+        float squaredDistance = 0;\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            squaredDistance += diff * diff;\n+        }\n+        return squaredDistance;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/VectorDistance.java","additions":583,"deletions":0,"binary":false,"changes":583,"status":"added"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+  \n+package org.openjdk.bench.jdk.incubator.vector.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class ChaChaBench {\n+\n+    @Param({\"16384\", \"65536\"})\n+    private int dataSize;\n+    \n+    private ChaChaVector cc20_S128 = makeCC20(VectorShape.S_128_BIT);\n+    private ChaChaVector cc20_S256 = makeCC20(VectorShape.S_256_BIT);\n+    private ChaChaVector cc20_S512 = makeCC20(VectorShape.S_512_BIT);\n+ \n+    private byte[] in;\n+    private byte[] out;\n+    \n+    private byte[] key = new byte[32];\n+    private byte[] nonce = new byte[12];\n+    private long counter = 0;\n+\n+    private static ChaChaVector makeCC20(VectorShape shape) {\n+        ChaChaVector cc20 = new ChaChaVector(shape);\n+        runKAT(cc20);\n+        return cc20;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        \n+        in = new byte[dataSize];\n+        out = new byte[dataSize];\n+    }\n+\n+    @Benchmark\n+    public void encrypt128() {\n+        cc20_S128.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    @Benchmark\n+    public void encrypt256() {\n+        cc20_S256.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    @Benchmark\n+    public void encrypt512() {\n+        cc20_S512.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    private static class ChaChaVector {\n+\n+        private static final int[] STATE_CONSTANTS =\n+            new int[]{0x61707865, 0x3320646e, 0x79622d32, 0x6b206574};\n+\n+        private final VectorSpecies<Integer> intSpecies;\n+        private final int numBlocks;\n+\n+        private final VectorShuffle<Integer> rot1;\n+        private final VectorShuffle<Integer> rot2;\n+        private final VectorShuffle<Integer> rot3;\n+\n+        private final IntVector counterAdd;\n+\n+        private final VectorShuffle<Integer> shuf0;\n+        private final VectorShuffle<Integer> shuf1;\n+        private final VectorShuffle<Integer> shuf2;\n+        private final VectorShuffle<Integer> shuf3;\n+\n+        private final VectorMask<Integer> mask0;\n+        private final VectorMask<Integer> mask1;\n+        private final VectorMask<Integer> mask2;\n+        private final VectorMask<Integer> mask3;\n+\n+        private final int[] state;\n+\n+        public ChaChaVector(VectorShape shape) {\n+            this.intSpecies = VectorSpecies.of(int.class, shape);\n+            this.numBlocks = intSpecies.length() \/ 4;\n+\n+            this.rot1 = makeRotate(1);\n+            this.rot2 = makeRotate(2);\n+            this.rot3 = makeRotate(3);\n+\n+            this.counterAdd = makeCounterAdd();\n+\n+            this.shuf0 = makeRearrangeShuffle(0);\n+            this.shuf1 = makeRearrangeShuffle(1);\n+            this.shuf2 = makeRearrangeShuffle(2);\n+            this.shuf3 = makeRearrangeShuffle(3);\n+\n+            this.mask0 = makeRearrangeMask(0);\n+            this.mask1 = makeRearrangeMask(1);\n+            this.mask2 = makeRearrangeMask(2);\n+            this.mask3 = makeRearrangeMask(3);\n+\n+            this.state = new int[numBlocks * 16];\n+        }\n+\n+        private VectorShuffle<Integer>  makeRotate(int amount) {\n+            int[] shuffleArr = new int[intSpecies.length()];\n+\n+            for (int i = 0; i < intSpecies.length(); i ++) {\n+                int offset = (i \/ 4) * 4;\n+                shuffleArr[i] = offset + ((i + amount) % 4);\n+            }\n+\n+            return VectorShuffle.fromValues(intSpecies, shuffleArr);\n+        }\n+\n+        private IntVector makeCounterAdd() {\n+            int[] addArr = new int[intSpecies.length()];\n+            for(int i = 0; i < numBlocks; i++) {\n+                addArr[4 * i] = numBlocks;\n+            }\n+            return IntVector.fromArray(intSpecies, addArr, 0);\n+        }\n+\n+        private VectorShuffle<Integer>  makeRearrangeShuffle(int order) {\n+            int[] shuffleArr = new int[intSpecies.length()];\n+            int start = order * 4;\n+            for (int i = 0; i < shuffleArr.length; i++) {\n+                shuffleArr[i] = (i % 4) + start;\n+            }\n+            return VectorShuffle.fromArray(intSpecies, shuffleArr, 0);\n+        }\n+\n+        private VectorMask<Integer> makeRearrangeMask(int order) {\n+            boolean[] maskArr = new boolean[intSpecies.length()];\n+            int start = order * 4;\n+            if (start < maskArr.length) {\n+                for (int i = 0; i < 4; i++) {\n+                    maskArr[i + start] = true;\n+                }\n+            }\n+\n+            return VectorMask.fromValues(intSpecies, maskArr);\n+        }\n+\n+        public void makeState(byte[] key, byte[] nonce, long counter,\n+            int[] out) {\n+\n+            \/\/ first field is constants\n+            for (int i = 0; i < 4; i++) {\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[4*j + i] = STATE_CONSTANTS[i];\n+                }\n+            }\n+\n+            \/\/ second field is first part of key\n+            int fieldStart = 4 * numBlocks;\n+            for (int i = 0; i < 4; i++) {\n+                int keyInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    keyInt += (0xFF & key[4 * i + j]) << 8 * j;\n+                }\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + i] = keyInt;\n+                }\n+            }\n+\n+            \/\/ third field is second part of key\n+            fieldStart = 8 * numBlocks;\n+            for (int i = 0; i < 4; i++) {\n+                int keyInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    keyInt += (0xFF & key[4 * (i + 4) + j]) << 8 * j;\n+                }\n+\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + i] = keyInt;\n+                }\n+            }\n+\n+            \/\/ fourth field is counter and nonce\n+            fieldStart = 12 * numBlocks;\n+            for (int j = 0; j < numBlocks; j++) {\n+                out[fieldStart + j*4] = (int) (counter + j);\n+            }\n+\n+            for (int i = 0; i < 3; i++) {\n+                int nonceInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    nonceInt += (0xFF & nonce[4 * i + j]) << 8 * j;\n+                }\n+\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + 1 + i] = nonceInt;\n+                }\n+            }\n+        }\n+\n+        public void chacha20(byte[] key, byte[] nonce, long counter,\n+            byte[] in, byte[] out) {\n+\n+            makeState(key, nonce, counter, state);\n+\n+            int len = intSpecies.length();\n+\n+            IntVector sa = IntVector.fromArray(intSpecies, state, 0);\n+            IntVector sb = IntVector.fromArray(intSpecies, state, len);\n+            IntVector sc = IntVector.fromArray(intSpecies, state, 2 * len);\n+            IntVector sd = IntVector.fromArray(intSpecies, state, 3 * len);\n+\n+            int stateLenBytes = state.length * 4;\n+            int numStates = (in.length + stateLenBytes - 1) \/ stateLenBytes;\n+            for (int j = 0; j < numStates; j++){\n+\n+                IntVector a = sa;\n+                IntVector b = sb;\n+                IntVector c = sc;\n+                IntVector d = sd;\n+\n+                for (int i = 0; i < 10; i++) {\n+                    \/\/ first round\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL, 16);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,12);\n+\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,8);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,7);\n+\n+                    \/\/ makeRotate\n+                    b = b.rearrange(rot1);\n+                    c = c.rearrange(rot2);\n+                    d = d.rearrange(rot3);\n+\n+                    \/\/ second round\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,16);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,12);\n+\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,8);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,7);\n+\n+                    \/\/ makeRotate\n+                    b = b.rearrange(rot3);\n+                    c = c.rearrange(rot2);\n+                    d = d.rearrange(rot1);\n+                }\n+\n+                a = a.add(sa);\n+                b = b.add(sb);\n+                c = c.add(sc);\n+                d = d.add(sd);\n+\n+                \/\/ rearrange the vectors\n+                if (intSpecies.length() == 4) {\n+                    \/\/ no rearrange needed\n+                } else if (intSpecies.length() == 8) {\n+                    IntVector a_r =\n+                            a.rearrange(shuf0).blend(b.rearrange(shuf0), mask1);\n+                    IntVector b_r =\n+                            c.rearrange(shuf0).blend(d.rearrange(shuf0), mask1);\n+                    IntVector c_r =\n+                            a.rearrange(shuf1).blend(b.rearrange(shuf1), mask1);\n+                    IntVector d_r =\n+                            c.rearrange(shuf1).blend(d.rearrange(shuf1), mask1);\n+\n+                    a = a_r;\n+                    b = b_r;\n+                    c = c_r;\n+                    d = d_r;\n+                } else if (intSpecies.length() == 16) {\n+                    IntVector a_r = a;\n+                    a_r = a_r.blend(b.rearrange(shuf0), mask1);\n+                    a_r = a_r.blend(c.rearrange(shuf0), mask2);\n+                    a_r = a_r.blend(d.rearrange(shuf0), mask3);\n+\n+                    IntVector b_r = b;\n+                    b_r = b_r.blend(a.rearrange(shuf1), mask0);\n+                    b_r = b_r.blend(c.rearrange(shuf1), mask2);\n+                    b_r = b_r.blend(d.rearrange(shuf1), mask3);\n+\n+                    IntVector c_r = c;\n+                    c_r = c_r.blend(a.rearrange(shuf2), mask0);\n+                    c_r = c_r.blend(b.rearrange(shuf2), mask1);\n+                    c_r = c_r.blend(d.rearrange(shuf2), mask3);\n+\n+                    IntVector d_r = d;\n+                    d_r = d_r.blend(a.rearrange(shuf3), mask0);\n+                    d_r = d_r.blend(b.rearrange(shuf3), mask1);\n+                    d_r = d_r.blend(c.rearrange(shuf3), mask2);\n+\n+                    a = a_r;\n+                    b = b_r;\n+                    c = c_r;\n+                    d = d_r;\n+                } else {\n+                    throw new RuntimeException(\"not supported\");\n+                }\n+\n+                \/\/ xor keystream with input\n+                int inOff = stateLenBytes * j;\n+                IntVector ina = IntVector.fromByteArray(intSpecies, in, inOff, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inb = IntVector.fromByteArray(intSpecies, in, inOff + 4 * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inc = IntVector.fromByteArray(intSpecies, in, inOff + 8 * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector ind = IntVector.fromByteArray(intSpecies, in, inOff + 12 * len, ByteOrder.LITTLE_ENDIAN);\n+\n+                ina.lanewise(VectorOperators.XOR, a).intoByteArray(out, inOff, ByteOrder.LITTLE_ENDIAN);\n+                inb.lanewise(VectorOperators.XOR, b).intoByteArray(out, inOff + 4 * len, ByteOrder.LITTLE_ENDIAN);\n+                inc.lanewise(VectorOperators.XOR, c).intoByteArray(out, inOff + 8 * len, ByteOrder.LITTLE_ENDIAN);\n+                ind.lanewise(VectorOperators.XOR, d).intoByteArray(out, inOff + 12 * len, ByteOrder.LITTLE_ENDIAN);\n+\n+                \/\/ increment counter\n+                sd = sd.add(counterAdd);\n+            }\n+        }\n+\n+        public int implBlockSize() {\n+            return numBlocks * 64;\n+        }\n+    }\n+\n+    private static byte[] hexStringToByteArray(String str) {\n+        byte[] result = new byte[str.length() \/ 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (byte) Character.digit(str.charAt(2 * i), 16);\n+            result[i] <<= 4;\n+            result[i] += Character.digit(str.charAt(2 * i + 1), 16);\n+        }\n+        return result;\n+    }\n+\n+    private static void runKAT(ChaChaVector cc20, String keyStr,\n+        String nonceStr, long counter, String inStr, String outStr) {\n+\n+        byte[] key = hexStringToByteArray(keyStr);\n+        byte[] nonce = hexStringToByteArray(nonceStr);\n+        byte[] in = hexStringToByteArray(inStr);\n+        byte[] expOut = hexStringToByteArray(outStr);\n+\n+        \/\/ implementation only works at multiples of some size\n+        int blockSize = cc20.implBlockSize();\n+\n+        int length = blockSize * ((in.length + blockSize - 1) \/ blockSize);\n+        in = Arrays.copyOf(in, length);\n+        byte[] out = new byte[length];\n+\n+        cc20.chacha20(key, nonce, counter, in, out);\n+\n+        byte[] actOut = new byte[expOut.length];\n+        System.arraycopy(out, 0, actOut, 0, expOut.length);\n+\n+        if (!Arrays.equals(out, 0, expOut.length, expOut, 0, expOut.length)) {\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    \/*\n+     * ChaCha20 Known Answer Tests to ensure that the implementation is correct.\n+     *\/\n+    private static void runKAT(ChaChaVector cc20) {\n+        runKAT(cc20,\n+        \"0000000000000000000000000000000000000000000000000000000000000001\",\n+        \"000000000000000000000002\",\n+        1,\n+        \"416e79207375626d697373696f6e20746f20746865204945544620696e74656e\" +\n+        \"6465642062792074686520436f6e7472696275746f7220666f72207075626c69\" +\n+        \"636174696f6e20617320616c6c206f722070617274206f6620616e2049455446\" +\n+        \"20496e7465726e65742d4472616674206f722052464320616e6420616e792073\" +\n+        \"746174656d656e74206d6164652077697468696e2074686520636f6e74657874\" +\n+        \"206f6620616e204945544620616374697669747920697320636f6e7369646572\" +\n+        \"656420616e20224945544620436f6e747269627574696f6e222e205375636820\" +\n+        \"73746174656d656e747320696e636c756465206f72616c2073746174656d656e\" +\n+        \"747320696e20494554462073657373696f6e732c2061732077656c6c20617320\" +\n+        \"7772697474656e20616e6420656c656374726f6e696320636f6d6d756e696361\" +\n+        \"74696f6e73206d61646520617420616e792074696d65206f7220706c6163652c\" +\n+        \"207768696368206172652061646472657373656420746f\",\n+        \"a3fbf07df3fa2fde4f376ca23e82737041605d9f4f4f57bd8cff2c1d4b7955ec\" +\n+        \"2a97948bd3722915c8f3d337f7d370050e9e96d647b7c39f56e031ca5eb6250d\" +\n+        \"4042e02785ececfa4b4bb5e8ead0440e20b6e8db09d881a7c6132f420e527950\" +\n+        \"42bdfa7773d8a9051447b3291ce1411c680465552aa6c405b7764d5e87bea85a\" +\n+        \"d00f8449ed8f72d0d662ab052691ca66424bc86d2df80ea41f43abf937d3259d\" +\n+        \"c4b2d0dfb48a6c9139ddd7f76966e928e635553ba76c5c879d7b35d49eb2e62b\" +\n+        \"0871cdac638939e25e8a1e0ef9d5280fa8ca328b351c3c765989cbcf3daa8b6c\" +\n+        \"cc3aaf9f3979c92b3720fc88dc95ed84a1be059c6499b9fda236e7e818b04b0b\" +\n+        \"c39c1e876b193bfe5569753f88128cc08aaa9b63d1a16f80ef2554d7189c411f\" +\n+        \"5869ca52c5b83fa36ff216b9c1d30062bebcfd2dc5bce0911934fda79a86f6e6\" +\n+        \"98ced759c3ff9b6477338f3da4f9cd8514ea9982ccafb341b2384dd902f3d1ab\" +\n+        \"7ac61dd29c6f21ba5b862f3730e37cfdc4fd806c22f221\"\n+        );\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/ChaChaBench.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -0,0 +1,663 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class Poly1305Bench {\n+\n+    @Param({\"16384\", \"65536\"})\n+    private int dataSize;\n+\n+    private Poly1305Vector poly1305_S128 = makePoly1305(VectorShape.S_128_BIT);\n+    private Poly1305Vector poly1305_S256 = makePoly1305(VectorShape.S_256_BIT);\n+    private Poly1305Vector poly1305_S512 = makePoly1305(VectorShape.S_512_BIT);\n+\n+    private byte[] in;\n+    private byte[] out = new byte[16];\n+    private byte[] key = new byte[32];\n+\n+    private static Poly1305Vector makePoly1305(VectorShape shape) {\n+        Poly1305Vector poly = new Poly1305Vector(shape);\n+        runKAT(poly);\n+        return poly;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        in = new byte[dataSize];\n+    }\n+\n+    @Benchmark\n+    public void auth128() {\n+        poly1305_S128.computeTag(key, in, out);\n+    }\n+\n+    @Benchmark\n+    public void auth256() {\n+        poly1305_S256.computeTag(key, in, out);\n+    }\n+\n+    @Benchmark\n+    public void auth512() {\n+        poly1305_S512.computeTag(key, in, out);\n+    }\n+\n+    private static class Poly1305Vector {\n+\n+        private static final int BITS_PER_LIMB = 26;\n+        private static final int LIMB_MASK = (1 << BITS_PER_LIMB) - 1;\n+        private static final int KEY_LENGTH = 32;\n+        private static final int RS_LENGTH = KEY_LENGTH \/ 2;\n+\n+        private final VectorSpecies<Long> longSpecies;\n+        private final VectorSpecies<Integer> intSpecies;\n+        private final int vectorWidth;\n+        private final int parBlockCount;\n+\n+        private final VectorShuffle<Long> inShuffle0;\n+        private final VectorShuffle<Long> inShuffle1;\n+        private final VectorMask<Long> inMask;\n+\n+        public Poly1305Vector(VectorShape shape) {\n+\n+            this.longSpecies = VectorSpecies.of(long.class, shape);\n+            int intSize = shape.vectorBitSize() \/ 2;\n+            VectorShape intShape = VectorShape.forBitSize(intSize);\n+            this.intSpecies = VectorSpecies.of(int.class, intShape);\n+            this.vectorWidth = longSpecies.length();\n+            this.parBlockCount = vectorWidth * 16;\n+\n+            this.inShuffle0 = makeInShuffle0();\n+            this.inShuffle1 = makeInShuffle1();\n+            this.inMask = makeInMask();\n+        }\n+\n+        private VectorShuffle<Long> makeInShuffle0() {\n+            int[] indexArr = new int[vectorWidth];\n+            for (int i = 0; i < indexArr.length; i++) {\n+                indexArr[i] = (2 * i) % vectorWidth;\n+            }\n+            return VectorShuffle.fromArray(longSpecies, indexArr, 0);\n+        }\n+        private VectorShuffle<Long> makeInShuffle1() {\n+            int[] indexArr = new int[vectorWidth];\n+            for (int i = 0; i < indexArr.length; i++) {\n+                indexArr[i] = ((2 * i) % vectorWidth) + 1;\n+            }\n+            return VectorShuffle.fromArray(longSpecies, indexArr, 0);\n+        }\n+        private VectorMask<Long> makeInMask() {\n+            boolean[] maskArr = new boolean[vectorWidth];\n+            for (int i = vectorWidth \/ 2; i < vectorWidth; i++) {\n+                maskArr[i] = true;\n+            }\n+            return VectorMask.fromArray(longSpecies, maskArr, 0);\n+        }\n+\n+        private static int[] fromByteArray(byte[] buf) {\n+            int[] result = new int[5];\n+\n+            result[0]\n+                    = (buf[0] & 0xFF)\n+                    + ((buf[1] & 0xFF) << 8)\n+                    + ((buf[2] & 0xFF) << 16)\n+                    + ((buf[3] & 0x03) << 24);\n+            result[1]\n+                    = ((buf[3] & 0xFF) >> 2)\n+                    + ((buf[4] & 0xFF) << 6)\n+                    + ((buf[5] & 0xFF) << 14)\n+                    + ((buf[6] & 0x0F) << 22);\n+            result[2]\n+                    = ((buf[6] & 0xFF) >> 4)\n+                    + ((buf[7] & 0xFF) << 4)\n+                    + ((buf[8] & 0xFF) << 12)\n+                    + ((buf[9] & 0x3F) << 20);\n+            result[3]\n+                    = ((buf[9] & 0xFF) >> 6)\n+                    + ((buf[10] & 0xFF) << 2)\n+                    + ((buf[11] & 0xFF) << 10)\n+                    + ((buf[12] & 0xFF) << 18);\n+            result[4]\n+                    = (buf[13] & 0xFF)\n+                    + ((buf[14] & 0xFF) << 8)\n+                    + ((buf[15] & 0xFF) << 16);\n+\n+            return result;\n+        }\n+\n+        private static void toByteArray(long v0, long v1, long v2, long v3,\n+            long v4, byte[] dst) {\n+\n+            dst[0] = (byte) v0;\n+            v0 >>= 8;\n+            dst[1] = (byte) v0;\n+            v0 >>= 8;\n+            dst[2] = (byte) v0;\n+            v0 >>= 8;\n+            dst[3] = (byte) v0;\n+\n+            dst[3] += (v1 & 0x3F) << 2;\n+            v1 >>= 6;\n+            dst[4] = (byte) v1;\n+            v1 >>= 8;\n+            dst[5] = (byte) v1;\n+            v1 >>= 8;\n+            dst[6] = (byte) v1;\n+\n+            dst[6] += (v2 & 0xF) << 4;\n+            v2 >>= 4;\n+            dst[7] = (byte) v2;\n+            v2 >>= 8;\n+            dst[8] = (byte) v2;\n+            v2 >>= 8;\n+            dst[9] = (byte) v2;\n+\n+            dst[9] += (v3 & 0x3) << 6;\n+            v3 >>= 2;\n+            dst[10] = (byte) v3;\n+            v3 >>= 8;\n+            dst[11] = (byte) v3;\n+            v3 >>= 8;\n+            dst[12] = (byte) v3;\n+\n+            dst[13] = (byte) v4;\n+            v4 >>= 8;\n+            dst[14] = (byte) v4;\n+            v4 >>= 8;\n+            dst[15] = (byte) v4;\n+        }\n+\n+        protected static long carryValue(long x) {\n+            return x >> BITS_PER_LIMB;\n+        }\n+\n+        public static void carryReduce(int[] r, long c0, long c1, long c2,\n+            long c3, long c4) {\n+\n+            long c;\n+\n+            c = carryValue(c3); c3 &= LIMB_MASK; c4 += c;\n+            c = carryValue(c4); c4 &= LIMB_MASK; c0 += c * 5;\n+            c = carryValue(c0); c0 &= LIMB_MASK; c1 += c;\n+            c = carryValue(c1); c1 &= LIMB_MASK; c2 += c;\n+            c = carryValue(c2); c2 &= LIMB_MASK; c3 += c;\n+            c = carryValue(c3); c3 &= LIMB_MASK; c4 += c;\n+\n+            r[0] = (int) c0;\n+            r[1] = (int) c1;\n+            r[2] = (int) c2;\n+            r[3] = (int) c3;\n+            r[4] = (int) c4;\n+        }\n+\n+        private int[] multiply(int[] a, int[] b) {\n+            int[] result = new int[5];\n+\n+            long a0 = a[0];\n+            long a1 = a[1];\n+            long a2 = a[2];\n+            long a3 = a[3];\n+            long a4 = a[4];\n+\n+            long c0 = (a0 * b[0]) + 5 * (a1 * b[4]) + 5 * (a2 * b[3]) +\n+                5 * (a3 * b[2]) + 5 * (a4 * b[1]);\n+            long c1 = (a0 * b[1]) + (a1 * b[0]) + 5 * (a2 * b[4]) +\n+                5 * (a3 * b[3]) + 5 * (a4 * b[2]);\n+            long c2 = (a0 * b[2]) + (a1 * b[1]) + (a2 * b[0]) +\n+                5 * (a3 * b[4]) + 5 * (a4 * b[3]);\n+            long c3 = (a0 * b[3]) + (a1 * b[2]) + (a2 * b[1]) + (a3 * b[0]) +\n+                5 * (a4 * b[4]);\n+            long c4 = (a0 * b[4]) + (a1 * b[3]) + (a2 * b[2]) + (a3 * b[1]) +\n+                (a4 * b[0]);\n+\n+            carryReduce(result, c0, c1, c2, c3, c4);\n+\n+            return result;\n+        }\n+\n+        private LongVector rPowerVec(int[][] r, long[] temp, int maxIndex,\n+            int secondIndex) {\n+\n+            for (int i = 0; i < temp.length; i++) {\n+                temp[i] = r[maxIndex - i][secondIndex];\n+            }\n+            return LongVector.fromArray(longSpecies, temp, 0);\n+        }\n+\n+        public void computeTag(byte[] key, byte[] msg, byte[] out) {\n+\n+            byte[] keyBytes = key.clone();\n+\n+            \/\/ setup key values\n+            \/\/ Clamp the bytes in the \"r\" half of the key.\n+            keyBytes[3] &= 15;\n+            keyBytes[7] &= 15;\n+            keyBytes[11] &= 15;\n+            keyBytes[15] &= 15;\n+            keyBytes[4] &= 252;\n+            keyBytes[8] &= 252;\n+            keyBytes[12] &= 252;\n+\n+            \/\/ Create IntegerModuloP elements from the r and s values\n+            int[][] r = new int[vectorWidth][];\n+            r[0] = fromByteArray(keyBytes);\n+            for (int i = 1; i < vectorWidth; i++) {\n+                r[i] = multiply(r[i - 1], r[0]);\n+            }\n+\n+            int rUpIndex = vectorWidth - 1;\n+            IntVector rUp0_int = IntVector.broadcast(intSpecies, r[rUpIndex][0]);\n+            IntVector rUp1_int = IntVector.broadcast(intSpecies, r[rUpIndex][1]);\n+            IntVector rUp2_int = IntVector.broadcast(intSpecies, r[rUpIndex][2]);\n+            IntVector rUp3_int = IntVector.broadcast(intSpecies, r[rUpIndex][3]);\n+            IntVector rUp4_int = IntVector.broadcast(intSpecies, r[rUpIndex][4]);\n+\n+            IntVector r5Up1_int = rUp1_int.mul(5);\n+            IntVector r5Up2_int = rUp2_int.mul(5);\n+            IntVector r5Up3_int = rUp3_int.mul(5);\n+            IntVector r5Up4_int = rUp4_int.mul(5);\n+\n+            LongVector longMsg0 = LongVector.fromByteArray(longSpecies, msg, 0, ByteOrder.LITTLE_ENDIAN);\n+            LongVector longMsg1 =\n+                LongVector.fromByteArray(longSpecies, msg, vectorWidth * 8, ByteOrder.LITTLE_ENDIAN);\n+\n+            LongVector inAlign0 =\n+            longMsg0.rearrange(inShuffle0).blend(longMsg1.rearrange(inShuffle0), inMask);\n+            LongVector inAlign1 =\n+            longMsg0.rearrange(inShuffle1).blend(longMsg1.rearrange(inShuffle1), inMask);\n+\n+            IntVector a0 = (IntVector)\n+                inAlign0.and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a1 = (IntVector)\n+                inAlign0.lanewise(VectorOperators.LSHR,26).and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a2 = (IntVector)\n+                inAlign0.lanewise(VectorOperators.LSHR,52).and(0xFFF).castShape(intSpecies, 0);\n+            a2 = a2.or(inAlign1.and(0x3FFF).lanewise(VectorOperators.LSHL,12).castShape(intSpecies, 0));\n+            IntVector a3 = (IntVector)\n+                inAlign1.lanewise(VectorOperators.LSHR,14).and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a4 = (IntVector)\n+                inAlign1.lanewise(VectorOperators.LSHR,40).and(0xFFFFFF).castShape(intSpecies, 0);\n+            a4 = a4.or(1 << 24);\n+\n+            int numParBlocks = msg.length \/ parBlockCount - 1;\n+            for (int i = 0; i < numParBlocks; i++) {\n+\n+                \/\/ multiply and reduce\n+                LongVector c0 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up2_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up1_int.castShape(longSpecies, 0)));\n+\n+                LongVector c1 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up2_int.castShape(longSpecies, 0)));\n+\n+                LongVector c2 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)));\n+\n+                LongVector c3 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp3_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)));\n+\n+                LongVector c4 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp4_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp3_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)));\n+\n+                \/\/ carry\/reduce\n+                \/\/ Note: this carry\/reduce sequence might not be correct\n+                c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c3 = c3.and(LIMB_MASK);\n+                c0 = c0.add(c4.lanewise(VectorOperators.LSHR, BITS_PER_LIMB).mul(5));\n+                c4 = c4.and(LIMB_MASK);\n+                c1 = c1.add(c0.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c0 = c0.and(LIMB_MASK);\n+                c2 = c2.add(c1.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c1 = c1.and(LIMB_MASK);\n+                c3 = c3.add(c2.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c2 = c2.and(LIMB_MASK);\n+                c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c3 = c3.and(LIMB_MASK);\n+\n+                a0 = (IntVector) c0.castShape(intSpecies, 0);\n+                a1 = (IntVector) c1.castShape(intSpecies, 0);\n+                a2 = (IntVector) c2.castShape(intSpecies, 0);\n+                a3 = (IntVector) c3.castShape(intSpecies, 0);\n+                a4 = (IntVector) c4.castShape(intSpecies, 0);\n+\n+                \/\/ fromByteArray and add next part of message\n+                int start = parBlockCount * (i + 1);\n+\n+                longMsg0 = LongVector.fromByteArray(longSpecies, msg, start, ByteOrder.LITTLE_ENDIAN);\n+                longMsg1 = LongVector.fromByteArray(longSpecies, msg,\n+                    start + vectorWidth * 8, ByteOrder.LITTLE_ENDIAN);\n+\n+                inAlign0 =\n+                        longMsg0.rearrange(inShuffle0).blend(longMsg1.rearrange(inShuffle0), inMask);\n+                inAlign1 =\n+                        longMsg0.rearrange(inShuffle1).blend(longMsg1.rearrange(inShuffle1), inMask);\n+\n+                IntVector in0 = (IntVector)\n+                    inAlign0.and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in1 = (IntVector)\n+                    inAlign0.lanewise(VectorOperators.LSHR, 26).and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in2 = (IntVector)\n+                    inAlign0.lanewise(VectorOperators.LSHR, 52).and(0xFFF).castShape(intSpecies, 0);\n+                in2 = in2.or(inAlign1.and(0x3FFF).lanewise(VectorOperators.LSHL, 12).castShape(intSpecies, 0));\n+                IntVector in3 = (IntVector)\n+                    inAlign1.lanewise(VectorOperators.LSHR, 14).and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in4 = (IntVector)\n+                    inAlign1.lanewise(VectorOperators.LSHR, 40).and(0xFFFFFF).castShape(intSpecies, 0);\n+                in4 = in4.or(1 << 24);\n+\n+                a0 = a0.add(in0);\n+                a1 = a1.add(in1);\n+                a2 = a2.add(in2);\n+                a3 = a3.add(in3);\n+                a4 = a4.add(in4);\n+            }\n+\n+            \/\/ multiply by powers of r\n+            long[] rTemp = new long[vectorWidth];\n+            LongVector rFin0 = rPowerVec(r, rTemp, rUpIndex, 0);\n+            LongVector rFin1 = rPowerVec(r, rTemp, rUpIndex, 1);\n+            LongVector rFin2 = rPowerVec(r, rTemp, rUpIndex, 2);\n+            LongVector rFin3 = rPowerVec(r, rTemp, rUpIndex, 3);\n+            LongVector rFin4 = rPowerVec(r, rTemp, rUpIndex, 4);\n+\n+            LongVector r5Fin_1 = rFin1.mul(5);\n+            LongVector r5Fin_2 = rFin2.mul(5);\n+            LongVector r5Fin_3 = rFin3.mul(5);\n+            LongVector r5Fin_4 = rFin4.mul(5);\n+\n+            LongVector c0 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin0)\n+                .add(a1.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a2.castShape(longSpecies, 0).mul(r5Fin_3))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_2))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_1));\n+            LongVector c1 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin1)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a2.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_3))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_2));\n+            LongVector c2 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin2)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_3));\n+            LongVector c3 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin3)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin2))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a3.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_4));\n+            LongVector c4 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin4)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin3))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin2))\n+                .add(a3.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a4.castShape(longSpecies, 0).mul(rFin0));\n+\n+            c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c3 = c3.and(LIMB_MASK);\n+            c0 = c0.add(c4.lanewise(VectorOperators.LSHR, BITS_PER_LIMB).mul(5));\n+            c4 = c4.and(LIMB_MASK);\n+            c1 = c1.add(c0.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c0 = c0.and(LIMB_MASK);\n+            c2 = c2.add(c1.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c1 = c1.and(LIMB_MASK);\n+            c3 = c3.add(c2.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c2 = c2.and(LIMB_MASK);\n+            c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c3 = c3.and(LIMB_MASK);\n+\n+            a0 = (IntVector) c0.castShape(intSpecies, 0);\n+            a1 = (IntVector) c1.castShape(intSpecies, 0);\n+            a2 = (IntVector) c2.castShape(intSpecies, 0);\n+            a3 = (IntVector) c3.castShape(intSpecies, 0);\n+            a4 = (IntVector) c4.castShape(intSpecies, 0);\n+\n+            \/\/ collect lanes and calculate tag\n+            long a0Fin = a0.reduceLanes(VectorOperators.ADD);\n+            long a1Fin = a1.reduceLanes(VectorOperators.ADD);\n+            long a2Fin = a2.reduceLanes(VectorOperators.ADD);\n+            long a3Fin = a3.reduceLanes(VectorOperators.ADD);\n+            long a4Fin = a4.reduceLanes(VectorOperators.ADD);\n+\n+            \/\/ carry\/reduce the result\n+            a4Fin = a4Fin + (a3Fin >>> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+            a0Fin = a0Fin + ((a4Fin >>> BITS_PER_LIMB) * 5);\n+            a4Fin = a4Fin & LIMB_MASK;\n+            a1Fin = a1Fin + (a0Fin >>> BITS_PER_LIMB);\n+            a0Fin = a0Fin & LIMB_MASK;\n+            a2Fin = a2Fin + (a1Fin >>> BITS_PER_LIMB);\n+            a1Fin = a1Fin & LIMB_MASK;\n+            a3Fin = a3Fin + (a2Fin >>> BITS_PER_LIMB);\n+            a2Fin = a2Fin & LIMB_MASK;\n+            a4Fin = a4Fin + (a3Fin >>> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+\n+            byte[] s_arr =\n+                Arrays.copyOfRange(keyBytes, RS_LENGTH, 2 * RS_LENGTH);\n+            int[] s = fromByteArray(s_arr);\n+\n+            \/\/ Add in the s-half of the key to the accumulator\n+            a0Fin += s[0];\n+            a1Fin += s[1];\n+            a2Fin += s[2];\n+            a3Fin += s[3];\n+            a4Fin += s[4];\n+\n+            \/\/ final carry mod 2^130\n+            a1Fin = a1Fin + (a0Fin >> BITS_PER_LIMB);\n+            a0Fin = a0Fin & LIMB_MASK;\n+            a2Fin = a2Fin + (a1Fin >> BITS_PER_LIMB);\n+            a1Fin = a1Fin & LIMB_MASK;\n+            a3Fin = a3Fin + (a2Fin >> BITS_PER_LIMB);\n+            a2Fin = a2Fin & LIMB_MASK;\n+            a4Fin = a4Fin + (a3Fin >> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+            a4Fin = a4Fin & LIMB_MASK;\n+\n+            \/\/ put result in buffer\n+            toByteArray(a0Fin, a1Fin, a2Fin, a3Fin, a4Fin, out);\n+        }\n+    }\n+\n+\n+    private static byte[] hexStringToByteArray(String str) {\n+        byte[] result = new byte[str.length() \/ 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (byte) Character.digit(str.charAt(2 * i), 16);\n+            result[i] <<= 4;\n+            result[i] += Character.digit(str.charAt(2 * i + 1), 16);\n+        }\n+        return result;\n+    }\n+\n+    public static String byteArrayToHexString(byte[] arr) {\n+        StringBuilder result = new StringBuilder();\n+        for (int i = 0; i < arr.length; ++i) {\n+            byte curVal = arr[i];\n+            result.append(Character.forDigit(curVal >> 4 & 0xF, 16));\n+            result.append(Character.forDigit(curVal & 0xF, 16));\n+        }\n+        return result.toString();\n+    }\n+\n+    private static void kat(Poly1305Vector poly1305, String key, String msg,\n+        String expectedTag) {\n+\n+        kat(poly1305, hexStringToByteArray(key), hexStringToByteArray(msg),\n+            hexStringToByteArray(expectedTag));\n+    }\n+\n+    private static void kat(Poly1305Vector poly1305, byte[] key, byte[] msg,\n+        byte[] expectedTag) {\n+\n+        byte[] tag = new byte[expectedTag.length];\n+        poly1305.computeTag(key, msg, tag);\n+        if (!Arrays.equals(tag, expectedTag)) {\n+            throw new RuntimeException(\n+                    \"bad tag: \" + byteArrayToHexString(tag) +\n+                    \" expected: \" + byteArrayToHexString(expectedTag));\n+        }\n+    }\n+\n+    \/*\n+     * Poly1305 Known Answer Tests to ensure that the implementation is correct.\n+     *\/\n+    private static void runKAT(Poly1305Vector poly1305) {\n+        kat(poly1305,\n+            \"d212b886dd4682a41f1759e6c5aef84760e5a63d4423ca7d1fb5c7ecfc5dac27\",\n+            \"5d2ad39e2a7b0bc5f375488643acf391188d01ad936971457427bc053c4262a1\" +\n+            \"598532850def8573213c5f79fa736703c57c03ec49b55617210998c8af408698\" +\n+            \"866632a7ecf7e9a688605cbca919e17e2badd090a7a6d83ad90be0617fa44642\" +\n+            \"cc9a1ca38514a026cbea51c287ec0b56719fc61183c88e9450ba85aa8ab7d390\",\n+            \"7ccdfa8e82df540276e8172f705adce2\");\n+\n+        kat(poly1305,\n+            \"2b0b684c86910104aee1d261ac4d5a0f5443b4b7746cf7f8ba03921d273f6a9b\",\n+            \"027b359f44a5d60f81073ceb74749207742529dcefa4a26a1817db2c8d50ba2b\" +\n+            \"d9e170cd1930946872d95e4eae41389f362087871a749897e0fbe42494e6f0b3\" +\n+            \"8db01e2059510b6fda4f422ce7d226433ba00940e1761baaff80d9b8f3a61d11\" +\n+            \"a109e6082d231cf85aa718199e6eaaaf07bad562469ef1b8e639c727967bf6da\" +\n+            \"bcd16fcb0fc102095325e2fac92e599e81c26900df1deb7b0a0b5c321a658024\" +\n+            \"26506740509ece646fecf33a517b66e57577372156aae85765c6b473521d1019\" +\n+            \"4f5fbe0e932cfee716e1d41c9154fb8e15b82ab7e807fb54f3d7d3e4c589cc9a\" +\n+            \"492d17ea4fd27894fa9d22a9db6d5df674cd1e97e7e8758a360291f22dfe1cc3\",\n+            \"84ca3a778faf0ab9f840fe5fb38ace27\");\n+\n+        kat(poly1305,\n+            \"870c6fa7da2eadb845ac8b0eeaed4cf856eca67bf96b64a29a2e6a881821fa8a\",\n+            \"ff1a3b67a4f575be5f05c4054e4c7365838c2cbe786ba78900c8b43f197c3c4d\" +\n+            \"120432a287e434669af579bcd56f3320e54d2f97a306f917f2f41b1c97cc69db\" +\n+            \"4ac2051adccd687fa89f92504d1ab5c3006681d846c8051aabccca0024ef5ec4\" +\n+            \"c43b8701ffc9d14fef8d55e229ed210a2b9bde996f5d7b545d15e1fc32764604\" +\n+            \"b2a0384dd173aa800b7526c8ff397c05130bb6a1f2194968adaef6979b023cd8\" +\n+            \"d9195d2739351c7e4ac6c43508634f813641f669e78cbcf732ccb1321a2cd2c4\" +\n+            \"14c7df5b9ea3408f2e12fbf3a3cbdb98699dd5402725ec25f9fff9bcd0f93cb3\" +\n+            \"cf0dac016fec41a5ef3ae8b8d258a09f530ad14ad2e52186041592eac0ea22ff\" +\n+            \"8c3751009b516c60f7764cccbb816394ef035bd8cb2a38d5c6b9229e528e56cd\" +\n+            \"62600b5219b64212642384e628f01d790eeef4963a7d1a63a9faff79d4acfa09\" +\n+            \"78b58b0b623ae89389661aa408b16814d3baaca20978dce6888c3365f4ffd2fa\" +\n+            \"8f031a44f2e870a06da21d7becf450d335e1386268bc189435e7955a477bc368\",\n+            \"ff4e0ee6feb1c6a57e638a79fafc7c60\");\n+\n+        kat(poly1305,\n+            \"c27987ae88a833ae2ea90371b2e257c15773da3bc34516b6b075446e1f844a81\",\n+            \"64e5a2e2940b173c7103ae931ced302a8f8c778f4e5c0b3677c51552655005d8\" +\n+            \"504b724107e7262448c94db83fc9c6a2a26fc973360dce15c0553b73bb733d3e\" +\n+            \"f61fcba8977e76c32523b80c3b45b1226b23ee17522f9b677880c69b356917ae\" +\n+            \"3c792a0c5b0c77b90dfa51483626323b7a73fffb1b128c595d553bf62a8f5bb9\" +\n+            \"fa48b4a850a932481bf607e8da84730c9052bba9316ec7eb84007a4eb5cbed5c\" +\n+            \"7c67ef32d4c5cb6cfbccd738d239857c240de6d3d4e5af14d480feb63541e5d8\" +\n+            \"036e088b2e32431e6fe0c4d3505aebe2e14bd02b6b15325f89aef048cd1236db\" +\n+            \"4461a59304b7c61ece2c52ef8ac4cf2326e6aaff013494b1b191be4ae4381f57\" +\n+            \"e72b947ee23d0a528087db9338bc28c68484929fc3436995b2083b06a765ceb7\" +\n+            \"09e9dd41ba896d99832d6851189766e844137d9a83d2890bc2be7afc82f9ebb8\" +\n+            \"bafe08ef5f7ff0cce9a1d08e6b797a17df04731f384a34b16e72e9f2ab070114\" +\n+            \"8008945509fe378658dc51eb752248f48364be327cd1b6bd148c518a976ae95d\" +\n+            \"d391f3b0d447251988c7e77400c9d44395b8f9f10cbc442a6804d0ad83e8c3e3\" +\n+            \"9fa09c2140fac143c90f09a7d907c57e29b528d54c8bd927f39aee2cec671213\" +\n+            \"c50fe657b29682d57a419e3e52dafb348cbe44b6c17e4be18f5c5e411734fcfc\" +\n+            \"99b9ca26f29a21cc93374ef1bfa86ca2bb3be76b94b4ef69ec790c968a51e4d0\",\n+            \"d4c09727f68fa3beb57ce9e74205b652\");\n+\n+        kat(poly1305,\n+            \"2593adf2efc0e49c7fde0d45de4f7a21ceb76df45c0e5a917ef1f6b7fbf4fb7e\",\n+            \"23665b9a6d4f04c9d58347d32d64d4cbf8d4ca993a8bb73758e6eb2db9f97096\" +\n+            \"d0f00aca8cb16460d2bc15c0136fa92482602f47b3ec78244c4dc619d9b28afa\" +\n+            \"19b063c196bcff848eff179102cce29dfcc58bf90a2f6311e6d021e2573ccbb4\" +\n+            \"4e06947167c9865127c0b7362196523f97c8157058f7aebff475f77e23393dc1\" +\n+            \"a3031bbaf31270db3eadc00cca6ae073aa53160d095afdce0a202de8a23d9a38\" +\n+            \"b0bed20cbe64e1ec77fc13ba0cfc9be52edb70475bf1aeaaff25e11f2e0ae47f\" +\n+            \"f23cbd4a6219d276fcc6c8f12a739f11434c86d4e24397f96ef6e36d9195fa8a\" +\n+            \"48eb55990d69feacfb754b5019a3ebafa98d5544077b46c136cc11de8ee7f8a6\" +\n+            \"76a6696600088696233f4e8f060ba8a64890fb638469639bfb727ed758c36250\" +\n+            \"a553b7ce1115509f2bb19c13cea87003a8eff45ce9e1cff0a21ba5ae19226d50\" +\n+            \"e108db212a588e5f4c502468859b9b607922c3311b5d912bd9400e696d7debbb\" +\n+            \"9ac5454cc7d0f95fc242c491f095a02f0d3bd7ead0f0b7358c9b1d85e4e9ab75\" +\n+            \"24bb43867c94a21a4e0db6470a210c9dd937e4801396bd687127fa7c83014c85\" +\n+            \"372553c56dfd6cd9b75fa10483aea825f8e3fa53c6bf17467e37c2e7439ed0ea\" +\n+            \"6fb24d13d428965c44f1ac943c7bc77fa84711c91b41f5ee6d9a7d9091648a96\" +\n+            \"cc7c261d7fc5d964446d1e3dcc41d32ecaa8d7791b8462563fcf7f96cd1d11d4\" +\n+            \"34923e0150321356866f5bdafebc96f2661bfd3c1f104e96b6492cafcbe25fc6\" +\n+            \"ec0c92a3bbec7328e1905d5951fae04625a2452f596027a5d9c64eed55165c8a\" +\n+            \"23bc3f944b4fa9c7ad83ebc1777c7153d5de13d04c0a12e774b17906a62f5134\" +\n+            \"685c2de31da08bd04840299fd62d56ffe95248365034e7ba95961cebf0542b24\",\n+            \"b9f68b0996caf5135136b10b37fe5f81\");\n+\n+        kat(poly1305,\n+            \"e9c8c78bc0ad5751f094fd4657fe5ef2a3c232f6930eef3431cde76659f04210\",\n+            \"914e57a2745fd475d7b8f982483fe11a05d7b55853239112d5ae99616c718b3c\" +\n+            \"4a0c2d05e3ca1df509614c0fe051b414d404149ec422e0998e192e51518518c4\" +\n+            \"b8acd9e3e3ff9f3b4ef931d3052755785d38e75821ceefa7da0bfe3f1fb2dc6d\" +\n+            \"738e2a2332e53ce77d44547621bb7aa724dd8805c7c795088db865d6b13d9b3e\" +\n+            \"8acec846efb072d105ab6e599f8292a7601087e0ba13af9f503dcfd426e26e4d\" +\n+            \"fb22bf5a1ff1a82d67d9bd8871e6adc17aa39d221f2865f81da9ed566192c269\" +\n+            \"3c85f0442924e603b9ae54b88dd0f21e92eedc40c08dd484c552e297894eeee8\" +\n+            \"b5acc91d5ae16f56257bb0836b48e1a8fa72e83a8b10b7026a7f466c8b08eac5\" +\n+            \"4359b70e639117cf688e263b891f004db94d77941380f3ab0559538c9398c859\" +\n+            \"b76d2bbcd6b635e753160583e7adc263097a80520d003514e134a21597c1ec57\" +\n+            \"55da3a70acc6951b4d4d81e98b9eb962d9e3bc37d5e8ebd61e2a3f61cc452a65\" +\n+            \"56571e12c190d4e3d0f8cc61ffcb60324b4a6987e7375a832ff807682e0b4595\" +\n+            \"66ef1f765638f3d2e837ed43ce2c1c7837f271c866908d865c3d9174fd4f8056\" +\n+            \"265abfb88fbc207db7a12c0a0ad035e5a728725e98cb682d41fd0bcf3aef2fd7\" +\n+            \"ab261727f310fc7cf3b34286c9e9ee235995315167191f3b4d77e5642fb57dbd\" +\n+            \"fdb5ccadefc5d03866918ab1a3eff54b405d8946e2b0c2fa444d1b2be4c3d41d\" +\n+            \"990515e7534190d66d10e38c36c5d3df0315db85ba10c924bef97d1faa07a5f8\" +\n+            \"f04998a7d38689237a1912bea3f821357d8383d7c5cfa66ba5965b5a94bb702c\" +\n+            \"e6583e59879021139355c5b90e0f9cd13b34f3357ffde404bbf34c97f9fd55b5\" +\n+            \"53e42d8a6b370eded02c8a5221e15db701da56918412520e12fd1ef9f4748647\" +\n+            \"858488d5e0abd5b9e01457768907e1d24581f9591771304192711292e4025fce\" +\n+            \"bd92adb2297e9496852f80bd78578bbdb292ca209f7584ff76e9eb66ec8a111e\" +\n+            \"add30dc7ef364c4f1339312f226fe0cfa7a5b1602417e469cf2c8e3874c51232\" +\n+            \"00f2d90dbe7f3c3ff5c6c6484052a80eb6229a6ed6176ad600da185da624bea6\",\n+            \"c1de44dd8ea245ca43e5587460feb514\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/Poly1305Bench.java","additions":663,"deletions":0,"binary":false,"changes":663,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import java.util.Random;\n+import java.util.function.IntFunction;\n+\n+public class AbstractVectorBenchmark {\n+    static final Random RANDOM = new Random(Integer.getInteger(\"jdk.incubator.vector.random-seed\", 1337));\n+\n+    static final VectorSpecies<Byte> B64  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> B128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Byte> B256 = ByteVector.SPECIES_256;\n+    static final VectorSpecies<Byte> B512 = ByteVector.SPECIES_512;\n+\n+    static final VectorSpecies<Short> S64  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+    static final VectorSpecies<Short> S512 = ShortVector.SPECIES_512;\n+\n+    static final VectorSpecies<Integer> I64  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> I128 = IntVector.SPECIES_128;\n+    static final VectorSpecies<Integer> I256 = IntVector.SPECIES_256;\n+    static final VectorSpecies<Integer> I512 = IntVector.SPECIES_512;\n+\n+    static final VectorSpecies<Long> L64  = LongVector.SPECIES_64;\n+    static final VectorSpecies<Long> L128 = LongVector.SPECIES_128;\n+    static final VectorSpecies<Long> L256 = LongVector.SPECIES_256;\n+    static final VectorSpecies<Long> L512 = LongVector.SPECIES_512;\n+\n+    static VectorShape widen(VectorShape s) {\n+        switch (s) {\n+            case S_64_BIT:  return VectorShape.S_128_BIT;\n+            case S_128_BIT: return VectorShape.S_256_BIT;\n+            case S_256_BIT: return VectorShape.S_512_BIT;\n+            default: throw new IllegalArgumentException(\"\" + s);\n+        }\n+    }\n+\n+    static VectorShape narrow(VectorShape s) {\n+        switch (s) {\n+            case S_512_BIT: return VectorShape.S_256_BIT;\n+            case S_256_BIT: return VectorShape.S_128_BIT;\n+            case S_128_BIT: return VectorShape.S_64_BIT;\n+            default: throw new IllegalArgumentException(\"\" + s);\n+        }\n+    }\n+\n+    static <E> VectorSpecies<E> widen(VectorSpecies<E> s) {\n+        return VectorSpecies.of(s.elementType(), widen(s.vectorShape()));\n+    }\n+\n+    static <E> VectorSpecies<E> narrow(VectorSpecies<E> s) {\n+        return VectorSpecies.of(s.elementType(), narrow(s.vectorShape()));\n+    }\n+\n+    static IntVector join(VectorSpecies<Integer> from, VectorSpecies<Integer> to, IntVector lo, IntVector hi) {\n+        assert 2 * from.length() == to.length();\n+\n+        int vlen = from.length();\n+        var lo_mask = mask(from, to, 0);\n+\n+        var v1 = lo.reinterpretShape(to, 0);\n+        var v2 = hi.reinterpretShape(to, 0).unslice(vlen);\n+        var r = v2.blend(v1, lo_mask);\n+        return (IntVector)r;\n+    }\n+\n+    static VectorMask<Integer> mask(VectorSpecies<Integer> from, VectorSpecies<Integer> to, int i) {\n+        int vlen = from.length();\n+        var v1 = IntVector.broadcast(from, 1);                   \/\/                         [1 1 ... 1]\n+        var v2 = v1.reinterpretShape(to, 0);                     \/\/ [0 0 ... 0 |   ...     | 1 1 ... 1]\n+        var v3 = v2.unslice(i * vlen);                           \/\/ [0 0 ... 0 | 1 1 ... 1 | 0 0 ... 0]\n+        return v3.compare(VectorOperators.NE, to.broadcast(0));  \/\/ [F F ... F | T T ... T | F F ... F]\n+    }\n+\n+    static <E> IntVector sum(ByteVector va) {\n+        VectorSpecies<Integer> species = VectorSpecies.of(Integer.class, va.shape());\n+        var acc = IntVector.zero(species);\n+        int limit = va.length() \/ species.length();\n+        for (int k = 0; k < limit; k++) {\n+            var vb = ((IntVector)(va.slice(k * B64.length()).reinterpretShape(B64, 0).castShape(species, 0))).and(0xFF);\n+            acc = acc.add(vb);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    boolean[] fillMask(int size, IntFunction<Boolean> f) {\n+        boolean[] array = new boolean[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] fillByte(int size, IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < size; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] fillInt(int size, IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] fillLong(int size, IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/AbstractVectorBenchmark.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ByteMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,1758 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ByteScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static byte bits(byte e) {\n+        return e;\n+    }\n+\n+    byte[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (byte)(2*i));\n+        bs = fill(i -> (byte)(i+1));\n+        cs = fill(i -> (byte)(i+5));\n+        rs = fill(i -> (byte)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> as;\n+    final IntFunction<byte[]> fb = vl -> bs;\n+    final IntFunction<byte[]> fc = vl -> cs;\n+    final IntFunction<byte[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a << (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a >> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(((a & 0xFF) >>> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a << (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(((a & 0xFF) >>> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a >> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROR_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROL_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = Byte.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (byte)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = Byte.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (byte)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = Byte.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (byte)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = Byte.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (byte)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    byte a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = new byte[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = new byte[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (byte)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] cs = fc.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                byte c = cs[i];\n+                rs[i] = (byte)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] cs = fc.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                byte c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(-((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(-((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(Math.abs((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(Math.abs((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(~((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(~((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(Integer.bitCount((int)a & 0xFF));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(Integer.bitCount((int)a & 0xFF)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":1758,"deletions":0,"binary":false,"changes":1758,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class DoubleMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1318 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class DoubleScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static long bits(double e) {\n+        return Double.doubleToLongBits(e);\n+    }\n+\n+    double[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (double)(2*i));\n+        bs = fill(i -> (double)(i+1));\n+        cs = fill(i -> (double)(i+5));\n+        rs = fill(i -> (double)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> as;\n+    final IntFunction<double[]> fb = vl -> bs;\n+    final IntFunction<double[]> fc = vl -> cs;\n+    final IntFunction<double[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Double.doubleToLongBits(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(Double.doubleToLongBits(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = Double.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (double)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = Double.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (double)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = Double.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (double)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = Double.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (double)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    double a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = new double[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = new double[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (double)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] cs = fc.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                double c = cs[i];\n+                rs[i] = (double)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] cs = fc.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                double c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(-((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(-((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.abs((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(Math.abs((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":1318,"deletions":0,"binary":false,"changes":1318,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1582 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class FloatMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":1582,"deletions":0,"binary":false,"changes":1582,"status":"added"},{"patch":"@@ -0,0 +1,1318 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class FloatScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static int bits(float e) {\n+        return Float.floatToIntBits(e);\n+    }\n+\n+    float[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (float)(2*i));\n+        bs = fill(i -> (float)(i+1));\n+        cs = fill(i -> (float)(i+5));\n+        rs = fill(i -> (float)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> as;\n+    final IntFunction<float[]> fb = vl -> bs;\n+    final IntFunction<float[]> fc = vl -> cs;\n+    final IntFunction<float[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Double.doubleToLongBits(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(Double.doubleToLongBits(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = Float.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (float)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = Float.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (float)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = Float.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (float)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = Float.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (float)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    float a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = new float[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = new float[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (float)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] cs = fc.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                float c = cs[i];\n+                rs[i] = (float)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] cs = fc.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                float c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(-((float)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(-((float)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.abs((float)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(Math.abs((float)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":1318,"deletions":0,"binary":false,"changes":1318,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IntMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,1758 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IntScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static int bits(int e) {\n+        return e;\n+    }\n+\n+    int[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (int)(2*i));\n+        bs = fill(i -> (int)(i+1));\n+        cs = fill(i -> (int)(i+5));\n+        rs = fill(i -> (int)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> as;\n+    final IntFunction<int[]> fb = vl -> bs;\n+    final IntFunction<int[]> fc = vl -> cs;\n+    final IntFunction<int[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROR_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROL_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = Integer.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (int)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = Integer.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (int)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = Integer.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (int)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = Integer.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (int)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = new int[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = new int[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (int)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] cs = fc.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                int c = cs[i];\n+                rs[i] = (int)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] cs = fc.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                int c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(-((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(-((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Math.abs((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Math.abs((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(~((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(~((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Integer.bitCount(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Integer.bitCount(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":1758,"deletions":0,"binary":false,"changes":1758,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class LongMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,1758 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class LongScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static long bits(long e) {\n+        return e;\n+    }\n+\n+    long[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (long)(2*i));\n+        bs = fill(i -> (long)(i+1));\n+        cs = fill(i -> (long)(i+5));\n+        rs = fill(i -> (long)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> as;\n+    final IntFunction<long[]> fb = vl -> bs;\n+    final IntFunction<long[]> fc = vl -> cs;\n+    final IntFunction<long[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROR_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROL_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = Long.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (long)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = Long.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (long)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = Long.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (long)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = Long.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (long)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    long a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = new long[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = new long[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (long)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] cs = fc.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                long c = cs[i];\n+                rs[i] = (long)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] cs = fc.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                long c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(-((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(-((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Math.abs((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Math.abs((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(~((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(~((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Long.bitCount(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Long.bitCount(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":1758,"deletions":0,"binary":false,"changes":1758,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Merge extends AbstractVectorBenchmark {\n+\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    int[] in, out;\n+\n+    @Setup\n+    public void setup() {\n+        size = size + (size % 64); \/\/ FIXME: process tails\n+        in  = new int[size];\n+        out = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            in[i] = i;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void merge64_128() {\n+        merge(I64, I128);\n+    }\n+\n+    @Benchmark\n+    public void merge128_256() {\n+        merge(I128, I256);\n+    }\n+\n+    @Benchmark\n+    public void merge256_512() {\n+        merge(I256, I512);\n+    }\n+\n+    @Benchmark\n+    public void merge64_256() {\n+        merge(I64, I256);\n+    }\n+\n+    @Benchmark\n+    public void merge128_512() {\n+        merge(I128, I512);\n+    }\n+\n+    @Benchmark\n+    public void merge64_512() {\n+        merge(I64, I256);\n+    }\n+\n+    IntVector merge(VectorSpecies<Integer> from, VectorSpecies<Integer> to, int idx) {\n+        assert from.length() <= to.length();\n+\n+        int vlenFrom = from.length();\n+        int vlenTo   =   to.length();\n+\n+        if (vlenFrom == vlenTo) {\n+            return IntVector.fromArray(from, in, idx);\n+        } else {\n+            var stepDown = narrow(to);\n+            int mid = stepDown.length();\n+            var lo = merge(from, stepDown, idx);\n+            var hi = merge(from, stepDown, idx + mid);\n+            return join(stepDown, to, lo, hi);\n+        }\n+    }\n+\n+\n+    void merge(VectorSpecies<Integer> from, VectorSpecies<Integer> to) {\n+        int vlenTo = to.length();\n+        for (int i = 0; i < in.length; i += vlenTo) {\n+            var r = merge(from, to, i);\n+            r.intoArray(out, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        assert Arrays.deepEquals(new Object[] {in}, new Object[] {out});\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Merge.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,630 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Population count algorithms from \"Faster Population Counts Using AVX2 Instructions\", 2018 by Mula, Kurz, Lemire\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class PopulationCount extends AbstractVectorBenchmark {\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    private long[] data;\n+\n+    @Setup\n+    public void init() {\n+        data = fillLong(size, i -> RANDOM.nextLong());\n+\/\/        data = fillLong(size, i -> 0L);\n+\/\/        data = fillLong(size, i -> -1L);\n+\n+        checkConsistency();\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        checkConsistency();\n+    }\n+\n+    void checkConsistency() {\n+        long popCount = longBitCount();\n+        assert popCount == treeOfAdders();\n+        assert popCount == WilkesWheelerGill();\n+        assert popCount == Wegner();\n+        assert popCount == Lauradoux();\n+        assert popCount == HarleySeal();\n+        assert popCount == Mula128();\n+        assert popCount == Mula256();\n+        assert popCount == HarleySeal256();\n+    }\n+\n+    long tail(int upper) {\n+        long acc = 0;\n+        for (int i = upper; i < data.length; i++) {\n+            acc += Long.bitCount(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    @Benchmark\n+    public long longBitCount() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += Long.bitCount(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 4. The Wegner function in C\n+\n+    long popcntWegner(long x) {\n+        int v = 0;\n+        while (x != 0) {\n+            x &= x - 1;\n+            v++;\n+        }\n+        return v;\n+    }\n+\n+    @Benchmark\n+    public long Wegner() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntWegner(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 2. A naive tree-of-adders function in C\n+\n+    static long popcntTree(long x) {\n+        long c1  = 0x5555555555555555L;\n+        long c2  = 0x3333333333333333L;\n+        long c4  = 0x0F0F0F0F0F0F0F0FL;\n+        long c8  = 0x00FF00FF00FF00FFL;\n+        long c16 = 0x0000FFFF0000FFFFL;\n+        long c32 = 0x00000000FFFFFFFFL;\n+\n+        x = (x & c1)  + ((x >>> 1)  & c1);\n+        x = (x & c2)  + ((x >>> 2)  & c2);\n+        x = (x & c4)  + ((x >>> 4)  & c4);\n+        x = (x & c8)  + ((x >>> 8)  & c8);\n+        x = (x & c16) + ((x >>> 16) & c16);\n+        x = (x & c32) + ((x >>> 32) & c32);\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long treeOfAdders() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntTree(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 3. The Wilkes-Wheeler-Gill function in C\n+\n+    static long popcntWWG(long x) {\n+        long c1 = 0x5555555555555555L;\n+        long c2 = 0x3333333333333333L;\n+        long c4 = 0x0F0F0F0F0F0F0F0FL;\n+\n+        x -= (x >>> 1) & c1;\n+        x = (( x >>> 2) & c2) + (x & c2) ;\n+        x = ( x + (x >>> 4) ) & c4;\n+        x *= 0x0101010101010101L;\n+        x = x >>> 56;\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long WilkesWheelerGill() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntWWG(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 5. The Lauradoux population count in C for sets of 12 words.\n+\n+    static long parallelPopcnt(long count1, long count2, long count3) {\n+        long m1  = 0x5555555555555555L;\n+        long m2  = 0x3333333333333333L;\n+        long m4  = 0x0F0F0F0F0F0F0F0FL;\n+\n+        long half1 = (count3      ) & m1;\n+        long half2 = (count3 >>> 1) & m1;\n+\n+        count1 -= (count1 >>> 1) & m1;\n+        count2 -= (count2 >>> 1) & m1;\n+        count1 += half1;\n+        count2 += half2;\n+        count1  = (count1 & m2) + (( count1 >>> 2) & m2);\n+        count1 += (count2 & m2) + (( count2 >>> 2) & m2);\n+        return (count1 & m4) + (( count1 >>> 4) & m4);\n+    }\n+\n+    static long reduce(long acc) {\n+        long m8  = 0x00FF00FF00FF00FFL;\n+        long m16 = 0x0000FFFF0000FFFFL;\n+        long m32 = 0x00000000FFFFFFFFL;\n+\n+        acc = (acc & m8) + (( acc >>> 8) & m8);\n+        acc = (acc + (acc >>> 16) ) & m16;\n+        acc = (acc & m32) + (acc >>> 32);\n+        return acc;\n+    }\n+\n+    static long popcntLauradoux(long[] xs, int off) {\n+        long acc = 0;\n+        for (int j = off; j < off+12; j += 3) {\n+            acc += parallelPopcnt(xs[j+0], xs[j+1], xs[j+2]);\n+        }\n+        return reduce(acc);\n+    }\n+\n+    @Benchmark\n+    public long Lauradoux() {\n+        long acc = 0;\n+        int upper = data.length - (data.length % 12);\n+        for (int i = 0; i < upper; i += 12) {\n+            acc += popcntLauradoux(data, i);\n+        }\n+        return acc + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 6. A C function implementing a bitwise parallel carry-save adder (CSA). Given three input words a, b, c, it\n+    \/\/ generates two new words h, l in which each bit represents the high and low bits in the bitwise sum of the bits from a,\n+    \/\/ b, and c.\n+\n+    static long csaLow(long a, long b, long c) {\n+        long u = a ^ b;\n+        long lo = u ^ c;\n+        return lo;\n+    }\n+\n+    static long csaHigh(long a, long b, long c) {\n+        long u = a ^ b;\n+        long hi = (a & b) | (u & c) ;\n+        return hi;\n+    }\n+\n+    \/\/ FIGURE 8. A C function implementing the Harley-Seal\n+    \/\/ population count over an array of 64-bit words. The count\n+    \/\/ function could be the Wilkes-Wheeler-Gill function.\n+    @Benchmark\n+    public long HarleySeal() {\n+        long total = 0, ones = 0, twos = 0, fours = 0, eights = 0, sixteens = 0;\n+        long twosA   = 0, twosB   = 0;\n+        long foursA  = 0, foursB  = 0;\n+        long eightsA = 0, eightsB = 0;\n+\n+        int step = 16;\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            \/\/ CSA(&twosA, &ones, ones, d[i+0], d[i +1]);\n+            twosA = csaHigh(ones, data[i+0], data[i+1]);\n+            ones  = csaLow(ones, data[i+0], data[i+1]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+2], d[i+3]);\n+            twosB = csaHigh(ones, data[i+2], data[i+3]);\n+            ones  = csaLow(ones, data[i+2], data[i+3]);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+4], d[i+5]);\n+            twosA = csaHigh(ones, data[i+4], data[i+5]);\n+            ones  = csaLow(ones, data[i+4], data[i+5]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+6], d[i+7]);\n+            twosB = csaHigh(ones, data[i+6], data[i+7]);\n+            ones  = csaLow(ones, data[i+6], data[i+7]);\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&eightsA, &fours, fours, foursA, foursB);\n+            eightsA = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+8], d[i+9]);\n+            twosA = csaHigh(ones, data[i+8], data[i+9]);\n+            ones  = csaLow(ones, data[i+8], data[i+9]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+10],d[i+11]);\n+            twosB = csaHigh(ones, data[i+10], data[i+11]);\n+            ones  = csaLow(ones, data[i+10], data[i+11]);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+12], d[i +13]);\n+            twosA = csaHigh(ones, data[i+12], data[i+13]);\n+            ones  = csaLow(ones, data[i+12], data[i+13]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+14], d[i +15]);\n+            twosB = csaHigh(ones, data[i+14], data[i+15]);\n+            ones  = csaLow(ones, data[i+14], data[i+15]);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ CSA(&eightsB, &fours, fours, foursA, foursB);\n+            eightsB = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&sixteens, &eights, eights, eightsA, eightsB);\n+            sixteens = csaHigh(eights, eightsA, eightsB);\n+            eights   = csaLow(eights, eightsA, eightsB);\n+\n+            total += Long.bitCount(sixteens);\n+        }\n+        total = 16 * total\n+                + 8 * Long.bitCount(eights)\n+                + 4 * Long.bitCount(fours)\n+                + 2 * Long.bitCount(twos)\n+                + 1 * Long.bitCount(ones);\n+\n+        return total + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 9. A C function using SSE intrinsics implementing Mula's algorithm to compute sixteen population counts,\n+    \/\/ corresponding to sixteen input bytes.\n+\n+    static final ByteVector MULA128_LOOKUP = IntVector.fromArray(I128,\n+            new int[]{\n+                    0x02_01_01_00, \/\/ 0, 1, 1, 2,\n+                    0x03_02_02_01, \/\/ 1, 2, 2, 3,\n+                    0x03_02_02_01, \/\/ 1, 2, 2, 3,\n+                    0x04_03_03_02  \/\/ 2, 3, 3, 4\n+            },\n+            0\n+            ).reinterpretAsBytes();\n+\n+    ByteVector popcntB128(ByteVector v) {\n+        var low_mask = ByteVector.broadcast(B128, (byte)0x0f);\n+\n+        var lo = v          .and(low_mask);\n+        var hi = v.lanewise(VectorOperators.LSHR, 4).and(low_mask);\n+\n+        var cnt1 = MULA128_LOOKUP.rearrange(lo.toShuffle());\n+        var cnt2 = MULA128_LOOKUP.rearrange(hi.toShuffle());\n+\n+        return cnt1.add(cnt2);\n+    }\n+\n+    @Benchmark\n+    public long Mula128() {\n+        var acc = LongVector.zero(L128); \/\/ IntVector\n+        int step = 32; \/\/ % B128.length() == 0!\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            var bacc = ByteVector.zero(B128);\n+            for (int j = 0; j < step; j += L128.length()) {\n+                var v1 = LongVector.fromArray(L128, data, i + j);\n+                var v2 = v1.reinterpretAsBytes();\n+                var v3 = popcntB128(v2);\n+                bacc = bacc.add(v3);\n+            }\n+            acc = acc.add(sumUnsignedBytes(bacc));\n+        }\n+        var r = acc.reduceLanes(VectorOperators.ADD) + tail(upper);\n+        return r;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 10. A C function using AVX2 intrinsics implementing Mula's algorithm to compute the four population counts\n+    \/\/ of the four 64-bit words in a 256-bit vector. The 32 B output vector should be interpreted as four separate\n+    \/\/ 64-bit counts that need to be summed to obtain the final population count.\n+\n+    static final ByteVector MULA256_LOOKUP = \n+            join(I128, I256, MULA128_LOOKUP.reinterpretAsInts(), MULA128_LOOKUP.reinterpretAsInts()).reinterpretAsBytes();\n+\n+    ByteVector popcntB256(ByteVector v) {\n+        var low_mask = ByteVector.broadcast(B256, (byte)0x0F);\n+\n+        var lo = v          .and(low_mask);\n+        var hi = v.lanewise(VectorOperators.LSHR, 4).and(low_mask);\n+\n+        var cnt1 = MULA256_LOOKUP.rearrange(lo.toShuffle());\n+        var cnt2 = MULA256_LOOKUP.rearrange(hi.toShuffle());\n+        var cnt = cnt1.add(cnt2);\n+\n+        return cnt;\n+    }\n+\n+    \/\/ Horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers,\n+    \/\/ and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in dst:\n+    \/\/   _mm256_sad_epu8(total, _mm256_setzero_si256())\n+    LongVector sumUnsignedBytes(ByteVector vb) {\n+        return sumUnsignedBytesShapes(vb);\n+\/\/        return sumUnsignedBytesShifts(vb);\n+    }\n+\n+    LongVector sumUnsignedBytesShapes(ByteVector vb) {\n+        VectorSpecies<Short> shortSpecies = VectorSpecies.of(short.class, vb.shape());\n+        VectorSpecies<Integer> intSpecies = VectorSpecies.of(int.class, vb.shape());\n+        VectorSpecies<Long> longSpecies = VectorSpecies.of(long.class, vb.shape());\n+\n+        var low_short_mask = ShortVector.broadcast(shortSpecies, (short) 0xFF);\n+        var low_int_mask = IntVector.broadcast(intSpecies, 0xFFFF);\n+        var low_long_mask = LongVector.broadcast(longSpecies, 0xFFFFFFFFL);\n+\n+        var vs = vb.reinterpretAsShorts(); \/\/ 16-bit\n+        var vs0 = vs.and(low_short_mask);\n+        var vs1 = vs.lanewise(VectorOperators.LSHR, 8).and(low_short_mask);\n+        var vs01 = vs0.add(vs1);\n+\n+        var vi = vs01.reinterpretAsInts(); \/\/ 32-bit\n+        var vi0 = vi.and(low_int_mask);\n+        var vi1 = vi.lanewise(VectorOperators.LSHR, 16).and(low_int_mask);\n+        var vi01 = vi0.add(vi1);\n+\n+        var vl = vi01.reinterpretAsLongs(); \/\/ 64-bit\n+        var vl0 = vl.and(low_long_mask);\n+        var vl1 = vl.lanewise(VectorOperators.LSHR, 32).and(low_long_mask);\n+        var vl01 = vl0.add(vl1);\n+\n+        return vl01;\n+    }\n+\n+    LongVector sumUnsignedBytesShifts(ByteVector vb) {\n+        VectorSpecies<Long> to = VectorSpecies.of(long.class, vb.shape());\n+\n+        var low_mask = LongVector.broadcast(to, 0xFF);\n+\n+        var vl = vb.reinterpretAsLongs();\n+\n+        var v0 = vl           .and(low_mask); \/\/ 8-bit\n+        var v1 = vl.lanewise(VectorOperators.LSHR, 8).and(low_mask);  \/\/ 8-bit\n+        var v2 = vl.lanewise(VectorOperators.LSHR, 16).and(low_mask); \/\/ 8-bit\n+        var v3 = vl.lanewise(VectorOperators.LSHR, 24).and(low_mask); \/\/ 8-bit\n+        var v4 = vl.lanewise(VectorOperators.LSHR, 32).and(low_mask); \/\/ 8-bit\n+        var v5 = vl.lanewise(VectorOperators.LSHR, 40).and(low_mask); \/\/ 8-bit\n+        var v6 = vl.lanewise(VectorOperators.LSHR, 48).and(low_mask); \/\/ 8-bit\n+        var v7 = vl.lanewise(VectorOperators.LSHR, 56).and(low_mask); \/\/ 8-bit\n+\n+        var v01 = v0.add(v1);\n+        var v23 = v2.add(v3);\n+        var v45 = v4.add(v5);\n+        var v67 = v6.add(v7);\n+\n+        var v03 = v01.add(v23);\n+        var v47 = v45.add(v67);\n+\n+        var sum = v03.add(v47); \/\/ 64-bit\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long Mula256() {\n+        var acc = LongVector.zero(L256);\n+        int step = 32; \/\/ % B256.length() == 0!\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            var bacc = ByteVector.zero(B256);\n+            for (int j = 0; j < step; j += L256.length()) {\n+                var v1 = LongVector.fromArray(L256, data, i + j);\n+                var v2 = popcntB256(v1.reinterpretAsBytes());\n+                bacc = bacc.add(v2);\n+            }\n+            acc = acc.add(sumUnsignedBytes(bacc));\n+        }\n+        return acc.reduceLanes(VectorOperators.ADD) + tail(upper);\n+    }\n+\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 11. A C function using AVX2 intrinsics implementing a bitwise parallel carry-save adder (CSA).\n+\n+    LongVector csaLow(LongVector a, LongVector b, LongVector c) {\n+        var u = a.lanewise(VectorOperators.XOR, b);\n+        var r = u.lanewise(VectorOperators.XOR, c);\n+        return r;\n+    }\n+\n+    LongVector csaHigh(LongVector a, LongVector b, LongVector c) {\n+        var u  = a.lanewise(VectorOperators.XOR, b);\n+        var ab = a.and(b);\n+        var uc = u.and(c);\n+        var r  = ab.or(uc); \/\/ (a & b) | ((a ^ b) & c)\n+        return r;\n+    }\n+\n+    LongVector popcntL256(LongVector v) {\n+        var vb1 = v.reinterpretAsBytes();\n+        var vb2 = popcntB256(vb1);\n+        return sumUnsignedBytes(vb2);\n+    }\n+\n+    \/\/ FIGURE 12. A C function using AVX2 intrinsics implementing Harley-Seal's algorithm. It assumes, for\n+    \/\/ simplicity, that the input size in 256-bit vectors is divisible by 16. See Fig. 10 for the count function.\n+\n+    @Benchmark\n+    public long HarleySeal256() {\n+        LongVector ones, twos, fours, eights, sixteens, vtotal, twosA, twosB, foursA, foursB, eightsA, eightsB;\n+        ones = twos = fours = eights = sixteens = twosA = twosB = foursA = foursB = eightsA = eights = vtotal = LongVector.broadcast(L256, 0);\n+\n+        var vlen = L256.length();\n+        int step = 16 * vlen;\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            \/\/ CSA(&twosA, &ones, ones, d[i+0], d[i +1]);\n+            var d0 = LongVector.fromArray(L256, data, i + 0 * vlen);\n+            var d1 = LongVector.fromArray(L256, data, i + 1 * vlen);\n+\n+            twosA = csaHigh(ones, d0, d1);\n+            ones  = csaLow(ones, d0, d1);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+2], d[i+3]);\n+            var d2 = LongVector.fromArray(L256, data, i + 2 * vlen);\n+            var d3 = LongVector.fromArray(L256, data, i + 3 * vlen);\n+            twosB = csaHigh(ones, d2, d3);\n+            ones  = csaLow(ones, d2, d3);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+4], d[i+5]);\n+            var d4 = LongVector.fromArray(L256, data, i + 4 * vlen);\n+            var d5 = LongVector.fromArray(L256, data, i + 5 * vlen);\n+            twosA = csaHigh(ones, d4, d5);\n+            ones  = csaLow(ones, d4, d5);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+6], d[i+7]);\n+            var d6 = LongVector.fromArray(L256, data, i + 6 * vlen);\n+            var d7 = LongVector.fromArray(L256, data, i + 7 * vlen);\n+            twosB = csaHigh(ones, d6, d7);\n+            ones  = csaLow(ones, d6, d7);\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&eightsA, &fours, fours, foursA, foursB);\n+            eightsA = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+8], d[i+9]);\n+            var d8 = LongVector.fromArray(L256, data, i + 8 * vlen);\n+            var d9 = LongVector.fromArray(L256, data, i + 9 * vlen);\n+            twosA = csaHigh(ones, d8, d9);\n+            ones  = csaLow(ones, d8, d9);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+10],d[i+11]);\n+            var d10 = LongVector.fromArray(L256, data, i + 10 * vlen);\n+            var d11 = LongVector.fromArray(L256, data, i + 11 * vlen);\n+            twosB = csaHigh(ones, d10, d11);\n+            ones  = csaLow(ones, d10, d11);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+12], d[i +13]);\n+            var d12 = LongVector.fromArray(L256, data, i + 12 * vlen);\n+            var d13 = LongVector.fromArray(L256, data, i + 13 * vlen);\n+            twosA = csaHigh(ones, d12, d13);\n+            ones  = csaLow(ones, d12, d13);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+14], d[i +15]);\n+            var d14 = LongVector.fromArray(L256, data, i + 14 * vlen);\n+            var d15 = LongVector.fromArray(L256, data, i + 15 * vlen);\n+            twosB = csaHigh(ones, d14, d15);\n+            ones  = csaLow(ones, d14, d15);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ CSA(&eightsB, &fours, fours, foursA, foursB);\n+            eightsB = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&sixteens, &eights, eights, eightsA, eightsB);\n+            sixteens = csaHigh(eights, eightsA, eightsB);\n+            eights   = csaLow(eights, eightsA, eightsB);\n+\n+            vtotal = vtotal.add(popcntL256(sixteens));\n+        }\n+\n+        vtotal = vtotal.mul(16);                       \/\/ << 4\n+        vtotal = vtotal.add(popcntL256(eights).mul(8)); \/\/ << 3\n+        vtotal = vtotal.add(popcntL256(fours).mul(4));  \/\/ << 2\n+        vtotal = vtotal.add(popcntL256(twos).mul(2));   \/\/ << 1\n+        vtotal = vtotal.add(popcntL256(ones));          \/\/ << 0\n+\n+        var total = vtotal.reduceLanes(VectorOperators.ADD);\n+\n+        return total + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+\/\/    ByteVector csaLow512(ByteVector a, ByteVector b, ByteVector c) {\n+\/\/        return _mm512_ternarylogic_epi32(c, b, a, 0x96); \/\/ vpternlogd\n+\/\/    }\n+\/\/\n+\/\/    ByteVector csaLow512(ByteVector a, ByteVector b, ByteVector c) {\n+\/\/        return _mm512_ternarylogic_epi32(c, b, a, 0xe8); \/\/ vpternlogd\n+\/\/    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/PopulationCount.java","additions":630,"deletions":0,"binary":false,"changes":630,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,2058 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ShortMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":2058,"deletions":0,"binary":false,"changes":2058,"status":"added"},{"patch":"@@ -0,0 +1,1758 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ShortScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    short[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (short)(2*i));\n+        bs = fill(i -> (short)(i+1));\n+        cs = fill(i -> (short)(i+5));\n+        rs = fill(i -> (short)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> as;\n+    final IntFunction<short[]> fb = vl -> bs;\n+    final IntFunction<short[]> fc = vl -> cs;\n+    final IntFunction<short[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a << (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a >> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(((a & 0xFFFF) >>> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a << (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(((a & 0xFFFF) >>> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a >> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROR_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROL_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = Short.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (short)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = Short.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (short)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = Short.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (short)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = Short.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (short)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    short a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = new short[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = new short[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (short)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                rs[i] = (short)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(-((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(-((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Math.abs((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Math.abs((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(~((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(~((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Integer.bitCount((int)a & 0xFFFF));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Integer.bitCount((int)a & 0xFFFF)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":1758,"deletions":0,"binary":false,"changes":1758,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Inspired by \"Sorting an AVX512 register\"\n+ *   http:\/\/0x80.pl\/articles\/avx512-sort-register.html\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SortVector extends AbstractVectorBenchmark {\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    int[] in, out;\n+\n+    @Setup\n+    public void setup() {\n+        size = size + (size % 16); \/\/ FIXME: process tails\n+        in  = fillInt(size, i -> RANDOM.nextInt());\n+        out = new int[size];\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI64() {\n+        sort(I64);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI128() {\n+        sort(I128);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI256() {\n+        sort(I256);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI512() {\n+        sort(I512);\n+    }\n+\n+\n+    void sort(VectorSpecies<Integer> spec) {\n+        var iota = (IntVector) VectorShuffle.iota(spec, 0, 1, false).toVector(); \/\/ [ 0 1 ... n ]\n+\n+        var result = IntVector.broadcast(spec, 0);\n+        var index = IntVector.broadcast(spec, 0);\n+        var incr = IntVector.broadcast(spec, 1);\n+\n+        for (int i = 0; i < in.length; i += spec.length()) {\n+            var input = IntVector.fromArray(spec, in, i);\n+\n+            for (int j = 0; j < input.length(); j++) {\n+                var shuf = index.toShuffle().wrapIndexes();\n+                var b = input.rearrange(shuf); \/\/ broadcast j-th element\n+                var lt = input.lt(b).trueCount();\n+                var eq = input.eq(b).trueCount();\n+\n+                \/\/ int\/long -> mask?\n+                \/\/ int m = (1 << (lt + eq)) - (1 << lt);\n+                \/\/ var mask = masks[lt + eq].lanewise(VectorOperators.XOR, masks[lt]);\n+                \/\/ var mask = masks[lt + eq].and(masks[lt].not());\n+                \/\/\n+                \/\/ masks[i] =  [ 0 0 ... 0 1 ... 1 ]\n+                \/\/                      i-th\n+                var m = iota.lt(spec.broadcast(lt + eq)).and(iota.lt(spec.broadcast(lt)).not());\n+\n+                result = result.blend(b, m);\n+                index = index.add(incr);\n+            }\n+            result.intoArray(out, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/SortVector.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\n+\/\/ Inspired by \"SIMDized sum of all bytes in the array\"\n+\/\/   http:\/\/0x80.pl\/notesen\/2018-10-24-sse-sumbytes.html\n+\/\/\n+\/\/ C\/C++ equivalent: https:\/\/github.com\/WojciechMula\/toys\/tree\/master\/sse-sumbytes\n+\/\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SumOfUnsignedBytes extends AbstractVectorBenchmark {\n+\n+    @Param({\"64\", \"1024\", \"4096\"})\n+    int size;\n+\n+    private byte[] data;\n+\n+    @Setup\n+    public void init() {\n+        size = size + size % 32; \/\/ FIXME: process tails\n+        data = fillByte(size, i -> (byte)(int)i);\n+\n+        int sum = scalar();\n+        assert vectorInt() == sum;\n+        assert vectorShort() == sum;\n+        \/\/assert vectorByte() == sum;\n+        \/\/assert vectorSAD() == sum;\n+    }\n+\n+    @Benchmark\n+    public int scalar() {\n+        int sum = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            sum += data[i] & 0xFF;\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ 1. 32-bit accumulators\n+    @Benchmark\n+    public int vectorInt() {\n+        final var lobyte_mask = IntVector.broadcast(I256, 0x000000FF);\n+\n+        var acc = IntVector.zero(I256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var vb = ByteVector.fromArray(B256, data, i);\n+            var vi = (IntVector)vb.reinterpretAsInts();\n+            for (int j = 0; j < 4; j++) {\n+                var tj = vi.lanewise(VectorOperators.LSHR, j * 8).and(lobyte_mask);\n+                acc = acc.add(tj);\n+            }\n+        }\n+        return (int)Integer.toUnsignedLong(acc.reduceLanes(VectorOperators.ADD));\n+    }\n+\n+    \/\/ 2. 16-bit accumulators\n+    @Benchmark\n+    public int vectorShort() {\n+        final var lobyte_mask = ShortVector.broadcast(S256, (short) 0x00FF);\n+\n+        \/\/ FIXME: overflow\n+        var acc = ShortVector.zero(S256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var vb = ByteVector.fromArray(B256, data, i);\n+            var vs = (ShortVector)vb.reinterpretAsShorts();\n+            for (int j = 0; j < 2; j++) {\n+                var tj = vs.lanewise(VectorOperators.LSHR, j * 8).and(lobyte_mask);\n+                acc = acc.add(tj);\n+            }\n+        }\n+\n+        int mid = S128.length();\n+        var accLo = ((IntVector)(acc.reinterpretShape(S128, 0).castShape(I256, 0))).and(0xFFFF); \/\/ low half as ints\n+        var accHi = ((IntVector)(acc.reinterpretShape(S128, 1).castShape(I256, 0))).and(0xFFFF); \/\/ high half as ints\n+        return accLo.reduceLanes(VectorOperators.ADD) + accHi.reduceLanes(VectorOperators.ADD);\n+    }\n+\n+    \/*\n+    \/\/ 3. 8-bit halves (MISSING: _mm_adds_epu8)\n+    @Benchmark\n+    public int vectorByte() {\n+        int window = 256;\n+        var acc_hi  = IntVector.zero(I256);\n+        var acc8_lo = ByteVector.zero(B256);\n+        for (int i = 0; i < data.length; i += window) {\n+            var acc8_hi = ByteVector.zero(B256);\n+            int limit = Math.min(window, data.length - i);\n+            for (int j = 0; j < limit; j += B256.length()) {\n+                var vb = ByteVector.fromArray(B256, data, i + j);\n+\n+                var t0 = acc8_lo.add(vb);\n+                var t1 = addSaturated(acc8_lo, vb); \/\/ MISSING\n+                var overflow = t0.notEqual(t1);\n+\n+                acc8_lo = t0;\n+                acc8_hi = acc8_hi.add((byte) 1, overflow);\n+            }\n+            acc_hi = acc_hi.add(sum(acc8_hi));\n+        }\n+        return sum(acc8_lo)\n+                .add(acc_hi.mul(256)) \/\/ overflow\n+                .addAll();\n+    }\n+\n+    \/\/ 4. Sum Of Absolute Differences (SAD) (MISSING: VPSADBW, _mm256_sad_epu8)\n+    public int vectorSAD() {\n+        var acc = IntVector.zero(I256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var v = ByteVector.fromArray(B256, data, i);\n+            var sad = sumOfAbsoluteDifferences(v, ByteVector.zero(B256)); \/\/ MISSING\n+            acc = acc.add(sad);\n+        }\n+        return acc.addAll();\n+    } *\/\n+\n+    \/\/ Helpers\n+    \/*\n+    static ByteVector addSaturated(ByteVector va, ByteVector vb) {\n+        var vc = ByteVector.zero(B256);\n+        for (int i = 0; i < B256.length(); i++) {\n+            if ((va.get(i) & 0xFF) + (vb.get(i) & 0xFF) < 0xFF) {\n+                vc = vc.withLane(i, (byte)(va.get(i) + vb.get(i)));\n+            } else {\n+                vc = vc.withLane(i, (byte)0xFF);\n+            }\n+        }\n+        return vc;\n+    }\n+    IntVector sumOfAbsoluteDifferences(ByteVector va, ByteVector vb) {\n+        var vc = ByteVector.zero(B256);\n+        for (int i = 0; i < B256.length(); i++) {\n+            if ((va.get(i) & 0xFF) > (vb.get(i) & 0xFF)) {\n+                vc = vc.withLane(i, (byte)(va.get(i) - vb.get(i)));\n+            } else {\n+                vc = vc.withLane(i, (byte)(vb.get(i) - va.get(i)));\n+            }\n+        }\n+        return sum(vc);\n+    } *\/\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/SumOfUnsignedBytes.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.utf8;\n+\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CoderResult;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import jdk.incubator.vector.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 5, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class DecodeBench {\n+\n+    @Param({\"32768\", \"8388608\"})\n+    private int dataSize;\n+\n+    @Param({\"1\", \"2\", \"3\", \"4\"})\n+    private int maxBytes;\n+\n+    private ByteBuffer src;\n+    private CharBuffer dst;\n+    private String in;\n+    private String out;\n+\n+    private static final VectorSpecies<Byte>  B128 = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+\n+    private static final HashMap<Long, DecoderLutEntry> lutTable = new HashMap<Long, DecoderLutEntry>();\n+\n+    private static class DecoderLutEntry {\n+        public final VectorShuffle<Byte> shufAB;   \/\/ shuffling mask to get lower two bytes of symbols\n+        public final VectorShuffle<Byte> shufC;    \/\/ shuffling mask to get third bytes of symbols\n+        public final byte srcStep;                 \/\/ number of bytes processed in input buffer\n+        public final byte dstStep;                 \/\/ number of symbols produced in output buffer (doubled)\n+        public final Vector<Byte> headerMask;      \/\/ mask of \"111..10\" bits required in each byte\n+        public final Vector<Short> zeroBits;\n+\n+        public DecoderLutEntry(VectorShuffle<Byte> _shufAB, VectorShuffle<Byte> _shufC,\n+                               byte _srcStep, byte _dstStep,\n+                               Vector<Byte> _headerMask, Vector<Short> _zeroBits) {\n+            shufAB = _shufAB;\n+            shufC = _shufC;\n+            srcStep = _srcStep;\n+            dstStep = _dstStep;\n+            headerMask = _headerMask;\n+            zeroBits = _zeroBits;\n+        }\n+\n+        \/\/ @Override\n+        \/\/ public String toString() {\n+        \/\/     return String.format(\"shufAB = %s, shufC = %s, srcStep = %d, dstStep = %d, headerMask = %s, zeroBits = %s\",\n+        \/\/         arrayToString(shufAB), arrayToString(shufC), srcStep, dstStep, arrayToString(headerMask), arrayToString(zeroBits));\n+        \/\/ }\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupLutTable() {\n+        int[] sizes = new int[32];\n+        computeLutRecursive(sizes, 0, 0); \/\/10609 entries total\n+\n+        \/\/ for (var entry : lutTable.entrySet()) {\n+        \/\/     System.out.println(\"\" + entry.getKey() + \" -> \" + entry.getValue());\n+        \/\/ }\n+    }\n+\n+    static void computeLutRecursive(int[] sizes, int num, int total) {\n+        if (total >= 16) {\n+            computeLutEntry(sizes, num);\n+            return;\n+        }\n+        for (int size = 1; size <= 3; size++) {\n+            sizes[num] = size;\n+            computeLutRecursive(sizes, num + 1, total + size);\n+        }\n+    }\n+\n+    static void computeLutEntry(int[] sizes, int num) {\n+        \/\/find maximal number of chars to decode\n+        int cnt = num - 1;\n+        int preSum = 0;\n+        for (int i = 0; i < cnt; i++)\n+            preSum += sizes[i];\n+        assert preSum < 16;\n+        \/\/ Note: generally, we can process a char only if the next byte is within XMM register\n+        \/\/ However, if the last char takes 3 bytes and fits the register tightly, we can take it too\n+        if (preSum == 13 && preSum + sizes[cnt] == 16)\n+            preSum += sizes[cnt++];\n+        \/\/still cannot process more that 8 chars per register\n+        while (cnt > 8)\n+            preSum -= sizes[--cnt];\n+\n+        \/\/generate bitmask\n+        long mask = 0;\n+        for (int i = 0, pos = 0; i < num; i++) {\n+            for (int j = 0; j < sizes[i]; j++, pos++) {\n+                \/\/ The first byte is not represented in the mask\n+                if (j > 0) {\n+                    mask |= 1 << pos;\n+                }\n+            }\n+        }\n+        assert mask <= 0xFFFF;\n+\n+        \/\/generate shuffle masks\n+        byte[] shufAB = new byte[16];\n+        byte[] shufC  = new byte[16];\n+        for (int i = 0; i < 16; i++)\n+            shufAB[i] = shufC[i] = (byte)0xFF;\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = sz-1; j >= 0; j--, pos++) {\n+                if (j < 2)\n+                    shufAB[2 * i + j] = (byte)pos;\n+                else\n+                    shufC[2 * i] = (byte)pos;\n+            }\n+        }\n+\n+        \/\/generate header masks for validation\n+        byte[] headerMask = new byte[16];\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = 0; j < sz; j++, pos++) {\n+                int bits;\n+                if      (j > 0)    bits = 2;\n+                else if (sz == 1)  bits = 1;\n+                else if (sz == 2)  bits = 3;\n+                else   \/*sz == 3*\/ bits = 4;\n+                headerMask[pos] = (byte)-(1 << (8 - bits));\n+            }\n+        }\n+\n+        \/\/generate min symbols values for validation\n+        short[] zeroBits = new short[8];\n+        for (int i = 0; i < 8; i++) {\n+            int sz = i < cnt ? sizes[i] : 1;\n+            if      (sz == 1)  zeroBits[i] = (short)(0xFF80);\n+            else if (sz == 2)  zeroBits[i] = (short)(0xF800);\n+            else   \/*sz == 3*\/ zeroBits[i] = (short)(0x0000);\n+        }\n+\n+        \/\/store info into the lookup table\n+        lutTable.put(mask, new DecoderLutEntry(ByteVector.fromArray(B128, shufAB, 0).toShuffle(),\n+                                               ByteVector.fromArray(B128, shufC, 0).toShuffle(),\n+                                               (byte)preSum, (byte)cnt,\n+                                               ByteVector.fromArray(B128, headerMask, 0),\n+                                               ShortVector.fromArray(S128, zeroBits, 0)));\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        in = randomString(dataSize, maxBytes);\n+        src = ByteBuffer.wrap(in.getBytes());\n+        dst = CharBuffer.allocate(in.length());\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setupInvocation() {\n+        src.clear();\n+        dst.clear();\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDownInvocation() {\n+        out = new String(dst.array());\n+        if (!in.equals(out)) {\n+            System.out.println(\"in  = (\" + in.length() + \") \\\"\" + arrayToString(in.getBytes()) + \"\\\"\");\n+            System.out.println(\"out = (\" + out.length() + \") \\\"\" + arrayToString(out.getBytes()) + \"\\\"\");\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    private static final Random RANDOM = new Random(0);\n+    private static int randomInt(int min \/* inclusive *\/, int max \/* inclusive *\/) {\n+        return RANDOM.nextInt(max - min + 1) + min;\n+    }\n+    private static String randomString(int dataSize, int maxBytes) {\n+        ByteBuffer buf = ByteBuffer.allocate(dataSize);\n+        for (int i = 0, size = randomInt(1, maxBytes); i + size - 1 < dataSize; i += size, size = randomInt(1, maxBytes)) {\n+            int b1, b2, b3, b4;\n+            switch (size) {\n+            case 1: {\n+                b1 = randomInt(0x00, 0x7F);\n+                buf.put(i + 0, (byte)((0b0     << (8 - 1)) | b1));\n+                break;\n+            }\n+            case 2: {\n+                b1 = randomInt(0xC2, 0xDF);\n+                b2 = randomInt(0x80, 0xBF);\n+                buf.put(i + 0, (byte)((0b110   << (8 - 3)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                break;\n+            }\n+            case 3: {\n+                b1 = randomInt(0xE0, 0xEF);\n+                switch (b1) {\n+                case 0xE0:\n+                    b2 = randomInt(0xA0, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b1110  << (8 - 4)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                break;\n+            }\n+            case 4: {\n+                b1 = randomInt(0xF0, 0xF4);\n+                switch (b1) {\n+                case 0xF0:\n+                    b2 = randomInt(0x90, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                case 0xF4:\n+                    b2 = randomInt(0x80, 0x8F);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b11110 << (8 - 5)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                buf.put(i + 3, (byte)((0b10    << (8 - 2)) | b4));\n+                break;\n+            }\n+            default:\n+                throw new RuntimeException(\"not supported\");\n+            }\n+        }\n+        return new String(buf.array(), Charset.forName(\"UTF-8\"));\n+    }\n+\n+    private static String arrayToString(byte[] array) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < array.length; ++i) {\n+            if (i != 0) sb.append(\",\");\n+            sb.append(String.format(\"%x\", (byte)array[i]));\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Benchmark\n+    public void decodeScalar() {\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVector() {\n+        decodeArrayVectorized(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVectorASCII() {\n+        decodeArrayVectorizedASCII(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    private static void decodeArrayVectorized(ByteBuffer src, CharBuffer dst) {\n+        \/\/ Algorithm is largely inspired from https:\/\/dirtyhandscoding.github.io\/posts\/utf8lut-vectorized-utf-8-converter-introduction.html\n+\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        while (sp + B128.length() < sl && dp + S128.length() < dl) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            \/* Decode *\/\n+\n+            var continuationByteMask = bytes.lanewise(VectorOperators.AND, (byte)0xC0).compare(VectorOperators.EQ, (byte)0x80);\n+            final DecoderLutEntry lookup = lutTable.get(continuationByteMask.toLong());\n+            if (lookup == null) {\n+                break;\n+            }\n+            \/\/ Shuffle the 1st and 2nd bytes\n+            var Rab = bytes.rearrange(lookup.shufAB, lookup.shufAB.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Shuffle the 3rd byte\n+            var Rc  = bytes.rearrange(lookup.shufC, lookup.shufC.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Extract the bits from each byte\n+            var sum = Rab.lanewise(VectorOperators.AND, (short)0x007F)\n+                 .add(Rab.lanewise(VectorOperators.AND, (short)0x3F00).lanewise(VectorOperators.LSHR, 2))\n+                 .add(Rc.lanewise(VectorOperators.LSHL, 12));\n+\n+            \/* Validate *\/\n+\n+            var zeroBits = lookup.zeroBits;\n+            if (sum.lanewise(VectorOperators.AND, zeroBits).compare(VectorOperators.NE, 0).anyTrue()) {\n+                break;\n+            }\n+            \/\/ Check for surrogate code point\n+            if (sum.lanewise(VectorOperators.SUB, (short)0x6000).compare(VectorOperators.GT, 0x77FF).anyTrue()) {\n+                break;\n+            }\n+            var headerMask = lookup.headerMask;\n+            if (bytes.lanewise(VectorOperators.AND, headerMask).compare(VectorOperators.NE, headerMask.lanewise(VectorOperators.LSHL, 1)).anyTrue()) {\n+                break;\n+            }\n+\n+            \/* Advance *\/\n+\n+            ((ShortVector)sum).intoCharArray(da, dp);\n+            sp += lookup.srcStep;\n+            dp += lookup.dstStep;\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static void decodeArrayVectorizedASCII(ByteBuffer src, CharBuffer dst) {\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        for (; sp <= sl - B128.length() && dp <= dl - S256.length(); sp += B128.length(), dp += S256.length()) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            if (bytes.compare(VectorOperators.LT, (byte) 0x00).anyTrue())\n+                break;\n+\n+            ((ShortVector) bytes.convertShape(VectorOperators.B2S, S256, 0)).intoCharArray(da, dp);\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {\n+        \/\/ This method is optimized for ASCII input.\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+        int dlASCII = dp + Math.min(sl - sp, dl - dp);\n+\n+        \/\/ ASCII only loop\n+        while (dp < dlASCII && sa[sp] >= 0)\n+            da[dp++] = (char) sa[sp++];\n+        while (sp < sl) {\n+            int b1 = sa[sp];\n+            if (b1 >= 0) {\n+                \/\/ 1 byte, 7 bits: 0xxxxxxx\n+                if (dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 1);\n+                da[dp++] = (char) b1;\n+                sp++;\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                \/\/ 2 bytes, 11 bits: 110xxxxx 10xxxxxx\n+                \/\/                   [C2..DF] [80..BF]\n+                if (sl - sp < 2 || dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 2);\n+                int b2 = sa[sp + 1];\n+                \/\/ Now we check the first byte of 2-byte sequence as\n+                \/\/     if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0)\n+                \/\/ no longer need to check b1 against c1 & c0 for\n+                \/\/ malformed as we did in previous version\n+                \/\/   (b1 & 0x1e) == 0x0 || (b2 & 0xc0) != 0x80;\n+                \/\/ only need to check the second byte b2.\n+                if (isNotContinuation(b2))\n+                    return malformedForLength(src, sp, dst, dp, 1);\n+                da[dp++] = (char) (((b1 << 6) ^ b2)\n+                                   ^\n+                                   (((byte) 0xC0 << 6) ^\n+                                    ((byte) 0x80 << 0)));\n+                sp += 2;\n+            } else if ((b1 >> 4) == -2) {\n+                \/\/ 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 3 || dp >= dl) {\n+                    if (srcRemaining > 1 && isMalformed3_2(b1, sa[sp + 1]))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    return xflow(src, sp, sl, dst, dp, 3);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                if (isMalformed3(b1, b2, b3))\n+                    return malformed(src, sp, dst, dp, 3);\n+                char c = (char)\n+                    ((b1 << 12) ^\n+                     (b2 <<  6) ^\n+                     (b3 ^\n+                      (((byte) 0xE0 << 12) ^\n+                       ((byte) 0x80 <<  6) ^\n+                       ((byte) 0x80 <<  0))));\n+                if (Character.isSurrogate(c))\n+                    return malformedForLength(src, sp, dst, dp, 3);\n+                da[dp++] = c;\n+                sp += 3;\n+            } else if ((b1 >> 3) == -2) {\n+                \/\/ 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 4 || dl - dp < 2) {\n+                    b1 &= 0xff;\n+                    if (b1 > 0xf4 ||\n+                        srcRemaining > 1 && isMalformed4_2(b1, sa[sp + 1] & 0xff))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    if (srcRemaining > 2 && isMalformed4_3(sa[sp + 2]))\n+                        return malformedForLength(src, sp, dst, dp, 2);\n+                    return xflow(src, sp, sl, dst, dp, 4);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                int b4 = sa[sp + 3];\n+                int uc = ((b1 << 18) ^\n+                          (b2 << 12) ^\n+                          (b3 <<  6) ^\n+                          (b4 ^\n+                           (((byte) 0xF0 << 18) ^\n+                            ((byte) 0x80 << 12) ^\n+                            ((byte) 0x80 <<  6) ^\n+                            ((byte) 0x80 <<  0))));\n+                if (isMalformed4(b2, b3, b4) ||\n+                    \/\/ shortest form check\n+                    !Character.isSupplementaryCodePoint(uc)) {\n+                    return malformed(src, sp, dst, dp, 4);\n+                }\n+                da[dp++] = Character.highSurrogate(uc);\n+                da[dp++] = Character.lowSurrogate(uc);\n+                sp += 4;\n+            } else\n+                return malformed(src, sp, dst, dp, 1);\n+        }\n+        return xflow(src, sp, sl, dst, dp, 0);\n+    }\n+\n+    private static CoderResult xflow(Buffer src, int sp, int sl,\n+                                     Buffer dst, int dp, int nb) {\n+        updatePositions(src, sp, dst, dp);\n+        return (nb == 0 || sl - sp < nb)\n+               ? CoderResult.UNDERFLOW : CoderResult.OVERFLOW;\n+    }\n+\n+    private static CoderResult malformedForLength(ByteBuffer src,\n+                                                  int sp,\n+                                                  CharBuffer dst,\n+                                                  int dp,\n+                                                  int malformedNB)\n+    {\n+        updatePositions(src, sp, dst, dp);\n+        return CoderResult.malformedForLength(malformedNB);\n+    }\n+\n+    private static CoderResult malformed(ByteBuffer src, int sp,\n+                                         CharBuffer dst, int dp,\n+                                         int nb)\n+    {\n+        src.position(sp - src.arrayOffset());\n+        CoderResult cr = malformedN(src, sp, nb);\n+        updatePositions(src, sp, dst, dp);\n+        return cr;\n+    }\n+\n+    private static CoderResult malformedN(ByteBuffer src, int sp,\n+                                          int nb) {\n+        switch (nb) {\n+        case 1:\n+        case 2:                    \/\/ always 1\n+            return CoderResult.malformedForLength(1);\n+        case 3:\n+            int b1 = src.get();\n+            int b2 = src.get();    \/\/ no need to lookup b3\n+            return CoderResult.malformedForLength(\n+                ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                 isNotContinuation(b2)) ? 1 : 2);\n+        case 4:  \/\/ we don't care the speed here\n+            b1 = src.get() & 0xff;\n+            b2 = src.get() & 0xff;\n+            if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+                return CoderResult.malformedForLength(1);\n+            if (isNotContinuation(src.get()))\n+                return CoderResult.malformedForLength(2);\n+            return CoderResult.malformedForLength(3);\n+        default:\n+            assert false;\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [E0]     [A0..BF] [80..BF]\n+    \/\/  [E1..EF] [80..BF] [80..BF]\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is only one byte left in src buffer\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [F0]     [90..BF] [80..BF] [80..BF]\n+    \/\/  [F1..F3] [80..BF] [80..BF] [80..BF]\n+    \/\/  [F4]     [80..8F] [80..BF] [80..BF]\n+    \/\/  only check 80-be range here, the [0xf0,0x80...] and [0xf4,0x90-...]\n+    \/\/  will be checked by Character.isSupplementaryCodePoint(uc)\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+               (b4 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is less than 4 bytes left in src buffer.\n+    \/\/ both b1 and b2 should be \"& 0xff\" before passed in.\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2  < 0x90 || b2 > 0xbf)) ||\n+               (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ tests if b1 and b2 are malformed as the first 2 bytes of a\n+    \/\/ legal`4-byte utf-8 byte sequence.\n+    \/\/ only used when there is less than 4 bytes left in src buffer,\n+    \/\/ after isMalformed4_2 has been invoked.\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static void updatePositions(Buffer src, int sp,\n+                                        Buffer dst, int dp) {\n+        src.position(sp - src.arrayOffset());\n+        dst.position(dp - dst.arrayOffset());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/utf8\/DecodeBench.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"}]}