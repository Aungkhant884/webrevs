{"files":[{"patch":"@@ -4,0 +4,1 @@\n+version=19\n","filename":".jcheck\/conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1202,3 +1202,0 @@\n-reg_class p0_reg(P0);\n-reg_class p1_reg(P1);\n-\n@@ -2737,4 +2734,1 @@\n-  \/\/ StoreVector (VectorStoreMask src)\n-  if (is_vshift_con_pattern(n, m) ||\n-      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask && n->Opcode() == Op_StoreVector) ||\n-      is_vector_arith_imm_pattern(n, m)) {\n+  if (is_vshift_con_pattern(n, m) || is_vector_arith_imm_pattern(n, m)) {\n@@ -3212,0 +3206,5 @@\n+  enc_class aarch64_enc_stlrb0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrb);\n+  %}\n+\n@@ -3217,0 +3216,5 @@\n+  enc_class aarch64_enc_stlrh0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrh);\n+  %}\n+\n@@ -3222,0 +3226,4 @@\n+  enc_class aarch64_enc_stlrw0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrw);\n+  %}\n@@ -3312,0 +3320,5 @@\n+  enc_class aarch64_enc_stlr0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlr);\n+  %}\n+\n@@ -5695,18 +5708,0 @@\n-operand pRegGov_P0()\n-%{\n-  constraint(ALLOC_IN_RC(p0_reg));\n-  match(RegVectMask);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand pRegGov_P1()\n-%{\n-  constraint(ALLOC_IN_RC(p1_reg));\n-  match(RegVectMask);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -8304,0 +8299,12 @@\n+instruct storeimmB0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreB mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrb  zr, $mem\\t# byte\" %}\n+\n+  ins_encode(aarch64_enc_stlrb0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8317,0 +8324,12 @@\n+instruct storeimmC0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreC mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrh  zr, $mem\\t# short\" %}\n+\n+  ins_encode(aarch64_enc_stlrh0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8331,0 +8350,12 @@\n+instruct storeimmI0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem(StoreI mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  zr, $mem\\t# int\" %}\n+\n+  ins_encode(aarch64_enc_stlrw0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8344,0 +8375,12 @@\n+instruct storeimmL0_volatile(immL0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreL mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  zr, $mem\\t# int\" %}\n+\n+  ins_encode(aarch64_enc_stlr0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8357,0 +8400,12 @@\n+instruct storeimmP0_volatile(immP0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreP mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  zr, $mem\\t# ptr\" %}\n+\n+  ins_encode(aarch64_enc_stlr0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8370,0 +8425,12 @@\n+instruct storeimmN0_volatile(immN0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreN mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  zr, $mem\\t# compressed ptr\" %}\n+\n+  ins_encode(aarch64_enc_stlrw0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16691,1 +16758,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -16701,1 +16768,1 @@\n-                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n@@ -16709,1 +16776,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -16718,1 +16785,1 @@\n-                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n@@ -16727,1 +16794,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -16738,1 +16805,1 @@\n-                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n@@ -16747,1 +16814,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -16758,1 +16825,1 @@\n-                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n@@ -17023,1 +17090,2 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4,\n+         USE_KILL src, USE_KILL dst, USE len, KILL cr);\n@@ -17025,1 +17093,1 @@\n-  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL R1, R2, R3, R4\" %}\n+  format %{ \"String Compress $src,$dst,$len -> $result  \/\/ KILL $src,$dst\" %}\n@@ -17028,0 +17096,1 @@\n+                           $result$$Register,\n@@ -17029,2 +17098,1 @@\n-                           $tmp3$$FloatRegister, $tmp4$$FloatRegister,\n-                           $result$$Register);\n+                           $tmp3$$FloatRegister, $tmp4$$FloatRegister);\n@@ -17032,1 +17100,1 @@\n-  ins_pipe( pipe_slow );\n+  ins_pipe(pipe_slow);\n@@ -17057,2 +17125,2 @@\n-                          vRegD_V0 Vtmp1, vRegD_V1 Vtmp2,\n-                          vRegD_V2 Vtmp3, vRegD_V3 Vtmp4,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1,\n+                          vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n@@ -17063,2 +17131,2 @@\n-  effect(USE_KILL src, USE_KILL dst, USE_KILL len,\n-         KILL Vtmp1, KILL Vtmp2, KILL Vtmp3, KILL Vtmp4, KILL cr);\n+  effect(USE_KILL src, USE_KILL dst, USE len,\n+         KILL vtmp0, KILL vtmp1, KILL vtmp2, KILL vtmp3, KILL cr);\n@@ -17066,1 +17134,1 @@\n-  format %{ \"Encode array $src,$dst,$len -> $result\" %}\n+  format %{ \"Encode ISO array $src,$dst,$len -> $result\" %}\n@@ -17069,2 +17137,3 @@\n-         $result$$Register, $Vtmp1$$FloatRegister,  $Vtmp2$$FloatRegister,\n-         $Vtmp3$$FloatRegister,  $Vtmp4$$FloatRegister);\n+                        $result$$Register, false,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister);\n@@ -17072,1 +17141,21 @@\n-  ins_pipe( pipe_class_memory );\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct encode_ascii_array(iRegP_R2 src, iRegP_R1 dst, iRegI_R3 len,\n+                            vRegD_V0 vtmp0, vRegD_V1 vtmp1,\n+                            vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n+                            iRegI_R0 result, rFlagsReg cr)\n+%{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(USE_KILL src, USE_KILL dst, USE len,\n+         KILL vtmp0, KILL vtmp1, KILL vtmp2, KILL vtmp3, KILL cr);\n+\n+  format %{ \"Encode ASCII array $src,$dst,$len -> $result\" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $result$$Register, true,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_memory);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":136,"deletions":47,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-\/\/ Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n@@ -1291,0 +1291,30 @@\n+\/\/ vector not - predicated\n+\n+instruct vnotI_masked(vReg dst, vReg src, immI_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (XorV (Binary src (ReplicateB m1)) pg));\n+  match(Set dst (XorV (Binary src (ReplicateS m1)) pg));\n+  match(Set dst (XorV (Binary src (ReplicateI m1)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_not $dst, $pg, $src\\t# vector (sve) B\/H\/S\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL_masked(vReg dst, vReg src, immL_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (XorV (Binary src (ReplicateL m1)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_not $dst, $pg, $src\\t# vector (sve) D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1321,0 +1351,30 @@\n+\/\/ vector and_not - predicated\n+\n+instruct vand_notI_masked(vReg dst_src1, vReg src2, immI_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) B\/H\/S\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_masked(vReg dst_src1, vReg src2, immL_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5576,99 +5636,0 @@\n-\/\/ Intrisics for String.compareTo()\n-\n-\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n-\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n-\/\/ string_compare can be shared with all variants.\n-\n-\n-instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::LL);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::LU);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::UL);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::UU);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":62,"deletions":101,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-\/\/ Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n@@ -748,0 +748,26 @@\n+\/\/ vector not - predicated\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (XorV (Binary src (ReplicateB m1)) pg));\n+  match(Set dst (XorV (Binary src (ReplicateS m1)) pg));\n+  match(Set dst (XorV (Binary src (ReplicateI m1)) pg));',\n+`match(Set dst (XorV (Binary src (ReplicateL m1)) pg));')')dnl\n+dnl\n+define(`VECTOR_NOT_PREDICATE', `\n+instruct vnot$1_masked`'(vReg dst, vReg src, imm$1_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  MATCH_RULE($1)\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_not $dst, $pg, $src\\t# vector (sve) $2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl                 $1, $2\n+VECTOR_NOT_PREDICATE(I, B\/H\/S)\n+VECTOR_NOT_PREDICATE(L, D)\n+undefine(MATCH_RULE)\n+dnl\n@@ -774,0 +800,26 @@\n+\/\/ vector and_not - predicated\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));',\n+`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));')')dnl\n+dnl\n+define(`VECTOR_AND_NOT_PREDICATE', `\n+instruct vand_not$1_masked`'(vReg dst_src1, vReg src2, imm$1_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  MATCH_RULE($1)\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) $2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl                     $1, $2\n+VECTOR_AND_NOT_PREDICATE(I, B\/H\/S)\n+VECTOR_AND_NOT_PREDICATE(L, D)\n+undefine(MATCH_RULE)\n+dnl\n@@ -3057,36 +3109,0 @@\n-\/\/ Intrisics for String.compareTo()\n-\n-\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n-\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n-\/\/ string_compare can be shared with all variants.\n-\n-dnl\n-define(`STRING_COMPARETO', `\n-instruct string_compare$1_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::$1));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::$1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl              $1\n-STRING_COMPARETO(LL)\n-STRING_COMPARETO(LU)\n-STRING_COMPARETO(UL)\n-STRING_COMPARETO(UU)\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":54,"deletions":38,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -407,12 +408,5 @@\n-  Address(Register r, int o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }\n-  Address(Register r, long o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }\n-  Address(Register r, long long o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }\n-  Address(Register r, unsigned int o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }\n-  Address(Register r, unsigned long o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }\n-  Address(Register r, unsigned long long o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }\n+\n+  template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+  Address(Register r, T o)\n+    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) {}\n+\n@@ -1729,1 +1723,1 @@\n-    int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \\\n+    int regNumber = (Rm == zr ? 31 : Rm->encoding());                   \\\n@@ -2427,0 +2421,6 @@\n+  \/\/ Zero compare.\n+  INSN(cmeq,   0, 0b100000100110, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmge,   1, 0b100000100010, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmgt,   0, 0b100000100010, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmle,   1, 0b100000100110, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmlt,   0, 0b100000101010, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -3048,0 +3048,1 @@\n+  INSN(sve_bic,  0b00000100, 0b011011000); \/\/ vector bitwise clear\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -679,2 +679,1 @@\n-    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n-    PRegister pgtmp1, PRegister pgtmp2, int ae) {\n+    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-                      FloatRegister vtmp2, FloatRegister vtmp3,\n-                      PRegister pgtmp1, PRegister pgtmp2, int ae);\n+                      FloatRegister vtmp2, FloatRegister vtmp3, int ae);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2476,0 +2476,10 @@\n+void Assembler::vmovddup(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x12);\n+  emit_operand(dst, src);\n+}\n+\n@@ -4763,1 +4773,1 @@\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n@@ -4768,0 +4778,9 @@\n+void Assembler::vpmovzxwq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+  vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+  vector_len == AVX_512bit? VM_Version::supports_evex() : 0, \" \");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x34, (0xC0 | encode));\n+}\n+\n@@ -4832,0 +4851,8 @@\n+void Assembler::vpopcntq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vpopcntdq(), \"must support vpopcntdq feature\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x55, (0xC0 | encode));\n+}\n+\n@@ -7597,0 +7624,3 @@\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_evex() : 0, \"\");\n@@ -7604,0 +7634,3 @@\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_evex() : 0, \"\");\n@@ -9358,1 +9391,1 @@\n-  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n@@ -9806,0 +9839,62 @@\n+void Assembler::evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x25, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src3, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_operand(dst, src3);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x25, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src3, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_operand(dst, src3);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":98,"deletions":3,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,1 @@\n-  bool is_lval() { return _is_lval; }\n+  bool is_lval() const { return _is_lval; }\n@@ -1470,0 +1470,1 @@\n+  void vmovddup(XMMRegister dst, Address src, int vector_len);\n@@ -1824,2 +1825,1 @@\n-  void vpmovzxbw( XMMRegister dst, Address src, int vector_len);\n-  void pmovzxdq(XMMRegister dst, XMMRegister src);\n+  void vpmovzxbw(XMMRegister dst, Address src, int vector_len);\n@@ -1827,1 +1827,0 @@\n-  void vpmovzxdq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1830,0 +1829,4 @@\n+  void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);\n+  void vpmovzxwq(XMMRegister dst, XMMRegister src, int vector_len);\n+  void pmovzxdq(XMMRegister dst, XMMRegister src);\n+  void vpmovzxdq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1846,3 +1849,0 @@\n-\n-  void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);\n-\n@@ -1872,0 +1872,1 @@\n+  void vpopcntq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -2415,0 +2416,6 @@\n+  void evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len);\n+  void evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len);\n+  void evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len);\n+  void evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len);\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1496,0 +1496,20 @@\n+void C2_MacroAssembler::load_vector(XMMRegister dst, Address src, int vlen_in_bytes) {\n+  switch (vlen_in_bytes) {\n+  case 4:  movdl(dst, src);   break;\n+  case 8:  movq(dst, src);    break;\n+  case 16: movdqu(dst, src);  break;\n+  case 32: vmovdqu(dst, src); break;\n+  case 64: evmovdquq(dst, src, Assembler::AVX_512bit); break;\n+  default: ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n+  if (reachable(src)) {\n+    load_vector(dst, as_Address(src), vlen_in_bytes);\n+  } else {\n+    lea(rscratch, src);\n+    load_vector(dst, Address(rscratch, 0), vlen_in_bytes);\n+  }\n+}\n+\n@@ -2195,78 +2215,0 @@\n-void C2_MacroAssembler::vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison,\n-                            int vlen_in_bytes, XMMRegister vtmp1, XMMRegister vtmp2, Register scratch) {\n-  int vlen_enc = vector_length_encoding(vlen_in_bytes*2);\n-  switch (typ) {\n-  case T_BYTE:\n-    vpmovzxbw(vtmp1, src1, vlen_enc);\n-    vpmovzxbw(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n-    vpacksswb(dst, dst, dst, vlen_enc);\n-    break;\n-  case T_SHORT:\n-    vpmovzxwd(vtmp1, src1, vlen_enc);\n-    vpmovzxwd(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n-    vpackssdw(dst, dst, dst, vlen_enc);\n-    break;\n-  case T_INT:\n-    vpmovzxdq(vtmp1, src1, vlen_enc);\n-    vpmovzxdq(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n-    vpermilps(dst, dst, 8, vlen_enc);\n-    break;\n-  default:\n-    assert(false, \"Should not reach here\");\n-  }\n-  if (vlen_in_bytes == 16) {\n-    vpermpd(dst, dst, 0x8, vlen_enc);\n-  }\n-}\n-\n-void C2_MacroAssembler::vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n-                              XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch) {\n-  int vlen_enc = vector_length_encoding(vlen_in_bytes);\n-  switch (typ) {\n-  case T_BYTE:\n-    vpmovzxbw(vtmp1, src1, vlen_enc);\n-    vpmovzxbw(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n-    vextracti128(vtmp1, src1, 1);\n-    vextracti128(vtmp2, src2, 1);\n-    vpmovzxbw(vtmp1, vtmp1, vlen_enc);\n-    vpmovzxbw(vtmp2, vtmp2, vlen_enc);\n-    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n-    vpacksswb(dst, dst, vtmp3, vlen_enc);\n-    vpermpd(dst, dst, 0xd8, vlen_enc);\n-    break;\n-  case T_SHORT:\n-    vpmovzxwd(vtmp1, src1, vlen_enc);\n-    vpmovzxwd(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n-    vextracti128(vtmp1, src1, 1);\n-    vextracti128(vtmp2, src2, 1);\n-    vpmovzxwd(vtmp1, vtmp1, vlen_enc);\n-    vpmovzxwd(vtmp2, vtmp2, vlen_enc);\n-    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::D,  vlen_enc, scratch);\n-    vpackssdw(dst, dst, vtmp3, vlen_enc);\n-    vpermpd(dst, dst, 0xd8, vlen_enc);\n-    break;\n-  case T_INT:\n-    vpmovzxdq(vtmp1, src1, vlen_enc);\n-    vpmovzxdq(vtmp2, src2, vlen_enc);\n-    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n-    vpshufd(dst, dst, 8, vlen_enc);\n-    vpermq(dst, dst, 8, vlen_enc);\n-    vextracti128(vtmp1, src1, 1);\n-    vextracti128(vtmp2, src2, 1);\n-    vpmovzxdq(vtmp1, vtmp1, vlen_enc);\n-    vpmovzxdq(vtmp2, vtmp2, vlen_enc);\n-    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::Q,  vlen_enc, scratch);\n-    vpshufd(vtmp3, vtmp3, 8, vlen_enc);\n-    vpermq(vtmp3, vtmp3, 0x80, vlen_enc);\n-    vpblendd(dst, dst, vtmp3, 0xf0, vlen_enc);\n-    break;\n-  default:\n-    assert(false, \"Should not reach here\");\n-  }\n-}\n-\n@@ -4155,0 +4097,47 @@\n+void C2_MacroAssembler::vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                             BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovzxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovzxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovzxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovzxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovzxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovzxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, XMMRegister src3,\n+                                   bool merge, BasicType bt, int vlen_enc) {\n+  if (bt == T_INT) {\n+    evpternlogd(dst, func, mask, src2, src3, merge, vlen_enc);\n+  } else {\n+    assert(bt == T_LONG, \"\");\n+    evpternlogq(dst, func, mask, src2, src3, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, Address src3,\n+                                   bool merge, BasicType bt, int vlen_enc) {\n+  if (bt == T_INT) {\n+    evpternlogd(dst, func, mask, src2, src3, merge, vlen_enc);\n+  } else {\n+    assert(bt == T_LONG, \"\");\n+    evpternlogq(dst, func, mask, src2, src3, merge, vlen_enc);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":68,"deletions":79,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+  void load_vector(XMMRegister dst, Address src, int vlen_in_bytes);\n+  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = rscratch1);\n@@ -154,6 +156,0 @@\n-  \/\/ vector compare\n-  void vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n-              XMMRegister vtmp1, XMMRegister vtmp2, Register scratch);\n-  void vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n-                XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch);\n-\n@@ -319,0 +315,10 @@\n+\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                            BasicType from_elem_bt, BasicType to_elem_bt);\n+\n+  void evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, XMMRegister src3,\n+                  bool merge, BasicType bt, int vlen_enc);\n+\n+  void evpternlog(XMMRegister dst, int func, KRegister mask, XMMRegister src2, Address src3,\n+                  bool merge, BasicType bt, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1408,0 +1408,1 @@\n+    case Op_PopCountVL:\n@@ -1459,0 +1460,3 @@\n+    case Op_VectorUCastB2X:\n+    case Op_VectorUCastS2X:\n+    case Op_VectorUCastI2X:\n@@ -1621,0 +1625,1 @@\n+#ifdef _LP64\n@@ -1624,0 +1629,4 @@\n+#else\n+      \/\/ x86_32.ad has a special match rule for SqrtD.\n+      \/\/ Together with common x86 rules, this handles all UseSSE cases.\n+#endif\n@@ -1797,9 +1806,1 @@\n-      if (size_in_bits == 256 && UseAVX < 2) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      break;\n-      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n-        return false;\n-      }\n-      break;\n-      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n+      if (bt != T_DOUBLE && size_in_bits == 256 && UseAVX < 2) {\n@@ -1927,0 +1928,6 @@\n+    case Op_MacroLogicV:\n+      if(bt != T_INT && bt != T_LONG) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -2579,9 +2586,15 @@\n-static inline jlong replicate8_imm(int con, int width) {\n-  \/\/ Load a constant of \"width\" (in bytes) and replicate it to fill 64bit.\n-  assert(width == 1 || width == 2 || width == 4, \"only byte, short or int types here\");\n-  int bit_width = width * 8;\n-  jlong val = con;\n-  val &= (((jlong) 1) << bit_width) - 1;  \/\/ mask off sign bits\n-  while(bit_width < 64) {\n-    val |= (val << bit_width);\n-    bit_width <<= 1;\n+template <class T>\n+static inline GrowableArray<jvalue>* vreplicate_imm(BasicType bt, T con, int len) {\n+  GrowableArray<jvalue>* val = new GrowableArray<jvalue>(len);\n+  jvalue ele;\n+  switch (bt) {\n+    case T_BYTE:   ele.b = con; break;\n+    case T_SHORT:  ele.s = con; break;\n+    case T_INT:    ele.i = con; break;\n+    case T_LONG:   ele.j = con; break;\n+    case T_FLOAT:  ele.f = con; break;\n+    case T_DOUBLE: ele.d = con; break;\n+    default: ShouldNotReachHere();\n+  }\n+  for (int i = 0; i < len; i++) {\n+    val->append(ele);\n@@ -2592,0 +2605,12 @@\n+static inline jlong high_bit_set(BasicType bt) {\n+  switch (bt) {\n+    case T_BYTE:  return 0x8080808080808080;\n+    case T_SHORT: return 0x8000800080008000;\n+    case T_INT:   return 0x8000000080000000;\n+    case T_LONG:  return 0x8000000000000000;\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n@@ -3839,8 +3864,1 @@\n-    switch (Matcher::vector_length_in_bytes(this)) {\n-      case  4: __ movdl    ($dst$$XMMRegister, $mem$$Address); break;\n-      case  8: __ movq     ($dst$$XMMRegister, $mem$$Address); break;\n-      case 16: __ movdqu   ($dst$$XMMRegister, $mem$$Address); break;\n-      case 32: __ vmovdqu  ($dst$$XMMRegister, $mem$$Address); break;\n-      case 64: __ evmovdqul($dst$$XMMRegister, $mem$$Address, Assembler::AVX_512bit); break;\n-      default: ShouldNotReachHere();\n-    }\n+    __ load_vector($dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n@@ -4024,16 +4042,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 1));\n-    if (vlen == 4) {\n-      __ movdl($dst$$XMMRegister, const_addr);\n-    } else {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen >= 16) {\n-        if (VM_Version::supports_avx2()) {\n-          int vlen_enc = vector_length_encoding(this);\n-          __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-        } else {\n-          assert(vlen == 16, \"sanity\");\n-          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n-    }\n+    InternalAddress addr = $constantaddress(T_BYTE, vreplicate_imm(T_BYTE, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4044,17 +4048,0 @@\n-\/\/ Replicate byte scalar zero to be vector\n-instruct ReplB_zero(vec dst, immI_0 zero) %{\n-  match(Set dst (ReplicateB zero));\n-  format %{ \"replicateB $dst,$zero\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 16) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      \/\/ Use vpxor since AVX512F does not have 512bit vxorpd (requires AVX512DQ).\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -4106,16 +4093,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 2));\n-    if (vlen == 2) {\n-      __ movdl($dst$$XMMRegister, const_addr);\n-    } else {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen >= 8) {\n-        if (VM_Version::supports_avx2()) {\n-          int vlen_enc = vector_length_encoding(this);\n-          __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-        } else {\n-          assert(vlen == 8, \"sanity\");\n-          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n-    }\n+    InternalAddress addr = $constantaddress(T_SHORT, vreplicate_imm(T_SHORT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4123,16 +4096,1 @@\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-instruct ReplS_zero(vec dst, immI_0 zero) %{\n-  match(Set dst (ReplicateS zero));\n-  format %{ \"replicateS $dst,$zero\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 8) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n+  ins_pipe( pipe_slow );\n@@ -4188,13 +4146,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 4));\n-    if (vlen <= 4) {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen == 4) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-      }\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_INT, vreplicate_imm(T_INT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4205,1 +4152,1 @@\n-\/\/ Replicate integer (4 byte) scalar zero to be vector\n+\/\/ Replicate scalar zero to be vector\n@@ -4207,0 +4154,2 @@\n+  match(Set dst (ReplicateB zero));\n+  match(Set dst (ReplicateS zero));\n@@ -4210,2 +4159,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n+    uint vsize = Matcher::vector_length_in_bytes(this);\n+    if (vsize <= 16) {\n@@ -4342,11 +4291,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress($con);\n-    if (vlen == 2) {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4422,0 +4362,11 @@\n+\/\/ Replicate float scalar immediate to be vector by loading from const table.\n+instruct ReplF_imm(vec dst, immF con) %{\n+  match(Set dst (ReplicateF con));\n+  format %{ \"replicateF $dst,$con\" %}\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4476,0 +4427,11 @@\n+\/\/ Replicate double (8 byte) scalar immediate to be vector by loading from const table.\n+instruct ReplD_imm(vec dst, immD con) %{\n+  match(Set dst (ReplicateD con));\n+  format %{ \"replicateD $dst,$con\" %}\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6945,2 +6907,3 @@\n-      case T_DOUBLE:\n-        __ vpmovsxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      case T_DOUBLE: {\n+        int mid_vlen_enc = (vlen_enc == Assembler::AVX_512bit) ? Assembler::AVX_256bit : Assembler::AVX_128bit;\n+        __ vpmovsxbd($dst$$XMMRegister, $src$$XMMRegister, mid_vlen_enc);\n@@ -6949,1 +6912,1 @@\n-\n+      }\n@@ -7016,2 +6979,3 @@\n-      case T_DOUBLE:\n-        __ vpmovsxwd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      case T_DOUBLE: {\n+        int mid_vlen_enc = (vlen_enc == Assembler::AVX_512bit) ? Assembler::AVX_256bit : Assembler::AVX_128bit;\n+        __ vpmovsxwd($dst$$XMMRegister, $src$$XMMRegister, mid_vlen_enc);\n@@ -7020,0 +6984,1 @@\n+      }\n@@ -7280,0 +7245,16 @@\n+instruct vucast(vec dst, vec src) %{\n+  match(Set dst (VectorUCastB2X src));\n+  match(Set dst (VectorUCastS2X src));\n+  match(Set dst (VectorUCastI2X src));\n+  format %{ \"vector_ucast $dst,$src\\t!\" %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    BasicType from_elem_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_unsigned_cast($dst$$XMMRegister, $src$$XMMRegister, vlen_enc, from_elem_bt, to_elem_bt);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7342,1 +7323,1 @@\n-instruct vcmp(legVec dst, legVec src1, legVec src2, immI8 cond, rRegP scratch) %{\n+instruct vcmp_direct(legVec dst, legVec src1, legVec src2, immI8 cond) %{\n@@ -7347,1 +7328,4 @@\n-            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1))) &&\n+            (n->in(2)->get_int() == BoolTest::eq ||\n+             n->in(2)->get_int() == BoolTest::lt ||\n+             n->in(2)->get_int() == BoolTest::gt)); \/\/ cond\n@@ -7349,2 +7333,1 @@\n-  effect(TEMP scratch);\n-  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t!\" %}\n@@ -7355,1 +7338,1 @@\n-    __ vpcmpCCW($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, ww, vlen_enc, $scratch$$Register);\n+    __ vpcmpCCW($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, cmp, ww, vlen_enc);\n@@ -7360,1 +7343,1 @@\n-instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+instruct vcmp_negate(legVec dst, legVec src1, legVec src2, immI8 cond, legVec xtmp) %{\n@@ -7362,4 +7345,7 @@\n-            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n-            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1))) &&\n+            (n->in(2)->get_int() == BoolTest::ne ||\n+             n->in(2)->get_int() == BoolTest::le ||\n+             n->in(2)->get_int() == BoolTest::ge)); \/\/ cond\n@@ -7367,2 +7353,2 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t! using $xtmp as TEMP\" %}\n@@ -7370,1 +7356,1 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -7372,3 +7358,2 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n-              $vtmp2$$XMMRegister, $scratch$$Register);\n+    Assembler::Width ww = widthForType(Matcher::vector_element_basic_type(this, $src1));\n+    __ vpcmpCCW($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp$$XMMRegister, cmp, ww, vlen_enc);\n@@ -7379,1 +7364,1 @@\n-instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec xtmp) %{\n@@ -7382,1 +7367,2 @@\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n@@ -7385,2 +7371,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n-  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $xtmp as TEMP\" %}\n@@ -7388,1 +7374,2 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n+    InternalAddress flip_bit = $constantaddress(high_bit_set(Matcher::vector_element_basic_type(this, $src1)));\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -7390,3 +7377,10 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n-    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n-                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+    Assembler::Width ww = widthForType(Matcher::vector_element_basic_type(this, $src1));\n+\n+    if (vlen_enc == Assembler::AVX_128bit) {\n+      __ vmovddup($xtmp$$XMMRegister, flip_bit, vlen_enc, noreg);\n+    } else {\n+      __ vbroadcastsd($xtmp$$XMMRegister, flip_bit, vlen_enc, noreg);\n+    }\n+    __ vpxor($dst$$XMMRegister, $xtmp$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+    __ vpxor($xtmp$$XMMRegister, $xtmp$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpcmpCCW($dst$$XMMRegister, $dst$$XMMRegister, $xtmp$$XMMRegister, $xtmp$$XMMRegister, cmp, ww, vlen_enc);\n@@ -7397,1 +7391,1 @@\n-instruct vcmpu64(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+instruct vcmp64(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n@@ -8620,0 +8614,14 @@\n+instruct vpopcountL(vec dst, vec src) %{\n+  match(Set dst (PopCountVL src));\n+  format %{ \"vpopcntq  $dst,$src\\t! vector popcount packedL\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"not enabled\");\n+\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vpopcntq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -9624,0 +9632,23 @@\n+instruct vternlog_reg_masked(vec dst, vec src2, vec src3, immU8 func, kReg mask) %{\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ evpternlog($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                  $src2$$XMMRegister, $src3$$XMMRegister, true, bt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vternlogd_mem_masked(vec dst, vec src2, memory src3, immU8 func, kReg mask) %{\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ evpternlog($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                  $src2$$XMMRegister, $src3$$Address, true, bt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":180,"deletions":149,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1369,1 +1369,1 @@\n-    uniq_idx = (uint*) AllocateHeap(sizeof(uint) * _uniq_idx_length);\n+    uniq_idx = (uint*) AdlAllocateHeap(sizeof(uint) * _uniq_idx_length);\n@@ -3479,1 +3479,1 @@\n-  subtree = (char *)AllocateHeap(len);\n+  subtree = (char *)AdlAllocateHeap(len);\n@@ -3929,1 +3929,1 @@\n-  char* buf = (char*) AllocateHeap(strlen(instr_ident) + 4);\n+  char* buf = (char*) AdlAllocateHeap(strlen(instr_ident) + 4);\n@@ -4238,0 +4238,1 @@\n+    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\",\n@@ -4239,1 +4240,1 @@\n-    \"FmaVD\",\"FmaVF\",\"PopCountVI\",\"VectorLongToMask\",\n+    \"FmaVD\",\"FmaVF\",\"PopCountVI\", \"PopCountVL\", \"VectorLongToMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,0 +275,1 @@\n+macro(PopCountVL)\n@@ -484,0 +485,3 @@\n+macro(VectorUCastB2X)\n+macro(VectorUCastS2X)\n+macro(VectorUCastI2X)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -325,1 +325,1 @@\n-  C->print_method(PHASE_BEFORE_MATCHING);\n+  C->print_method(PHASE_BEFORE_MATCHING, 1);\n@@ -2326,0 +2326,8 @@\n+    } else if (n->req() == 6) {\n+      Node* b3 = new BinaryNode(n->in(4), n->in(5));\n+      Node* b2 = new BinaryNode(n->in(3), b3);\n+      Node* b1 = new BinaryNode(n->in(2), b2);\n+      n->set_req(2, b1);\n+      n->del_req(5);\n+      n->del_req(4);\n+      n->del_req(3);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -795,1 +795,2 @@\n-    _last_flag                       = Flag_for_post_loop_opts_igvn\n+    Flag_is_removed_by_peephole      = 1 << 17,\n+    _last_flag                       = Flag_is_removed_by_peephole\n@@ -1096,0 +1097,2 @@\n+  Node* unique_ctrl_out_or_null() const;\n+  \/\/ Return the unique control out. Asserts if none or more than one control out.\n@@ -1257,3 +1260,0 @@\n-  int  _debug_idx;                     \/\/ Unique value assigned to every node.\n-  int   debug_idx() const              { return _debug_idx; }\n-  void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }\n@@ -1266,0 +1266,4 @@\n+  int  _debug_idx;                     \/\/ Unique value assigned to every node.\n+  int   debug_idx() const              { return _debug_idx; }\n+  void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2360,1 +2360,2 @@\n-  assert(opr->get_con() == VectorSupport::VECTOR_OP_CAST ||\n+  assert(opr->get_con() == VectorSupport::VECTOR_OP_CAST  ||\n+         opr->get_con() == VectorSupport::VECTOR_OP_UCAST ||\n@@ -2362,1 +2363,2 @@\n-  bool is_cast = (opr->get_con() == VectorSupport::VECTOR_OP_CAST);\n+  bool is_cast = (opr->get_con() == VectorSupport::VECTOR_OP_CAST || opr->get_con() == VectorSupport::VECTOR_OP_UCAST);\n+  bool is_ucast = (opr->get_con() == VectorSupport::VECTOR_OP_UCAST);\n@@ -2447,1 +2449,1 @@\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from);\n+    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,2 @@\n+  case Op_PopCountL:\n+    return Op_PopCountVL;\n@@ -300,0 +302,10 @@\n+bool VectorNode::is_vpopcnt_long(Node* n) {\n+  if (n->Opcode() == Op_PopCountL) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\n+\n+\n@@ -534,0 +546,1 @@\n+  case Op_PopCountVL: return new PopCountVLNode(n1, vt);\n@@ -1087,6 +1100,9 @@\n-    case Op_VectorCastB2X: return new VectorCastB2XNode(n1, vt);\n-    case Op_VectorCastS2X: return new VectorCastS2XNode(n1, vt);\n-    case Op_VectorCastI2X: return new VectorCastI2XNode(n1, vt);\n-    case Op_VectorCastL2X: return new VectorCastL2XNode(n1, vt);\n-    case Op_VectorCastF2X: return new VectorCastF2XNode(n1, vt);\n-    case Op_VectorCastD2X: return new VectorCastD2XNode(n1, vt);\n+    case Op_VectorCastB2X:  return new VectorCastB2XNode(n1, vt);\n+    case Op_VectorCastS2X:  return new VectorCastS2XNode(n1, vt);\n+    case Op_VectorCastI2X:  return new VectorCastI2XNode(n1, vt);\n+    case Op_VectorCastL2X:  return new VectorCastL2XNode(n1, vt);\n+    case Op_VectorCastF2X:  return new VectorCastF2XNode(n1, vt);\n+    case Op_VectorCastD2X:  return new VectorCastD2XNode(n1, vt);\n+    case Op_VectorUCastB2X: return new VectorUCastB2XNode(n1, vt);\n+    case Op_VectorUCastS2X: return new VectorUCastS2XNode(n1, vt);\n+    case Op_VectorUCastI2X: return new VectorUCastI2XNode(n1, vt);\n@@ -1099,1 +1115,2 @@\n-int VectorCastNode::opcode(BasicType bt) {\n+int VectorCastNode::opcode(BasicType bt, bool is_signed) {\n+  assert((is_integral_type(bt) && bt != T_LONG) || is_signed, \"\");\n@@ -1101,3 +1118,3 @@\n-    case T_BYTE:   return Op_VectorCastB2X;\n-    case T_SHORT:  return Op_VectorCastS2X;\n-    case T_INT:    return Op_VectorCastI2X;\n+    case T_BYTE:   return is_signed ? Op_VectorCastB2X : Op_VectorUCastB2X;\n+    case T_SHORT:  return is_signed ? Op_VectorCastS2X : Op_VectorUCastS2X;\n+    case T_INT:    return is_signed ? Op_VectorCastI2X : Op_VectorUCastI2X;\n@@ -1208,1 +1225,1 @@\n-                                       uint truth_table, const TypeVect* vt) {\n+                                       Node* mask, uint truth_table, const TypeVect* vt) {\n@@ -1213,0 +1230,1 @@\n+  assert(!mask || mask->bottom_type()->isa_vectmask(), \"predicated register type expected\");\n@@ -1214,1 +1232,1 @@\n-  return new MacroLogicVNode(in1, in2, in3, fn, vt);\n+  return new MacroLogicVNode(in1, in2, in3, fn, mask, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,1 @@\n+  static bool is_vpopcnt_long(Node* n);\n@@ -508,0 +509,8 @@\n+\/\/------------------------------PopCountVLNode---------------------------------\n+\/\/ Vector popcount long bits\n+class PopCountVLNode : public VectorNode {\n+ public:\n+  PopCountVLNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -535,1 +544,2 @@\n- bool _is_var_shift;\n+ private:\n+  bool _is_var_shift;\n@@ -543,0 +553,4 @@\n+  virtual uint hash() const { return VectorNode::hash() + _is_var_shift; }\n+  virtual bool cmp(const Node& n) const {\n+    return VectorNode::cmp(n) && _is_var_shift == ((ShiftVNode&)n)._is_var_shift;\n+  }\n@@ -544,1 +558,1 @@\n-  virtual  uint  size_of() const { return sizeof(ShiftVNode); }\n+  virtual uint size_of() const { return sizeof(ShiftVNode); }\n@@ -1309,2 +1323,7 @@\n-  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, const TypeVect* vt)\n-  : VectorNode(in1, in2, in3, fn, vt) {}\n+  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, Node* mask, const TypeVect* vt)\n+  : VectorNode(in1, in2, in3, fn, vt) {\n+     if (mask) {\n+       this->add_req(mask);\n+       this->add_flag(Node::Flag_is_predicated_vector);\n+     }\n+  }\n@@ -1315,1 +1334,2 @@\n-  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3, uint truth_table, const TypeVect* vt);\n+  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3,\n+                               Node* mask, uint truth_table, const TypeVect* vt);\n@@ -1481,1 +1501,1 @@\n-  static int  opcode(BasicType bt);\n+  static int  opcode(BasicType bt, bool is_signed = true);\n@@ -1535,0 +1555,24 @@\n+class VectorUCastB2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorUCastS2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastS2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorUCastI2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":51,"deletions":7,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-    \/\/ Other payload values are: 'oop' type location and Scalar-replaced boxed vector representation.\n+    \/\/ Other payload values are: 'oop' type location and scalar-replaced boxed vector representation.\n@@ -182,1 +182,1 @@\n-  } else if (!payload->is_object()) {\n+  } else if (!payload->is_object() && !payload->is_constant_oop()) {\n@@ -185,1 +185,1 @@\n-    assert(payload->is_object(), \"expected 'object' value for scalar-replaced boxed vector but got: %s\", ss.as_string());\n+    assert(false, \"expected 'object' value for scalar-replaced boxed vector but got: %s\", ss.as_string());\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n@@ -80,1 +80,2 @@\n-    VECTOR_OP_REINTERPRET = 18,\n+    VECTOR_OP_UCAST       = 18,\n+    VECTOR_OP_REINTERPRET = 19,\n@@ -83,4 +84,4 @@\n-    VECTOR_OP_MASK_TRUECOUNT = 19,\n-    VECTOR_OP_MASK_FIRSTTRUE = 20,\n-    VECTOR_OP_MASK_LASTTRUE  = 21,\n-    VECTOR_OP_MASK_TOLONG    = 22,\n+    VECTOR_OP_MASK_TRUECOUNT = 20,\n+    VECTOR_OP_MASK_FIRSTTRUE = 21,\n+    VECTOR_OP_MASK_LASTTRUE  = 22,\n+    VECTOR_OP_MASK_TOLONG    = 23,\n@@ -89,2 +90,2 @@\n-    VECTOR_OP_LROTATE = 23,\n-    VECTOR_OP_RROTATE = 24,\n+    VECTOR_OP_LROTATE = 24,\n+    VECTOR_OP_RROTATE = 25,\n@@ -92,3 +93,3 @@\n-    VECTOR_OP_COMPRESS = 25,\n-    VECTOR_OP_EXPAND = 26,\n-    VECTOR_OP_MASK_COMPRESS = 27,\n+    VECTOR_OP_COMPRESS = 26,\n+    VECTOR_OP_EXPAND = 27,\n+    VECTOR_OP_MASK_COMPRESS = 28,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -663,1 +663,1 @@\n-  volatile_nonstatic_field(nmethod,            _stack_traversal_mark,                         long)                                  \\\n+  volatile_nonstatic_field(nmethod,            _stack_traversal_mark,                         int64_t)                               \\\n@@ -1202,0 +1202,1 @@\n+  declare_integer_type(int64_t)                                           \\\n@@ -1772,0 +1773,1 @@\n+  declare_c2_type(PopCountVLNode, VectorNode)                             \\\n@@ -1850,0 +1852,3 @@\n+  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,1 +67,2 @@\n-    public static final int VECTOR_OP_REINTERPRET = 18;\n+    public static final int VECTOR_OP_UCAST       = 18;\n+    public static final int VECTOR_OP_REINTERPRET = 19;\n@@ -70,4 +71,4 @@\n-    public static final int VECTOR_OP_MASK_TRUECOUNT = 19;\n-    public static final int VECTOR_OP_MASK_FIRSTTRUE = 20;\n-    public static final int VECTOR_OP_MASK_LASTTRUE  = 21;\n-    public static final int VECTOR_OP_MASK_TOLONG    = 22;\n+    public static final int VECTOR_OP_MASK_TRUECOUNT = 20;\n+    public static final int VECTOR_OP_MASK_FIRSTTRUE = 21;\n+    public static final int VECTOR_OP_MASK_LASTTRUE  = 22;\n+    public static final int VECTOR_OP_MASK_TOLONG    = 23;\n@@ -76,2 +77,2 @@\n-    public static final int VECTOR_OP_LROTATE = 23;\n-    public static final int VECTOR_OP_RROTATE = 24;\n+    public static final int VECTOR_OP_LROTATE = 24;\n+    public static final int VECTOR_OP_RROTATE = 25;\n@@ -80,3 +81,3 @@\n-    public static final int VECTOR_OP_COMPRESS = 25;\n-    public static final int VECTOR_OP_EXPAND = 26;\n-    public static final int VECTOR_OP_MASK_COMPRESS = 27;\n+    public static final int VECTOR_OP_COMPRESS = 26;\n+    public static final int VECTOR_OP_EXPAND = 27;\n+    public static final int VECTOR_OP_MASK_COMPRESS = 28;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2672,1 +2672,2 @@\n-            ByteVector v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            ByteVector v = broadcast((byte) 0).blend(this, m);\n@@ -2687,1 +2688,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -2690,1 +2691,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (byte) 0;\n@@ -2723,28 +2725,0 @@\n-    private\n-    @ForceInline\n-    ByteVector reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<ByteVector> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<ByteVector>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, ByteVector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2491,1 +2491,2 @@\n-            DoubleVector v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            DoubleVector v = broadcast((double) 0).blend(this, m);\n@@ -2506,1 +2507,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -2509,1 +2510,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (double) 0;\n@@ -2536,24 +2538,0 @@\n-    private\n-    @ForceInline\n-    DoubleVector reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<DoubleVector> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<DoubleVector>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, DoubleVector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2511,1 +2511,2 @@\n-            FloatVector v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            FloatVector v = broadcast((float) 0).blend(this, m);\n@@ -2526,1 +2527,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -2529,1 +2530,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (float) 0;\n@@ -2556,24 +2558,0 @@\n-    private\n-    @ForceInline\n-    FloatVector reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<FloatVector> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<FloatVector>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, FloatVector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2668,1 +2668,2 @@\n-            IntVector v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            IntVector v = broadcast((int) 0).blend(this, m);\n@@ -2683,1 +2684,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -2686,1 +2687,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (int) 0;\n@@ -2719,28 +2721,0 @@\n-    private\n-    @ForceInline\n-    IntVector reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<IntVector> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<IntVector>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, IntVector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2534,1 +2534,2 @@\n-            LongVector v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            LongVector v = broadcast((long) 0).blend(this, m);\n@@ -2549,1 +2550,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -2552,1 +2553,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (long) 0;\n@@ -2585,28 +2587,0 @@\n-    private\n-    @ForceInline\n-    LongVector reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<LongVector> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<LongVector>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, LongVector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2672,1 +2672,2 @@\n-            ShortVector v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            ShortVector v = broadcast((short) 0).blend(this, m);\n@@ -2687,1 +2688,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -2690,1 +2691,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (short) 0;\n@@ -2723,28 +2725,0 @@\n-    private\n-    @ForceInline\n-    ShortVector reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<ShortVector> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<ShortVector>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, ShortVector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3112,1 +3112,2 @@\n-            $abstractvectortype$ v = reduceIdentityVector(op).blend(this, m);\n+            \/\/ FIXME:  The JIT should handle this.\n+            $abstractvectortype$ v = broadcast(($type$) 0).blend(this, m);\n@@ -3127,1 +3128,1 @@\n-            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            \/\/ FIXME:  The JIT should handle this.\n@@ -3130,1 +3131,2 @@\n-            return this.lane(thisNZ.firstTrue());\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : ($type$) 0;\n@@ -3165,32 +3167,0 @@\n-    private\n-    @ForceInline\n-    $abstractvectortype$ reduceIdentityVector(VectorOperators.Associative op) {\n-        int opc = opCode(op);\n-        UnaryOperator<$abstractvectortype$> fn\n-            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n-                switch (opc_) {\n-                case VECTOR_OP_ADD:\n-#if[BITWISE]\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n-#end[BITWISE]\n-                    return v -> v.broadcast(0);\n-                case VECTOR_OP_MUL:\n-                    return v -> v.broadcast(1);\n-#if[BITWISE]\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n-#end[BITWISE]\n-                case VECTOR_OP_MIN:\n-                    return v -> v.broadcast(MAX_OR_INF);\n-                case VECTOR_OP_MAX:\n-                    return v -> v.broadcast(MIN_OR_INF);\n-                default: return null;\n-                }\n-            });\n-        return fn.apply(this);\n-    }\n-    private static final\n-    ImplCache<Associative,UnaryOperator<$abstractvectortype$>> REDUCE_ID_IMPL\n-        = new ImplCache<>(Associative.class, $Type$Vector.class);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1801,0 +1801,1 @@\n+                       [\"bic\", \"ZPZ\", \"m\", \"dn\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1087,36 +1087,37 @@\n-    __ sve_cnt(z28, __ D, p4, z29);                    \/\/       cnt     z28.d, p4\/m, z29.d\n-    __ sve_eor(z9, __ H, p3, z2);                      \/\/       eor     z9.h, p3\/m, z9.h, z2.h\n-    __ sve_lsl(z28, __ B, p0, z7);                     \/\/       lsl     z28.b, p0\/m, z28.b, z7.b\n-    __ sve_lsr(z26, __ H, p5, z17);                    \/\/       lsr     z26.h, p5\/m, z26.h, z17.h\n-    __ sve_mul(z8, __ D, p4, z21);                     \/\/       mul     z8.d, p4\/m, z8.d, z21.d\n-    __ sve_neg(z5, __ S, p5, z21);                     \/\/       neg     z5.s, p5\/m, z21.s\n-    __ sve_not(z22, __ S, p4, z29);                    \/\/       not     z22.s, p4\/m, z29.s\n-    __ sve_orr(z19, __ S, p0, z4);                     \/\/       orr     z19.s, p0\/m, z19.s, z4.s\n-    __ sve_smax(z23, __ B, p1, z19);                   \/\/       smax    z23.b, p1\/m, z23.b, z19.b\n-    __ sve_smin(z23, __ B, p6, z19);                   \/\/       smin    z23.b, p6\/m, z23.b, z19.b\n-    __ sve_sub(z8, __ D, p2, z14);                     \/\/       sub     z8.d, p2\/m, z8.d, z14.d\n-    __ sve_fabs(z17, __ S, p7, z21);                   \/\/       fabs    z17.s, p7\/m, z21.s\n-    __ sve_fadd(z30, __ D, p0, z10);                   \/\/       fadd    z30.d, p0\/m, z30.d, z10.d\n-    __ sve_fdiv(z12, __ S, p0, z9);                    \/\/       fdiv    z12.s, p0\/m, z12.s, z9.s\n-    __ sve_fmax(z24, __ D, p4, z4);                    \/\/       fmax    z24.d, p4\/m, z24.d, z4.d\n-    __ sve_fmin(z6, __ D, p2, z27);                    \/\/       fmin    z6.d, p2\/m, z6.d, z27.d\n-    __ sve_fmul(z13, __ D, p4, z30);                   \/\/       fmul    z13.d, p4\/m, z13.d, z30.d\n-    __ sve_fneg(z22, __ D, p5, z30);                   \/\/       fneg    z22.d, p5\/m, z30.d\n-    __ sve_frintm(z9, __ S, p3, z19);                  \/\/       frintm  z9.s, p3\/m, z19.s\n-    __ sve_frintn(z20, __ S, p7, z9);                  \/\/       frintn  z20.s, p7\/m, z9.s\n-    __ sve_frintp(z13, __ S, p3, z19);                 \/\/       frintp  z13.s, p3\/m, z19.s\n-    __ sve_fsqrt(z24, __ S, p2, z19);                  \/\/       fsqrt   z24.s, p2\/m, z19.s\n-    __ sve_fsub(z17, __ S, p4, z16);                   \/\/       fsub    z17.s, p4\/m, z17.s, z16.s\n-    __ sve_fmad(z0, __ S, p0, z11, z7);                \/\/       fmad    z0.s, p0\/m, z11.s, z7.s\n-    __ sve_fmla(z14, __ D, p4, z4, z15);               \/\/       fmla    z14.d, p4\/m, z4.d, z15.d\n-    __ sve_fmls(z5, __ D, p0, z10, z21);               \/\/       fmls    z5.d, p0\/m, z10.d, z21.d\n-    __ sve_fnmla(z3, __ D, p0, z9, z19);               \/\/       fnmla   z3.d, p0\/m, z9.d, z19.d\n-    __ sve_fnmls(z10, __ S, p6, z3, z19);              \/\/       fnmls   z10.s, p6\/m, z3.s, z19.s\n-    __ sve_mla(z23, __ H, p7, z13, z21);               \/\/       mla     z23.h, p7\/m, z13.h, z21.h\n-    __ sve_mls(z26, __ S, p3, z17, z30);               \/\/       mls     z26.s, p3\/m, z17.s, z30.s\n-    __ sve_and(z14, z2, z29);                          \/\/       and     z14.d, z2.d, z29.d\n-    __ sve_eor(z21, z20, z7);                          \/\/       eor     z21.d, z20.d, z7.d\n-    __ sve_orr(z2, z1, z26);                           \/\/       orr     z2.d, z1.d, z26.d\n-    __ sve_bic(z9, z16, z17);                          \/\/       bic     z9.d, z16.d, z17.d\n-    __ sve_uzp1(z0, __ D, z4, z2);                     \/\/       uzp1    z0.d, z4.d, z2.d\n-    __ sve_uzp2(z14, __ S, z6, z11);                   \/\/       uzp2    z14.s, z6.s, z11.s\n+    __ sve_bic(z28, __ D, p4, z29);                    \/\/       bic     z28.d, p4\/m, z28.d, z29.d\n+    __ sve_cnt(z9, __ H, p3, z2);                      \/\/       cnt     z9.h, p3\/m, z2.h\n+    __ sve_eor(z28, __ B, p0, z7);                     \/\/       eor     z28.b, p0\/m, z28.b, z7.b\n+    __ sve_lsl(z26, __ H, p5, z17);                    \/\/       lsl     z26.h, p5\/m, z26.h, z17.h\n+    __ sve_lsr(z8, __ D, p4, z21);                     \/\/       lsr     z8.d, p4\/m, z8.d, z21.d\n+    __ sve_mul(z5, __ S, p5, z21);                     \/\/       mul     z5.s, p5\/m, z5.s, z21.s\n+    __ sve_neg(z22, __ S, p4, z29);                    \/\/       neg     z22.s, p4\/m, z29.s\n+    __ sve_not(z19, __ S, p0, z4);                     \/\/       not     z19.s, p0\/m, z4.s\n+    __ sve_orr(z23, __ B, p1, z19);                    \/\/       orr     z23.b, p1\/m, z23.b, z19.b\n+    __ sve_smax(z23, __ B, p6, z19);                   \/\/       smax    z23.b, p6\/m, z23.b, z19.b\n+    __ sve_smin(z8, __ D, p2, z14);                    \/\/       smin    z8.d, p2\/m, z8.d, z14.d\n+    __ sve_sub(z17, __ B, p7, z21);                    \/\/       sub     z17.b, p7\/m, z17.b, z21.b\n+    __ sve_fabs(z30, __ D, p0, z10);                   \/\/       fabs    z30.d, p0\/m, z10.d\n+    __ sve_fadd(z12, __ S, p0, z9);                    \/\/       fadd    z12.s, p0\/m, z12.s, z9.s\n+    __ sve_fdiv(z24, __ D, p4, z4);                    \/\/       fdiv    z24.d, p4\/m, z24.d, z4.d\n+    __ sve_fmax(z6, __ D, p2, z27);                    \/\/       fmax    z6.d, p2\/m, z6.d, z27.d\n+    __ sve_fmin(z13, __ D, p4, z30);                   \/\/       fmin    z13.d, p4\/m, z13.d, z30.d\n+    __ sve_fmul(z22, __ D, p5, z30);                   \/\/       fmul    z22.d, p5\/m, z22.d, z30.d\n+    __ sve_fneg(z9, __ S, p3, z19);                    \/\/       fneg    z9.s, p3\/m, z19.s\n+    __ sve_frintm(z20, __ S, p7, z9);                  \/\/       frintm  z20.s, p7\/m, z9.s\n+    __ sve_frintn(z13, __ S, p3, z19);                 \/\/       frintn  z13.s, p3\/m, z19.s\n+    __ sve_frintp(z24, __ S, p2, z19);                 \/\/       frintp  z24.s, p2\/m, z19.s\n+    __ sve_fsqrt(z17, __ S, p4, z16);                  \/\/       fsqrt   z17.s, p4\/m, z16.s\n+    __ sve_fsub(z0, __ S, p0, z11);                    \/\/       fsub    z0.s, p0\/m, z0.s, z11.s\n+    __ sve_fmad(z15, __ S, p3, z15, z4);               \/\/       fmad    z15.s, p3\/m, z15.s, z4.s\n+    __ sve_fmla(z29, __ D, p1, z0, z10);               \/\/       fmla    z29.d, p1\/m, z0.d, z10.d\n+    __ sve_fmls(z26, __ D, p0, z0, z9);                \/\/       fmls    z26.d, p0\/m, z0.d, z9.d\n+    __ sve_fnmla(z28, __ D, p2, z24, z3);              \/\/       fnmla   z28.d, p2\/m, z24.d, z3.d\n+    __ sve_fnmls(z7, __ D, p6, z28, z13);              \/\/       fnmls   z7.d, p6\/m, z28.d, z13.d\n+    __ sve_mla(z10, __ D, p6, z12, z17);               \/\/       mla     z10.d, p6\/m, z12.d, z17.d\n+    __ sve_mls(z17, __ S, p3, z2, z29);                \/\/       mls     z17.s, p3\/m, z2.s, z29.s\n+    __ sve_and(z21, z20, z7);                          \/\/       and     z21.d, z20.d, z7.d\n+    __ sve_eor(z2, z1, z26);                           \/\/       eor     z2.d, z1.d, z26.d\n+    __ sve_orr(z9, z16, z17);                          \/\/       orr     z9.d, z16.d, z17.d\n+    __ sve_bic(z0, z4, z2);                            \/\/       bic     z0.d, z4.d, z2.d\n+    __ sve_uzp1(z14, __ S, z6, z11);                   \/\/       uzp1    z14.s, z6.s, z11.s\n+    __ sve_uzp2(z14, __ H, z16, z29);                  \/\/       uzp2    z14.h, z16.h, z29.h\n@@ -1125,9 +1126,9 @@\n-    __ sve_andv(v14, __ H, p4, z29);                   \/\/       andv h14, p4, z29.h\n-    __ sve_orv(v3, __ H, p0, z22);                     \/\/       orv h3, p0, z22.h\n-    __ sve_eorv(v3, __ B, p6, z27);                    \/\/       eorv b3, p6, z27.b\n-    __ sve_smaxv(v19, __ D, p5, z7);                   \/\/       smaxv d19, p5, z7.d\n-    __ sve_sminv(v21, __ H, p3, z5);                   \/\/       sminv h21, p3, z5.h\n-    __ sve_fminv(v25, __ D, p1, z21);                  \/\/       fminv d25, p1, z21.d\n-    __ sve_fmaxv(v17, __ S, p0, z3);                   \/\/       fmaxv s17, p0, z3.s\n-    __ sve_fadda(v19, __ S, p3, z7);                   \/\/       fadda s19, p3, s19, z7.s\n-    __ sve_uaddv(v14, __ H, p4, z17);                  \/\/       uaddv d14, p4, z17.h\n+    __ sve_andv(v3, __ H, p0, z22);                    \/\/       andv h3, p0, z22.h\n+    __ sve_orv(v3, __ B, p6, z27);                     \/\/       orv b3, p6, z27.b\n+    __ sve_eorv(v19, __ D, p5, z7);                    \/\/       eorv d19, p5, z7.d\n+    __ sve_smaxv(v21, __ H, p3, z5);                   \/\/       smaxv h21, p3, z5.h\n+    __ sve_sminv(v25, __ S, p1, z21);                  \/\/       sminv s25, p1, z21.s\n+    __ sve_fminv(v17, __ S, p0, z3);                   \/\/       fminv s17, p0, z3.s\n+    __ sve_fmaxv(v19, __ S, p3, z7);                   \/\/       fmaxv s19, p3, z7.s\n+    __ sve_fadda(v14, __ S, p4, z17);                  \/\/       fadda s14, p4, s14, z17.s\n+    __ sve_uaddv(v13, __ D, p6, z17);                  \/\/       uaddv d13, p6, z17.d\n@@ -1152,7 +1153,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003ab,     0x94000000,\n-    0x97ffffd4,     0x940003a8,     0x3400000a,     0x34fffa2a,\n-    0x340074aa,     0x35000008,     0x35fff9c8,     0x35007448,\n-    0xb400000b,     0xb4fff96b,     0xb40073eb,     0xb500001d,\n-    0xb5fff91d,     0xb500739d,     0x10000013,     0x10fff8b3,\n-    0x10007333,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363072b6,     0x3758000c,     0x375ff7cc,     0x3758724c,\n+    0x14000000,     0x17ffffd7,     0x140003a6,     0x94000000,\n+    0x97ffffd4,     0x940003a3,     0x3400000a,     0x34fffa2a,\n+    0x3400740a,     0x35000008,     0x35fff9c8,     0x350073a8,\n+    0xb400000b,     0xb4fff96b,     0xb400734b,     0xb500001d,\n+    0xb5fff91d,     0xb50072fd,     0x10000013,     0x10fff8b3,\n+    0x10007293,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307216,     0x3758000c,     0x375ff7cc,     0x375871ac,\n@@ -1163,13 +1164,13 @@\n-    0x54007020,     0x54000001,     0x54fff541,     0x54006fc1,\n-    0x54000002,     0x54fff4e2,     0x54006f62,     0x54000002,\n-    0x54fff482,     0x54006f02,     0x54000003,     0x54fff423,\n-    0x54006ea3,     0x54000003,     0x54fff3c3,     0x54006e43,\n-    0x54000004,     0x54fff364,     0x54006de4,     0x54000005,\n-    0x54fff305,     0x54006d85,     0x54000006,     0x54fff2a6,\n-    0x54006d26,     0x54000007,     0x54fff247,     0x54006cc7,\n-    0x54000008,     0x54fff1e8,     0x54006c68,     0x54000009,\n-    0x54fff189,     0x54006c09,     0x5400000a,     0x54fff12a,\n-    0x54006baa,     0x5400000b,     0x54fff0cb,     0x54006b4b,\n-    0x5400000c,     0x54fff06c,     0x54006aec,     0x5400000d,\n-    0x54fff00d,     0x54006a8d,     0x5400000e,     0x54ffefae,\n-    0x54006a2e,     0x5400000f,     0x54ffef4f,     0x540069cf,\n+    0x54006f80,     0x54000001,     0x54fff541,     0x54006f21,\n+    0x54000002,     0x54fff4e2,     0x54006ec2,     0x54000002,\n+    0x54fff482,     0x54006e62,     0x54000003,     0x54fff423,\n+    0x54006e03,     0x54000003,     0x54fff3c3,     0x54006da3,\n+    0x54000004,     0x54fff364,     0x54006d44,     0x54000005,\n+    0x54fff305,     0x54006ce5,     0x54000006,     0x54fff2a6,\n+    0x54006c86,     0x54000007,     0x54fff247,     0x54006c27,\n+    0x54000008,     0x54fff1e8,     0x54006bc8,     0x54000009,\n+    0x54fff189,     0x54006b69,     0x5400000a,     0x54fff12a,\n+    0x54006b0a,     0x5400000b,     0x54fff0cb,     0x54006aab,\n+    0x5400000c,     0x54fff06c,     0x54006a4c,     0x5400000d,\n+    0x54fff00d,     0x540069ed,     0x5400000e,     0x54ffefae,\n+    0x5400698e,     0x5400000f,     0x54ffef4f,     0x5400692f,\n@@ -1207,1 +1208,1 @@\n-    0xbd1b1869,     0x58005a1b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800597b,     0x1800000b,     0xf8945060,\n@@ -1337,51 +1338,51 @@\n-    0x05e14c00,     0x05304001,     0x05314001,     0x05a18610,\n-    0x05e18610,     0x1e601000,     0x1e603000,     0x1e621000,\n-    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n-    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n-    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n-    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n-    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n-    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n-    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n-    0x1e7e3000,     0xf8208193,     0xf83101b6,     0xf83c13fe,\n-    0xf821239a,     0xf824309e,     0xf826535e,     0xf8304109,\n-    0xf82c7280,     0xf8216058,     0xf8a08309,     0xf8ba03d0,\n-    0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,\n-    0xf8a2418a,     0xf8ac71af,     0xf8a26287,     0xf8fa8090,\n-    0xf8e20184,     0xf8f01215,     0xf8f022ab,     0xf8f7334c,\n-    0xf8f751dc,     0xf8eb4038,     0xf8ec715f,     0xf8f06047,\n-    0xf863826d,     0xf8710070,     0xf86113cb,     0xf86521e8,\n-    0xf87d301e,     0xf8745287,     0xf87742bc,     0xf87b70b9,\n-    0xf8616217,     0xb83f8185,     0xb82901fc,     0xb83d13f6,\n-    0xb83320bf,     0xb82e33f0,     0xb830529b,     0xb830416c,\n-    0xb82973c6,     0xb831639b,     0xb8be8147,     0xb8b4008a,\n-    0xb8b81231,     0xb8b623a3,     0xb8af3276,     0xb8b35056,\n-    0xb8af4186,     0xb8b071ab,     0xb8b763c1,     0xb8f38225,\n-    0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,\n-    0xb8ff5278,     0xb8f14389,     0xb8fb70ef,     0xb8f563f7,\n-    0xb87983e2,     0xb87b0150,     0xb8771073,     0xb8702320,\n-    0xb87a3057,     0xb870508c,     0xb87c43be,     0xb87070db,\n-    0xb86961fd,     0xce273c87,     0xce080ac9,     0xce7e8e9b,\n-    0xce808b45,     0xce79806e,     0xce758768,     0xcec0835a,\n-    0xce608ad8,     0x2520d264,     0x2521cf80,     0x058074c1,\n-    0x054242c9,     0x05004476,     0x25a0df08,     0x25a1c206,\n-    0x0583288b,     0x05401c3a,     0x05027e8d,     0x2520ce05,\n-    0x25a1cb0a,     0x0580989a,     0x0540e096,     0x0500fb73,\n-    0x2560c2ce,     0x2521d590,     0x05803e97,     0x05400d31,\n-    0x05003ed0,     0x2520c623,     0x25a1cdd1,     0x058052ac,\n-    0x0540ba33,     0x05003ed7,     0x25a0c6cd,     0x2521cf00,\n-    0x0583c5b1,     0x05407336,     0x05001e62,     0x04e400f4,\n-    0x04a80407,     0x65c402d3,     0x65cb0ac9,     0x659007c5,\n-    0x0456ac36,     0x04c01608,     0x049a048f,     0x041087a8,\n-    0x04dab3bc,     0x04590c49,     0x041380fc,     0x0451963a,\n-    0x04d012a8,     0x0497b6a5,     0x049eb3b6,     0x04980093,\n-    0x04080677,     0x040a1a77,     0x04c109c8,     0x049cbeb1,\n-    0x65c0815e,     0x658d812c,     0x65c69098,     0x65c78b66,\n-    0x65c293cd,     0x04ddb7d6,     0x6582ae69,     0x6580bd34,\n-    0x6581ae6d,     0x658daa78,     0x65819211,     0x65a78160,\n-    0x65ef108e,     0x65f52145,     0x65f34123,     0x65b3786a,\n-    0x04555db7,     0x049e6e3a,     0x043d304e,     0x04a73295,\n-    0x047a3022,     0x04f13209,     0x05e26880,     0x05ab6cce,\n-    0x045a33ae,     0x045822c3,     0x04193b63,     0x04c834f3,\n-    0x044a2cb5,     0x65c726b9,     0x65862071,     0x65982cf3,\n-    0x0441322e,\n+    0x05e14c00,     0x05304001,     0x05314001,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8208193,\n+    0xf83101b6,     0xf83c13fe,     0xf821239a,     0xf824309e,\n+    0xf826535e,     0xf8304109,     0xf82c7280,     0xf8216058,\n+    0xf8a08309,     0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,\n+    0xf8a2310b,     0xf8aa522f,     0xf8a2418a,     0xf8ac71af,\n+    0xf8a26287,     0xf8fa8090,     0xf8e20184,     0xf8f01215,\n+    0xf8f022ab,     0xf8f7334c,     0xf8f751dc,     0xf8eb4038,\n+    0xf8ec715f,     0xf8f06047,     0xf863826d,     0xf8710070,\n+    0xf86113cb,     0xf86521e8,     0xf87d301e,     0xf8745287,\n+    0xf87742bc,     0xf87b70b9,     0xf8616217,     0xb83f8185,\n+    0xb82901fc,     0xb83d13f6,     0xb83320bf,     0xb82e33f0,\n+    0xb830529b,     0xb830416c,     0xb82973c6,     0xb831639b,\n+    0xb8be8147,     0xb8b4008a,     0xb8b81231,     0xb8b623a3,\n+    0xb8af3276,     0xb8b35056,     0xb8af4186,     0xb8b071ab,\n+    0xb8b763c1,     0xb8f38225,     0xb8e202d0,     0xb8ed12aa,\n+    0xb8fd219b,     0xb8fb3023,     0xb8ff5278,     0xb8f14389,\n+    0xb8fb70ef,     0xb8f563f7,     0xb87983e2,     0xb87b0150,\n+    0xb8771073,     0xb8702320,     0xb87a3057,     0xb870508c,\n+    0xb87c43be,     0xb87070db,     0xb86961fd,     0xce273c87,\n+    0xce080ac9,     0xce7e8e9b,     0xce808b45,     0xce79806e,\n+    0xce758768,     0xcec0835a,     0xce608ad8,     0x2520d264,\n+    0x2521cf80,     0x058074c1,     0x054242c9,     0x05004476,\n+    0x25a0df08,     0x25a1c206,     0x0583288b,     0x05401c3a,\n+    0x05027e8d,     0x2520ce05,     0x25a1cb0a,     0x0580989a,\n+    0x0540e096,     0x0500fb73,     0x2560c2ce,     0x2521d590,\n+    0x05803e97,     0x05400d31,     0x05003ed0,     0x2520c623,\n+    0x25a1cdd1,     0x058052ac,     0x0540ba33,     0x05003ed7,\n+    0x25a0c6cd,     0x2521cf00,     0x0583c5b1,     0x05407336,\n+    0x05001e62,     0x04e400f4,     0x04a80407,     0x65c402d3,\n+    0x65cb0ac9,     0x659007c5,     0x0456ac36,     0x04c01608,\n+    0x049a048f,     0x041087a8,     0x04db13bc,     0x045aac49,\n+    0x041900fc,     0x0453963a,     0x04d192a8,     0x049016a5,\n+    0x0497b3b6,     0x049ea093,     0x04180677,     0x04081a77,\n+    0x04ca09c8,     0x04011eb1,     0x04dca15e,     0x6580812c,\n+    0x65cd9098,     0x65c68b66,     0x65c793cd,     0x65c297d6,\n+    0x049dae69,     0x6582bd34,     0x6580ae6d,     0x6581aa78,\n+    0x658db211,     0x65818160,     0x65a48def,     0x65ea041d,\n+    0x65e9201a,     0x65e34b1c,     0x65ed7b87,     0x04d1598a,\n+    0x049d6c51,     0x04273295,     0x04ba3022,     0x04713209,\n+    0x04e23080,     0x05ab68ce,     0x057d6e0e,     0x045a22c3,\n+    0x04183b63,     0x04d934f3,     0x04482cb5,     0x048a26b9,\n+    0x65872071,     0x65862cf3,     0x6598322e,     0x04c13a2d,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":118,"deletions":117,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -1253,0 +1253,4 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n@@ -3268,1 +3272,1 @@\n-            res = (byte)Math.min(res, a[i]);\n+            res = (byte) Math.min(res, a[i]);\n@@ -3276,2 +3280,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduce(a, i));\n@@ -3299,1 +3303,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3309,2 +3313,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.min(res, a[i]);\n@@ -3318,3 +3322,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3344,1 +3347,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3354,1 +3357,1 @@\n-            res = (byte)Math.max(res, a[i]);\n+            res = (byte) Math.max(res, a[i]);\n@@ -3362,2 +3365,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduce(a, i));\n@@ -3385,1 +3388,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3395,2 +3398,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.max(res, a[i]);\n@@ -3404,3 +3407,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3430,1 +3432,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3437,0 +3439,85 @@\n+    static byte FIRST_NONZEROReduce(byte[] a, int idx) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAll(byte[] a) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte128VectorTests::FIRST_NONZEROReduce, Byte128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static byte FIRST_NONZEROReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte128VectorTests::FIRST_NONZEROReduceMasked, Byte128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1253,0 +1253,4 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n@@ -3268,1 +3272,1 @@\n-            res = (byte)Math.min(res, a[i]);\n+            res = (byte) Math.min(res, a[i]);\n@@ -3276,2 +3280,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduce(a, i));\n@@ -3299,1 +3303,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3309,2 +3313,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.min(res, a[i]);\n@@ -3318,3 +3322,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3344,1 +3347,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3354,1 +3357,1 @@\n-            res = (byte)Math.max(res, a[i]);\n+            res = (byte) Math.max(res, a[i]);\n@@ -3362,2 +3365,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduce(a, i));\n@@ -3385,1 +3388,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3395,2 +3398,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.max(res, a[i]);\n@@ -3404,3 +3407,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3430,1 +3432,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3437,0 +3439,85 @@\n+    static byte FIRST_NONZEROReduce(byte[] a, int idx) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAll(byte[] a) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte256VectorTests::FIRST_NONZEROReduce, Byte256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static byte FIRST_NONZEROReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte256VectorTests::FIRST_NONZEROReduceMasked, Byte256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1253,0 +1253,4 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n@@ -3268,1 +3272,1 @@\n-            res = (byte)Math.min(res, a[i]);\n+            res = (byte) Math.min(res, a[i]);\n@@ -3276,2 +3280,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduce(a, i));\n@@ -3299,1 +3303,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3309,2 +3313,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.min(res, a[i]);\n@@ -3318,3 +3322,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3344,1 +3347,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3354,1 +3357,1 @@\n-            res = (byte)Math.max(res, a[i]);\n+            res = (byte) Math.max(res, a[i]);\n@@ -3362,2 +3365,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduce(a, i));\n@@ -3385,1 +3388,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3395,2 +3398,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.max(res, a[i]);\n@@ -3404,3 +3407,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3430,1 +3432,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3437,0 +3439,85 @@\n+    static byte FIRST_NONZEROReduce(byte[] a, int idx) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAll(byte[] a) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte512VectorTests::FIRST_NONZEROReduce, Byte512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static byte FIRST_NONZEROReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte512VectorTests::FIRST_NONZEROReduceMasked, Byte512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1253,0 +1253,4 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n@@ -3268,1 +3272,1 @@\n-            res = (byte)Math.min(res, a[i]);\n+            res = (byte) Math.min(res, a[i]);\n@@ -3276,2 +3280,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduce(a, i));\n@@ -3299,1 +3303,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3309,2 +3313,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.min(res, a[i]);\n@@ -3318,3 +3322,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3344,1 +3347,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3354,1 +3357,1 @@\n-            res = (byte)Math.max(res, a[i]);\n+            res = (byte) Math.max(res, a[i]);\n@@ -3362,2 +3365,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduce(a, i));\n@@ -3385,1 +3388,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3395,2 +3398,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.max(res, a[i]);\n@@ -3404,3 +3407,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3430,1 +3432,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3437,0 +3439,85 @@\n+    static byte FIRST_NONZEROReduce(byte[] a, int idx) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAll(byte[] a) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte64VectorTests::FIRST_NONZEROReduce, Byte64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static byte FIRST_NONZEROReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte64VectorTests::FIRST_NONZEROReduceMasked, Byte64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1258,0 +1258,4 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n@@ -3273,1 +3277,1 @@\n-            res = (byte)Math.min(res, a[i]);\n+            res = (byte) Math.min(res, a[i]);\n@@ -3281,2 +3285,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduce(a, i));\n@@ -3304,1 +3308,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3314,2 +3318,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.min(res, a[i]);\n@@ -3323,3 +3327,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3349,1 +3352,1 @@\n-                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3359,1 +3362,1 @@\n-            res = (byte)Math.max(res, a[i]);\n+            res = (byte) Math.max(res, a[i]);\n@@ -3367,2 +3370,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduce(a, i));\n@@ -3390,1 +3393,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3400,2 +3403,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) Math.max(res, a[i]);\n@@ -3409,3 +3412,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (byte)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3435,1 +3437,1 @@\n-                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3442,0 +3444,85 @@\n+    static byte FIRST_NONZEROReduce(byte[] a, int idx) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAll(byte[] a) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                ByteMaxVectorTests::FIRST_NONZEROReduce, ByteMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static byte FIRST_NONZEROReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte FIRST_NONZEROReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = (byte) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                ByteMaxVectorTests::FIRST_NONZEROReduceMasked, ByteMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1351,0 +1351,4 @@\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n@@ -2329,1 +2333,1 @@\n-            res = (double)Math.min(res, a[i]);\n+            res = (double) Math.min(res, a[i]);\n@@ -2337,2 +2341,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduce(a, i));\n@@ -2360,1 +2364,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2370,2 +2374,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.min(res, a[i]);\n@@ -2379,3 +2383,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2405,1 +2408,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2415,1 +2418,1 @@\n-            res = (double)Math.max(res, a[i]);\n+            res = (double) Math.max(res, a[i]);\n@@ -2423,2 +2426,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduce(a, i));\n@@ -2446,1 +2449,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2456,2 +2459,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.max(res, a[i]);\n@@ -2465,3 +2468,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2491,1 +2493,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2498,0 +2500,85 @@\n+    static double FIRST_NONZEROReduce(double[] a, int idx) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAll(double[] a) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceDouble128VectorTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Double128VectorTests::FIRST_NONZEROReduce, Double128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static double FIRST_NONZEROReduceMasked(double[] a, int idx, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAllMasked(double[] a, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceDouble128VectorTestsMasked(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Double128VectorTests::FIRST_NONZEROReduceMasked, Double128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1351,0 +1351,4 @@\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n@@ -2329,1 +2333,1 @@\n-            res = (double)Math.min(res, a[i]);\n+            res = (double) Math.min(res, a[i]);\n@@ -2337,2 +2341,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduce(a, i));\n@@ -2360,1 +2364,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2370,2 +2374,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.min(res, a[i]);\n@@ -2379,3 +2383,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2405,1 +2408,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2415,1 +2418,1 @@\n-            res = (double)Math.max(res, a[i]);\n+            res = (double) Math.max(res, a[i]);\n@@ -2423,2 +2426,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduce(a, i));\n@@ -2446,1 +2449,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2456,2 +2459,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.max(res, a[i]);\n@@ -2465,3 +2468,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2491,1 +2493,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2498,0 +2500,85 @@\n+    static double FIRST_NONZEROReduce(double[] a, int idx) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAll(double[] a) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceDouble256VectorTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Double256VectorTests::FIRST_NONZEROReduce, Double256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static double FIRST_NONZEROReduceMasked(double[] a, int idx, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAllMasked(double[] a, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceDouble256VectorTestsMasked(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Double256VectorTests::FIRST_NONZEROReduceMasked, Double256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1351,0 +1351,4 @@\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n@@ -2329,1 +2333,1 @@\n-            res = (double)Math.min(res, a[i]);\n+            res = (double) Math.min(res, a[i]);\n@@ -2337,2 +2341,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduce(a, i));\n@@ -2360,1 +2364,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2370,2 +2374,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.min(res, a[i]);\n@@ -2379,3 +2383,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2405,1 +2408,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2415,1 +2418,1 @@\n-            res = (double)Math.max(res, a[i]);\n+            res = (double) Math.max(res, a[i]);\n@@ -2423,2 +2426,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduce(a, i));\n@@ -2446,1 +2449,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2456,2 +2459,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.max(res, a[i]);\n@@ -2465,3 +2468,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2491,1 +2493,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2498,0 +2500,85 @@\n+    static double FIRST_NONZEROReduce(double[] a, int idx) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAll(double[] a) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceDouble512VectorTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Double512VectorTests::FIRST_NONZEROReduce, Double512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static double FIRST_NONZEROReduceMasked(double[] a, int idx, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAllMasked(double[] a, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceDouble512VectorTestsMasked(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Double512VectorTests::FIRST_NONZEROReduceMasked, Double512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1351,0 +1351,4 @@\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n@@ -2329,1 +2333,1 @@\n-            res = (double)Math.min(res, a[i]);\n+            res = (double) Math.min(res, a[i]);\n@@ -2337,2 +2341,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduce(a, i));\n@@ -2360,1 +2364,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2370,2 +2374,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.min(res, a[i]);\n@@ -2379,3 +2383,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2405,1 +2408,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2415,1 +2418,1 @@\n-            res = (double)Math.max(res, a[i]);\n+            res = (double) Math.max(res, a[i]);\n@@ -2423,2 +2426,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduce(a, i));\n@@ -2446,1 +2449,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2456,2 +2459,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.max(res, a[i]);\n@@ -2465,3 +2468,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2491,1 +2493,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2498,0 +2500,85 @@\n+    static double FIRST_NONZEROReduce(double[] a, int idx) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAll(double[] a) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceDouble64VectorTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Double64VectorTests::FIRST_NONZEROReduce, Double64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static double FIRST_NONZEROReduceMasked(double[] a, int idx, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAllMasked(double[] a, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceDouble64VectorTestsMasked(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Double64VectorTests::FIRST_NONZEROReduceMasked, Double64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1356,0 +1356,4 @@\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n@@ -2334,1 +2338,1 @@\n-            res = (double)Math.min(res, a[i]);\n+            res = (double) Math.min(res, a[i]);\n@@ -2342,2 +2346,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduce(a, i));\n@@ -2365,1 +2369,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2375,2 +2379,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.min(res, a[i]);\n@@ -2384,3 +2388,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2410,1 +2413,1 @@\n-                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2420,1 +2423,1 @@\n-            res = (double)Math.max(res, a[i]);\n+            res = (double) Math.max(res, a[i]);\n@@ -2428,2 +2431,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduce(a, i));\n@@ -2451,1 +2454,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2461,2 +2464,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (double) Math.max(res, a[i]);\n@@ -2470,3 +2473,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (double)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2496,1 +2498,1 @@\n-                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2503,0 +2505,85 @@\n+    static double FIRST_NONZEROReduce(double[] a, int idx) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAll(double[] a) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceDoubleMaxVectorTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                DoubleMaxVectorTests::FIRST_NONZEROReduce, DoubleMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static double FIRST_NONZEROReduceMasked(double[] a, int idx, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static double FIRST_NONZEROReduceAllMasked(double[] a, boolean[] mask) {\n+        double res = (double) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceDoubleMaxVectorTestsMasked(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                DoubleMaxVectorTests::FIRST_NONZEROReduceMasked, DoubleMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1361,0 +1361,4 @@\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n@@ -2339,1 +2343,1 @@\n-            res = (float)Math.min(res, a[i]);\n+            res = (float) Math.min(res, a[i]);\n@@ -2347,2 +2351,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduce(a, i));\n@@ -2370,1 +2374,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2380,2 +2384,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.min(res, a[i]);\n@@ -2389,3 +2393,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2415,1 +2418,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2425,1 +2428,1 @@\n-            res = (float)Math.max(res, a[i]);\n+            res = (float) Math.max(res, a[i]);\n@@ -2433,2 +2436,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduce(a, i));\n@@ -2456,1 +2459,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2466,2 +2469,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.max(res, a[i]);\n@@ -2475,3 +2478,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2501,1 +2503,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2508,0 +2510,85 @@\n+    static float FIRST_NONZEROReduce(float[] a, int idx) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAll(float[] a) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceFloat128VectorTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Float128VectorTests::FIRST_NONZEROReduce, Float128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static float FIRST_NONZEROReduceMasked(float[] a, int idx, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAllMasked(float[] a, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceFloat128VectorTestsMasked(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Float128VectorTests::FIRST_NONZEROReduceMasked, Float128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1361,0 +1361,4 @@\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n@@ -2339,1 +2343,1 @@\n-            res = (float)Math.min(res, a[i]);\n+            res = (float) Math.min(res, a[i]);\n@@ -2347,2 +2351,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduce(a, i));\n@@ -2370,1 +2374,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2380,2 +2384,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.min(res, a[i]);\n@@ -2389,3 +2393,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2415,1 +2418,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2425,1 +2428,1 @@\n-            res = (float)Math.max(res, a[i]);\n+            res = (float) Math.max(res, a[i]);\n@@ -2433,2 +2436,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduce(a, i));\n@@ -2456,1 +2459,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2466,2 +2469,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.max(res, a[i]);\n@@ -2475,3 +2478,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2501,1 +2503,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2508,0 +2510,85 @@\n+    static float FIRST_NONZEROReduce(float[] a, int idx) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAll(float[] a) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceFloat256VectorTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Float256VectorTests::FIRST_NONZEROReduce, Float256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static float FIRST_NONZEROReduceMasked(float[] a, int idx, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAllMasked(float[] a, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceFloat256VectorTestsMasked(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Float256VectorTests::FIRST_NONZEROReduceMasked, Float256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1361,0 +1361,4 @@\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n@@ -2339,1 +2343,1 @@\n-            res = (float)Math.min(res, a[i]);\n+            res = (float) Math.min(res, a[i]);\n@@ -2347,2 +2351,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduce(a, i));\n@@ -2370,1 +2374,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2380,2 +2384,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.min(res, a[i]);\n@@ -2389,3 +2393,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2415,1 +2418,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2425,1 +2428,1 @@\n-            res = (float)Math.max(res, a[i]);\n+            res = (float) Math.max(res, a[i]);\n@@ -2433,2 +2436,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduce(a, i));\n@@ -2456,1 +2459,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2466,2 +2469,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.max(res, a[i]);\n@@ -2475,3 +2478,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2501,1 +2503,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2508,0 +2510,85 @@\n+    static float FIRST_NONZEROReduce(float[] a, int idx) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAll(float[] a) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceFloat512VectorTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Float512VectorTests::FIRST_NONZEROReduce, Float512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static float FIRST_NONZEROReduceMasked(float[] a, int idx, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAllMasked(float[] a, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceFloat512VectorTestsMasked(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Float512VectorTests::FIRST_NONZEROReduceMasked, Float512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1361,0 +1361,4 @@\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n@@ -2339,1 +2343,1 @@\n-            res = (float)Math.min(res, a[i]);\n+            res = (float) Math.min(res, a[i]);\n@@ -2347,2 +2351,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduce(a, i));\n@@ -2370,1 +2374,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2380,2 +2384,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.min(res, a[i]);\n@@ -2389,3 +2393,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2415,1 +2418,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2425,1 +2428,1 @@\n-            res = (float)Math.max(res, a[i]);\n+            res = (float) Math.max(res, a[i]);\n@@ -2433,2 +2436,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduce(a, i));\n@@ -2456,1 +2459,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2466,2 +2469,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.max(res, a[i]);\n@@ -2475,3 +2478,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2501,1 +2503,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2508,0 +2510,85 @@\n+    static float FIRST_NONZEROReduce(float[] a, int idx) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAll(float[] a) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceFloat64VectorTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Float64VectorTests::FIRST_NONZEROReduce, Float64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static float FIRST_NONZEROReduceMasked(float[] a, int idx, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAllMasked(float[] a, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceFloat64VectorTestsMasked(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Float64VectorTests::FIRST_NONZEROReduceMasked, Float64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1366,0 +1366,4 @@\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n@@ -2344,1 +2348,1 @@\n-            res = (float)Math.min(res, a[i]);\n+            res = (float) Math.min(res, a[i]);\n@@ -2352,2 +2356,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduce(a, i));\n@@ -2375,1 +2379,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2385,2 +2389,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.min(res, a[i]);\n@@ -2394,3 +2398,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -2420,1 +2423,1 @@\n-                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2430,1 +2433,1 @@\n-            res = (float)Math.max(res, a[i]);\n+            res = (float) Math.max(res, a[i]);\n@@ -2438,2 +2441,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduce(a, i));\n@@ -2461,1 +2464,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2471,2 +2474,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (float) Math.max(res, a[i]);\n@@ -2480,3 +2483,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (float)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -2506,1 +2508,1 @@\n-                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2513,0 +2515,85 @@\n+    static float FIRST_NONZEROReduce(float[] a, int idx) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAll(float[] a) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceFloatMaxVectorTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                FloatMaxVectorTests::FIRST_NONZEROReduce, FloatMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static float FIRST_NONZEROReduceMasked(float[] a, int idx, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static float FIRST_NONZEROReduceAllMasked(float[] a, boolean[] mask) {\n+        float res = (float) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceFloatMaxVectorTestsMasked(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                FloatMaxVectorTests::FIRST_NONZEROReduceMasked, FloatMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1213,0 +1213,4 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n@@ -3233,1 +3237,1 @@\n-            res = (int)Math.min(res, a[i]);\n+            res = (int) Math.min(res, a[i]);\n@@ -3241,2 +3245,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduce(a, i));\n@@ -3264,1 +3268,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3274,2 +3278,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.min(res, a[i]);\n@@ -3283,3 +3287,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3309,1 +3312,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3319,1 +3322,1 @@\n-            res = (int)Math.max(res, a[i]);\n+            res = (int) Math.max(res, a[i]);\n@@ -3327,2 +3330,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduce(a, i));\n@@ -3350,1 +3353,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3360,2 +3363,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.max(res, a[i]);\n@@ -3369,3 +3372,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3395,1 +3397,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3402,0 +3404,85 @@\n+    static int FIRST_NONZEROReduce(int[] a, int idx) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAll(int[] a) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int128VectorTests::FIRST_NONZEROReduce, Int128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static int FIRST_NONZEROReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int128VectorTests::FIRST_NONZEROReduceMasked, Int128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1213,0 +1213,4 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n@@ -3233,1 +3237,1 @@\n-            res = (int)Math.min(res, a[i]);\n+            res = (int) Math.min(res, a[i]);\n@@ -3241,2 +3245,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduce(a, i));\n@@ -3264,1 +3268,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3274,2 +3278,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.min(res, a[i]);\n@@ -3283,3 +3287,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3309,1 +3312,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3319,1 +3322,1 @@\n-            res = (int)Math.max(res, a[i]);\n+            res = (int) Math.max(res, a[i]);\n@@ -3327,2 +3330,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduce(a, i));\n@@ -3350,1 +3353,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3360,2 +3363,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.max(res, a[i]);\n@@ -3369,3 +3372,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3395,1 +3397,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3402,0 +3404,85 @@\n+    static int FIRST_NONZEROReduce(int[] a, int idx) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAll(int[] a) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int256VectorTests::FIRST_NONZEROReduce, Int256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static int FIRST_NONZEROReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int256VectorTests::FIRST_NONZEROReduceMasked, Int256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1213,0 +1213,4 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n@@ -3233,1 +3237,1 @@\n-            res = (int)Math.min(res, a[i]);\n+            res = (int) Math.min(res, a[i]);\n@@ -3241,2 +3245,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduce(a, i));\n@@ -3264,1 +3268,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3274,2 +3278,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.min(res, a[i]);\n@@ -3283,3 +3287,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3309,1 +3312,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3319,1 +3322,1 @@\n-            res = (int)Math.max(res, a[i]);\n+            res = (int) Math.max(res, a[i]);\n@@ -3327,2 +3330,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduce(a, i));\n@@ -3350,1 +3353,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3360,2 +3363,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.max(res, a[i]);\n@@ -3369,3 +3372,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3395,1 +3397,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3402,0 +3404,85 @@\n+    static int FIRST_NONZEROReduce(int[] a, int idx) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAll(int[] a) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int512VectorTests::FIRST_NONZEROReduce, Int512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static int FIRST_NONZEROReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int512VectorTests::FIRST_NONZEROReduceMasked, Int512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1213,0 +1213,4 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n@@ -3233,1 +3237,1 @@\n-            res = (int)Math.min(res, a[i]);\n+            res = (int) Math.min(res, a[i]);\n@@ -3241,2 +3245,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduce(a, i));\n@@ -3264,1 +3268,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3274,2 +3278,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.min(res, a[i]);\n@@ -3283,3 +3287,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3309,1 +3312,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3319,1 +3322,1 @@\n-            res = (int)Math.max(res, a[i]);\n+            res = (int) Math.max(res, a[i]);\n@@ -3327,2 +3330,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduce(a, i));\n@@ -3350,1 +3353,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3360,2 +3363,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.max(res, a[i]);\n@@ -3369,3 +3372,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3395,1 +3397,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3402,0 +3404,85 @@\n+    static int FIRST_NONZEROReduce(int[] a, int idx) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAll(int[] a) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int64VectorTests::FIRST_NONZEROReduce, Int64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static int FIRST_NONZEROReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int64VectorTests::FIRST_NONZEROReduceMasked, Int64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1218,0 +1218,4 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n@@ -3238,1 +3242,1 @@\n-            res = (int)Math.min(res, a[i]);\n+            res = (int) Math.min(res, a[i]);\n@@ -3246,2 +3250,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduce(a, i));\n@@ -3269,1 +3273,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3279,2 +3283,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.min(res, a[i]);\n@@ -3288,3 +3292,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3314,1 +3317,1 @@\n-                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3324,1 +3327,1 @@\n-            res = (int)Math.max(res, a[i]);\n+            res = (int) Math.max(res, a[i]);\n@@ -3332,2 +3335,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduce(a, i));\n@@ -3355,1 +3358,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3365,2 +3368,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (int) Math.max(res, a[i]);\n@@ -3374,3 +3377,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (int)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3400,1 +3402,1 @@\n-                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3407,0 +3409,85 @@\n+    static int FIRST_NONZEROReduce(int[] a, int idx) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAll(int[] a) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                IntMaxVectorTests::FIRST_NONZEROReduce, IntMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static int FIRST_NONZEROReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int FIRST_NONZEROReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = (int) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                IntMaxVectorTests::FIRST_NONZEROReduceMasked, IntMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1235,0 +1235,4 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n@@ -3255,1 +3259,1 @@\n-            res = (long)Math.min(res, a[i]);\n+            res = (long) Math.min(res, a[i]);\n@@ -3263,2 +3267,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduce(a, i));\n@@ -3286,1 +3290,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3296,2 +3300,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.min(res, a[i]);\n@@ -3305,3 +3309,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3331,1 +3334,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3341,1 +3344,1 @@\n-            res = (long)Math.max(res, a[i]);\n+            res = (long) Math.max(res, a[i]);\n@@ -3349,2 +3352,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduce(a, i));\n@@ -3372,1 +3375,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3382,2 +3385,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.max(res, a[i]);\n@@ -3391,3 +3394,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3417,1 +3419,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3424,0 +3426,85 @@\n+    static long FIRST_NONZEROReduce(long[] a, int idx) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAll(long[] a) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long128VectorTests::FIRST_NONZEROReduce, Long128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static long FIRST_NONZEROReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long128VectorTests::FIRST_NONZEROReduceMasked, Long128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1235,0 +1235,4 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n@@ -3255,1 +3259,1 @@\n-            res = (long)Math.min(res, a[i]);\n+            res = (long) Math.min(res, a[i]);\n@@ -3263,2 +3267,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduce(a, i));\n@@ -3286,1 +3290,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3296,2 +3300,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.min(res, a[i]);\n@@ -3305,3 +3309,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3331,1 +3334,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3341,1 +3344,1 @@\n-            res = (long)Math.max(res, a[i]);\n+            res = (long) Math.max(res, a[i]);\n@@ -3349,2 +3352,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduce(a, i));\n@@ -3372,1 +3375,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3382,2 +3385,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.max(res, a[i]);\n@@ -3391,3 +3394,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3417,1 +3419,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3424,0 +3426,85 @@\n+    static long FIRST_NONZEROReduce(long[] a, int idx) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAll(long[] a) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long256VectorTests::FIRST_NONZEROReduce, Long256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static long FIRST_NONZEROReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long256VectorTests::FIRST_NONZEROReduceMasked, Long256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1235,0 +1235,4 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n@@ -3255,1 +3259,1 @@\n-            res = (long)Math.min(res, a[i]);\n+            res = (long) Math.min(res, a[i]);\n@@ -3263,2 +3267,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduce(a, i));\n@@ -3286,1 +3290,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3296,2 +3300,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.min(res, a[i]);\n@@ -3305,3 +3309,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3331,1 +3334,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3341,1 +3344,1 @@\n-            res = (long)Math.max(res, a[i]);\n+            res = (long) Math.max(res, a[i]);\n@@ -3349,2 +3352,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduce(a, i));\n@@ -3372,1 +3375,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3382,2 +3385,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.max(res, a[i]);\n@@ -3391,3 +3394,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3417,1 +3419,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3424,0 +3426,85 @@\n+    static long FIRST_NONZEROReduce(long[] a, int idx) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAll(long[] a) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long512VectorTests::FIRST_NONZEROReduce, Long512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static long FIRST_NONZEROReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long512VectorTests::FIRST_NONZEROReduceMasked, Long512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1235,0 +1235,4 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n@@ -3255,1 +3259,1 @@\n-            res = (long)Math.min(res, a[i]);\n+            res = (long) Math.min(res, a[i]);\n@@ -3263,2 +3267,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduce(a, i));\n@@ -3286,1 +3290,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3296,2 +3300,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.min(res, a[i]);\n@@ -3305,3 +3309,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3331,1 +3334,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3341,1 +3344,1 @@\n-            res = (long)Math.max(res, a[i]);\n+            res = (long) Math.max(res, a[i]);\n@@ -3349,2 +3352,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduce(a, i));\n@@ -3372,1 +3375,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3382,2 +3385,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.max(res, a[i]);\n@@ -3391,3 +3394,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3417,1 +3419,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3424,0 +3426,85 @@\n+    static long FIRST_NONZEROReduce(long[] a, int idx) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAll(long[] a) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long64VectorTests::FIRST_NONZEROReduce, Long64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static long FIRST_NONZEROReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long64VectorTests::FIRST_NONZEROReduceMasked, Long64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1240,0 +1240,4 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n@@ -3260,1 +3264,1 @@\n-            res = (long)Math.min(res, a[i]);\n+            res = (long) Math.min(res, a[i]);\n@@ -3268,2 +3272,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduce(a, i));\n@@ -3291,1 +3295,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3301,2 +3305,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.min(res, a[i]);\n@@ -3310,3 +3314,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3336,1 +3339,1 @@\n-                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3346,1 +3349,1 @@\n-            res = (long)Math.max(res, a[i]);\n+            res = (long) Math.max(res, a[i]);\n@@ -3354,2 +3357,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduce(a, i));\n@@ -3377,1 +3380,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3387,2 +3390,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (long) Math.max(res, a[i]);\n@@ -3396,3 +3399,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (long)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3422,1 +3424,1 @@\n-                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3429,0 +3431,85 @@\n+    static long FIRST_NONZEROReduce(long[] a, int idx) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAll(long[] a) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                LongMaxVectorTests::FIRST_NONZEROReduce, LongMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static long FIRST_NONZEROReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long FIRST_NONZEROReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = (long) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                LongMaxVectorTests::FIRST_NONZEROReduceMasked, LongMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1243,0 +1243,4 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n@@ -3258,1 +3262,1 @@\n-            res = (short)Math.min(res, a[i]);\n+            res = (short) Math.min(res, a[i]);\n@@ -3266,2 +3270,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduce(a, i));\n@@ -3289,1 +3293,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3299,2 +3303,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.min(res, a[i]);\n@@ -3308,3 +3312,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3334,1 +3337,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3344,1 +3347,1 @@\n-            res = (short)Math.max(res, a[i]);\n+            res = (short) Math.max(res, a[i]);\n@@ -3352,2 +3355,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduce(a, i));\n@@ -3375,1 +3378,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3385,2 +3388,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.max(res, a[i]);\n@@ -3394,3 +3397,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3420,1 +3422,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3427,0 +3429,85 @@\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short128VectorTests::FIRST_NONZEROReduce, Short128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short128VectorTests::FIRST_NONZEROReduceMasked, Short128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1243,0 +1243,4 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n@@ -3258,1 +3262,1 @@\n-            res = (short)Math.min(res, a[i]);\n+            res = (short) Math.min(res, a[i]);\n@@ -3266,2 +3270,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduce(a, i));\n@@ -3289,1 +3293,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3299,2 +3303,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.min(res, a[i]);\n@@ -3308,3 +3312,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3334,1 +3337,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3344,1 +3347,1 @@\n-            res = (short)Math.max(res, a[i]);\n+            res = (short) Math.max(res, a[i]);\n@@ -3352,2 +3355,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduce(a, i));\n@@ -3375,1 +3378,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3385,2 +3388,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.max(res, a[i]);\n@@ -3394,3 +3397,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3420,1 +3422,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3427,0 +3429,85 @@\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short256VectorTests::FIRST_NONZEROReduce, Short256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short256VectorTests::FIRST_NONZEROReduceMasked, Short256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1243,0 +1243,4 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n@@ -3258,1 +3262,1 @@\n-            res = (short)Math.min(res, a[i]);\n+            res = (short) Math.min(res, a[i]);\n@@ -3266,2 +3270,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduce(a, i));\n@@ -3289,1 +3293,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3299,2 +3303,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.min(res, a[i]);\n@@ -3308,3 +3312,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3334,1 +3337,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3344,1 +3347,1 @@\n-            res = (short)Math.max(res, a[i]);\n+            res = (short) Math.max(res, a[i]);\n@@ -3352,2 +3355,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduce(a, i));\n@@ -3375,1 +3378,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3385,2 +3388,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.max(res, a[i]);\n@@ -3394,3 +3397,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3420,1 +3422,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3427,0 +3429,85 @@\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short512VectorTests::FIRST_NONZEROReduce, Short512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short512VectorTests::FIRST_NONZEROReduceMasked, Short512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1243,0 +1243,4 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n@@ -3258,1 +3262,1 @@\n-            res = (short)Math.min(res, a[i]);\n+            res = (short) Math.min(res, a[i]);\n@@ -3266,2 +3270,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduce(a, i));\n@@ -3289,1 +3293,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3299,2 +3303,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.min(res, a[i]);\n@@ -3308,3 +3312,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3334,1 +3337,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3344,1 +3347,1 @@\n-            res = (short)Math.max(res, a[i]);\n+            res = (short) Math.max(res, a[i]);\n@@ -3352,2 +3355,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduce(a, i));\n@@ -3375,1 +3378,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3385,2 +3388,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.max(res, a[i]);\n@@ -3394,3 +3397,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3420,1 +3422,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3427,0 +3429,85 @@\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short64VectorTests::FIRST_NONZEROReduce, Short64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short64VectorTests::FIRST_NONZEROReduceMasked, Short64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1248,0 +1248,4 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n@@ -3263,1 +3267,1 @@\n-            res = (short)Math.min(res, a[i]);\n+            res = (short) Math.min(res, a[i]);\n@@ -3271,2 +3275,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduce(a, i));\n@@ -3294,1 +3298,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -3304,2 +3308,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.min(res, a[i]);\n@@ -3313,3 +3317,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.min(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n@@ -3339,1 +3342,1 @@\n-                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -3349,1 +3352,1 @@\n-            res = (short)Math.max(res, a[i]);\n+            res = (short) Math.max(res, a[i]);\n@@ -3357,2 +3360,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduce(a, i));\n@@ -3380,1 +3383,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -3390,2 +3393,2 @@\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+            if (mask[i % SPECIES.length()])\n+                res = (short) Math.max(res, a[i]);\n@@ -3399,3 +3402,2 @@\n-        for (int i = 0; i < a.length; i++) {\n-            if(mask[i % SPECIES.length()])\n-                res = (short)Math.max(res, a[i]);\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n@@ -3425,1 +3427,1 @@\n-                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -3432,0 +3434,85 @@\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                ShortMaxVectorTests::FIRST_NONZEROReduce, ShortMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = (short) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                ShortMaxVectorTests::FIRST_NONZEROReduceMasked, ShortMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":107,"deletions":20,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-reduction_scalar_min=\"Reduction-Scalar-Min-op\"\n-reduction_scalar_max=\"Reduction-Scalar-Max-op\"\n+reduction_scalar_func=\"Reduction-Scalar-op-func\"\n@@ -61,2 +60,1 @@\n-reduction_scalar_min_masked=\"Reduction-Scalar-Masked-Min-op\"\n-reduction_scalar_max_masked=\"Reduction-Scalar-Masked-Max-op\"\n+reduction_scalar_masked_func=\"Reduction-Scalar-Masked-op-func\"\n@@ -64,2 +62,1 @@\n-reduction_op_min=\"Reduction-Min-op\"\n-reduction_op_max=\"Reduction-Max-op\"\n+reduction_op_func=\"Reduction-op-func\"\n@@ -67,2 +64,1 @@\n-reduction_op_min_masked=\"Reduction-Masked-Min-op\"\n-reduction_op_max_masked=\"Reduction-Masked-Max-op\"\n+reduction_op_masked_func=\"Reduction-Masked-op-func\"\n@@ -341,1 +337,1 @@\n-function gen_reduction_op_min {\n+function gen_reduction_op_func {\n@@ -343,12 +339,4 @@\n-  gen_op_tmpl $reduction_scalar_min \"$@\"\n-  gen_op_tmpl $reduction_op_min \"$@\"\n-  gen_op_tmpl $reduction_scalar_min_masked \"$@\"\n-  gen_op_tmpl $reduction_op_min_masked \"$@\"\n-}\n-\n-function gen_reduction_op_max {\n-  echo \"Generating reduction op $1 ($2)...\"\n-  gen_op_tmpl $reduction_scalar_max \"$@\"\n-  gen_op_tmpl $reduction_op_max \"$@\"\n-  gen_op_tmpl $reduction_scalar_max_masked \"$@\"\n-  gen_op_tmpl $reduction_op_max_masked \"$@\"\n+  gen_op_tmpl $reduction_scalar_func \"$@\"\n+  gen_op_tmpl $reduction_op_func \"$@\"\n+  gen_op_tmpl $reduction_scalar_masked_func \"$@\"\n+  gen_op_tmpl $reduction_op_masked_func \"$@\"\n@@ -466,3 +454,3 @@\n-gen_reduction_op_min \"MIN\" \"\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_max \"MAX\" \"\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-#gen_reduction_op \"reduce_FIRST_NONZERO\" \"lanewise_FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)=0?a:b\" \"\" \"1\"\n+gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n+gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n+gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1503,0 +1503,4 @@\n+    static $type$ firstNonZero($type$ a, $type$ b) {\n+        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}