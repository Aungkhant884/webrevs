{"files":[{"patch":"@@ -16927,0 +16927,1 @@\n+  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -650,0 +650,2 @@\n+public:\n+\n@@ -653,1 +655,1 @@\n-  void emit_long(jint x) {\n+  void emit_int32(jint x) {\n@@ -659,1 +661,1 @@\n-  void emit_long(jint x) {\n+  void emit_int32(jint x) {\n@@ -664,2 +666,0 @@\n-public:\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1305,0 +1305,6 @@\n+\n+  void ghash_modmul (FloatRegister result,\n+                     FloatRegister result_lo, FloatRegister result_hi, FloatRegister b,\n+                     FloatRegister a, FloatRegister vzr, FloatRegister a1_xor_a0, FloatRegister p,\n+                     FloatRegister t1, FloatRegister t2, FloatRegister t3);\n+  void ghash_load_wide(int index, Register data, FloatRegister result, FloatRegister state);\n@@ -1310,0 +1316,20 @@\n+  void ghash_multiply(FloatRegister result_lo, FloatRegister result_hi,\n+                      FloatRegister a, FloatRegister b, FloatRegister a1_xor_a0,\n+                      FloatRegister tmp1, FloatRegister tmp2, FloatRegister tmp3);\n+  void ghash_multiply_wide(int index,\n+                           FloatRegister result_lo, FloatRegister result_hi,\n+                           FloatRegister a, FloatRegister b, FloatRegister a1_xor_a0,\n+                           FloatRegister tmp1, FloatRegister tmp2, FloatRegister tmp3);\n+  void ghash_reduce(FloatRegister result, FloatRegister lo, FloatRegister hi,\n+                    FloatRegister p, FloatRegister z, FloatRegister t1);\n+  void ghash_reduce_wide(int index, FloatRegister result, FloatRegister lo, FloatRegister hi,\n+                    FloatRegister p, FloatRegister z, FloatRegister t1);\n+  void ghash_processBlocks_wide(address p, Register state, Register subkeyH,\n+                                Register data, Register blocks, int unrolls);\n+\n+\n+  void aesenc_loadkeys(Register key, Register keylen);\n+  void aesecb_encrypt(Register from, Register to, Register keylen,\n+                      FloatRegister data = v0, int unrolls = 1);\n+  void aesecb_decrypt(Register from, Register to, Register key, Register keylen);\n+  void aes_round(FloatRegister input, FloatRegister subkey);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -12796,0 +12796,1 @@\n+  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -10289,0 +10289,1 @@\n+  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1173,0 +1173,7 @@\n+\/\/ See 8273459.  Function for ensuring 64-byte alignment, intended for stubs only.\n+\/\/ Stub code is generated once and never copied.\n+\/\/ NMethods can't use this because they get copied and we can't force alignment > 32 bytes.\n+void MacroAssembler::align64() {\n+  align(64, (unsigned long long) pc());\n+}\n+\n@@ -1174,0 +1181,2 @@\n+  \/\/ 8273459: Ensure alignment is possible with current segment alignment\n+  assert(modulus <= CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n@@ -5417,1 +5426,1 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1\n+\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n@@ -5430,0 +5439,13 @@\n+   \/\/\n+   \/\/@IntrinsicCandidate\n+   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n+   \/\/    byte[] da, int dp, int len) {\n+   \/\/  int i = 0;\n+   \/\/  for (; i < len; i++) {\n+   \/\/    char c = sa[sp++];\n+   \/\/    if (c >= '\\u0080')\n+   \/\/      break;\n+   \/\/    da[dp++] = (byte)c;\n+   \/\/  }\n+   \/\/  return i;\n+   \/\/}\n@@ -5433,1 +5455,1 @@\n-  Register tmp5, Register result) {\n+  Register tmp5, Register result, bool ascii) {\n@@ -5444,0 +5466,3 @@\n+  int mask = ascii ? 0xff80ff80 : 0xff00ff00;\n+  int short_mask = ascii ? 0xff80 : 0xff00;\n+\n@@ -5463,1 +5488,1 @@\n-      movl(tmp5, 0xff00ff00);   \/\/ create mask to test for Unicode chars in vector\n+      movl(tmp5, mask);   \/\/ create mask to test for Unicode or non-ASCII chars in vector\n@@ -5472,1 +5497,1 @@\n-      vptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode chars in  vector\n+      vptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode or non-ASCII chars in vector\n@@ -5487,1 +5512,1 @@\n-      movl(tmp5, 0xff00ff00);   \/\/ create mask to test for Unicode chars in vector\n+      movl(tmp5, mask);   \/\/ create mask to test for Unicode or non-ASCII chars in vector\n@@ -5511,1 +5536,1 @@\n-      ptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode chars in  vector\n+      ptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode or non-ASCII chars in vector\n@@ -5549,1 +5574,1 @@\n-  testl(tmp5, 0xff00);      \/\/ check if Unicode char\n+  testl(tmp5, short_mask);      \/\/ check if Unicode or non-ASCII char\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+  void align64();\n@@ -949,1 +950,1 @@\n-  void generateHtbl_48_block_zmm(Register htbl);\n+  void generateHtbl_48_block_zmm(Register htbl, Register avx512_subkeyHtbl);\n@@ -960,1 +961,1 @@\n-                      Register state, Register subkeyHtbl, Register counter);\n+                      Register state, Register subkeyHtbl, Register avx512_subkeyHtbl, Register counter);\n@@ -1822,1 +1823,1 @@\n-                        XMMRegister tmp4, Register tmp5, Register result);\n+                        XMMRegister tmp4, Register tmp5, Register result, bool ascii);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3001,1 +3001,1 @@\n-    __ align(64);\n+    __ align64();\n@@ -3012,1 +3012,1 @@\n-    __ align(64);\n+    __ align64();\n@@ -3071,1 +3071,1 @@\n-    __ align(64);\n+    __ align64();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4197,1 +4197,1 @@\n-    __ align(64);\n+    __ align64();\n@@ -4206,1 +4206,1 @@\n-    __ align(64);\n+    __ align64();\n@@ -4251,1 +4251,1 @@\n-    __ align(64);\n+    __ align64();\n@@ -4415,1 +4415,3 @@\n-    const Address counter_mem(rbp, 3 * wordSize);\n+    const Address avx512_subkeyH_mem(rbp, 3 * wordSize);\n+    const Register avx512_subkeyHtbl = r13;\n+    const Address counter_mem(rbp, 4 * wordSize);\n@@ -4424,1 +4426,3 @@\n-    const Address counter_mem(rbp, 9 * wordSize);\n+    const Address avx512_subkeyH_mem(rbp, 9 * wordSize);\n+    const Register avx512_subkeyHtbl = r12;\n+    const Address counter_mem(rbp, 10 * wordSize);\n@@ -4441,0 +4445,1 @@\n+    __ movptr(avx512_subkeyHtbl, avx512_subkeyH_mem);\n@@ -4443,1 +4448,1 @@\n-    __ aesgcm_encrypt(in, len, ct, out, key, state, subkeyHtbl, counter);\n+    __ aesgcm_encrypt(in, len, ct, out, key, state, subkeyHtbl, avx512_subkeyHtbl, counter);\n@@ -4462,1 +4467,1 @@\n-    __ align(64);\n+    __ align64();\n@@ -5381,1 +5386,1 @@\n-    __ align(64, (unsigned long long)__ pc());\n+    __ align64();\n@@ -5441,1 +5446,1 @@\n-    __ align(64, (unsigned long long)__ pc());\n+    __ align64();\n@@ -5848,1 +5853,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5865,1 +5870,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5881,1 +5886,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5898,1 +5903,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5915,1 +5920,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5932,1 +5937,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5949,1 +5954,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n@@ -5966,1 +5971,1 @@\n-    __ align(64, (unsigned long long) __ pc());\n+    __ align64();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+  do_intrinsic(_encodeAsciiArray,       java_lang_StringCoding, encodeAsciiArray_name, encodeISOArray_signature, F_S)   \\\n+   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+                                                                                                                        \\\n@@ -420,1 +423,1 @@\n-   do_name(gcm_crypt_name, \"implGCMCrypt\")                                                                                 \\\n+   do_name(gcm_crypt_name, \"implGCMCrypt0\")                                                                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -219,0 +219,3 @@\n+  case vmIntrinsics::_encodeAsciiArray:\n+    if (!Matcher::match_rule_supported(Op_EncodeISOArray) || !Matcher::supports_encode_ascii_array) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -776,2 +776,6 @@\n-    _stress_seed = FLAG_IS_DEFAULT(StressSeed) ?\n-      static_cast<uint>(Ticks::now().nanoseconds()) : StressSeed;\n+    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && RepeatCompilation)) {\n+      _stress_seed = static_cast<uint>(Ticks::now().nanoseconds());\n+      FLAG_SET_ERGO(StressSeed, _stress_seed);\n+    } else {\n+      _stress_seed = StressSeed;\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -594,1 +594,3 @@\n-    return inline_encodeISOArray();\n+    return inline_encodeISOArray(false);\n+  case vmIntrinsics::_encodeAsciiArray:\n+    return inline_encodeISOArray(true);\n@@ -4889,2 +4891,2 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1\n-bool LibraryCallKit::inline_encodeISOArray() {\n+\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n+bool LibraryCallKit::inline_encodeISOArray(bool ascii) {\n@@ -4925,1 +4927,1 @@\n-  Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length);\n+  Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length, ascii);\n@@ -6796,0 +6798,12 @@\n+  ciKlass* klass = ciTypeArrayKlass::make(T_LONG);\n+  Node* klass_node = makecon(TypeKlassPtr::make(klass));\n+\n+  \/\/ htbl entries is set to 96 only fox x86-64\n+  if (Matcher::htbl_entries == -1) return false;\n+\n+  \/\/ new array to hold 48 computed htbl entries\n+  Node* subkeyHtbl_48_entries = new_array(klass_node, intcon(Matcher::htbl_entries), 0);\n+  if (subkeyHtbl_48_entries == NULL) return false;\n+\n+  Node* subkeyHtbl_48_entries_start = array_element_address(subkeyHtbl_48_entries, intcon(0), T_LONG);\n+\n@@ -6800,1 +6814,1 @@\n-                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n+                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, subkeyHtbl_48_entries_start, cnt_start);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-  bool inline_encodeISOArray();\n+  bool inline_encodeISOArray(bool ascii);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}