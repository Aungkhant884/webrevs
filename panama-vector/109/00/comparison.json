{"files":[{"patch":"@@ -808,0 +808,6 @@\n+                @Override\n+                @ForceInline\n+                public boolean isDirect(ByteBuffer bb) {\n+                    return !(bb instanceof HeapByteBuffer);\n+                }\n+\n@@ -818,0 +824,1 @@\n+                @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,6 @@\n+    \/**\n+     * Check if {@link ByteBuffer} is direct, used by Panama. Consider moving this as Buffer API.\n+     * It's better, avoids polymorphism and takes from immutable mem, easier for loop unswitch\n+     *\/\n+    boolean isDirect(ByteBuffer bb);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -379,0 +380,5 @@\n+    @ForceInline\n+    public static boolean isDirect(ByteBuffer bb) {\n+      return BufferAccess.NIO_ACCESS.isDirect(bb);\n+    }\n+\n@@ -387,1 +393,1 @@\n-    V loadFromByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n+    V loadFromByteBuffer(boolean isDirectBuff, Class<? extends V> vmClass, Class<E> e, int length,\n@@ -393,0 +399,1 @@\n+                    isDirectBuff,\n@@ -407,1 +414,1 @@\n-    V loadFromByteBufferScoped(ScopedMemoryAccess.Scope scope,\n+    V loadFromByteBufferScoped(boolean isDirectBuff, ScopedMemoryAccess.Scope scope,\n@@ -417,6 +424,13 @@\n-            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n-\n-            return VectorSupport.load(vmClass, e, length,\n-                      base, BufferAccess.bufferAddress(bb, offset),\n-                      bb, offset, s,\n-                      defaultImpl);\n+            if (isDirectBuff) {\n+              return VectorSupport.load(vmClass, e, length,\n+                        null,\n+                        BufferAccess.bufferAddress(bb, offset),\n+                        bb, offset, s,\n+                        defaultImpl);\n+            } else {\n+              return VectorSupport.load(vmClass, e, length,\n+                        Objects.requireNonNull(BufferAccess.bufferBase(bb)),\n+                        BufferAccess.bufferAddress(bb, offset),\n+                        bb, offset, s,\n+                        defaultImpl);\n+            }\n@@ -431,1 +445,1 @@\n-    void storeIntoByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n+    void storeIntoByteBuffer(boolean isDirectBuff, Class<? extends V> vmClass, Class<E> e, int length,\n@@ -437,0 +451,1 @@\n+                    isDirectBuff,\n@@ -451,1 +466,1 @@\n-    void storeIntoByteBufferScoped(ScopedMemoryAccess.Scope scope,\n+    void storeIntoByteBufferScoped(boolean isDirectBuff, ScopedMemoryAccess.Scope scope,\n@@ -461,7 +476,16 @@\n-            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n-\n-            VectorSupport.store(vmClass, e, length,\n-                                base, BufferAccess.bufferAddress(bb, offset),\n-                                v,\n-                                bb, offset,\n-                                defaultImpl);\n+            \/\/ Ternary over isDirectBuff can be compiled as phi\n+            if (isDirectBuff) {\n+              VectorSupport.store(vmClass, e, length,\n+                                  null,\n+                                  BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            } else {\n+              VectorSupport.store(vmClass, e, length,\n+                                  Objects.requireNonNull(BufferAccess.bufferBase(bb)),\n+                                  BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -3566,8 +3566,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        }\n@@ -3616,8 +3629,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3177,8 +3177,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        }\n@@ -3227,8 +3240,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3164,8 +3164,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        }\n@@ -3214,8 +3227,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3273,8 +3273,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        }\n@@ -3323,8 +3336,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3176,8 +3176,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        }\n@@ -3226,8 +3239,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3553,8 +3553,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        }\n@@ -3603,8 +3616,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -4521,8 +4521,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        }\n@@ -4571,8 +4584,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -91,0 +91,5 @@\n+  @Benchmark\n+  public void heapBuffersNotInlined() {\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}