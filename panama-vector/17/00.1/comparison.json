{"files":[{"patch":"@@ -2432,0 +2432,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+      case Op_VectorMaskWrapper:\n@@ -187,0 +188,1 @@\n+      case Op_VectorUnbox:\n@@ -896,1 +898,2 @@\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+      case Op_VectorMaskWrapper:\n@@ -174,0 +175,1 @@\n+      case Op_VectorUnbox:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -853,0 +853,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1000,0 +1000,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2166,0 +2166,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -928,0 +928,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1578,0 +1578,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -862,0 +862,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1032,0 +1032,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1123,0 +1123,25 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n+\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n+\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n+  }\n+\n+  return stk_args;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1371,0 +1371,14 @@\n+\/\/ Vector calling convention not supported.\n+const bool Matcher::supports_vector_calling_convention() {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1583,0 +1583,17 @@\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return true;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  int lo = XMM0_num;\n+  int hi = XMM0b_num;\n+  if (ideal_reg == Op_VecX) hi = XMM0d_num;\n+  else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n+  else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n+  return OptoRegPair(hi, lo);\n+}\n+\n@@ -12417,0 +12434,12 @@\n+\/\/ Call runtime without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf,vector \" %}\n+  ins_encode(Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -715,0 +715,3 @@\n+  product(bool, IncrementalInlineVirtual, true, DIAGNOSTIC,                 \\\n+          \"do post parse inlining of virtual calls\")                        \\\n+                                                                            \\\n@@ -755,0 +758,3 @@\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -492,0 +492,1 @@\n+          iklass->nof_nonstatic_fields(); \/\/ FIXME: iklass->_nonstatic_fields == NULL\n@@ -619,1 +620,1 @@\n-  for (JVMState* p = this; p->_caller != NULL; p = p->_caller) {\n+  for (JVMState* p = this; p != NULL; p = p->_caller) {\n@@ -722,3 +723,5 @@\n-    OptoRegPair regs = is_CallRuntime()\n-      ? match->c_return_value(ideal_reg,true)  \/\/ Calls into C runtime\n-      : match->  return_value(ideal_reg,true); \/\/ Calls into compiled Java code\n+    OptoRegPair regs = Opcode() == Op_CallLeafVector\n+      ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n+      : is_CallRuntime()\n+        ? match->c_return_value(ideal_reg,true)    \/\/ Calls into C runtime\n+        : match->return_value(ideal_reg, true);    \/\/ Calls into compiled Java code\n@@ -726,0 +729,10 @@\n+\n+    \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n+    if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(OptoReg::is_valid(regs.second())) {\n+        for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n+          rm.Insert(r);\n+        }\n+      }\n+    }\n+\n@@ -1103,0 +1116,42 @@\n+\n+Node* CallDynamicJavaNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  CallGenerator* cg = generator();\n+  if (can_reshape && cg != NULL) {\n+    assert(IncrementalInlineVirtual, \"required\");\n+    assert(cg->call_node() == this, \"mismatch\");\n+    assert(cg->is_virtual_late_inline(), \"not virtual\");\n+\n+    \/\/ Recover symbolic info for method resolution\n+    ciMethod* caller = jvms()->method();\n+    ciBytecodeStream iter(caller);\n+    iter.force_bci(jvms()->bci());\n+\n+    bool             not_used1;\n+    ciSignature*     not_used2;\n+    ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+    ciKlass*         holder       = iter.get_declared_method_holder();\n+    if (orig_callee->is_method_handle_intrinsic()) {\n+      assert(_override_symbolic_info, \"\");\n+      orig_callee = method();\n+      holder = method()->holder();\n+    }\n+\n+    ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+\n+    Node* receiver_node = in(TypeFunc::Parms);\n+    const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+\n+    int  not_used3;\n+    bool call_does_dispatch;\n+    ciMethod* callee = phase->C->optimize_virtual_call(caller, jvms()->bci(), klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                       call_does_dispatch, not_used3);  \/\/ out-parameters\n+    if (!call_does_dispatch) {\n+      \/\/ Register for late inlining\n+      cg->set_callee_method(callee);\n+      phase->C->prepend_late_inline(cg); \/\/ TODO prepend or append for virtual calls? MH late inlining prepends to the list.\n+      set_generator(NULL);\n+    }\n+  }\n+  return CallNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1123,0 +1178,5 @@\n+uint CallLeafVectorNode::size_of() const { return sizeof(*this); }\n+bool CallLeafVectorNode::cmp( const Node &n ) const {\n+  CallLeafVectorNode &call = (CallLeafVectorNode&)n;\n+  return CallLeafNode::cmp(call) && _num_bits == call._num_bits;\n+}\n@@ -1129,0 +1189,15 @@\n+void CallLeafVectorNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+#ifdef ASSERT\n+  assert(tf()->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+         \"return vector size must match\");\n+  const TypeTuple* d = tf()->domain();\n+  for (uint i = TypeFunc::Parms; i < d->cnt(); i++) {\n+    Node* arg = in(i);\n+    assert(arg->bottom_type()->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+           \"vector argument size must match\");\n+  }\n+#endif\n+\n+  Matcher::vector_calling_convention(parm_regs, _num_bits, argcnt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":79,"deletions":4,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+class         CallLeafVectorNode;\n@@ -616,1 +617,1 @@\n-    if (C->needs_clone_jvms() && jvms() != NULL) {\n+    if (jvms() != NULL) {\n@@ -772,0 +773,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -780,0 +782,1 @@\n+protected:\n@@ -830,0 +833,18 @@\n+\/\/------------------------------CallLeafVectorNode-------------------------------\n+\/\/ CallLeafNode but calling with vector calling convention instead.\n+class CallLeafVectorNode : public CallLeafNode {\n+private:\n+  uint _num_bits;\n+protected:\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallLeafVectorNode(const TypeFunc* tf, address addr, const char* name,\n+                   const TypePtr* adr_type, uint num_bits)\n+    : CallLeafNode(tf, addr, name, adr_type), _num_bits(num_bits)\n+  {\n+  }\n+  virtual int   Opcode() const;\n+  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -349,0 +349,17 @@\n+void Compile::remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead) {\n+  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  int shift = 0;\n+  for (int i = 0; i < inlines->length(); i++) {\n+    CallGenerator* cg = inlines->at(i);\n+    CallNode* call = cg->call_node();\n+    if (shift > 0) {\n+      inlines->at_put(i - shift, cg);\n+    }\n+    if (call == dead) {\n+      shift++;\n+    }\n+  }\n+  inlines->trunc_to(inlines->length() - shift);\n+  assert(shift <= 1, \"sanity\");\n+}\n+\n@@ -1860,0 +1877,1 @@\n+\n@@ -1862,2 +1880,2 @@\n-  int i = 0;\n-  for (; i <_late_inlines.length() && !inlining_progress(); i++) {\n+\n+  for (int i = 0; i < _late_inlines.length(); i++) {\n@@ -1866,0 +1884,1 @@\n+    assert(inlining_incrementally() || cg->is_virtual_late_inline(), \"no inlining allowed\");\n@@ -1867,5 +1886,8 @@\n-    if (failing())  return false;\n-  }\n-  int j = 0;\n-  for (; i < _late_inlines.length(); i++, j++) {\n-    _late_inlines.at_put(j, _late_inlines.at(i));\n+    assert(_late_inlines.at(i) == cg, \"no insertions before current position allowed\");\n+    if (failing()) {\n+      return false;\n+    } else if (inlining_progress()) {\n+      _late_inlines_pos = i+1; \/\/ restore the position in case new elements were inserted\n+      print_method(PHASE_INCREMENTAL_INLINE_STEP, cg->call_node(), 3);\n+      break; \/\/ process one call site at a time\n+    }\n@@ -1873,2 +1895,5 @@\n-  _late_inlines.trunc_to(j);\n-  assert(inlining_progress() || _late_inlines.length() == 0, \"\");\n+  \/\/ Remove processed elements.\n+  _late_inlines.truncate_to(_late_inlines_pos);\n+  _late_inlines_pos = 0;\n+\n+  assert(inlining_progress() || _late_inlines.length() == 0, \"no progress\");\n@@ -1880,0 +1905,1 @@\n+\n@@ -1894,0 +1920,1 @@\n+  print_method(PHASE_INCREMENTAL_INLINE_CLEANUP, 3);\n@@ -1935,0 +1962,4 @@\n+\n+    if (_late_inlines.length() == 0) {\n+      break; \/\/ no more progress\n+    }\n@@ -2081,1 +2112,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2091,1 +2123,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2233,0 +2265,25 @@\n+\n+  assert(_late_inlines.length() == 0 || IncrementalInlineVirtual, \"not empty\");\n+\n+  while (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual calls.\n+    \/\/ Though it's maybe too late for inlining, strength-reducing them to direct calls is still an option.\n+\n+    \/\/ \"inlining_incrementally() == false\" is used to signal that no inlining is allowed.\n+    \/\/ Tracking and verification of modified nodes is disabled by _modified_nodes == NULL as if inlining_incrementally() were set.\n+    assert(inlining_incrementally() == false, \"not allowed\");\n+\n+    for_igvn()->clear();\n+    initial_gvn()->replace_with(&igvn);\n+\n+    DEBUG_ONLY( int late_inlines_before = _late_inlines.length(); )\n+\n+    while (inline_incrementally_one()) {\n+      assert(!failing(), \"inconsistent\");\n+    }\n+    if (failing())  return;\n+\n+    inline_incrementally_cleanup(igvn);\n+\n+    assert(_late_inlines.length() < late_inlines_before, \"no progress\");\n+  }\n@@ -2907,0 +2964,1 @@\n+  case Op_CallLeafVector:\n@@ -3258,3 +3316,4 @@\n-    if (OptimizeStringConcat) {\n-      ProjNode* p = n->as_Proj();\n-      if (p->_is_io_use) {\n+    if (OptimizeStringConcat || IncrementalInline || IncrementalInlineVirtual) {\n+      ProjNode* proj = n->as_Proj();\n+      if (proj->_is_io_use) {\n+        assert(proj->_con == TypeFunc::I_O || proj->_con == TypeFunc::Memory, \"\");\n@@ -3264,13 +3323,4 @@\n-        \/\/ the original one.\n-        Node* proj = NULL;\n-        \/\/ Replace with just one\n-        for (SimpleDUIterator i(p->in(0)); i.has_next(); i.next()) {\n-          Node *use = i.get();\n-          if (use->is_Proj() && p != use && use->as_Proj()->_con == p->_con) {\n-            proj = use;\n-            break;\n-          }\n-        }\n-        assert(proj != NULL || p->_con == TypeFunc::I_O, \"io may be dropped at an infinite loop\");\n-        if (proj != NULL) {\n-          p->subsume_by(proj, this);\n+        \/\/ the original one. Merge them.\n+        Node* non_io_proj = proj->in(0)->as_Multi()->proj_out_or_null(proj->_con, false \/*is_io_use*\/);\n+        if (non_io_proj  != NULL) {\n+          proj->subsume_by(non_io_proj , this);\n@@ -4132,1 +4182,1 @@\n-    if (!cg->is_late_inline()) {\n+    if (!cg->is_late_inline() && !cg->is_virtual_late_inline()) {\n@@ -4186,1 +4236,3 @@\n-        const char* msg = \"live nodes > LiveNodeCountInliningCutoff\";\n+        bool is_virtual = cg->is_virtual_late_inline();\n+        const char* msg = (is_virtual ? \"virtual call\"\n+                                      : \"live nodes > LiveNodeCountInliningCutoff\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":81,"deletions":29,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -945,0 +945,1 @@\n+  void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1017,0 +1017,1 @@\n+    case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1353,2 +1353,4 @@\n-      if( !parm_regs[i].first()->is_valid() &&\n-          !parm_regs[i].second()->is_valid() ) {\n+      VMReg first = parm_regs[i].first();\n+      VMReg second = parm_regs[i].second();\n+      if( !first->is_valid() &&\n+          !second->is_valid() ) {\n@@ -1357,0 +1359,9 @@\n+      \/\/ Handle case where arguments are in vector registers.\n+      if(call->in(TypeFunc::Parms + i)->bottom_type()->isa_vect()) {\n+        OptoReg::Name reg_fst = OptoReg::as_OptoReg(first);\n+        OptoReg::Name reg_snd = OptoReg::as_OptoReg(second);\n+        assert (reg_fst <= reg_snd, \"fst=%d snd=%d\", reg_fst, reg_snd);\n+        for (OptoReg::Name r = reg_fst; r <= reg_snd; r++) {\n+          rm->Insert(r);\n+        }\n+      }\n@@ -1358,1 +1369,1 @@\n-      OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg1 = warp_outgoing_stk_arg(first, begin_out_arg_area, out_arg_limit_per_call );\n@@ -1362,1 +1373,1 @@\n-      OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg2 = warp_outgoing_stk_arg(second, begin_out_arg_area, out_arg_limit_per_call );\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -436,0 +436,7 @@\n+  \/\/ Java-Native vector calling convention\n+  static const bool supports_vector_calling_convention();\n+  static void vector_calling_convention(VMRegPair *regs,\n+                                        uint num_bits,\n+                                        uint total_args_passed);\n+  static OptoRegPair vector_return_value(uint ideal_reg);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/callGenerator.hpp\"\n@@ -557,1 +558,1 @@\n-  \/\/ cloning CallNode may need to clone JVMState\n+    \/\/ cloning CallNode may need to clone JVMState\n@@ -560,0 +561,6 @@\n+    \/\/ CallGenerator is linked to the original node.\n+    CallGenerator* cg = n->as_Call()->generator();\n+    if (cg != NULL) {\n+      CallGenerator* cloned_cg = cg->with_call_node(n->as_Call());\n+      n->as_Call()->set_generator(cloned_cg);\n+    }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1105,4 +1105,6 @@\n-  while (modified_list->size()) {\n-    Node* n = modified_list->pop();\n-    n->dump();\n-    assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+  if (modified_list != NULL) {\n+    while (modified_list->size()) {\n+      Node* n = modified_list->pop();\n+      n->dump();\n+      assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -664,0 +664,19 @@\n+const TypeFunc *OptoRuntime::Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type) {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(num_arg);\n+  \/\/ Symbol* name of class to be loaded\n+  assert(num_arg > 0, \"must have at least 1 input\");\n+  for (uint i = 0; i < num_arg; i++) {\n+    fields[TypeFunc::Parms+i] = in_type;\n+  }\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+num_arg, fields);\n+\n+  \/\/ create result type (range)\n+  const uint num_ret = 1;\n+  fields = TypeTuple::fields(num_ret);\n+  fields[TypeFunc::Parms+0] = out_type;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+num_ret, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -262,0 +262,1 @@\n+  static const TypeFunc* Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -222,0 +222,15 @@\n+  if (opc == Op_CallLeafVector) {\n+    if (!UseVectorStubs) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector stubs support is disabled\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::supports_vector_calling_convention()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** no vector calling conventions supported\");\n+      }\n+      return false;\n+    }\n+  }\n+\n@@ -271,10 +286,22 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  switch (n) {\n-    case 1:\n-    case 2: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n-      break;\n-    }\n-    case 3: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n-      break;\n+  if (sopc == Op_CallLeafVector) {\n+    assert(UseVectorStubs, \"sanity\");\n+    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    if (operation == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** svml call failed\");\n+      }\n+      return false;\n+     }\n+  } else {\n+    const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+    switch (n) {\n+      case 1:\n+      case 2: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n+        break;\n+      }\n+      case 3: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n+        break;\n+      }\n+      default: fatal(\"unsupported arity: %d\", n);\n@@ -282,1 +309,0 @@\n-    default: fatal(\"unsupported arity: %d\", n);\n@@ -648,1 +674,5 @@\n-      val = gvn().transform(new VectorReinterpretNode(val, val->bottom_type()->is_vect(), to_vect_type));\n+      if (arch_supports_vector(Op_VectorReinterpret, num_elem, T_BYTE, VecMaskNotUsed)) {\n+        val = gvn().transform(new VectorReinterpretNode(val, val->bottom_type()->is_vect(), to_vect_type));\n+      } else {\n+        return false;\n+      }\n@@ -660,1 +690,5 @@\n-      vload = gvn().transform(new VectorReinterpretNode(vload, vload->bottom_type()->is_vect(), to_vect_type));\n+      if (arch_supports_vector(Op_VectorReinterpret, num_elem, T_BYTE, VecMaskNotUsed)) {\n+        vload = gvn().transform(new VectorReinterpretNode(vload, vload->bottom_type()->is_vect(), to_vect_type));\n+      } else {\n+        return false;\n+      }\n@@ -1173,0 +1207,417 @@\n+static void get_svml_address(int op, int bits, BasicType bt, const char** name_ptr, address* addr_ptr) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(name_ptr != NULL, \"unexpected\");\n+  assert(addr_ptr != NULL, \"unexpected\");\n+\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Since the addresses are resolved at runtime, using switch instead of table - otherwise might get NULL addresses.\n+  if (bt == T_FLOAT) {\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_float64\";  *addr_ptr = StubRoutines::vector_exp_float64();  break;\n+            case 128: *name_ptr = \"vector_exp_float128\"; *addr_ptr = StubRoutines::vector_exp_float128(); break;\n+            case 256: *name_ptr = \"vector_exp_float256\"; *addr_ptr = StubRoutines::vector_exp_float256(); break;\n+            case 512: *name_ptr = \"vector_exp_float512\"; *addr_ptr = StubRoutines::vector_exp_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_float64\";  *addr_ptr = StubRoutines::vector_log1p_float64();  break;\n+            case 128: *name_ptr = \"vector_log1p_float128\"; *addr_ptr = StubRoutines::vector_log1p_float128(); break;\n+            case 256: *name_ptr = \"vector_log1p_float256\"; *addr_ptr = StubRoutines::vector_log1p_float256(); break;\n+            case 512: *name_ptr = \"vector_log1p_float512\"; *addr_ptr = StubRoutines::vector_log1p_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_float64\";  *addr_ptr = StubRoutines::vector_log_float64();  break;\n+            case 128: *name_ptr = \"vector_log_float128\"; *addr_ptr = StubRoutines::vector_log_float128(); break;\n+            case 256: *name_ptr = \"vector_log_float256\"; *addr_ptr = StubRoutines::vector_log_float256(); break;\n+            case 512: *name_ptr = \"vector_log_float512\"; *addr_ptr = StubRoutines::vector_log_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_float64\";  *addr_ptr = StubRoutines::vector_log10_float64();  break;\n+            case 128: *name_ptr = \"vector_log10_float128\"; *addr_ptr = StubRoutines::vector_log10_float128(); break;\n+            case 256: *name_ptr = \"vector_log10_float256\"; *addr_ptr = StubRoutines::vector_log10_float256(); break;\n+            case 512: *name_ptr = \"vector_log10_float512\"; *addr_ptr = StubRoutines::vector_log10_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_float64\";  *addr_ptr = StubRoutines::vector_expm1_float64();  break;\n+            case 128: *name_ptr = \"vector_expm1_float128\"; *addr_ptr = StubRoutines::vector_expm1_float128(); break;\n+            case 256: *name_ptr = \"vector_expm1_float256\"; *addr_ptr = StubRoutines::vector_expm1_float256(); break;\n+            case 512: *name_ptr = \"vector_expm1_float512\"; *addr_ptr = StubRoutines::vector_expm1_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_float64\";  *addr_ptr = StubRoutines::vector_sin_float64();  break;\n+            case 128: *name_ptr = \"vector_sin_float128\"; *addr_ptr = StubRoutines::vector_sin_float128(); break;\n+            case 256: *name_ptr = \"vector_sin_float256\"; *addr_ptr = StubRoutines::vector_sin_float256(); break;\n+            case 512: *name_ptr = \"vector_sin_float512\"; *addr_ptr = StubRoutines::vector_sin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_float64\";  *addr_ptr = StubRoutines::vector_cos_float64();  break;\n+            case 128: *name_ptr = \"vector_cos_float128\"; *addr_ptr = StubRoutines::vector_cos_float128(); break;\n+            case 256: *name_ptr = \"vector_cos_float256\"; *addr_ptr = StubRoutines::vector_cos_float256(); break;\n+            case 512: *name_ptr = \"vector_cos_float512\"; *addr_ptr = StubRoutines::vector_cos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_float64\";  *addr_ptr = StubRoutines::vector_tan_float64();  break;\n+            case 128: *name_ptr = \"vector_tan_float128\"; *addr_ptr = StubRoutines::vector_tan_float128(); break;\n+            case 256: *name_ptr = \"vector_tan_float256\"; *addr_ptr = StubRoutines::vector_tan_float256(); break;\n+            case 512: *name_ptr = \"vector_tan_float512\"; *addr_ptr = StubRoutines::vector_tan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_float64\";  *addr_ptr = StubRoutines::vector_sinh_float64();  break;\n+            case 128: *name_ptr = \"vector_sinh_float128\"; *addr_ptr = StubRoutines::vector_sinh_float128(); break;\n+            case 256: *name_ptr = \"vector_sinh_float256\"; *addr_ptr = StubRoutines::vector_sinh_float256(); break;\n+            case 512: *name_ptr = \"vector_sinh_float512\"; *addr_ptr = StubRoutines::vector_sinh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_float64\";  *addr_ptr = StubRoutines::vector_cosh_float64();  break;\n+            case 128: *name_ptr = \"vector_cosh_float128\"; *addr_ptr = StubRoutines::vector_cosh_float128(); break;\n+            case 256: *name_ptr = \"vector_cosh_float256\"; *addr_ptr = StubRoutines::vector_cosh_float256(); break;\n+            case 512: *name_ptr = \"vector_cosh_float512\"; *addr_ptr = StubRoutines::vector_cosh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_float64\";  *addr_ptr = StubRoutines::vector_tanh_float64();  break;\n+            case 128: *name_ptr = \"vector_tanh_float128\"; *addr_ptr = StubRoutines::vector_tanh_float128(); break;\n+            case 256: *name_ptr = \"vector_tanh_float256\"; *addr_ptr = StubRoutines::vector_tanh_float256(); break;\n+            case 512: *name_ptr = \"vector_tanh_float512\"; *addr_ptr = StubRoutines::vector_tanh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_float64\";  *addr_ptr = StubRoutines::vector_asin_float64();  break;\n+            case 128: *name_ptr = \"vector_asin_float128\"; *addr_ptr = StubRoutines::vector_asin_float128(); break;\n+            case 256: *name_ptr = \"vector_asin_float256\"; *addr_ptr = StubRoutines::vector_asin_float256(); break;\n+            case 512: *name_ptr = \"vector_asin_float512\"; *addr_ptr = StubRoutines::vector_asin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_float64\";  *addr_ptr = StubRoutines::vector_acos_float64();  break;\n+            case 128: *name_ptr = \"vector_acos_float128\"; *addr_ptr = StubRoutines::vector_acos_float128(); break;\n+            case 256: *name_ptr = \"vector_acos_float256\"; *addr_ptr = StubRoutines::vector_acos_float256(); break;\n+            case 512: *name_ptr = \"vector_acos_float512\"; *addr_ptr = StubRoutines::vector_acos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_float64\";  *addr_ptr = StubRoutines::vector_atan_float64();  break;\n+            case 128: *name_ptr = \"vector_atan_float128\"; *addr_ptr = StubRoutines::vector_atan_float128(); break;\n+            case 256: *name_ptr = \"vector_atan_float256\"; *addr_ptr = StubRoutines::vector_atan_float256(); break;\n+            case 512: *name_ptr = \"vector_atan_float512\"; *addr_ptr = StubRoutines::vector_atan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_float64\";  *addr_ptr = StubRoutines::vector_cbrt_float64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_float128\"; *addr_ptr = StubRoutines::vector_cbrt_float128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_float256\"; *addr_ptr = StubRoutines::vector_cbrt_float256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_float512\"; *addr_ptr = StubRoutines::vector_cbrt_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+       case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_float64\";  *addr_ptr = StubRoutines::vector_hypot_float64();  break;\n+            case 128: *name_ptr = \"vector_hypot_float128\"; *addr_ptr = StubRoutines::vector_hypot_float128(); break;\n+            case 256: *name_ptr = \"vector_hypot_float256\"; *addr_ptr = StubRoutines::vector_hypot_float256(); break;\n+            case 512: *name_ptr = \"vector_hypot_float512\"; *addr_ptr = StubRoutines::vector_hypot_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_float64\";  *addr_ptr = StubRoutines::vector_pow_float64();  break;\n+            case 128: *name_ptr = \"vector_pow_float128\"; *addr_ptr = StubRoutines::vector_pow_float128(); break;\n+            case 256: *name_ptr = \"vector_pow_float256\"; *addr_ptr = StubRoutines::vector_pow_float256(); break;\n+            case 512: *name_ptr = \"vector_pow_float512\"; *addr_ptr = StubRoutines::vector_pow_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_float64\";  *addr_ptr = StubRoutines::vector_atan2_float64();  break;\n+            case 128: *name_ptr = \"vector_atan2_float128\"; *addr_ptr = StubRoutines::vector_atan2_float128(); break;\n+            case 256: *name_ptr = \"vector_atan2_float256\"; *addr_ptr = StubRoutines::vector_atan2_float256(); break;\n+            case 512: *name_ptr = \"vector_atan2_float512\"; *addr_ptr = StubRoutines::vector_atan2_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  } else {\n+    assert(bt == T_DOUBLE, \"must be FP type only\");\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_double64\";  *addr_ptr = StubRoutines::vector_exp_double64();  break;\n+            case 128: *name_ptr = \"vector_exp_double128\"; *addr_ptr = StubRoutines::vector_exp_double128(); break;\n+            case 256: *name_ptr = \"vector_exp_double256\"; *addr_ptr = StubRoutines::vector_exp_double256(); break;\n+            case 512: *name_ptr = \"vector_exp_double512\"; *addr_ptr = StubRoutines::vector_exp_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_double64\";  *addr_ptr = StubRoutines::vector_log1p_double64();  break;\n+            case 128: *name_ptr = \"vector_log1p_double128\"; *addr_ptr = StubRoutines::vector_log1p_double128(); break;\n+            case 256: *name_ptr = \"vector_log1p_double256\"; *addr_ptr = StubRoutines::vector_log1p_double256(); break;\n+            case 512: *name_ptr = \"vector_log1p_double512\"; *addr_ptr = StubRoutines::vector_log1p_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_double64\";  *addr_ptr = StubRoutines::vector_log_double64();  break;\n+            case 128: *name_ptr = \"vector_log_double128\"; *addr_ptr = StubRoutines::vector_log_double128(); break;\n+            case 256: *name_ptr = \"vector_log_double256\"; *addr_ptr = StubRoutines::vector_log_double256(); break;\n+            case 512: *name_ptr = \"vector_log_double512\"; *addr_ptr = StubRoutines::vector_log_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_double64\";  *addr_ptr = StubRoutines::vector_log10_double64();  break;\n+            case 128: *name_ptr = \"vector_log10_double128\"; *addr_ptr = StubRoutines::vector_log10_double128(); break;\n+            case 256: *name_ptr = \"vector_log10_double256\"; *addr_ptr = StubRoutines::vector_log10_double256(); break;\n+            case 512: *name_ptr = \"vector_log10_double512\"; *addr_ptr = StubRoutines::vector_log10_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_double64\";  *addr_ptr = StubRoutines::vector_expm1_double64();  break;\n+            case 128: *name_ptr = \"vector_expm1_double128\"; *addr_ptr = StubRoutines::vector_expm1_double128(); break;\n+            case 256: *name_ptr = \"vector_expm1_double256\"; *addr_ptr = StubRoutines::vector_expm1_double256(); break;\n+            case 512: *name_ptr = \"vector_expm1_double512\"; *addr_ptr = StubRoutines::vector_expm1_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_double64\";  *addr_ptr = StubRoutines::vector_sin_double64();  break;\n+            case 128: *name_ptr = \"vector_sin_double128\"; *addr_ptr = StubRoutines::vector_sin_double128(); break;\n+            case 256: *name_ptr = \"vector_sin_double256\"; *addr_ptr = StubRoutines::vector_sin_double256(); break;\n+            case 512: *name_ptr = \"vector_sin_double512\"; *addr_ptr = StubRoutines::vector_sin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_double64\";  *addr_ptr = StubRoutines::vector_cos_double64();  break;\n+            case 128: *name_ptr = \"vector_cos_double128\"; *addr_ptr = StubRoutines::vector_cos_double128(); break;\n+            case 256: *name_ptr = \"vector_cos_double256\"; *addr_ptr = StubRoutines::vector_cos_double256(); break;\n+            case 512: *name_ptr = \"vector_cos_double512\"; *addr_ptr = StubRoutines::vector_cos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_double64\";  *addr_ptr = StubRoutines::vector_tan_double64();  break;\n+            case 128: *name_ptr = \"vector_tan_double128\"; *addr_ptr = StubRoutines::vector_tan_double128(); break;\n+            case 256: *name_ptr = \"vector_tan_double256\"; *addr_ptr = StubRoutines::vector_tan_double256(); break;\n+            case 512: *name_ptr = \"vector_tan_double512\"; *addr_ptr = StubRoutines::vector_tan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_double64\";  *addr_ptr = StubRoutines::vector_sinh_double64();  break;\n+            case 128: *name_ptr = \"vector_sinh_double128\"; *addr_ptr = StubRoutines::vector_sinh_double128(); break;\n+            case 256: *name_ptr = \"vector_sinh_double256\"; *addr_ptr = StubRoutines::vector_sinh_double256(); break;\n+            case 512: *name_ptr = \"vector_sinh_double512\"; *addr_ptr = StubRoutines::vector_sinh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_double64\";  *addr_ptr = StubRoutines::vector_cosh_double64();  break;\n+            case 128: *name_ptr = \"vector_cosh_double128\"; *addr_ptr = StubRoutines::vector_cosh_double128(); break;\n+            case 256: *name_ptr = \"vector_cosh_double256\"; *addr_ptr = StubRoutines::vector_cosh_double256(); break;\n+            case 512: *name_ptr = \"vector_cosh_double512\"; *addr_ptr = StubRoutines::vector_cosh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_double64\";  *addr_ptr = StubRoutines::vector_tanh_double64();  break;\n+            case 128: *name_ptr = \"vector_tanh_double128\"; *addr_ptr = StubRoutines::vector_tanh_double128(); break;\n+            case 256: *name_ptr = \"vector_tanh_double256\"; *addr_ptr = StubRoutines::vector_tanh_double256(); break;\n+            case 512: *name_ptr = \"vector_tanh_double512\"; *addr_ptr = StubRoutines::vector_tanh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_double64\";  *addr_ptr = StubRoutines::vector_asin_double64();  break;\n+            case 128: *name_ptr = \"vector_asin_double128\"; *addr_ptr = StubRoutines::vector_asin_double128(); break;\n+            case 256: *name_ptr = \"vector_asin_double256\"; *addr_ptr = StubRoutines::vector_asin_double256(); break;\n+            case 512: *name_ptr = \"vector_asin_double512\"; *addr_ptr = StubRoutines::vector_asin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_double64\";  *addr_ptr = StubRoutines::vector_acos_double64();  break;\n+            case 128: *name_ptr = \"vector_acos_double128\"; *addr_ptr = StubRoutines::vector_acos_double128(); break;\n+            case 256: *name_ptr = \"vector_acos_double256\"; *addr_ptr = StubRoutines::vector_acos_double256(); break;\n+            case 512: *name_ptr = \"vector_acos_double512\"; *addr_ptr = StubRoutines::vector_acos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_double64\";  *addr_ptr = StubRoutines::vector_atan_double64();  break;\n+            case 128: *name_ptr = \"vector_atan_double128\"; *addr_ptr = StubRoutines::vector_atan_double128(); break;\n+            case 256: *name_ptr = \"vector_atan_double256\"; *addr_ptr = StubRoutines::vector_atan_double256(); break;\n+            case 512: *name_ptr = \"vector_atan_double512\"; *addr_ptr = StubRoutines::vector_atan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_double64\";  *addr_ptr = StubRoutines::vector_cbrt_double64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_double128\"; *addr_ptr = StubRoutines::vector_cbrt_double128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_double256\"; *addr_ptr = StubRoutines::vector_cbrt_double256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_double512\"; *addr_ptr = StubRoutines::vector_cbrt_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_double64\";  *addr_ptr = StubRoutines::vector_hypot_double64();  break;\n+            case 128: *name_ptr = \"vector_hypot_double128\"; *addr_ptr = StubRoutines::vector_hypot_double128(); break;\n+            case 256: *name_ptr = \"vector_hypot_double256\"; *addr_ptr = StubRoutines::vector_hypot_double256(); break;\n+            case 512: *name_ptr = \"vector_hypot_double512\"; *addr_ptr = StubRoutines::vector_hypot_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_double64\";  *addr_ptr = StubRoutines::vector_pow_double64();  break;\n+            case 128: *name_ptr = \"vector_pow_double128\"; *addr_ptr = StubRoutines::vector_pow_double128(); break;\n+            case 256: *name_ptr = \"vector_pow_double256\"; *addr_ptr = StubRoutines::vector_pow_double256(); break;\n+            case 512: *name_ptr = \"vector_pow_double512\"; *addr_ptr = StubRoutines::vector_pow_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_double64\";  *addr_ptr = StubRoutines::vector_atan2_double64();  break;\n+            case 128: *name_ptr = \"vector_atan2_double128\"; *addr_ptr = StubRoutines::vector_atan2_double128(); break;\n+            case 256: *name_ptr = \"vector_atan2_double256\"; *addr_ptr = StubRoutines::vector_atan2_double256(); break;\n+            case 512: *name_ptr = \"vector_atan2_double512\"; *addr_ptr = StubRoutines::vector_atan2_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  }\n+#else\n+  *name_ptr = \"invalid\";\n+  *addr_ptr = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+}\n+\n+Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(opd1 != NULL, \"must not be null\");\n+  const TypeVect* vt = TypeVect::make(bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != NULL ? 2 : 1, vt, vt);\n+  const char* name = NULL;\n+  address addr = NULL;\n+\n+  \/\/ Get address for svml method.\n+  get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, &name, &addr);\n+\n+  if (addr == NULL) {\n+    return NULL;\n+  }\n+\n+  assert(name != NULL, \"name must not be null\");\n+  Node* operation = make_runtime_call(RC_VECTOR,\n+                                      call_type,\n+                                      addr,\n+                                      name,\n+                                      TypePtr::BOTTOM,\n+                                      opd1,\n+                                      opd2);\n+  return _gvn.transform(new ProjNode(_gvn.transform(operation), TypeFunc::Parms));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":464,"deletions":13,"binary":false,"changes":477,"status":"modified"},{"patch":"@@ -4232,0 +4232,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+  static int vector_calling_convention(VMRegPair *regs,\n+                                       uint num_bits,\n+                                       uint total_args_passed);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,0 +187,147 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+address StubRoutines::_vector_exp_float64                = NULL;\n+address StubRoutines::_vector_exp_float128               = NULL;\n+address StubRoutines::_vector_exp_float256               = NULL;\n+address StubRoutines::_vector_exp_float512               = NULL;\n+address StubRoutines::_vector_exp_double64               = NULL;\n+address StubRoutines::_vector_exp_double128              = NULL;\n+address StubRoutines::_vector_exp_double256              = NULL;\n+address StubRoutines::_vector_exp_double512              = NULL;\n+address StubRoutines::_vector_expm1_float64              = NULL;\n+address StubRoutines::_vector_expm1_float128             = NULL;\n+address StubRoutines::_vector_expm1_float256             = NULL;\n+address StubRoutines::_vector_expm1_float512             = NULL;\n+address StubRoutines::_vector_expm1_double64             = NULL;\n+address StubRoutines::_vector_expm1_double128            = NULL;\n+address StubRoutines::_vector_expm1_double256            = NULL;\n+address StubRoutines::_vector_expm1_double512            = NULL;\n+address StubRoutines::_vector_log1p_float64              = NULL;\n+address StubRoutines::_vector_log1p_float128             = NULL;\n+address StubRoutines::_vector_log1p_float256             = NULL;\n+address StubRoutines::_vector_log1p_float512             = NULL;\n+address StubRoutines::_vector_log1p_double64             = NULL;\n+address StubRoutines::_vector_log1p_double128            = NULL;\n+address StubRoutines::_vector_log1p_double256            = NULL;\n+address StubRoutines::_vector_log1p_double512            = NULL;\n+address StubRoutines::_vector_log_float64                = NULL;\n+address StubRoutines::_vector_log_float128               = NULL;\n+address StubRoutines::_vector_log_float256               = NULL;\n+address StubRoutines::_vector_log_float512               = NULL;\n+address StubRoutines::_vector_log_double64               = NULL;\n+address StubRoutines::_vector_log_double128              = NULL;\n+address StubRoutines::_vector_log_double256              = NULL;\n+address StubRoutines::_vector_log_double512              = NULL;\n+address StubRoutines::_vector_log10_float64              = NULL;\n+address StubRoutines::_vector_log10_float128             = NULL;\n+address StubRoutines::_vector_log10_float256             = NULL;\n+address StubRoutines::_vector_log10_float512             = NULL;\n+address StubRoutines::_vector_log10_double64             = NULL;\n+address StubRoutines::_vector_log10_double128            = NULL;\n+address StubRoutines::_vector_log10_double256            = NULL;\n+address StubRoutines::_vector_log10_double512            = NULL;\n+address StubRoutines::_vector_sin_float64                = NULL;\n+address StubRoutines::_vector_sin_float128               = NULL;\n+address StubRoutines::_vector_sin_float256               = NULL;\n+address StubRoutines::_vector_sin_float512               = NULL;\n+address StubRoutines::_vector_sin_double64               = NULL;\n+address StubRoutines::_vector_sin_double128              = NULL;\n+address StubRoutines::_vector_sin_double256              = NULL;\n+address StubRoutines::_vector_sin_double512              = NULL;\n+address StubRoutines::_vector_cos_float64                = NULL;\n+address StubRoutines::_vector_cos_float128               = NULL;\n+address StubRoutines::_vector_cos_float256               = NULL;\n+address StubRoutines::_vector_cos_float512               = NULL;\n+address StubRoutines::_vector_cos_double64               = NULL;\n+address StubRoutines::_vector_cos_double128              = NULL;\n+address StubRoutines::_vector_cos_double256              = NULL;\n+address StubRoutines::_vector_cos_double512              = NULL;\n+address StubRoutines::_vector_tan_float64                = NULL;\n+address StubRoutines::_vector_tan_float128               = NULL;\n+address StubRoutines::_vector_tan_float256               = NULL;\n+address StubRoutines::_vector_tan_float512               = NULL;\n+address StubRoutines::_vector_tan_double64               = NULL;\n+address StubRoutines::_vector_tan_double128              = NULL;\n+address StubRoutines::_vector_tan_double256              = NULL;\n+address StubRoutines::_vector_tan_double512              = NULL;\n+address StubRoutines::_vector_sinh_float64               = NULL;\n+address StubRoutines::_vector_sinh_float128               = NULL;\n+address StubRoutines::_vector_sinh_float256               = NULL;\n+address StubRoutines::_vector_sinh_float512               = NULL;\n+address StubRoutines::_vector_sinh_double64               = NULL;\n+address StubRoutines::_vector_sinh_double128              = NULL;\n+address StubRoutines::_vector_sinh_double256              = NULL;\n+address StubRoutines::_vector_sinh_double512              = NULL;\n+address StubRoutines::_vector_cosh_float64                = NULL;\n+address StubRoutines::_vector_cosh_float128               = NULL;\n+address StubRoutines::_vector_cosh_float256               = NULL;\n+address StubRoutines::_vector_cosh_float512               = NULL;\n+address StubRoutines::_vector_cosh_double64               = NULL;\n+address StubRoutines::_vector_cosh_double128              = NULL;\n+address StubRoutines::_vector_cosh_double256              = NULL;\n+address StubRoutines::_vector_cosh_double512              = NULL;\n+address StubRoutines::_vector_tanh_float64                = NULL;\n+address StubRoutines::_vector_tanh_float128               = NULL;\n+address StubRoutines::_vector_tanh_float256               = NULL;\n+address StubRoutines::_vector_tanh_float512               = NULL;\n+address StubRoutines::_vector_tanh_double64               = NULL;\n+address StubRoutines::_vector_tanh_double128              = NULL;\n+address StubRoutines::_vector_tanh_double256              = NULL;\n+address StubRoutines::_vector_tanh_double512              = NULL;\n+address StubRoutines::_vector_acos_float64                = NULL;\n+address StubRoutines::_vector_acos_float128               = NULL;\n+address StubRoutines::_vector_acos_float256               = NULL;\n+address StubRoutines::_vector_acos_float512               = NULL;\n+address StubRoutines::_vector_acos_double64               = NULL;\n+address StubRoutines::_vector_acos_double128              = NULL;\n+address StubRoutines::_vector_acos_double256              = NULL;\n+address StubRoutines::_vector_acos_double512              = NULL;\n+address StubRoutines::_vector_asin_float64                = NULL;\n+address StubRoutines::_vector_asin_float128               = NULL;\n+address StubRoutines::_vector_asin_float256               = NULL;\n+address StubRoutines::_vector_asin_float512               = NULL;\n+address StubRoutines::_vector_asin_double64               = NULL;\n+address StubRoutines::_vector_asin_double128              = NULL;\n+address StubRoutines::_vector_asin_double256              = NULL;\n+address StubRoutines::_vector_asin_double512              = NULL;\n+address StubRoutines::_vector_atan_float64                = NULL;\n+address StubRoutines::_vector_atan_float128               = NULL;\n+address StubRoutines::_vector_atan_float256               = NULL;\n+address StubRoutines::_vector_atan_float512               = NULL;\n+address StubRoutines::_vector_atan_double64               = NULL;\n+address StubRoutines::_vector_atan_double128              = NULL;\n+address StubRoutines::_vector_atan_double256              = NULL;\n+address StubRoutines::_vector_atan_double512              = NULL;\n+address StubRoutines::_vector_pow_float64                 = NULL;\n+address StubRoutines::_vector_pow_float128                = NULL;\n+address StubRoutines::_vector_pow_float256                = NULL;\n+address StubRoutines::_vector_pow_float512                = NULL;\n+address StubRoutines::_vector_pow_double64                = NULL;\n+address StubRoutines::_vector_pow_double128               = NULL;\n+address StubRoutines::_vector_pow_double256               = NULL;\n+address StubRoutines::_vector_pow_double512               = NULL;\n+address StubRoutines::_vector_hypot_float64               = NULL;\n+address StubRoutines::_vector_hypot_float128              = NULL;\n+address StubRoutines::_vector_hypot_float256              = NULL;\n+address StubRoutines::_vector_hypot_float512              = NULL;\n+address StubRoutines::_vector_hypot_double64              = NULL;\n+address StubRoutines::_vector_hypot_double128             = NULL;\n+address StubRoutines::_vector_hypot_double256             = NULL;\n+address StubRoutines::_vector_hypot_double512             = NULL;\n+address StubRoutines::_vector_cbrt_float64                = NULL;\n+address StubRoutines::_vector_cbrt_float128               = NULL;\n+address StubRoutines::_vector_cbrt_float256               = NULL;\n+address StubRoutines::_vector_cbrt_float512               = NULL;\n+address StubRoutines::_vector_cbrt_double64               = NULL;\n+address StubRoutines::_vector_cbrt_double128              = NULL;\n+address StubRoutines::_vector_cbrt_double256              = NULL;\n+address StubRoutines::_vector_cbrt_double512              = NULL;\n+address StubRoutines::_vector_atan2_float64               = NULL;\n+address StubRoutines::_vector_atan2_float128              = NULL;\n+address StubRoutines::_vector_atan2_float256              = NULL;\n+address StubRoutines::_vector_atan2_float512              = NULL;\n+address StubRoutines::_vector_atan2_double64              = NULL;\n+address StubRoutines::_vector_atan2_double128             = NULL;\n+address StubRoutines::_vector_atan2_double256             = NULL;\n+address StubRoutines::_vector_atan2_double512             = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -270,0 +270,166 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Vector Math Routines\n+  static address _vector_exp_float64;\n+  static address _vector_exp_float128;\n+  static address _vector_exp_float256;\n+  static address _vector_exp_float512;\n+  static address _vector_exp_double64;\n+  static address _vector_exp_double128;\n+  static address _vector_exp_double256;\n+  static address _vector_exp_double512;\n+\n+  static address _vector_expm1_float64;\n+  static address _vector_expm1_float128;\n+  static address _vector_expm1_float256;\n+  static address _vector_expm1_float512;\n+  static address _vector_expm1_double64;\n+  static address _vector_expm1_double128;\n+  static address _vector_expm1_double256;\n+  static address _vector_expm1_double512;\n+\n+  static address _vector_log1p_float64;\n+  static address _vector_log1p_float128;\n+  static address _vector_log1p_float256;\n+  static address _vector_log1p_float512;\n+  static address _vector_log1p_double64;\n+  static address _vector_log1p_double128;\n+  static address _vector_log1p_double256;\n+  static address _vector_log1p_double512;\n+\n+  static address _vector_log_float64;\n+  static address _vector_log_float128;\n+  static address _vector_log_float256;\n+  static address _vector_log_float512;\n+  static address _vector_log_double64;\n+  static address _vector_log_double128;\n+  static address _vector_log_double256;\n+  static address _vector_log_double512;\n+\n+  static address _vector_log10_float64;\n+  static address _vector_log10_float128;\n+  static address _vector_log10_float256;\n+  static address _vector_log10_float512;\n+  static address _vector_log10_double64;\n+  static address _vector_log10_double128;\n+  static address _vector_log10_double256;\n+  static address _vector_log10_double512;\n+\n+  static address _vector_sin_float64;\n+  static address _vector_sin_float128;\n+  static address _vector_sin_float256;\n+  static address _vector_sin_float512;\n+  static address _vector_sin_double64;\n+  static address _vector_sin_double128;\n+  static address _vector_sin_double256;\n+  static address _vector_sin_double512;\n+\n+  static address _vector_cos_float64;\n+  static address _vector_cos_float128;\n+  static address _vector_cos_float256;\n+  static address _vector_cos_float512;\n+  static address _vector_cos_double64;\n+  static address _vector_cos_double128;\n+  static address _vector_cos_double256;\n+  static address _vector_cos_double512;\n+\n+  static address _vector_tan_float64;\n+  static address _vector_tan_float128;\n+  static address _vector_tan_float256;\n+  static address _vector_tan_float512;\n+  static address _vector_tan_double64;\n+  static address _vector_tan_double128;\n+  static address _vector_tan_double256;\n+  static address _vector_tan_double512;\n+\n+  static address _vector_sinh_float64;\n+  static address _vector_sinh_float128;\n+  static address _vector_sinh_float256;\n+  static address _vector_sinh_float512;\n+  static address _vector_sinh_double64;\n+  static address _vector_sinh_double128;\n+  static address _vector_sinh_double256;\n+  static address _vector_sinh_double512;\n+\n+  static address _vector_cosh_float64;\n+  static address _vector_cosh_float128;\n+  static address _vector_cosh_float256;\n+  static address _vector_cosh_float512;\n+  static address _vector_cosh_double64;\n+  static address _vector_cosh_double128;\n+  static address _vector_cosh_double256;\n+  static address _vector_cosh_double512;\n+\n+  static address _vector_tanh_float64;\n+  static address _vector_tanh_float128;\n+  static address _vector_tanh_float256;\n+  static address _vector_tanh_float512;\n+  static address _vector_tanh_double64;\n+  static address _vector_tanh_double128;\n+  static address _vector_tanh_double256;\n+  static address _vector_tanh_double512;\n+\n+  static address _vector_acos_float64;\n+  static address _vector_acos_float128;\n+  static address _vector_acos_float256;\n+  static address _vector_acos_float512;\n+  static address _vector_acos_double64;\n+  static address _vector_acos_double128;\n+  static address _vector_acos_double256;\n+  static address _vector_acos_double512;\n+\n+  static address _vector_asin_float64;\n+  static address _vector_asin_float128;\n+  static address _vector_asin_float256;\n+  static address _vector_asin_float512;\n+  static address _vector_asin_double64;\n+  static address _vector_asin_double128;\n+  static address _vector_asin_double256;\n+  static address _vector_asin_double512;\n+\n+  static address _vector_atan_float64;\n+  static address _vector_atan_float128;\n+  static address _vector_atan_float256;\n+  static address _vector_atan_float512;\n+  static address _vector_atan_double64;\n+  static address _vector_atan_double128;\n+  static address _vector_atan_double256;\n+  static address _vector_atan_double512;\n+\n+  static address _vector_pow_float64;\n+  static address _vector_pow_float128;\n+  static address _vector_pow_float256;\n+  static address _vector_pow_float512;\n+  static address _vector_pow_double64;\n+  static address _vector_pow_double128;\n+  static address _vector_pow_double256;\n+  static address _vector_pow_double512;\n+\n+  static address _vector_hypot_float64;\n+  static address _vector_hypot_float128;\n+  static address _vector_hypot_float256;\n+  static address _vector_hypot_float512;\n+  static address _vector_hypot_double64;\n+  static address _vector_hypot_double128;\n+  static address _vector_hypot_double256;\n+  static address _vector_hypot_double512;\n+\n+  static address _vector_cbrt_float64;\n+  static address _vector_cbrt_float128;\n+  static address _vector_cbrt_float256;\n+  static address _vector_cbrt_float512;\n+  static address _vector_cbrt_double64;\n+  static address _vector_cbrt_double128;\n+  static address _vector_cbrt_double256;\n+  static address _vector_cbrt_double512;\n+\n+  static address _vector_atan2_float64;\n+  static address _vector_atan2_float128;\n+  static address _vector_atan2_float256;\n+  static address _vector_atan2_float512;\n+  static address _vector_atan2_double64;\n+  static address _vector_atan2_double128;\n+  static address _vector_atan2_double256;\n+  static address _vector_atan2_double512;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n+\n@@ -447,0 +613,165 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  static address vector_exp_float64()   { return _vector_exp_float64;   }\n+  static address vector_exp_float128()  { return _vector_exp_float128;  }\n+  static address vector_exp_float256()  { return _vector_exp_float256;  }\n+  static address vector_exp_float512()  { return _vector_exp_float512;  }\n+  static address vector_exp_double64()  { return _vector_exp_double64;  }\n+  static address vector_exp_double128() { return _vector_exp_double128; }\n+  static address vector_exp_double256() { return _vector_exp_double256; }\n+  static address vector_exp_double512() { return _vector_exp_double512; }\n+\n+  static address vector_expm1_float64()   { return _vector_expm1_float64;   }\n+  static address vector_expm1_float128()  { return _vector_expm1_float128;  }\n+  static address vector_expm1_float256()  { return _vector_expm1_float256;  }\n+  static address vector_expm1_float512()  { return _vector_expm1_float512;  }\n+  static address vector_expm1_double64()  { return _vector_expm1_double64;  }\n+  static address vector_expm1_double128() { return _vector_expm1_double128; }\n+  static address vector_expm1_double256() { return _vector_expm1_double256; }\n+  static address vector_expm1_double512() { return _vector_expm1_double512; }\n+\n+  static address vector_log1p_float64()   { return _vector_log1p_float64;   }\n+  static address vector_log1p_float128()  { return _vector_log1p_float128;  }\n+  static address vector_log1p_float256()  { return _vector_log1p_float256;  }\n+  static address vector_log1p_float512()  { return _vector_log1p_float512;  }\n+  static address vector_log1p_double64()  { return _vector_log1p_double64;  }\n+  static address vector_log1p_double128() { return _vector_log1p_double128; }\n+  static address vector_log1p_double256() { return _vector_log1p_double256; }\n+  static address vector_log1p_double512() { return _vector_log1p_double512; }\n+\n+  static address vector_log_float64()   { return _vector_log_float64;   }\n+  static address vector_log_float128()  { return _vector_log_float128;  }\n+  static address vector_log_float256()  { return _vector_log_float256;  }\n+  static address vector_log_float512()  { return _vector_log_float512;  }\n+  static address vector_log_double64()  { return _vector_log_double64;  }\n+  static address vector_log_double128() { return _vector_log_double128; }\n+  static address vector_log_double256() { return _vector_log_double256; }\n+  static address vector_log_double512() { return _vector_log_double512; }\n+\n+  static address vector_log10_float64()   { return _vector_log10_float64;   }\n+  static address vector_log10_float128()  { return _vector_log10_float128;  }\n+  static address vector_log10_float256()  { return _vector_log10_float256;  }\n+  static address vector_log10_float512()  { return _vector_log10_float512;  }\n+  static address vector_log10_double64()  { return _vector_log10_double64;  }\n+  static address vector_log10_double128() { return _vector_log10_double128; }\n+  static address vector_log10_double256() { return _vector_log10_double256; }\n+  static address vector_log10_double512() { return _vector_log10_double512; }\n+\n+  static address vector_sin_float64()   { return _vector_sin_float64;   }\n+  static address vector_sin_float128()  { return _vector_sin_float128;  }\n+  static address vector_sin_float256()  { return _vector_sin_float256;  }\n+  static address vector_sin_float512()  { return _vector_sin_float512;  }\n+  static address vector_sin_double64()  { return _vector_sin_double64;  }\n+  static address vector_sin_double128() { return _vector_sin_double128; }\n+  static address vector_sin_double256() { return _vector_sin_double256; }\n+  static address vector_sin_double512() { return _vector_sin_double512; }\n+\n+  static address vector_cos_float64()    { return _vector_cos_float64;   }\n+  static address vector_cos_float128()   { return _vector_cos_float128;  }\n+  static address vector_cos_float256()   { return _vector_cos_float256;  }\n+  static address vector_cos_float512()   { return _vector_cos_float512;  }\n+  static address vector_cos_double64()   { return _vector_cos_double64;  }\n+  static address vector_cos_double128()  { return _vector_cos_double128; }\n+  static address vector_cos_double256()  { return _vector_cos_double256; }\n+  static address vector_cos_double512()  { return _vector_cos_double512; }\n+\n+  static address vector_tan_float64()   { return _vector_tan_float64;   }\n+  static address vector_tan_float128()  { return _vector_tan_float128;  }\n+  static address vector_tan_float256()  { return _vector_tan_float256;  }\n+  static address vector_tan_float512()  { return _vector_tan_float512;  }\n+  static address vector_tan_double64()  { return _vector_tan_double64;  }\n+  static address vector_tan_double128() { return _vector_tan_double128; }\n+  static address vector_tan_double256() { return _vector_tan_double256; }\n+  static address vector_tan_double512() { return _vector_tan_double512; }\n+\n+  static address vector_sinh_float64()   { return _vector_sinh_float64;   }\n+  static address vector_sinh_float128()  { return _vector_sinh_float128;  }\n+  static address vector_sinh_float256()  { return _vector_sinh_float256;  }\n+  static address vector_sinh_float512()  { return _vector_sinh_float512;  }\n+  static address vector_sinh_double64()  { return _vector_sinh_double64;  }\n+  static address vector_sinh_double128() { return _vector_sinh_double128; }\n+  static address vector_sinh_double256() { return _vector_sinh_double256; }\n+  static address vector_sinh_double512() { return _vector_sinh_double512; }\n+\n+  static address vector_cosh_float64()   { return _vector_cosh_float64;   }\n+  static address vector_cosh_float128()  { return _vector_cosh_float128;  }\n+  static address vector_cosh_float256()  { return _vector_cosh_float256;  }\n+  static address vector_cosh_float512()  { return _vector_cosh_float512;  }\n+  static address vector_cosh_double64()  { return _vector_cosh_double64;  }\n+  static address vector_cosh_double128() { return _vector_cosh_double128; }\n+  static address vector_cosh_double256() { return _vector_cosh_double256; }\n+  static address vector_cosh_double512() { return _vector_cosh_double512; }\n+\n+  static address vector_tanh_float64()   { return _vector_tanh_float64;   }\n+  static address vector_tanh_float128()  { return _vector_tanh_float128;  }\n+  static address vector_tanh_float256()  { return _vector_tanh_float256;  }\n+  static address vector_tanh_float512()  { return _vector_tanh_float512;  }\n+  static address vector_tanh_double64()  { return _vector_tanh_double64;  }\n+  static address vector_tanh_double128() { return _vector_tanh_double128; }\n+  static address vector_tanh_double256() { return _vector_tanh_double256; }\n+  static address vector_tanh_double512() { return _vector_tanh_double512; }\n+\n+  static address vector_asin_float64()   { return _vector_asin_float64;   }\n+  static address vector_asin_float128()  { return _vector_asin_float128;  }\n+  static address vector_asin_float256()  { return _vector_asin_float256;  }\n+  static address vector_asin_float512()  { return _vector_asin_float512;  }\n+  static address vector_asin_double64()  { return _vector_asin_double64;  }\n+  static address vector_asin_double128() { return _vector_asin_double128; }\n+  static address vector_asin_double256() { return _vector_asin_double256; }\n+  static address vector_asin_double512() { return _vector_asin_double512; }\n+\n+  static address vector_acos_float64()   { return _vector_acos_float64;   }\n+  static address vector_acos_float128()  { return _vector_acos_float128;  }\n+  static address vector_acos_float256()  { return _vector_acos_float256;  }\n+  static address vector_acos_float512()  { return _vector_acos_float512;  }\n+  static address vector_acos_double64()  { return _vector_acos_double64;  }\n+  static address vector_acos_double128() { return _vector_acos_double128; }\n+  static address vector_acos_double256() { return _vector_acos_double256; }\n+  static address vector_acos_double512() { return _vector_acos_double512; }\n+\n+  static address vector_atan_float64()   { return _vector_atan_float64;   }\n+  static address vector_atan_float128()  { return _vector_atan_float128;  }\n+  static address vector_atan_float256()  { return _vector_atan_float256;  }\n+  static address vector_atan_float512()  { return _vector_atan_float512;  }\n+  static address vector_atan_double64()  { return _vector_atan_double64;  }\n+  static address vector_atan_double128() { return _vector_atan_double128; }\n+  static address vector_atan_double256() { return _vector_atan_double256; }\n+  static address vector_atan_double512() { return _vector_atan_double512; }\n+\n+  static address vector_pow_float64()   { return _vector_pow_float64;   }\n+  static address vector_pow_float128()  { return _vector_pow_float128;  }\n+  static address vector_pow_float256()  { return _vector_pow_float256;  }\n+  static address vector_pow_float512()  { return _vector_pow_float512;  }\n+  static address vector_pow_double64()  { return _vector_pow_double64;  }\n+  static address vector_pow_double128() { return _vector_pow_double128; }\n+  static address vector_pow_double256() { return _vector_pow_double256; }\n+  static address vector_pow_double512() { return _vector_pow_double512; }\n+\n+  static address vector_hypot_float64()   { return _vector_hypot_float64;   }\n+  static address vector_hypot_float128()  { return _vector_hypot_float128;  }\n+  static address vector_hypot_float256()  { return _vector_hypot_float256;  }\n+  static address vector_hypot_float512()  { return _vector_hypot_float512;  }\n+  static address vector_hypot_double64()  { return _vector_hypot_double64;  }\n+  static address vector_hypot_double128() { return _vector_hypot_double128; }\n+  static address vector_hypot_double256() { return _vector_hypot_double256; }\n+  static address vector_hypot_double512() { return _vector_hypot_double512; }\n+\n+  static address vector_cbrt_float64()   { return _vector_cbrt_float64;   }\n+  static address vector_cbrt_float128()  { return _vector_cbrt_float128;  }\n+  static address vector_cbrt_float256()  { return _vector_cbrt_float256;  }\n+  static address vector_cbrt_float512()  { return _vector_cbrt_float512;  }\n+  static address vector_cbrt_double64()  { return _vector_cbrt_double64;  }\n+  static address vector_cbrt_double128() { return _vector_cbrt_double128; }\n+  static address vector_cbrt_double256() { return _vector_cbrt_double256; }\n+  static address vector_cbrt_double512() { return _vector_cbrt_double512; }\n+\n+  static address vector_atan2_float64()   { return _vector_atan2_float64;   }\n+  static address vector_atan2_float128()  { return _vector_atan2_float128;  }\n+  static address vector_atan2_float256()  { return _vector_atan2_float256;  }\n+  static address vector_atan2_float512()  { return _vector_atan2_float512;  }\n+  static address vector_atan2_double64()  { return _vector_atan2_double64;  }\n+  static address vector_atan2_double128() { return _vector_atan2_double128; }\n+  static address vector_atan2_double256() { return _vector_atan2_double256; }\n+  static address vector_atan2_double512() { return _vector_atan2_double512; }\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":331,"deletions":0,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -1525,0 +1525,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -298,0 +298,11 @@\n+  void truncate_to(int idx) {\n+    for (int i = 0, j = idx; j < length(); i++, j++) {\n+      at_put(i, at(j));\n+    }\n+    trunc_to(length() - idx);\n+  }\n+\n+  void truncate_from(int idx) {\n+    trunc_to(idx);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (double) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (double) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (double) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (double) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (double) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (double) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (double) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (double) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (double) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (double) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (double) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (double) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (double) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (double) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (double) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (double) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (double) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (double) Math.hypot(a, b));\n-            }\n@@ -670,0 +662,6 @@\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.hypot(a, b));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (float) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (float) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (float) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (float) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (float) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (float) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (float) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (float) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (float) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (float) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (float) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (float) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (float) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (float) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (float) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (float) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (float) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (float) Math.hypot(a, b));\n-            }\n@@ -670,0 +662,6 @@\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.hypot(a, b));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-    public static final \/*float*\/ Unary SIN = unary(\"SIN\", \"sin\", -1 \/*VectorSupport.VECTOR_OP_SIN*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary SIN = unary(\"SIN\", \"sin\", VectorSupport.VECTOR_OP_SIN, VO_ONLYFP);\n@@ -494,1 +494,1 @@\n-    public static final \/*float*\/ Unary COS = unary(\"COS\", \"cos\", -1 \/*VectorSupport.VECTOR_OP_COS*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary COS = unary(\"COS\", \"cos\", VectorSupport.VECTOR_OP_COS, VO_ONLYFP);\n@@ -496,1 +496,1 @@\n-    public static final \/*float*\/ Unary TAN = unary(\"TAN\", \"tan\", -1 \/*VectorSupport.VECTOR_OP_TAN*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary TAN = unary(\"TAN\", \"tan\", VectorSupport.VECTOR_OP_TAN, VO_ONLYFP);\n@@ -498,1 +498,1 @@\n-    public static final \/*float*\/ Unary ASIN = unary(\"ASIN\", \"asin\", -1 \/*VectorSupport.VECTOR_OP_ASIN*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary ASIN = unary(\"ASIN\", \"asin\", VectorSupport.VECTOR_OP_ASIN, VO_ONLYFP);\n@@ -500,1 +500,1 @@\n-    public static final \/*float*\/ Unary ACOS = unary(\"ACOS\", \"acos\", -1 \/*VectorSupport.VECTOR_OP_ACOS*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary ACOS = unary(\"ACOS\", \"acos\", VectorSupport.VECTOR_OP_ACOS, VO_ONLYFP);\n@@ -502,1 +502,1 @@\n-    public static final \/*float*\/ Unary ATAN = unary(\"ATAN\", \"atan\", -1 \/*VectorSupport.VECTOR_OP_ATAN*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary ATAN = unary(\"ATAN\", \"atan\", VectorSupport.VECTOR_OP_ATAN, VO_ONLYFP);\n@@ -505,1 +505,1 @@\n-    public static final \/*float*\/ Unary EXP = unary(\"EXP\", \"exp\", -1 \/*VectorSupport.VECTOR_OP_EXP*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary EXP = unary(\"EXP\", \"exp\", VectorSupport.VECTOR_OP_EXP, VO_ONLYFP);\n@@ -507,1 +507,1 @@\n-    public static final \/*float*\/ Unary LOG = unary(\"LOG\", \"log\", -1 \/*VectorSupport.VECTOR_OP_LOG*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary LOG = unary(\"LOG\", \"log\", VectorSupport.VECTOR_OP_LOG, VO_ONLYFP);\n@@ -509,1 +509,1 @@\n-    public static final \/*float*\/ Unary LOG10 = unary(\"LOG10\", \"log10\", -1 \/*VectorSupport.VECTOR_OP_LOG10*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary LOG10 = unary(\"LOG10\", \"log10\", VectorSupport.VECTOR_OP_LOG10, VO_ONLYFP);\n@@ -513,1 +513,1 @@\n-    public static final \/*float*\/ Unary CBRT = unary(\"CBRT\", \"cbrt\", -1 \/*VectorSupport.VECTOR_OP_CBRT*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary CBRT = unary(\"CBRT\", \"cbrt\", VectorSupport.VECTOR_OP_CBRT, VO_ONLYFP);\n@@ -516,1 +516,1 @@\n-    public static final \/*float*\/ Unary SINH = unary(\"SINH\", \"sinh\", -1 \/*VectorSupport.VECTOR_OP_SINH*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary SINH = unary(\"SINH\", \"sinh\", VectorSupport.VECTOR_OP_SINH, VO_ONLYFP);\n@@ -518,1 +518,1 @@\n-    public static final \/*float*\/ Unary COSH = unary(\"COSH\", \"cosh\", -1 \/*VectorSupport.VECTOR_OP_COSH*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary COSH = unary(\"COSH\", \"cosh\", VectorSupport.VECTOR_OP_COSH, VO_ONLYFP);\n@@ -520,1 +520,1 @@\n-    public static final \/*float*\/ Unary TANH = unary(\"TANH\", \"tanh\", -1 \/*VectorSupport.VECTOR_OP_TANH*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary TANH = unary(\"TANH\", \"tanh\", VectorSupport.VECTOR_OP_TANH, VO_ONLYFP);\n@@ -522,1 +522,1 @@\n-    public static final \/*float*\/ Unary EXPM1 = unary(\"EXPM1\", \"expm1\", -1 \/*VectorSupport.VECTOR_OP_EXPM1*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary EXPM1 = unary(\"EXPM1\", \"expm1\", VectorSupport.VECTOR_OP_EXPM1, VO_ONLYFP);\n@@ -524,1 +524,1 @@\n-    public static final \/*float*\/ Unary LOG1P = unary(\"LOG1P\", \"log1p\", -1 \/*VectorSupport.VECTOR_OP_LOG1P*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Unary LOG1P = unary(\"LOG1P\", \"log1p\", VectorSupport.VECTOR_OP_LOG1P, VO_ONLYFP);\n@@ -566,1 +566,1 @@\n-    public static final \/*float*\/ Binary ATAN2 = binary(\"ATAN2\", \"atan2\", -1 \/*VectorSupport.VECTOR_OP_ATAN2*\/ , VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Binary ATAN2 = binary(\"ATAN2\", \"atan2\", VectorSupport.VECTOR_OP_ATAN2, VO_ONLYFP);\n@@ -568,1 +568,1 @@\n-    public static final \/*float*\/ Binary POW = binary(\"POW\", \"pow\", -1 \/*VectorSupport.VECTOR_OP_POW*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Binary POW = binary(\"POW\", \"pow\", VectorSupport.VECTOR_OP_POW, VO_ONLYFP);\n@@ -570,1 +570,1 @@\n-    public static final \/*float*\/ Binary HYPOT = binary(\"HYPOT\", \"hypot\", -1 \/*VectorSupport.VECTOR_OP_HYPOT*\/, VO_ONLYFP | VO_SPECIAL);\n+    public static final \/*float*\/ Binary HYPOT = binary(\"HYPOT\", \"hypot\", VectorSupport.VECTOR_OP_HYPOT, VO_ONLYFP);\n@@ -1353,5 +1353,1 @@\n-                       op == BITWISE_BLEND ||\n-                       op == SIN   || op == COS   || op == TAN   || op == ASIN || op == ACOS || op == ATAN || op == EXP  ||\n-                       op == LOG   || op == LOG10 || op == SQRT  || op == CBRT || op == SINH || op == COSH || op == TANH ||\n-                       op == EXPM1 || op == LOG1P || op == ATAN2 || op == POW || op == HYPOT\n-                ) : op;\n+                       op == BITWISE_BLEND) : op;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -572,33 +572,0 @@\n-#if[FP]\n-            if (op == SIN) {\n-                return uOp((i, a) -> ($type$) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> ($type$) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> ($type$) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> ($type$) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> ($type$) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> ($type$) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> ($type$) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> ($type$) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> ($type$) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> ($type$) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> ($type$) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> ($type$) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> ($type$) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> ($type$) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> ($type$) Math.log1p(a));\n-            }\n-#end[FP]\n@@ -617,0 +584,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log10(a));\n@@ -619,0 +604,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log1p(a));\n@@ -692,9 +689,0 @@\n-#if[FP]\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.hypot(a, b));\n-            }\n-#end[FP]\n@@ -737,0 +725,6 @@\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.hypot(a, b));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":36,"deletions":42,"binary":false,"changes":78,"status":"modified"}]}