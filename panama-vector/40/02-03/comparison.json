{"files":[{"patch":"@@ -2424,0 +2424,1 @@\n+    case Op_MaskAll:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,11 +223,0 @@\n-  static void sve_compare(C2_MacroAssembler masm, PRegister pd, BasicType bt,\n-                          PRegister pg, FloatRegister zn, FloatRegister zm, int cond) {\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n-    if (bt == T_FLOAT || bt == T_DOUBLE) {\n-      sve_compare_fp(masm, pd, size, pg, zn, zm, cond);\n-    } else {\n-      assert(is_integral_type(bt), \"Unsupported type\");\n-      sve_compare_integral(masm, pd, size, pg, zn, zm, cond);\n-    }\n-  }\n-\n@@ -389,1 +378,1 @@\n-  format %{ \"sve_cmpeq  $pg, $src, -1\\t# vector mask (sve)\" %}\n+  format %{ \"sve_cmpne  $pg, $src, 0\\t# vector mask (sve)\" %}\n@@ -392,2 +381,2 @@\n-    __ sve_cmpeq(as_PRegister($pg$$reg), elemType_to_regVariant(bt),\n-                 ptrue, as_FloatRegister($src$$reg), -1);\n+    __ sve_cmpne(as_PRegister($pg$$reg), elemType_to_regVariant(bt),\n+                 ptrue, as_FloatRegister($src$$reg), 0);\n@@ -434,0 +423,19 @@\n+\/\/ maskAll\n+\n+instruct vmaskAll(pRegGov pg, immL src) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (MaskAll src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ptrue $pg\\t# mask all (sve)\" %}\n+  ins_encode %{\n+    long value = $src$$constant;\n+    if (value == -1) {\n+      __ sve_ptrue(as_PRegister($pg$$reg), __ B);\n+    } else {\n+      assert(value == 0, \"Unsupported value\");\n+      __ sve_pfalse(as_PRegister($pg$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -440,1 +448,1 @@\n-  format %{ \"sve_cpy $dst, $pg, -1\\t# mask to vector (sve)\" %}\n+  format %{ \"sve_cpy $dst, $pg, 1\\t# mask to vector (sve)\" %}\n@@ -444,1 +452,1 @@\n-               as_PRegister($pg$$reg), -1, false);\n+               as_PRegister($pg$$reg), 1, false);\n@@ -1522,20 +1530,0 @@\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(vReg dst, vReg src1, vReg src2, immI cond, pRegGov pTmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(TEMP pTmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_cmp $pTmp, $src1, $src2\\n\\t\"\n-            \"sve_cpy $dst, $pTmp, -1\\t # vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = vector_element_basic_type(this);\n-    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,\n-                ptrue, as_FloatRegister($src1$$reg),\n-                as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),\n-               as_PRegister($pTmp$$reg), -1, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -1564,2 +1552,2 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t # vector load mask (B)\" %}\n+  ins_cost(0);\n+  format %{ \"vloadmaskB (elided)\\t# vector load mask (sve) (B) - do nothing\" %}\n@@ -1567,2 +1555,1 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($src$$reg));\n+    \/\/ empty\n@@ -1577,3 +1564,2 @@\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_uunpklo $dst, $src\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to H)\" %}\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uunpklo $dst, $src\\t# vector load mask (sve) (B to H)\" %}\n@@ -1583,2 +1569,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ H, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1594,1 +1578,1 @@\n-  ins_cost(3 * SVE_COST);\n+  ins_cost(2 * SVE_COST);\n@@ -1596,2 +1580,1 @@\n-            \"sve_uunpklo $dst, $dst\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to S)\" %}\n+            \"sve_uunpklo $dst, $dst\\t# vector load mask (sve) (B to S)\" %}\n@@ -1603,2 +1586,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1614,1 +1595,1 @@\n-  ins_cost(4 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -1617,2 +1598,1 @@\n-            \"sve_uunpklo $dst, $dst\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to D)\" %}\n+            \"sve_uunpklo $dst, $dst\\t# vector load mask (sve) (B to D)\" %}\n@@ -1626,2 +1606,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1637,2 +1615,2 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t # vector store mask (B)\" %}\n+  ins_cost(0);\n+  format %{ \"vstoremaskB (elided)\\t# vector store mask (sve) (B) - do nothing\" %}\n@@ -1640,2 +1618,1 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($src$$reg));\n+    \/\/ empty\n@@ -1650,1 +1627,1 @@\n-  ins_cost(3 * SVE_COST);\n+  ins_cost(2 * SVE_COST);\n@@ -1652,2 +1629,1 @@\n-            \"sve_uzp1 $dst, $src, $tmp\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector store mask (sve) (H to B)\" %}\n+            \"sve_uzp1 $dst, $src, $tmp\\t# vector store mask (sve) (H to B)\" %}\n@@ -1658,3 +1634,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($dst$$reg));\n-\n@@ -1669,1 +1642,1 @@\n-  ins_cost(4 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -1672,2 +1645,1 @@\n-            \"sve_uzp1 $dst, $dst, $tmp\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector store mask (sve) (S to B)\" %}\n+            \"sve_uzp1 $dst, $dst, $tmp\\t# vector store mask (sve) (S to B)\" %}\n@@ -1680,2 +1652,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1690,1 +1660,1 @@\n-  ins_cost(5 * SVE_COST);\n+  ins_cost(4 * SVE_COST);\n@@ -1694,2 +1664,1 @@\n-            \"sve_uzp1 $dst, $dst, $tmp\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector store mask (sve) (D to B)\" %}\n+            \"sve_uzp1 $dst, $dst, $tmp\\t# vector store mask (sve) (D to B)\" %}\n@@ -1704,2 +1673,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($dst$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":42,"deletions":75,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -219,11 +219,0 @@\n-  static void sve_compare(C2_MacroAssembler masm, PRegister pd, BasicType bt,\n-                          PRegister pg, FloatRegister zn, FloatRegister zm, int cond) {\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n-    if (bt == T_FLOAT || bt == T_DOUBLE) {\n-      sve_compare_fp(masm, pd, size, pg, zn, zm, cond);\n-    } else {\n-      assert(is_integral_type(bt), \"Unsupported type\");\n-      sve_compare_integral(masm, pd, size, pg, zn, zm, cond);\n-    }\n-  }\n-\n@@ -392,1 +381,1 @@\n-  format %{ \"sve_cmpeq  $pg, $src, -1\\t# vector mask (sve)\" %}\n+  format %{ \"sve_cmpne  $pg, $src, 0\\t# vector mask (sve)\" %}\n@@ -395,2 +384,2 @@\n-    __ sve_cmpeq(as_PRegister($pg$$reg), elemType_to_regVariant(bt),\n-                 ptrue, as_FloatRegister($src$$reg), -1);\n+    __ sve_cmpne(as_PRegister($pg$$reg), elemType_to_regVariant(bt),\n+                 ptrue, as_FloatRegister($src$$reg), 0);\n@@ -426,0 +415,19 @@\n+\/\/ maskAll\n+\n+instruct vmaskAll(pRegGov pg, immL src) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (MaskAll src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ptrue $pg\\t# mask all (sve)\" %}\n+  ins_encode %{\n+    long value = $src$$constant;\n+    if (value == -1) {\n+      __ sve_ptrue(as_PRegister($pg$$reg), __ B);\n+    } else {\n+      assert(value == 0, \"Unsupported value\");\n+      __ sve_pfalse(as_PRegister($pg$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -432,1 +440,1 @@\n-  format %{ \"sve_cpy $dst, $pg, -1\\t# mask to vector (sve)\" %}\n+  format %{ \"sve_cpy $dst, $pg, 1\\t# mask to vector (sve)\" %}\n@@ -436,1 +444,1 @@\n-               as_PRegister($pg$$reg), -1, false);\n+               as_PRegister($pg$$reg), 1, false);\n@@ -929,20 +937,0 @@\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(vReg dst, vReg src1, vReg src2, immI cond, pRegGov pTmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(TEMP pTmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_cmp $pTmp, $src1, $src2\\n\\t\"\n-            \"sve_cpy $dst, $pTmp, -1\\t # vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = vector_element_basic_type(this);\n-    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,\n-                ptrue, as_FloatRegister($src1$$reg),\n-                as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),\n-               as_PRegister($pTmp$$reg), -1, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -971,2 +959,2 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t # vector load mask (B)\" %}\n+  ins_cost(0);\n+  format %{ \"vloadmaskB (elided)\\t# vector load mask (sve) (B) - do nothing\" %}\n@@ -974,2 +962,1 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($src$$reg));\n+    \/\/ empty\n@@ -984,3 +971,2 @@\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_uunpklo $dst, $src\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to H)\" %}\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uunpklo $dst, $src\\t# vector load mask (sve) (B to H)\" %}\n@@ -990,2 +976,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ H, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1001,1 +985,1 @@\n-  ins_cost(3 * SVE_COST);\n+  ins_cost(2 * SVE_COST);\n@@ -1003,2 +987,1 @@\n-            \"sve_uunpklo $dst, $dst\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to S)\" %}\n+            \"sve_uunpklo $dst, $dst\\t# vector load mask (sve) (B to S)\" %}\n@@ -1010,2 +993,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1021,1 +1002,1 @@\n-  ins_cost(4 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -1024,2 +1005,1 @@\n-            \"sve_uunpklo $dst, $dst\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to D)\" %}\n+            \"sve_uunpklo $dst, $dst\\t# vector load mask (sve) (B to D)\" %}\n@@ -1033,2 +1013,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1044,2 +1022,2 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t # vector store mask (B)\" %}\n+  ins_cost(0);\n+  format %{ \"vstoremaskB (elided)\\t# vector store mask (sve) (B) - do nothing\" %}\n@@ -1047,2 +1025,1 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($src$$reg));\n+    \/\/ empty\n@@ -1057,1 +1034,1 @@\n-  ins_cost(3 * SVE_COST);\n+  ins_cost(2 * SVE_COST);\n@@ -1059,2 +1036,1 @@\n-            \"sve_uzp1 $dst, $src, $tmp\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector store mask (sve) (H to B)\" %}\n+            \"sve_uzp1 $dst, $src, $tmp\\t# vector store mask (sve) (H to B)\" %}\n@@ -1065,3 +1041,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($dst$$reg));\n-\n@@ -1076,1 +1049,1 @@\n-  ins_cost(4 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -1079,2 +1052,1 @@\n-            \"sve_uzp1 $dst, $dst, $tmp\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector store mask (sve) (S to B)\" %}\n+            \"sve_uzp1 $dst, $dst, $tmp\\t# vector store mask (sve) (S to B)\" %}\n@@ -1087,2 +1059,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($dst$$reg));\n@@ -1097,1 +1067,1 @@\n-  ins_cost(5 * SVE_COST);\n+  ins_cost(4 * SVE_COST);\n@@ -1101,2 +1071,1 @@\n-            \"sve_uzp1 $dst, $dst, $tmp\\n\\t\"\n-            \"sve_neg $dst, $dst\\t # vector store mask (sve) (D to B)\" %}\n+            \"sve_uzp1 $dst, $dst, $tmp\\t# vector store mask (sve) (D to B)\" %}\n@@ -1111,2 +1080,0 @@\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n-               as_FloatRegister($dst$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":42,"deletions":75,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -3238,0 +3238,6 @@\n+  void sve_pfalse(PRegister pd) {\n+    starti;\n+    f(0b00100101, 31, 24), f(0b00, 23, 22), f(0b011000111001, 21, 10);\n+    f(0b000000, 9, 4), prf(pd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4088,5 +4088,0 @@\n-        \/*\n-         * TODO: Check whether NegVF\/NegVD is neeeded here, in\n-         * case unnecessary vector rematerialization happens.\n-         *\/\n-        strcmp(opType,\"NegVI\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+macro(MaskAll)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -806,23 +806,36 @@\n-\n-  Node* elem = NULL;\n-  switch (elem_bt) {\n-    case T_BOOLEAN: \/\/ fall-through\n-    case T_BYTE:    \/\/ fall-through\n-    case T_SHORT:   \/\/ fall-through\n-    case T_CHAR:    \/\/ fall-through\n-    case T_INT: {\n-      elem = gvn().transform(new ConvL2INode(bits));\n-      break;\n-    }\n-    case T_DOUBLE: {\n-      elem = gvn().transform(new MoveL2DNode(bits));\n-      break;\n-    }\n-    case T_FLOAT: {\n-      bits = gvn().transform(new ConvL2INode(bits));\n-      elem = gvn().transform(new MoveI2FNode(bits));\n-      break;\n-    }\n-    case T_LONG: {\n-      elem = bits; \/\/ no conversion needed\n-      break;\n+  Node* node = NULL;\n+  const TypeLong* value = gvn().type(bits)->is_long();\n+  if (is_vector_mask(vbox_klass) &&\n+     value->is_con() && (value->get_con() == -1 || value->get_con() == 0) &&\n+     arch_supports_vector(Op_MaskAll, num_elem, elem_bt, VecMaskNotUsed)) {\n+     ConLNode* con = (ConLNode*)gvn().makecon(value);\n+     node = gvn().transform(new MaskAllNode(con, TypeVMask::make(elem_bt, num_elem)));\n+     \/\/ TODO: remove the conversion once reboxing for predicate is supported.\n+     node = gvn().transform(new MaskToVectorNode(node, TypeVect::make(elem_bt, num_elem)));\n+  }\n+\n+  if (node == NULL) {\n+    Node* elem = NULL;\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        elem = gvn().transform(new ConvL2INode(bits));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        elem = gvn().transform(new MoveL2DNode(bits));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        bits = gvn().transform(new ConvL2INode(bits));\n+        elem = gvn().transform(new MoveI2FNode(bits));\n+        break;\n+      }\n+      case T_LONG: {\n+        elem = bits; \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n@@ -830,2 +843,0 @@\n-    default: fatal(\"%s\", type2name(elem_bt));\n-  }\n@@ -833,2 +844,3 @@\n-  Node* broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt));\n-  broadcast = gvn().transform(broadcast);\n+    node = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt));\n+    node = gvn().transform(node);\n+  }\n@@ -836,1 +848,1 @@\n-  Node* box = box_vector(broadcast, vbox_type, elem_bt, num_elem);\n+  Node* box = box_vector(node, vbox_type, elem_bt, num_elem);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":40,"deletions":28,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -724,2 +724,1 @@\n-  \/\/ StoreVectorNode (VectorStoreMask src)  ==>  StoreVectorMask (NegVI src).\n-  \/\/ TODO: Check whether \"NegVI\" can be removed.\n+  \/\/ StoreVectorNode (VectorStoreMask src)  ==>  (StoreVectorMask src).\n@@ -731,2 +730,0 @@\n-      \/\/ Convert mask values -1\/0 to boolean values 1\/0.\n-      Node* neg = phase->transform(new NegVINode(value->in(1), type));\n@@ -737,1 +734,1 @@\n-                                                      adr_type(), neg, mem_type));\n+                                                      adr_type(), value->in(1), mem_type));\n@@ -1029,2 +1026,1 @@\n-  \/\/ VectorLoadMask (LoadVector src)  ==> NegVI (LoadVectorMask src).\n-  \/\/ TODO: Check whether \"NegVI\" can be removed.\n+  \/\/ VectorLoadMask (LoadVector src)  ==> (LoadVectorMask src).\n@@ -1036,6 +1032,4 @@\n-    Node* load_mask = phase->transform(new LoadVectorMaskNode(load->in(MemNode::Control),\n-                                                              load->in(MemNode::Memory),\n-                                                              load->in(MemNode::Address),\n-                                                              load->adr_type(), type, mem_type));\n-    \/\/ Convert boolean values 1\/0 to mask values -1\/0.\n-    return phase->transform(new NegVINode(load_mask, type));\n+    return phase->transform(new LoadVectorMaskNode(load->in(MemNode::Control),\n+                                                   load->in(MemNode::Memory),\n+                                                   load->in(MemNode::Address),\n+                                                   load->adr_type(), type, mem_type));\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -913,0 +913,9 @@\n+class MaskAllNode : public VectorMaskNode {\n+ public:\n+  MaskAllNode(ConLNode* in, const TypeVMask* vmask_type) : VectorMaskNode(in, vmask_type) {\n+    assert(in->get_long() == 0 || in->get_long() == -1, \"Unsupported value to mask all\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1894,0 +1894,1 @@\n+  declare_c2_type(MaskAllNode, VectorMaskNode)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}