{"files":[{"patch":"@@ -4,0 +4,2 @@\n+\/**\/.idea\n+\/**\/*.iml\n@@ -5,0 +7,1 @@\n+\/**\/.vscode\n@@ -21,0 +24,4 @@\n+\n+# Downloaded binaries\n+\/src\/utils\/hsdis\/binutils*\n+\/src\/utils\/hsdis\/build\/\n","filename":".gitignore","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -763,0 +763,8 @@\n+\n+  \/\/ The memory barrier checks are based on ones for unsafe access.\n+  \/\/ This is not 1-1 implementation.\n+  const Type *const base_type = gvn().type(base);\n+\n+  \/\/ Is off heap access (true implies can_access_non_heap = true)\n+  const bool off_heap_access = TypePtr::NULL_PTR == base_type;\n+\n@@ -764,1 +772,4 @@\n-  bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(gvn().type(base));\n+  const bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(base_type);\n+\n+  \/\/ Not determined access, base can and can not be null.\n+  const bool mixed_access = !off_heap_access && can_access_non_heap;\n@@ -826,1 +837,1 @@\n-  if (can_access_non_heap) {\n+  if (mixed_access) {\n@@ -873,1 +884,1 @@\n-  if (can_access_non_heap) {\n+  if (mixed_access) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+        static final long BYTE_BUFFER_IS_READ_ONLY\n+                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+\n@@ -376,0 +379,5 @@\n+    @ForceInline\n+    public static boolean isReadOnly(ByteBuffer bb) {\n+        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n+    }\n+\n@@ -409,0 +417,2 @@\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n@@ -410,3 +420,3 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    bb, offset, s,\n-                    defaultImpl);\n+                      base, BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n@@ -451,0 +461,2 @@\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n@@ -452,4 +464,4 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    v,\n-                    bb, offset,\n-                    defaultImpl);\n+                                base, BufferAccess.bufferAddress(bb, offset),\n+                                v,\n+                                bb, offset,\n+                                defaultImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3461,1 +3461,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3086,1 +3086,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3073,1 +3073,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3182,1 +3182,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3085,1 +3085,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3448,1 +3448,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4398,1 +4398,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test if memory ordering is preserved\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileThreshold=100 -XX:CompileCommand=dontinline,compiler.vectorapi.VectorMemoryAlias::test\n+ *      compiler.vectorapi.VectorMemoryAlias\n+ * @modules jdk.incubator.vector\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+public class VectorMemoryAlias {\n+  public static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+  public static void main(String[] args) {\n+    for (int i=0; i < 30000; i++) {\n+      if (test() != 1) {\n+        throw new AssertionError();\n+      }\n+    }\n+  }\n+\n+  public static int test() {\n+    byte arr[] = new byte[256];\n+    final var bb = ByteBuffer.wrap(arr);\n+    final var ones = ByteVector.broadcast(SPECIES, 1);\n+    var res = ByteVector.zero(SPECIES);\n+\n+    int result = 0;\n+    result += arr[2];\n+    res.add(ones).intoByteBuffer(bb, 0, ByteOrder.nativeOrder());\n+    result += arr[2];\n+\n+    return result;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  ByteBuffer directInRo, directOutRo;\n+  ByteBuffer heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+\n+    directInRo = directIn.asReadOnlyBuffer();\n+    directOutRo = directOut.asReadOnlyBuffer();\n+\n+    heapInRo = heapIn.asReadOnlyBuffer();\n+    heapOutRo = heapOut.asReadOnlyBuffer();\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers2() {\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers3() {\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(directInRo, directOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers4() {\n+    copyIntoNotInlined(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, directOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedBuffers5() {\n+    copyIntoNotInlined(directIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, directIn);\n+    copyIntoNotInlined(heapIn, directOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyIntoNotInlined(heapIn, directOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = heapIn.array();\n+    byte[] out = heapOut.array();\n+\n+    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyIntoNotInlined(ByteBuffer in, ByteBuffer out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}