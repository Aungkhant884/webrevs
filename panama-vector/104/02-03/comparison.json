{"files":[{"patch":"@@ -800,0 +800,1 @@\n+                    assert 1==2;\n@@ -802,0 +803,5 @@\n+                @Override\n+                @ForceInline\n+                public byte[] getBufferBaseFiled(ByteBuffer bb) {\n+                    return bb.hb;\n+                }\n@@ -804,0 +810,1 @@\n+                @ForceInline\n@@ -808,0 +815,6 @@\n+                @Override\n+                @ForceInline\n+                public boolean isDirect(ByteBuffer bb) {\n+                    return !(bb instanceof HeapByteBuffer);\n+                }\n+\n@@ -818,0 +831,1 @@\n+                @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,0 +74,5 @@\n+    \/**\n+     * Avoids polymorphism from {@link #getBufferBase}\n+     *\/\n+    byte[] getBufferBaseFiled(ByteBuffer bb);\n+\n@@ -79,0 +84,6 @@\n+    \/**\n+     * Check if {@link ByteBuffer} is direct, used by Panama. Consider moving this as Buffer API.\n+     * It's better, avoids polymorphism and takes from immutable mem, easier for loop unswitch\n+     *\/\n+    boolean isDirect(ByteBuffer bb);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -357,0 +357,3 @@\n+        static final long BYTE_BUFFER_IS_READ_ONLY\n+                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+\n@@ -377,0 +380,11 @@\n+    @ForceInline\n+    public static\n+    boolean isDirect(ByteBuffer bb) {\n+      return BufferAccess.NIO_ACCESS.isDirect(bb);\n+    }\n+\n+    @ForceInline\n+    public static boolean isReadOnly(ByteBuffer bb) {\n+        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n+    }\n+\n@@ -380,1 +394,1 @@\n-    V loadFromByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n+    V loadFromByteBuffer(boolean directBuff, Class<? extends V> vmClass, Class<E> e, int length,\n@@ -387,0 +401,1 @@\n+                    directBuff,\n@@ -401,0 +416,1 @@\n+                          boolean directBuff,\n@@ -413,1 +429,2 @@\n-                      base, BufferAccess.bufferAddress(bb, offset),\n+                      directBuff ? null : Objects.requireNonNull(base), \/\/ Direct buff to const fold\n+                      BufferAccess.bufferAddress(bb, offset),\n@@ -424,1 +441,1 @@\n-    void storeIntoByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n+    void storeIntoByteBuffer(boolean directBuff, Class<? extends V> vmClass, Class<E> e, int length,\n@@ -431,0 +448,1 @@\n+                    directBuff,\n@@ -445,0 +463,1 @@\n+                                   boolean directBuff,\n@@ -457,1 +476,2 @@\n-                                base, BufferAccess.bufferAddress(bb, offset),\n+                                directBuff ? null : Objects.requireNonNull(base), \/\/ Direct buff to const fold\n+                                BufferAccess.bufferAddress(bb, offset),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3567,8 +3567,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        }\n@@ -3617,8 +3630,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3178,8 +3178,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        }\n@@ -3228,8 +3241,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3165,8 +3165,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        }\n@@ -3215,8 +3228,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3274,8 +3274,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        }\n@@ -3324,8 +3337,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3177,8 +3177,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        }\n@@ -3227,8 +3240,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3554,8 +3554,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        }\n@@ -3604,8 +3617,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -4522,8 +4522,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        }\n@@ -4572,8 +4585,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -106,0 +106,39 @@\n+  @Benchmark\n+  public void pollutedBuffers4() {\n+    copyMemory(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyMemory(heapIn, directOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedBuffers5() {\n+    copyMemory(directIn, heapOut);\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(heapIn, directIn);\n+    copyMemory(heapIn, directOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyMemory(heapIn, directOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = heapIn.array();\n+    byte[] out = heapOut.array();\n+\n+    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.length()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, 0);\n+      v.intoArray(out, 0);\n+    }\n+  }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}