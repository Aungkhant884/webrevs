{"files":[{"patch":"@@ -776,1 +776,0 @@\n-  bool mismatched_array = false;\n@@ -781,5 +780,0 @@\n-  if (arr_type == NULL && !off_heap_access) {\n-    \/\/ Load or store to something different than array? Or just can't determine array type?\n-    mismatched_array = true;\n-  }\n-\n@@ -842,1 +836,0 @@\n-  const bool needs_bar = mixed_access || mismatched_array;\n@@ -844,1 +837,1 @@\n-  if (needs_bar) {\n+  if (mixed_access) {\n@@ -891,1 +884,1 @@\n-  if (needs_bar) {\n+  if (mixed_access) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+        static final long BYTE_BUFFER_IS_READ_ONLY\n+                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+\n@@ -376,0 +379,5 @@\n+    @ForceInline\n+    public static boolean isReadOnly(ByteBuffer bb) {\n+        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n+    }\n+\n@@ -409,1 +417,1 @@\n-            byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n@@ -411,7 +419,1 @@\n-            if (base == null) {\n-              return VectorSupport.load(vmClass, e, length,\n-                      null, BufferAccess.bufferAddress(bb, offset),\n-                      bb, offset, s,\n-                      defaultImpl);\n-            } else {\n-              return VectorSupport.load(vmClass, e, length,\n+            return VectorSupport.load(vmClass, e, length,\n@@ -421,1 +423,0 @@\n-            }\n@@ -462,13 +463,5 @@\n-            if (base == null) {\n-              VectorSupport.store(vmClass, e, length,\n-                                  null, BufferAccess.bufferAddress(bb, offset),\n-                                  v,\n-                                  bb, offset,\n-                                  defaultImpl);\n-            } else {\n-              VectorSupport.store(vmClass, e, length,\n-                                  base, BufferAccess.bufferAddress(bb, offset),\n-                                  v,\n-                                  bb, offset,\n-                                  defaultImpl);\n-            }\n+            VectorSupport.store(vmClass, e, length,\n+                                base, BufferAccess.bufferAddress(bb, offset),\n+                                v,\n+                                bb, offset,\n+                                defaultImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3461,1 +3461,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3086,1 +3086,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3073,1 +3073,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3182,1 +3182,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3085,1 +3085,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3448,1 +3448,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4398,1 +4398,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-\n+  public static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n@@ -57,3 +57,2 @@\n-    final var vs = VectorSpecies.ofLargestShape(byte.class);\n-    final var ones = ByteVector.broadcast(vs, 1);\n-    var res = ByteVector.zero(vs);\n+    final var ones = ByteVector.broadcast(SPECIES, 1);\n+    var res = ByteVector.zero(SPECIES);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-    copyMemory(directIn, directOut);\n-    copyMemory(heapIn, heapOut);\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n@@ -99,2 +99,2 @@\n-    copyMemory(directIn, directOut);\n-    copyMemory(heapIn, heapOut);\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n@@ -102,2 +102,2 @@\n-    copyMemory(directInRo, directOut);\n-    copyMemory(heapInRo, heapOut);\n+    copyIntoNotInlined(directInRo, directOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n@@ -108,2 +108,2 @@\n-    copyMemory(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n-    copyMemory(heapIn, heapOut);\n+    copyIntoNotInlined(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n@@ -111,2 +111,2 @@\n-    copyMemory(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n-    copyMemory(heapIn, directOut);\n+    copyIntoNotInlined(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, directOut);\n@@ -120,2 +120,2 @@\n-    copyMemory(directIn, heapOut);\n-    copyMemory(heapIn, heapOut);\n+    copyIntoNotInlined(directIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n@@ -123,2 +123,2 @@\n-    copyMemory(heapIn, directIn);\n-    copyMemory(heapIn, directOut);\n+    copyIntoNotInlined(heapIn, directIn);\n+    copyIntoNotInlined(heapIn, directOut);\n@@ -128,1 +128,1 @@\n-        copyMemory(heapIn, directOutRo);\n+        copyIntoNotInlined(heapIn, directOutRo);\n@@ -146,0 +146,5 @@\n+  protected void copyIntoNotInlined(ByteBuffer in, ByteBuffer out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"}]}