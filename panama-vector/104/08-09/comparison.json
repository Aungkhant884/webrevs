{"files":[{"patch":"@@ -4,2 +4,0 @@\n-\/**\/.idea\n-\/**\/*.iml\n@@ -7,1 +5,0 @@\n-\/**\/.vscode\n@@ -24,4 +21,0 @@\n-\n-# Downloaded binaries\n-\/src\/utils\/hsdis\/binutils*\n-\/src\/utils\/hsdis\/build\/\n","filename":".gitignore","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -768,2 +768,2 @@\n-  \/\/ Is off heap access (true implies can_access_non_heap = true)\n-  const bool off_heap_access = TypePtr::NULL_PTR == base_type;\n+  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n+  const TypeAryPtr* arr_type = addr_type->isa_aryptr();\n@@ -771,2 +771,2 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n-  const bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(base_type);\n+  const bool in_native = TypePtr::NULL_PTR == base_type; \/\/ base always null\n+  const bool in_heap   = !TypePtr::NULL_PTR->higher_equal(base_type); \/\/ base never null\n@@ -774,2 +774,1 @@\n-  \/\/ Not determined access, base can and can not be null.\n-  const bool mixed_access = !off_heap_access && can_access_non_heap;\n+  const bool is_mixed_access = !in_heap && !in_native;\n@@ -777,2 +776,3 @@\n-  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n-  const TypeAryPtr* arr_type = addr_type->isa_aryptr();\n+  const bool is_mismatched_access = in_heap && (addr_type->isa_aryptr() == NULL);\n+\n+  const bool needs_cpu_membar = is_mixed_access || is_mismatched_access;\n@@ -837,1 +837,1 @@\n-  if (mixed_access) {\n+  if (needs_cpu_membar) {\n@@ -884,1 +884,1 @@\n-  if (mixed_access) {\n+  if (needs_cpu_membar) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}