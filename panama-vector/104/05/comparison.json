{"files":[{"patch":"@@ -4,0 +4,2 @@\n+\/**\/.idea\n+\/**\/*.iml\n@@ -5,0 +7,1 @@\n+\/**\/.vscode\n@@ -21,0 +24,4 @@\n+\n+# Downloaded binaries\n+\/src\/utils\/hsdis\/binutils*\n+\/src\/utils\/hsdis\/build\/\n","filename":".gitignore","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -763,0 +763,8 @@\n+\n+  \/\/ This check is repetition of some checks from inline_unsafe_access(), used to determine if barriers are needed\n+  \/\/ Not full scope of checks is performed, we check only if access can be mixed\n+  const Type *const base_type = gvn().type(base);\n+\n+  \/\/ Is off heap access (true implies can_access_non_heap = true)\n+  const bool off_heap_access = TypePtr::NULL_PTR == base_type;\n+\n@@ -764,1 +772,4 @@\n-  bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(gvn().type(base));\n+  const bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(base_type);\n+\n+  \/\/ Not determined access base can and can not be null.\n+  const bool mixed_access = !off_heap_access && can_access_non_heap;\n@@ -826,1 +837,1 @@\n-  if (can_access_non_heap) {\n+  if (mixed_access) {\n@@ -873,1 +884,1 @@\n-  if (can_access_non_heap) {\n+  if (mixed_access) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -802,0 +802,5 @@\n+                @Override\n+                @ForceInline\n+                public byte[] getBufferBaseFiled(ByteBuffer bb) {\n+                    return bb.hb;\n+                }\n@@ -804,0 +809,1 @@\n+                @ForceInline\n@@ -808,0 +814,6 @@\n+                @Override\n+                @ForceInline\n+                public boolean isDirect(ByteBuffer bb) {\n+                    return !(bb instanceof HeapByteBuffer);\n+                }\n+\n@@ -818,0 +830,1 @@\n+                @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,0 +74,5 @@\n+    \/**\n+     * Avoids polymorphism from {@link #getBufferBase}\n+     *\/\n+    byte[] getBufferBaseFiled(ByteBuffer bb);\n+\n@@ -79,0 +84,6 @@\n+    \/**\n+     * Check if {@link ByteBuffer} is direct, used by Panama. Consider moving this as Buffer API.\n+     * It's better, avoids polymorphism and takes from immutable mem, easier for loop unswitch\n+     *\/\n+    boolean isDirect(ByteBuffer bb);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -356,0 +357,3 @@\n+        static final long BYTE_BUFFER_IS_READ_ONLY\n+                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+\n@@ -376,0 +380,11 @@\n+    @ForceInline\n+    public static\n+    boolean isDirect(ByteBuffer bb) {\n+      return BufferAccess.NIO_ACCESS.isDirect(bb);\n+    }\n+\n+    @ForceInline\n+    public static boolean isReadOnly(ByteBuffer bb) {\n+        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n+    }\n+\n@@ -379,1 +394,1 @@\n-    V loadFromByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n+    V loadFromByteBuffer(boolean directBuff, Class<? extends V> vmClass, Class<E> e, int length,\n@@ -386,0 +401,1 @@\n+                    directBuff,\n@@ -400,0 +416,1 @@\n+                          boolean directBuff,\n@@ -409,0 +426,2 @@\n+            byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n@@ -410,3 +429,4 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    bb, offset, s,\n-                    defaultImpl);\n+                      directBuff ? null : Objects.requireNonNull(base), \/\/ Direct buff to const fold\n+                      BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n@@ -421,1 +441,1 @@\n-    void storeIntoByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n+    void storeIntoByteBuffer(boolean directBuff, Class<? extends V> vmClass, Class<E> e, int length,\n@@ -428,0 +448,1 @@\n+                    directBuff,\n@@ -442,0 +463,1 @@\n+                                   boolean directBuff,\n@@ -451,0 +473,2 @@\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n@@ -452,4 +476,5 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    v,\n-                    bb, offset,\n-                    defaultImpl);\n+                                directBuff ? null : Objects.requireNonNull(base), \/\/ Direct buff to const fold\n+                                BufferAccess.bufferAddress(bb, offset),\n+                                v,\n+                                bb, offset,\n+                                defaultImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -3461,0 +3461,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3566,8 +3567,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        }\n@@ -3616,8 +3630,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3086,0 +3086,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3177,8 +3178,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        }\n@@ -3227,8 +3241,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3073,0 +3073,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3164,8 +3165,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        }\n@@ -3214,8 +3228,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3182,0 +3182,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3273,8 +3274,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        }\n@@ -3323,8 +3337,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3085,0 +3085,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3176,8 +3177,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        }\n@@ -3226,8 +3240,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3448,0 +3448,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3553,8 +3554,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        }\n@@ -3603,8 +3617,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -4398,0 +4398,1 @@\n+        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -4521,8 +4522,21 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                });\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        }\n@@ -4571,8 +4585,24 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                });\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+          throw new ReadOnlyBufferException();\n+        }\n+        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  true,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        } else {\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  false,\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test if memory ordering is preserved\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileThreshold=100 -XX:CompileCommand=dontinline,compiler.vectorapi.VectorMemoryAlias::test\n+ *      compiler.vectorapi.VectorMemoryAlias\n+ * @modules jdk.incubator.vector\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+public class VectorMemoryAlias {\n+\n+  public static void main(String[] args) {\n+    for (int i=0; i < 30000; i++) {\n+      if (test() != 1) {\n+        throw new AssertionError();\n+      }\n+    }\n+  }\n+\n+  public static int test() {\n+    byte arr[] = new byte[256];\n+    final var bb = ByteBuffer.wrap(arr);\n+    final var vs = VectorSpecies.ofLargestShape(byte.class);\n+    final var ones = ByteVector.broadcast(vs, 1);\n+    var res = ByteVector.zero(vs);\n+\n+    int result = 0;\n+    result += arr[2];\n+    res.add(ones).intoByteBuffer(bb, 0, ByteOrder.nativeOrder());\n+    result += arr[2];\n+\n+    return result;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  ByteBuffer directInRo, directOutRo;\n+  ByteBuffer heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+\n+    directInRo = directIn.asReadOnlyBuffer();\n+    directOutRo = directOut.asReadOnlyBuffer();\n+\n+    heapInRo = heapIn.asReadOnlyBuffer();\n+    heapOutRo = heapOut.asReadOnlyBuffer();\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers2() {\n+    copyMemory(directIn, directOut);\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers3() {\n+    copyMemory(directIn, directOut);\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(directInRo, directOut);\n+    copyMemory(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers4() {\n+    copyMemory(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyMemory(heapIn, directOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedBuffers5() {\n+    copyMemory(directIn, heapOut);\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(heapIn, directIn);\n+    copyMemory(heapIn, directOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyMemory(heapIn, directOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = heapIn.array();\n+    byte[] out = heapOut.array();\n+\n+    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"}]}