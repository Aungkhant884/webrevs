{"files":[{"patch":"@@ -776,0 +776,1 @@\n+  bool mismatched_array = false;\n@@ -780,0 +781,5 @@\n+  if (arr_type == NULL && !off_heap_access) {\n+    \/\/ Load or store to something different than array? Or just can't determine array type?\n+    mismatched_array = true;\n+  }\n+\n@@ -836,0 +842,1 @@\n+  const bool needs_bar = mixed_access || mismatched_array;\n@@ -837,1 +844,1 @@\n-  if (mixed_access) {\n+  if (needs_bar) {\n@@ -884,1 +891,1 @@\n-  if (mixed_access) {\n+  if (needs_bar) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -802,5 +802,0 @@\n-                @Override\n-                @ForceInline\n-                public byte[] getBufferBaseFiled(ByteBuffer bb) {\n-                    return bb.hb;\n-                }\n@@ -809,1 +804,0 @@\n-                @ForceInline\n@@ -814,6 +808,0 @@\n-                @Override\n-                @ForceInline\n-                public boolean isDirect(ByteBuffer bb) {\n-                    return !(bb instanceof HeapByteBuffer);\n-                }\n-\n@@ -830,1 +818,0 @@\n-                @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-    \/**\n-     * Avoids polymorphism from {@link #getBufferBase}\n-     *\/\n-    byte[] getBufferBaseFiled(ByteBuffer bb);\n-\n@@ -84,6 +79,0 @@\n-    \/**\n-     * Check if {@link ByteBuffer} is direct, used by Panama. Consider moving this as Buffer API.\n-     * It's better, avoids polymorphism and takes from immutable mem, easier for loop unswitch\n-     *\/\n-    boolean isDirect(ByteBuffer bb);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Objects;\n@@ -357,3 +356,0 @@\n-        static final long BYTE_BUFFER_IS_READ_ONLY\n-                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n-\n@@ -380,11 +376,0 @@\n-    @ForceInline\n-    public static\n-    boolean isDirect(ByteBuffer bb) {\n-      return BufferAccess.NIO_ACCESS.isDirect(bb);\n-    }\n-\n-    @ForceInline\n-    public static boolean isReadOnly(ByteBuffer bb) {\n-        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n-    }\n-\n@@ -394,1 +379,1 @@\n-    V loadFromByteBuffer(boolean directBuff, Class<? extends V> vmClass, Class<E> e, int length,\n+    V loadFromByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n@@ -401,1 +386,0 @@\n-                    directBuff,\n@@ -416,1 +400,0 @@\n-                          boolean directBuff,\n@@ -428,3 +411,8 @@\n-            return VectorSupport.load(vmClass, e, length,\n-                      directBuff ? null : Objects.requireNonNull(base), \/\/ Direct buff to const fold\n-                      BufferAccess.bufferAddress(bb, offset),\n+            if (base == null) {\n+              return VectorSupport.load(vmClass, e, length,\n+                      null, BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n+            } else {\n+              return VectorSupport.load(vmClass, e, length,\n+                      base, BufferAccess.bufferAddress(bb, offset),\n@@ -433,0 +421,1 @@\n+            }\n@@ -441,1 +430,1 @@\n-    void storeIntoByteBuffer(boolean directBuff, Class<? extends V> vmClass, Class<E> e, int length,\n+    void storeIntoByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n@@ -448,1 +437,0 @@\n-                    directBuff,\n@@ -463,1 +451,0 @@\n-                                   boolean directBuff,\n@@ -475,6 +462,13 @@\n-            VectorSupport.store(vmClass, e, length,\n-                                directBuff ? null : Objects.requireNonNull(base), \/\/ Direct buff to const fold\n-                                BufferAccess.bufferAddress(bb, offset),\n-                                v,\n-                                bb, offset,\n-                                defaultImpl);\n+            if (base == null) {\n+              VectorSupport.store(vmClass, e, length,\n+                                  null, BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            } else {\n+              VectorSupport.store(vmClass, e, length,\n+                                  base, BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":24,"deletions":30,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -3461,1 +3461,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3567,21 +3566,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.get(o + i * 1));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.get(o + i * 1));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                });\n@@ -3630,24 +3616,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3086,1 +3086,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3178,21 +3177,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                });\n@@ -3241,24 +3227,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3073,1 +3073,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3165,21 +3164,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                });\n@@ -3228,24 +3214,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3182,1 +3182,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3274,21 +3273,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                });\n@@ -3337,24 +3323,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3085,1 +3085,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3177,21 +3176,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                });\n@@ -3240,24 +3226,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3448,1 +3448,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -3554,21 +3553,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                });\n@@ -3617,24 +3603,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -4398,1 +4398,0 @@\n-        \/\/TODO Optimize: polymorphic call can lead to lack of inlining, and strange unswitch\n@@ -4522,21 +4521,8 @@\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                  });\n-        } else {\n-          return ScopedMemoryAccess.loadFromByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  bb, offset, vsp,\n-                  (buf, off, s) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      return s.ldOp(wb, off,\n-                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                  });\n-        }\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                });\n@@ -4585,24 +4571,8 @@\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-          throw new ReadOnlyBufferException();\n-        }\n-        if (ScopedMemoryAccess.isDirect(bb)) { \/\/ Flag has to be passed as constant for better loop unswitch\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  true,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                  });\n-        } else {\n-          ScopedMemoryAccess.storeIntoByteBuffer(\n-                  false,\n-                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                  this, bb, offset,\n-                  (buf, off, v) -> {\n-                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                      v.stOp(wb, off,\n-                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                  });\n-        }\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":16,"deletions":46,"binary":false,"changes":62,"status":"modified"}]}