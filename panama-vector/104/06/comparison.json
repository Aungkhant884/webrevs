{"files":[{"patch":"@@ -4,0 +4,2 @@\n+\/**\/.idea\n+\/**\/*.iml\n@@ -5,0 +7,1 @@\n+\/**\/.vscode\n@@ -21,0 +24,4 @@\n+\n+# Downloaded binaries\n+\/src\/utils\/hsdis\/binutils*\n+\/src\/utils\/hsdis\/build\/\n","filename":".gitignore","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -763,0 +763,8 @@\n+\n+  \/\/ This check is repetition of some checks from inline_unsafe_access(), used to determine if barriers are needed\n+  \/\/ Not full scope of checks is performed, we check only if access can be mixed\n+  const Type *const base_type = gvn().type(base);\n+\n+  \/\/ Is off heap access (true implies can_access_non_heap = true)\n+  const bool off_heap_access = TypePtr::NULL_PTR == base_type;\n+\n@@ -764,1 +772,5 @@\n-  bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(gvn().type(base));\n+  const bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(base_type);\n+\n+  \/\/ Not determined access base can and can not be null.\n+  const bool mixed_access = !off_heap_access && can_access_non_heap;\n+  bool mismatched_array = false;\n@@ -769,0 +781,5 @@\n+  if (arr_type == NULL && !off_heap_access) {\n+    \/\/ Load or store to something different than array? Or just can't determine array type?\n+    mismatched_array = true;\n+  }\n+\n@@ -825,0 +842,1 @@\n+  const bool needs_bar = mixed_access || mismatched_array;\n@@ -826,1 +844,1 @@\n-  if (can_access_non_heap) {\n+  if (needs_bar) {\n@@ -873,1 +891,1 @@\n-  if (can_access_non_heap) {\n+  if (needs_bar) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -409,4 +409,13 @@\n-            return VectorSupport.load(vmClass, e, length,\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    bb, offset, s,\n-                    defaultImpl);\n+            byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n+            if (base == null) {\n+              return VectorSupport.load(vmClass, e, length,\n+                      null, BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n+            } else {\n+              return VectorSupport.load(vmClass, e, length,\n+                      base, BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n+            }\n@@ -451,5 +460,15 @@\n-            VectorSupport.store(vmClass, e, length,\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    v,\n-                    bb, offset,\n-                    defaultImpl);\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n+            if (base == null) {\n+              VectorSupport.store(vmClass, e, length,\n+                                  null, BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            } else {\n+              VectorSupport.store(vmClass, e, length,\n+                                  base, BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test if memory ordering is preserved\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileThreshold=100 -XX:CompileCommand=dontinline,compiler.vectorapi.VectorMemoryAlias::test\n+ *      compiler.vectorapi.VectorMemoryAlias\n+ * @modules jdk.incubator.vector\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+public class VectorMemoryAlias {\n+\n+  public static void main(String[] args) {\n+    for (int i=0; i < 30000; i++) {\n+      if (test() != 1) {\n+        throw new AssertionError();\n+      }\n+    }\n+  }\n+\n+  public static int test() {\n+    byte arr[] = new byte[256];\n+    final var bb = ByteBuffer.wrap(arr);\n+    final var vs = VectorSpecies.ofLargestShape(byte.class);\n+    final var ones = ByteVector.broadcast(vs, 1);\n+    var res = ByteVector.zero(vs);\n+\n+    int result = 0;\n+    result += arr[2];\n+    res.add(ones).intoByteBuffer(bb, 0, ByteOrder.nativeOrder());\n+    result += arr[2];\n+\n+    return result;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  ByteBuffer directInRo, directOutRo;\n+  ByteBuffer heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+\n+    directInRo = directIn.asReadOnlyBuffer();\n+    directOutRo = directOut.asReadOnlyBuffer();\n+\n+    heapInRo = heapIn.asReadOnlyBuffer();\n+    heapOutRo = heapOut.asReadOnlyBuffer();\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers2() {\n+    copyMemory(directIn, directOut);\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers3() {\n+    copyMemory(directIn, directOut);\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(directInRo, directOut);\n+    copyMemory(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers4() {\n+    copyMemory(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyMemory(heapIn, directOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedBuffers5() {\n+    copyMemory(directIn, heapOut);\n+    copyMemory(heapIn, heapOut);\n+\n+    copyMemory(heapIn, directIn);\n+    copyMemory(heapIn, directOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyMemory(heapIn, directOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = heapIn.array();\n+    byte[] out = heapOut.array();\n+\n+    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"}]}