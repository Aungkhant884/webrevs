{"files":[{"patch":"@@ -283,2 +283,8 @@\n-        VectorMask<E> badMask =\n-            iota.compare(GE, iota.broadcast(indexLimit));\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Halffloat.class) {\n+            badMask =\n+                iota.compare(GE, iota.broadcast(Float.floatToFloat16((float)indexLimit)));\n+        } else {\n+            badMask =\n+                iota.compare(GE, iota.broadcast(indexLimit));\n+        }\n@@ -293,2 +299,7 @@\n-            VectorMask<E> badMask2 =\n-                iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            if (vectorSpecies().elementType() == Halffloat.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -425,12 +425,24 @@\n-        Object ia = Array.newInstance(laneType.elementType,\n-                                      laneCount);\n-        assert(ia.getClass() == laneType.arrayType);\n-        checkValue(laneCount-1);  \/\/ worst case\n-        for (int i = 0; i < laneCount; i++) {\n-            if ((byte)i == i)\n-                Array.setByte(ia, i, (byte)i);\n-            else if ((short)i == i)\n-                Array.setShort(ia, i, (short)i);\n-            else\n-                Array.setInt(ia, i, i);\n-            assert(Array.getDouble(ia, i) == i);\n+        Object ia = null;\n+        if (elementType() == Halffloat.class) {\n+            ia = Array.newInstance(short.class, laneCount);\n+            checkValue(laneCount-1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                \/\/ All the numbers in the range [0 2048] are directly representable in FP16 format without the precision loss.\n+                if (i < 2049)\n+                    Array.setShort(ia, i, Float.floatToFloat16((float)i));\n+                else\n+                    assert(Array.getShort(ia, i) == i);\n+            }\n+        } else {\n+            ia = Array.newInstance(laneType.elementType, laneCount);\n+            assert(ia.getClass() == laneType.arrayType);\n+            checkValue(laneCount-1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                if ((byte)i == i)\n+                    Array.setByte(ia, i, (byte)i);\n+                else if ((short)i == i)\n+                    Array.setShort(ia, i, (short)i);\n+                else\n+                    Array.setInt(ia, i, i);\n+                assert(Array.getDouble(ia, i) == i);\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    public static final short NaN = (short)0xffff;\n+    public static final short NaN = (short)0x7e00;\n@@ -81,1 +81,1 @@\n-        this.value = valueOf(f);\n+        this.value = Float.floatToFloat16(f);\n@@ -89,17 +89,1 @@\n-        int val = (int)value;\n-        float result;\n-        switch(val) {\n-          case Halffloat.POSITIVE_INFINITY:\n-               result = Float.POSITIVE_INFINITY;\n-               break;\n-          case Halffloat.NEGATIVE_INFINITY:\n-               result = Float.NEGATIVE_INFINITY;\n-               break;\n-          case Halffloat.NaN:\n-               result = Float.NaN;\n-               break;\n-          default:\n-               result = (Float.intBitsToFloat(((val&0x8000)<<16) | (((val&0x7c00)+0x1C000)<<13) | ((val&0x03FF)<<13)));\n-               break;\n-       }\n-       return result;\n+       return Float.float16ToFloat(value);\n@@ -114,8 +98,4 @@\n-        if (f > Halffloat.MAX_FLOAT_VALUE) return Halffloat.POSITIVE_INFINITY;\n-        if (Float.isNaN(f)) return Halffloat.NaN;\n-\n-        if (f < Halffloat.MIN_FLOAT_VALUE) return Halffloat.NEGATIVE_INFINITY;\n-\n-        int val = Float.floatToIntBits(f);\n-        val = ((((val>>16)&0x8000)|((((val&0x7f800000)-0x38000000)>>13)&0x7c00)|((val>>13)&0x03ff)));\n-        return (short)val;\n+        if (Float.isNaN(f)) {\n+            return Halffloat.NaN;\n+        }\n+        return Float.floatToFloat16(f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat.java","additions":7,"deletions":27,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -674,1 +674,1 @@\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -690,1 +690,1 @@\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,0 +518,16 @@\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n@@ -553,0 +569,16 @@\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n@@ -690,1 +722,1 @@\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat512Vector.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -666,1 +666,1 @@\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3940,1 +3940,1 @@\n-                short v = (short) lv;\n+                short v = Float.floatToFloat16((float) lv);\n@@ -3942,1 +3942,1 @@\n-                if ((int)v != lv) {\n+                if ((int) Float.float16ToFloat(v) != lv) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -956,2 +956,1 @@\n-#if[FP]\n-#if[short]\n+#if[FP16]\n@@ -968,15 +967,1 @@\n-#else[short]\n-            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n-            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n-            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n-            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n-            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n-            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n-#end[short]\n-#else[FP]\n+#else[FP16]\n@@ -995,1 +980,1 @@\n-#end[FP]\n+#end[FP16]\n@@ -3392,2 +3377,1 @@\n-#if[FP]\n-#if[short]\n+#if[FP16]\n@@ -3402,1 +3386,1 @@\n-#else[short]\n+#else[FP16]\n@@ -3411,11 +3395,1 @@\n-#end[short]\n-#else[FP]\n-            case VECTOR_OP_ADD: return (v, m) ->\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n-            case VECTOR_OP_MUL: return (v, m) ->\n-                    toBits(v.rOp(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n-            case VECTOR_OP_MIN: return (v, m) ->\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n-            case VECTOR_OP_MAX: return (v, m) ->\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n-#end[FP]\n+#end[FP16]\n@@ -5542,0 +5516,7 @@\n+#if[FP16]\n+                $type$ v = Float.floatToFloat16((float) lv);\n+                va[i] = v;\n+                if ((int) Float.float16ToFloat(v) != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+#else[FP16]\n@@ -5547,0 +5528,1 @@\n+#end[FP16]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -543,0 +543,18 @@\n+#if[!16L]\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+#end[!16L]\n@@ -593,0 +611,18 @@\n+#if[!16L]\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+#end[!16L]\n@@ -944,0 +980,3 @@\n+#if[FP16]\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+#else[FP16]\n@@ -945,0 +984,1 @@\n+#end[FP16]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  FPtype=$type\n@@ -127,0 +128,1 @@\n+      FPtype=FP32\n@@ -136,0 +138,1 @@\n+      FPtype=FP64\n@@ -146,0 +149,1 @@\n+      FPtype=FP16\n@@ -150,1 +154,1 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -K$FPtype -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1346,1 +1346,54 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1346,1 +1346,54 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1346,1 +1346,54 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1346,1 +1346,54 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1351,1 +1351,54 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1651,1 +1651,3 @@\n-#if[!Halffloat]\n+#if[Halffloat]\n+    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+#else[Halffloat]\n@@ -1677,0 +1679,1 @@\n+#end[Halffloat]\n@@ -1730,0 +1733,1 @@\n+#if[!Halffloat]\n@@ -1771,2 +1775,0 @@\n-#else[!Halffloat]\n-    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}