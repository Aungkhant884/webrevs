{"files":[{"patch":"@@ -1298,1 +1298,25 @@\n- bool is_CAS(int opcode, bool maybe_volatile);\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline uint vector_length(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length();\n+  }\n+\n+  static inline uint vector_length(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length();\n+  }\n+\n+  bool is_CAS(int opcode, bool maybe_volatile);\n@@ -2403,0 +2427,8 @@\n+    case Op_VectorMaskCmp:\n+    \/\/ We don't have VectorReinterpret with bit_size less than 64 support for\n+    \/\/ now, even for byte type. To be refined with fully VectorCast support.\n+    case Op_VectorReinterpret:\n+      if (vlen < 2 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n@@ -2416,0 +2448,17 @@\n+    \/\/ Some types of VectorCast are not implemented for now.\n+    case Op_VectorCastI2X:\n+      if (bt == T_BYTE) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastS2X:\n+      if (vlen < 4 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2X:\n+    case Op_VectorCastD2X:\n+      if (bt == T_INT || bt == T_SHORT || bt == T_BYTE || bt == T_LONG) {\n+        return false;\n+      }\n+      break;\n@@ -2444,4 +2493,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2515,1 +2560,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -2556,0 +2601,33 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ JDK-8183543: When taking the number of available registers as int\n+  \/\/ register pressure threshold, the jtreg test:\n+  \/\/ test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java\n+  \/\/ failed due to C2 compilation failure with\n+  \/\/ \"COMPILE SKIPPED: failed spill-split-recycle sanity check\".\n+  \/\/\n+  \/\/ A derived pointer is live at CallNode and then is flagged by RA\n+  \/\/ as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip\n+  \/\/ derived pointers and lastly fail to spill after reaching maximum\n+  \/\/ number of iterations. Lowering the default pressure threshold to\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ a high register pressure area of the code so that split_DEF can\n+  \/\/ generate DefinitionSpillCopy for the derived pointer.\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  if (!PreserveFramePointer) {\n+    \/\/ When PreserveFramePointer is off, frame pointer is allocatable,\n+    \/\/ but different from other SOC registers, it is excluded from\n+    \/\/ fatproj's mask because its save type is No-Save. Decrease 1 to\n+    \/\/ ensure high pressure at fatproj when PreserveFramePointer is off.\n+    \/\/ See check_pressure_at_fatproj().\n+    default_int_pressure_threshold--;\n+  }\n+  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ _FLOAT_REG_mask is generated by adlc from the float_reg register class.\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+}\n+\n@@ -3769,4 +3847,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n@@ -3843,4 +3917,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n@@ -5469,0 +5539,9 @@\n+operand pReg()\n+%{\n+  constraint(ALLOC_IN_RC(pr_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -8878,5 +8957,0 @@\n-\n-\/\/ storeLConditional is used by PhaseMacroExpand::expand_lock_node\n-\/\/ when attempting to rebias a lock towards the current thread.  We\n-\/\/ must use the acquire form of cmpxchg in order to guarantee acquire\n-\/\/ semantics in this case.\n@@ -16639,2 +16713,2 @@\n-                              iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n-                              iRegINoSp tmp3, rFlagsReg cr)\n+                             iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n+                             iRegINoSp tmp3, rFlagsReg cr)\n@@ -16643,1 +16717,1 @@\n-  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n+  predicate((UseSVE == 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -16662,1 +16736,1 @@\n-  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  predicate((UseSVE == 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n@@ -16670,2 +16744,2 @@\n-                           $result$$Register, $tmp1$$Register, $tmp2$$Register,\n-                           $tmp3$$Register);\n+                            $result$$Register, $tmp1$$Register, $tmp2$$Register,\n+                            $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":99,"deletions":25,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -5300,0 +5300,169 @@\n+\n+\/\/ vector mask reductions\n+\n+instruct vmask_truecount8B(iRegINoSp dst, vecD src, vecD tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount16B(iRegINoSp dst, vecX src, vecX tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_LT8B(iRegINoSp dst, vecD src, rFlagsReg cr) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  ins_cost(7 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (4I\/4S\/2I)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() == 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(6 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label FIRST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, zr);\n+    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8);\n+\n+    \/\/ Reverse the bits and count the leading zero bytes.\n+    __ bind(FIRST_TRUE_INDEX);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ movw(rscratch1, 7);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label LAST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 16 - 1);\n+    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8 - 1);\n+\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n+    __ bind(LAST_TRUE_INDEX);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2248,0 +2248,148 @@\n+dnl\n+dnl VMASK_TRUECOUNT($1,     $2 )\n+dnl VMASK_TRUECOUNT(suffix, reg)\n+define(`VMASK_TRUECOUNT', `\n+instruct vmask_truecount$1(iRegINoSp dst, $2 src, $2 tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector ($1)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T$1, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`ARGLIST',\n+`ifelse($1, `_LT8B', `iRegINoSp dst, vecD src, rFlagsReg cr', `iRegINoSp dst, vecD src')')\n+dnl\n+dnl VMASK_FIRSTTRUE_D($1,     $2,   $3,   $4  )\n+dnl VMASK_FIRSTTRUE_D(suffix, cond, cost, size)\n+define(`VMASK_FIRSTTRUE_D', `\n+instruct vmask_firsttrue$1(ARGLIST($1)) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() $2 8);\n+  match(Set dst (VectorMaskFirstTrue src));dnl\n+ifelse($1, `_LT8B', `\n+  effect(KILL cr);')\n+  ins_cost($3 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector ($4)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);dnl\n+ifelse(`$1', `_LT8B', `\n+    __ movw(rscratch1, vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+undefine(ARGLIST)dnl\n+dnl\n+\/\/ vector mask reductions\n+VMASK_TRUECOUNT(8B,  vecD)\n+VMASK_TRUECOUNT(16B, vecX)\n+VMASK_FIRSTTRUE_D(_LT8B, <,  7, 4I\/4S\/2I)\n+VMASK_FIRSTTRUE_D(8B,    ==, 4, 8B)\n+\n+instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(6 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label FIRST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, zr);\n+    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8);\n+\n+    \/\/ Reverse the bits and count the leading zero bytes.\n+    __ bind(FIRST_TRUE_INDEX);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ movw(rscratch1, 7);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label LAST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 16 - 1);\n+    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8 - 1);\n+\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n+    __ bind(LAST_TRUE_INDEX);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -94,23 +94,0 @@\n-  static inline BasicType vector_element_basic_type(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline uint vector_length(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->length();\n-  }\n-\n-  static inline uint vector_length(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->length();\n-  }\n@@ -188,0 +165,4 @@\n+      case Op_VectorMaskTrueCount:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskFirstTrue:\n+        return false;\n@@ -3827,0 +3808,40 @@\n+\n+\/\/ Intrisics for String.indexOf(char)\n+\n+\n+instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n+                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), true \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n+                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), false \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -89,23 +89,0 @@\n-  static inline BasicType vector_element_basic_type(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline uint vector_length(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->length();\n-  }\n-\n-  static inline uint vector_length(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->length();\n-  }\n@@ -183,0 +160,4 @@\n+      case Op_VectorMaskTrueCount:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskFirstTrue:\n+        return false;\n@@ -2532,0 +2513,27 @@\n+\n+\/\/ Intrisics for String.indexOf(char)\n+\n+dnl\n+define(`STRING_INDEXOF_CHAR', `\n+instruct string$1_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::$1));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+\n+  format %{ \"String$2 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n+                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), $3 \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}')dnl\n+dnl                 $1 $2      $3\n+STRING_INDEXOF_CHAR(L, Latin1, true)\n+STRING_INDEXOF_CHAR(U, UTF16,  false)\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -158,1 +158,10 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n+\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -180,0 +189,47 @@\n+\/\/ An \"all-purpose\" add\/subtract immediate, per ARM documentation:\n+\/\/ A \"programmer-friendly\" assembler may accept a negative immediate\n+\/\/ between -(2^24 -1) and -1 inclusive, causing it to convert a\n+\/\/ requested ADD operation to a SUB, or vice versa, and then encode\n+\/\/ the absolute value of the immediate as for uimm24.\n+void Assembler::add_sub_immediate(Instruction_aarch64 &current_insn,\n+                                  Register Rd, Register Rn, unsigned uimm, int op,\n+                                  int negated_op) {\n+  bool sets_flags = op & 1;   \/\/ this op sets flags\n+  union {\n+    unsigned u;\n+    int imm;\n+  };\n+  u = uimm;\n+  bool shift = false;\n+  bool neg = imm < 0;\n+  if (neg) {\n+    imm = -imm;\n+    op = negated_op;\n+  }\n+  assert(Rd != sp || imm % 16 == 0, \"misaligned stack\");\n+  if (imm >= (1 << 11)\n+      && ((imm >> 12) << 12 == imm)) {\n+    imm >>= 12;\n+    shift = true;\n+  }\n+  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);\n+\n+  \/\/ add\/subtract immediate ops with the S bit set treat r31 as zr;\n+  \/\/ with S unset they use sp.\n+  if (sets_flags)\n+    zrf(Rd, 0);\n+  else\n+    srf(Rd, 0);\n+\n+  srf(Rn, 5);\n+}\n+\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n@@ -284,37 +340,0 @@\n-\/\/ An \"all-purpose\" add\/subtract immediate, per ARM documentation:\n-\/\/ A \"programmer-friendly\" assembler may accept a negative immediate\n-\/\/ between -(2^24 -1) and -1 inclusive, causing it to convert a\n-\/\/ requested ADD operation to a SUB, or vice versa, and then encode\n-\/\/ the absolute value of the immediate as for uimm24.\n-void Assembler::add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                                  int negated_op) {\n-  bool sets_flags = op & 1;   \/\/ this op sets flags\n-  union {\n-    unsigned u;\n-    int imm;\n-  };\n-  u = uimm;\n-  bool shift = false;\n-  bool neg = imm < 0;\n-  if (neg) {\n-    imm = -imm;\n-    op = negated_op;\n-  }\n-  assert(Rd != sp || imm % 16 == 0, \"misaligned stack\");\n-  if (imm >= (1 << 11)\n-      && ((imm >> 12) << 12 == imm)) {\n-    imm >>= 12;\n-    shift = true;\n-  }\n-  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);\n-\n-  \/\/ add\/subtract immediate ops with the S bit set treat r31 as zr;\n-  \/\/ with S unset they use sp.\n-  if (sets_flags)\n-    zrf(Rd, 0);\n-  else\n-    srf(Rd, 0);\n-\n-  srf(Rn, 5);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":57,"deletions":38,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -250,3 +250,3 @@\n-    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n-    mask <<= lsb;\n-    assert_cond((bits & mask) == 0);\n+    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n+    mask <<= lsb;\n+    assert_cond((bits & mask) == 0);\n@@ -316,1 +316,1 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n@@ -697,40 +697,8 @@\n-  Instruction_aarch64* current;\n-\n-  void set_current(Instruction_aarch64* i) { current = i; }\n-\n-  void f(unsigned val, int msb, int lsb) {\n-    current->f(val, msb, lsb);\n-  }\n-  void f(unsigned val, int msb) {\n-    current->f(val, msb, msb);\n-  }\n-  void sf(int64_t val, int msb, int lsb) {\n-    current->sf(val, msb, lsb);\n-  }\n-  void rf(Register reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void srf(Register reg, int lsb) {\n-    current->srf(reg, lsb);\n-  }\n-  void zrf(Register reg, int lsb) {\n-    current->zrf(reg, lsb);\n-  }\n-  void rf(FloatRegister reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void prf(PRegister reg, int lsb) {\n-    current->prf(reg, lsb);\n-  }\n-  void pgrf(PRegister reg, int lsb) {\n-    current->pgrf(reg, lsb);\n-  }\n-  void fixed(unsigned value, unsigned mask) {\n-    current->fixed(value, mask);\n-  }\n-\n-  void emit() {\n-    emit_long(current->get_insn());\n-    assert_cond(current->get_bits() == 0xffffffff);\n-    current = NULL;\n-  }\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -767,2 +735,2 @@\n-  void add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                         int negated_op);\n+  void add_sub_immediate(Instruction_aarch64 &current_insn, Register Rd, Register Rn,\n+                         unsigned uimm, int op, int negated_op);\n@@ -780,1 +748,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);                    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);      \\\n@@ -793,1 +761,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);     \\\n@@ -1095,1 +1063,1 @@\n-           Register rt = (Register)0b11111) {\n+           Register rt = as_Register(0b11111)) {\n@@ -1364,1 +1332,1 @@\n-    rf((Register)Rt, 0);                                                \\\n+    rf(as_Register(Rt), 0);                                             \\\n@@ -1378,1 +1346,1 @@\n-    rf(Rn, 5), rf((Register)Rt, 0);                                     \\\n+    rf(Rn, 5), rf(as_Register(Rt), 0);                                  \\\n@@ -1411,1 +1379,1 @@\n-      adr.encode_nontemporal_pair(current);\n+      adr.encode_nontemporal_pair(&current_insn);\n@@ -1413,1 +1381,1 @@\n-      adr.encode_pair(current);\n+      adr.encode_pair(&current_insn);\n@@ -1439,1 +1407,2 @@\n-    ld_st1(size, p1, V, L, (Register)Rt1, (Register)Rt2, adr, no_allocate); \\\n+    ld_st1(size, p1, V, L,                                              \\\n+           as_Register(Rt1), as_Register(Rt2), adr, no_allocate);       \\\n@@ -1474,1 +1443,1 @@\n-    adr.encode(current);\n+    adr.encode(&current_insn);\n@@ -1502,1 +1471,1 @@\n-    ld_st2((Register)pfop, adr, size, op);                      \\\n+    ld_st2(as_Register(pfop), adr, size, op);                   \\\n@@ -1513,1 +1482,1 @@\n-    ld_st2((Register)Rt, adr, size, op, 1);             \\\n+    ld_st2(as_Register(Rt), adr, size, op, 1);          \\\n@@ -1552,1 +1521,1 @@\n-  void op_shifted_reg(unsigned decode,\n+  void op_shifted_reg(Instruction_aarch64 &current_insn, unsigned decode,\n@@ -1563,8 +1532,8 @@\n-#define INSN(NAME, size, op, N)                                 \\\n-  void NAME(Register Rd, Register Rn, Register Rm,              \\\n-            enum shift_kind kind = LSL, unsigned shift = 0) {   \\\n-    starti;                                                     \\\n-    guarantee(size == 1 || shift < 32, \"incorrect shift\");      \\\n-    f(N, 21);                                                   \\\n-    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \\\n-    op_shifted_reg(0b01010, kind, shift, size, op);             \\\n+#define INSN(NAME, size, op, N)                                         \\\n+  void NAME(Register Rd, Register Rn, Register Rm,                      \\\n+            enum shift_kind kind = LSL, unsigned shift = 0) {           \\\n+    starti;                                                             \\\n+    guarantee(size == 1 || shift < 32, \"incorrect shift\");              \\\n+    f(N, 21);                                                           \\\n+    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1590,1 +1559,1 @@\n-    op_shifted_reg(0b01010, kind, shift, size, op);                     \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1637,1 +1606,1 @@\n-    op_shifted_reg(0b01011, kind, shift, size, op);     \\\n+    op_shifted_reg(current_insn, 0b01011, kind, shift, size, op);      \\\n@@ -1658,1 +1627,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1661,1 +1630,1 @@\n-  void add_sub_extended_reg(unsigned op, unsigned decode,\n+  void add_sub_extended_reg(Instruction_aarch64 &current_insn, unsigned op, unsigned decode,\n@@ -1681,1 +1650,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1782,1 +1751,1 @@\n-  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) { \\\n+  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) {    \\\n@@ -1798,1 +1767,1 @@\n-  void data_processing(unsigned op29, unsigned opcode,\n+  void data_processing(Instruction_aarch64 &current_insn, unsigned op29, unsigned opcode,\n@@ -1806,5 +1775,5 @@\n-#define INSN(NAME, op29, opcode2, opcode)       \\\n-  void NAME(Register Rd, Register Rn) {         \\\n-    starti;                                     \\\n-    f(opcode2, 20, 16);                         \\\n-    data_processing(op29, opcode, Rd, Rn);      \\\n+#define INSN(NAME, op29, opcode2, opcode)                       \\\n+  void NAME(Register Rd, Register Rn) {                         \\\n+    starti;                                                     \\\n+    f(opcode2, 20, 16);                                         \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1829,5 +1798,5 @@\n-#define INSN(NAME, op29, opcode)                        \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    starti;                                             \\\n-    rf(Rm, 16);                                         \\\n-    data_processing(op29, opcode, Rd, Rn);              \\\n+#define INSN(NAME, op29, opcode)                                \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {            \\\n+    starti;                                                     \\\n+    rf(Rm, 16);                                                 \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1878,3 +1847,3 @@\n-#define INSN(NAME, op54, op31, o0)                      \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    data_processing(op54, op31, o0, Rd, Rn, Rm, (Register)31);  \\\n+#define INSN(NAME, op54, op31, o0)                                      \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {                    \\\n+    data_processing(op54, op31, o0, Rd, Rn, Rm, as_Register(31));       \\\n@@ -2059,1 +2028,1 @@\n-    float_int_convert(op31, type, rmode, opcode, Rd, (Register)Vn);     \\\n+    float_int_convert(op31, type, rmode, opcode, Rd, as_Register(Vn));  \\\n@@ -2070,1 +2039,1 @@\n-  \/\/ INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n+  INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n@@ -2076,1 +2045,1 @@\n-    float_int_convert(op31, type, rmode, opcode, (Register)Vd, Rn);     \\\n+    float_int_convert(op31, type, rmode, opcode, as_Register(Vd), Rn);  \\\n@@ -2131,1 +2100,1 @@\n-                     FloatRegister Vn, FloatRegister Vm = (FloatRegister)0) {\n+                     FloatRegister Vn, FloatRegister Vm = as_FloatRegister(0)) {\n@@ -2261,4 +2230,4 @@\n-#define INSN(NAME, op)                                            \\\n-  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {   \\\n-    ld_st2((Register)Rt, adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n-  }                                                                      \\\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {  \\\n+    ld_st2(as_Register(Rt), adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n+  }\n@@ -3308,2 +3277,2 @@\n-    f(op, 31, 24), f(T, 23, 22), f(0b0, 21), rf(Zm, 16), f((cond >> 1) & 0x7, 15, 13);            \\\n-    pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0);                                        \\\n+    f(op, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);                \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond & 1, 4), prf(Pd, 0);                                          \\\n@@ -3312,8 +3281,8 @@\n-  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);\n-  INSN(sve_cmpne, 0b00100100, 0b1011, 0);\n-  INSN(sve_cmpge, 0b00100100, 0b1000, 0);\n-  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);\n-  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);\n-  INSN(sve_fcmne, 0b01100101, 0b0111, 1);\n-  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);\n-  INSN(sve_fcmge, 0b01100101, 0b0100, 1);\n+  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);  \/\/ Compare signed equal to vector\n+  INSN(sve_cmpne, 0b00100100, 0b1011, 0);  \/\/ Compare not equal to vector\n+  INSN(sve_cmpge, 0b00100100, 0b1000, 0);  \/\/ Compare signed greater than or equal to vector\n+  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);  \/\/ Compare signed greater than vector\n+  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);  \/\/ Floating-point compare vectors: Equal\n+  INSN(sve_fcmne, 0b01100101, 0b0111, 1);  \/\/ Floating-point compare vectors: Not Equal\n+  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);  \/\/ Floating-point compare vectors: Greater than\n+  INSN(sve_fcmge, 0b01100101, 0b0100, 1);  \/\/ Floating-point compare vectors: Greater than or equal\n@@ -3368,2 +3337,2 @@\n-\/\/ SVE while[cond]\n-#define INSN(NAME, decode, sf)                                            \\\n+\/\/ Predicate counted loop (SVE) (32-bit variants are not included)\n+#define INSN(NAME, decode)                                                \\\n@@ -3374,2 +3343,2 @@\n-    zrf(Rm, 16), f(0, 15, 13), f(sf, 12), f(decode >> 1, 11, 10),         \\\n-    zrf(Rn, 5), f(decode & 0b1, 4), prf(Pd, 0);                           \\\n+    zrf(Rm, 16), f(0, 15, 13), f(1, 12), f(decode >> 1, 11, 10),          \\\n+    zrf(Rn, 5), f(decode & 1, 4), prf(Pd, 0);                             \\\n@@ -3378,8 +3347,4 @@\n-  INSN(sve_whilelt,  0b010, 1);\n-  INSN(sve_whileltw, 0b010, 0);\n-  INSN(sve_whilele,  0b011, 1);\n-  INSN(sve_whilelew, 0b011, 0);\n-  INSN(sve_whilelo,  0b110, 1);\n-  INSN(sve_whilelow, 0b110, 0);\n-  INSN(sve_whilels,  0b111, 1);\n-  INSN(sve_whilelsw, 0b111, 0);\n+  INSN(sve_whilelt, 0b010);  \/\/ While incrementing signed scalar less than scalar\n+  INSN(sve_whilele, 0b011);  \/\/ While incrementing signed scalar less than or equal to scalar\n+  INSN(sve_whilelo, 0b110);  \/\/ While incrementing unsigned scalar lower than scalar\n+  INSN(sve_whilels, 0b111);  \/\/ While incrementing unsigned scalar lower than or the same as scalar\n@@ -3388,0 +3353,33 @@\n+  \/\/ Predicate scan (SVE)\n+\n+  \/\/ Break after the first true condition\n+  void sve_brka(PRegister pd, PRegister pg, PRegister pn, bool isMerge) {\n+    starti;\n+    f(0b00100101, 31, 24), f(0b00, 23, 22), f(0b01000001, 21, 14),\n+    prf(pg, 10), f(0b0, 9), prf(pn, 5), f(isMerge ? 1 : 0, 4), prf(pd, 0);\n+  }\n+\n+\/\/ Element count and increment scalar (SVE)\n+#define INSN(NAME, TYPE)                                                             \\\n+  void NAME(Register Xdn, unsigned imm4 = 1, int pattern = 0b11111) {                \\\n+    starti;                                                                          \\\n+    f(0b00000100, 31, 24), f(TYPE, 23, 22), f(0b10, 21, 20);                         \\\n+    f(imm4 - 1, 19, 16), f(0b11100, 15, 11), f(0, 10), f(pattern, 9, 5), rf(Xdn, 0); \\\n+  }\n+\n+  INSN(sve_cntb, B);  \/\/ Set scalar to multiple of 8-bit predicate constraint element count\n+  INSN(sve_cnth, H);  \/\/ Set scalar to multiple of 16-bit predicate constraint element count\n+  INSN(sve_cntw, S);  \/\/ Set scalar to multiple of 32-bit predicate constraint element count\n+  INSN(sve_cntd, D);  \/\/ Set scalar to multiple of 64-bit predicate constraint element count\n+#undef INSN\n+\n+  \/\/ Predicate count and increment scalar (SVE)\n+\n+  \/\/ Set scalar to the number of Active predicate elements that are TRUE\n+  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n+    prf(pg, 5), rf(rd, 0);\n+  }\n+\n@@ -3518,1 +3516,2 @@\n-  assem->emit();\n+  assem->emit_int32(insn);\n+  assert_cond(get_bits() == 0xffffffff);\n@@ -3521,0 +3520,9 @@\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n@@ -3528,2 +3536,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":125,"deletions":119,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -543,0 +543,69 @@\n+void C2_MacroAssembler::string_indexof_char_sve(Register str1, Register cnt1,\n+                                                Register ch, Register result,\n+                                                FloatRegister ztmp1,\n+                                                FloatRegister ztmp2,\n+                                                PRegister tmp_pg,\n+                                                PRegister tmp_pdn, bool isL)\n+{\n+  \/\/ Note that `tmp_pdn` should *NOT* be used as governing predicate register.\n+  assert(tmp_pg->is_governing(),\n+         \"this register has to be a governing predicate register\");\n+\n+  Label LOOP, MATCH, DONE, NOMATCH;\n+  Register vec_len = rscratch1;\n+  Register idx = rscratch2;\n+\n+  SIMD_RegVariant T = (isL == true) ? B : H;\n+\n+  cbz(cnt1, NOMATCH);\n+\n+  \/\/ Assign the particular char throughout the vector.\n+  sve_dup(ztmp2, T, ch);\n+  if (isL) {\n+    sve_cntb(vec_len);\n+  } else {\n+    sve_cnth(vec_len);\n+  }\n+  mov(idx, 0);\n+\n+  \/\/ Generate a predicate to control the reading of input string.\n+  sve_whilelt(tmp_pg, T, idx, cnt1);\n+\n+  BIND(LOOP);\n+    \/\/ Read a vector of 8- or 16-bit data depending on the string type. Note\n+    \/\/ that inactive elements indicated by the predicate register won't cause\n+    \/\/ a data read from memory to the destination vector.\n+    if (isL) {\n+      sve_ld1b(ztmp1, T, tmp_pg, Address(str1, idx));\n+    } else {\n+      sve_ld1h(ztmp1, T, tmp_pg, Address(str1, idx, Address::lsl(1)));\n+    }\n+    add(idx, idx, vec_len);\n+\n+    \/\/ Perform the comparison. An element of the destination predicate is set\n+    \/\/ to active if the particular char is matched.\n+    sve_cmpeq(tmp_pdn, T, tmp_pg, ztmp1, ztmp2);\n+\n+    \/\/ Branch if the particular char is found.\n+    br(NE, MATCH);\n+\n+    sve_whilelt(tmp_pg, T, idx, cnt1);\n+\n+    \/\/ Loop back if the particular char not found.\n+    br(MI, LOOP);\n+\n+  BIND(NOMATCH);\n+    mov(result, -1);\n+    b(DONE);\n+\n+  BIND(MATCH);\n+    \/\/ Undo the index increment.\n+    sub(idx, idx, vec_len);\n+\n+    \/\/ Crop the vector to find its location.\n+    sve_brka(tmp_pdn, tmp_pg, tmp_pdn, false \/* isMerge *\/);\n+    add(result, idx, -1);\n+    sve_incp(result, T, tmp_pdn);\n+  BIND(DONE);\n+}\n+\n@@ -837,0 +906,42 @@\n+void C2_MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                                     FloatRegister src2, int cond, bool isQ) {\n+  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        fcmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        cmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: cmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n+      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n+      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n+      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n+      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -49,2 +49,11 @@\n-                           Register ch, Register result,\n-                           Register tmp1, Register tmp2, Register tmp3);\n+                            Register ch, Register result,\n+                            Register tmp1, Register tmp2, Register tmp3);\n+\n+  void string_indexof_char_sve(Register str1, Register cnt1,\n+                               Register ch, Register result,\n+                               FloatRegister ztmp1, FloatRegister ztmp2,\n+                               PRegister pgtmp, PRegister ptmp, bool isL);\n+\n+  \/\/ SIMD&FP comparison\n+  void neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                    FloatRegister src2, int cond, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -445,172 +444,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg);\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL)\n-    counters = BiasedLocking::counters();\n-\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());\n-  Address saved_mark_addr(lock_reg, 0);\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::NE, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_prototype_header(tmp_reg, obj_reg);\n-  orr(tmp_reg, tmp_reg, rthread);\n-  eor(tmp_reg, swap_reg, tmp_reg);\n-  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    Label around;\n-    cbnz(tmp_reg, around);\n-    atomic_incw(Address((address)counters->biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);\n-    b(done);\n-    bind(around);\n-  } else {\n-    cbz(tmp_reg, done);\n-  }\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cbnz(rscratch1, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n-  cbnz(rscratch1, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  {\n-    Label here;\n-    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-    andr(swap_reg, swap_reg, rscratch1);\n-    orr(tmp_reg, swap_reg, rthread);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, this means that\n-    \/\/ another thread succeeded in biasing it toward itself and we\n-    \/\/ need to revoke that bias. The revocation will occur in the\n-    \/\/ interpreter runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->anonymously_biased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    orr(tmp_reg, rthread, tmp_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, then another thread\n-    \/\/ succeeded in biasing it toward itself and we need to revoke that\n-    \/\/ bias. The revocation will occur in the runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->rebiased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here, nope;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &nope);\n-    bind(here);\n-\n-    \/\/ Fall through to the normal CAS-based lock, because no matter what\n-    \/\/ the result of the above CAS, some thread must have succeeded in\n-    \/\/ removing the bias bit from the object's header.\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->revoked_lock_entry_count_addr()), tmp_reg,\n-                  rscratch1, rscratch2);\n-    }\n-    bind(nope);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(temp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::EQ, done);\n-}\n-\n@@ -3840,5 +3667,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src) {\n-  load_klass(dst, src);\n-  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n@@ -5344,43 +5166,0 @@\n-void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n-                                  FloatRegister src2, int cond, bool isQ) {\n-  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        fcmeq(dst, size, src1, src2);\n-        notr(dst, T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  } else {\n-    switch (cond) {\n-      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        cmeq(dst, size, src1, src2);\n-        notr(dst, T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: cmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n-      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n-      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n-      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n-      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":221,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -1838,0 +1838,5 @@\n+    case Op_VectorMaskCmp:\n+      if (vlen < 2 || size_in_bits < 32) {\n+        return false;\n+      }\n+      break;\n@@ -1871,1 +1876,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1875,0 +1880,8 @@\n+    case MoveF2VL_rule:\n+    case MoveF2LEG_rule:\n+    case MoveVL2F_rule:\n+    case MoveLEG2F_rule:\n+    case MoveD2VL_rule:\n+    case MoveD2LEG_rule:\n+    case MoveVL2D_rule:\n+    case MoveLEG2D_rule:\n@@ -1901,12 +1914,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  int float_pressure_threshold = default_pressure_threshold;\n-#ifdef _LP64\n-  if (UseAVX > 2) {\n-    \/\/ Increase pressure threshold on machines with AVX3 which have\n-    \/\/ 2x more XMM registers.\n-    float_pressure_threshold = default_pressure_threshold * 2;\n-  }\n-#endif\n-  return float_pressure_threshold;\n-}\n-\n@@ -4847,1 +4848,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4880,1 +4882,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4914,1 +4917,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4947,1 +4951,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4980,1 +4985,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5013,1 +5019,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5048,1 +5055,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5082,1 +5090,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5115,1 +5124,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5149,1 +5159,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5182,1 +5193,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5215,1 +5227,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5363,1 +5376,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5397,1 +5411,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5421,1 +5436,2 @@\n-  predicate(VM_Version::supports_avx512dq());\n+  predicate(VM_Version::supports_avx512dq() &&\n+              (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5506,1 +5522,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5539,1 +5556,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5610,1 +5628,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5643,1 +5662,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5827,0 +5847,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -5850,0 +5871,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -6462,1 +6484,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6496,1 +6519,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6530,1 +6554,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6576,1 +6601,1 @@\n-  predicate(UseAVX <= 2 &&\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vlbw()) &&\n@@ -6592,1 +6617,1 @@\n-  predicate(UseAVX <= 2 &&\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vlbw()) &&\n@@ -6610,1 +6635,1 @@\n-  predicate(UseAVX > 2 ||\n+  predicate((UseAVX > 2 && VM_Version::supports_avx512vlbw()) ||\n@@ -6725,1 +6750,1 @@\n-        __ vcvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister, dst_vlen_enc);\n+        __ vcvtdq2ps($dst$$XMMRegister, $src$$XMMRegister, dst_vlen_enc);\n@@ -6731,1 +6756,1 @@\n-        __ vcvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister, dst_vlen_enc);\n+        __ vcvtdq2pd($dst$$XMMRegister, $src$$XMMRegister, dst_vlen_enc);\n@@ -6897,1 +6922,1 @@\n-            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n@@ -7434,1 +7459,16 @@\n-instruct loadMask(vec dst, vec src) %{\n+instruct loadMask(legVec dst, legVec src) %{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP dst);\n+  format %{ \"vector_loadmask_byte $dst,$src\\n\\t\" %}\n+  ins_encode %{\n+    int vlen_in_bytes = vector_length_in_bytes(this);\n+    BasicType elem_bt = vector_element_basic_type(this);\n+\n+    __ load_vector_mask($dst$$XMMRegister, $src$$XMMRegister, vlen_in_bytes, elem_bt, true);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct loadMask_evex(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n@@ -7442,1 +7482,1 @@\n-    __ load_vector_mask($dst$$XMMRegister, $src$$XMMRegister, vlen_in_bytes, elem_bt);\n+    __ load_vector_mask($dst$$XMMRegister, $src$$XMMRegister, vlen_in_bytes, elem_bt, false);\n@@ -7951,0 +7991,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -7975,0 +8016,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -8052,0 +8094,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)->in(1)) > 8);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":86,"deletions":43,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -435,0 +435,1 @@\n+  remove_useless_coarsened_locks(useful);            \/\/ remove useless coarsened locks nodes\n@@ -504,0 +505,6 @@\n+  if ((_do_locks_coarsening != EliminateLocks) && PrintOpto) {\n+    \/\/ Recompiling without locks coarsening\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without locks coarsening         **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -531,1 +538,2 @@\n-                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, bool install_code, DirectiveSet* directive)\n+                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing,\n+                  bool do_locks_coarsening, bool install_code, DirectiveSet* directive)\n@@ -538,0 +546,1 @@\n+                  _do_locks_coarsening(do_locks_coarsening),\n@@ -569,0 +578,1 @@\n+                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n@@ -835,0 +845,1 @@\n+    _do_locks_coarsening(false),\n@@ -4128,1 +4139,1 @@\n-    value = new CastIINode(value, itype, carry_dependency, true \/* range check dependency *\/);\n+    value = new CastIINode(value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n@@ -4451,0 +4462,97 @@\n+\/**\n+ * Track coarsened Lock and Unlock nodes.\n+ *\/\n+\n+class Lock_List : public Node_List {\n+  uint _origin_cnt;\n+public:\n+  Lock_List(Arena *a, uint cnt) : Node_List(a), _origin_cnt(cnt) {}\n+  uint origin_cnt() const { return _origin_cnt; }\n+};\n+\n+void Compile::add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks) {\n+  int length = locks.length();\n+  if (length > 0) {\n+    \/\/ Have to keep this list until locks elimination during Macro nodes elimination.\n+    Lock_List* locks_list = new (comp_arena()) Lock_List(comp_arena(), length);\n+    for (int i = 0; i < length; i++) {\n+      AbstractLockNode* lock = locks.at(i);\n+      assert(lock->is_coarsened(), \"expecting only coarsened AbstractLock nodes, but got '%s'[%d] node\", lock->Name(), lock->_idx);\n+      locks_list->push(lock);\n+    }\n+    _coarsened_locks.append(locks_list);\n+  }\n+}\n+\n+void Compile::remove_useless_coarsened_locks(Unique_Node_List& useful) {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    for (uint j = 0; j < locks_list->size(); j++) {\n+      Node* lock = locks_list->at(j);\n+      assert(lock->is_AbstractLock(), \"sanity\");\n+      if (!useful.member(lock)) {\n+        locks_list->yank(lock);\n+      }\n+    }\n+  }\n+}\n+\n+void Compile::remove_coarsened_lock(Node* n) {\n+  if (n->is_AbstractLock()) {\n+    int count = coarsened_count();\n+    for (int i = 0; i < count; i++) {\n+      Node_List* locks_list = _coarsened_locks.at(i);\n+      locks_list->yank(n);\n+    }\n+  }\n+}\n+\n+bool Compile::coarsened_locks_consistent() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    bool unbalanced = false;\n+    bool modified = false; \/\/ track locks kind modifications\n+    Lock_List* locks_list = (Lock_List*)_coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size == 0) {\n+      unbalanced = false; \/\/ All locks were eliminated - good\n+    } else if (size != locks_list->origin_cnt()) {\n+      unbalanced = true; \/\/ Some locks were removed from list\n+    } else {\n+      for (uint j = 0; j < size; j++) {\n+        Node* lock = locks_list->at(j);\n+        \/\/ All nodes in group should have the same state (modified or not)\n+        if (!lock->as_AbstractLock()->is_coarsened()) {\n+          if (j == 0) {\n+            \/\/ first on list was modified, the rest should be too for consistency\n+            modified = true;\n+          } else if (!modified) {\n+            \/\/ this lock was modified but previous locks on the list were not\n+            unbalanced = true;\n+            break;\n+          }\n+        } else if (modified) {\n+          \/\/ previous locks on list were modified but not this lock\n+          unbalanced = true;\n+          break;\n+        }\n+      }\n+    }\n+    if (unbalanced) {\n+      \/\/ unbalanced monitor enter\/exit - only some [un]lock nodes were removed or modified\n+#ifdef ASSERT\n+      if (PrintEliminateLocks) {\n+        tty->print_cr(\"=== unbalanced coarsened locks ===\");\n+        for (uint l = 0; l < size; l++) {\n+          locks_list->at(l)->dump();\n+        }\n+      }\n+#endif\n+      record_failure(C2Compiler::retry_no_locks_coarsening());\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -4477,4 +4585,6 @@\n-      uint max = n->len();\n-      for( uint i = 0; i < max; ++i ) {\n-        Node *m = n->in(i);\n-        if (not_a_node(m))  continue;\n+      \/\/ Iterate over outs - endless loops is unreachable from below\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node *m = n->fast_out(i);\n+        if (not_a_node(m)) {\n+          continue;\n+        }\n@@ -4501,4 +4611,6 @@\n-      uint max = n->len();\n-      for( uint i = 0; i < max; ++i ) {\n-        Node *m = n->in(i);\n-        if (not_a_node(m))  continue;\n+      \/\/ Iterate over outs - endless loops is unreachable from below\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node *m = n->fast_out(i);\n+        if (not_a_node(m)) {\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":122,"deletions":10,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -414,3 +414,0 @@\n-  if (num_elem < 4)\n-    return false;\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-    assert(mask->Opcode() == Op_VectorStoreMask, \"\");\n+    assert(mask->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN, \"\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1202,1 +1202,1 @@\n-\/\/ Default hash\/equals functions used by ResourceHashtable and KVHashtable\n+\/\/ Default hash\/equals functions used by ResourceHashtable\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -911,1 +911,8 @@\n-           self._merge = \"\/m\"\n+           assert len(args) > 2, \"Must specify predicate type\"\n+           for arg in args[2:]:\n+              if arg == 'm':\n+                 self._merge = \"\/m\"\n+              elif arg == 'z':\n+                 self._merge = \"\/z\"\n+              else:\n+                 assert arg == \"dn\", \"Unknown predicate type\"\n@@ -914,1 +921,1 @@\n-           self._merge =\"\"\n+           self._merge = \"\"\n@@ -924,0 +931,2 @@\n+\n+        self._dnm = None\n@@ -925,3 +934,4 @@\n-            self._dnm = args[2]\n-        else:\n-            self._dnm = None\n+           for arg in args[2:]:\n+             if arg == \"dn\":\n+               self._dnm = arg\n+\n@@ -1526,0 +1536,1 @@\n+                        [\"fmov\",   \"__ fmovhid(r0, v1);\",                                \"fmov\\tx0, v1.d[1]\"],\n@@ -1575,0 +1586,11 @@\n+                        [\"cntb\",   \"__ sve_cntb(r9);\",                                   \"cntb\\tx9\"],\n+                        [\"cnth\",   \"__ sve_cnth(r10);\",                                  \"cnth\\tx10\"],\n+                        [\"cntw\",   \"__ sve_cntw(r11);\",                                  \"cntw\\tx11\"],\n+                        [\"cntd\",   \"__ sve_cntd(r12);\",                                  \"cntd\\tx12\"],\n+                        [\"brka\",   \"__ sve_brka(p2, p0, p2, false);\",                    \"brka\\tp2.b, p0\/z, p2.b\"],\n+                        [\"brka\",   \"__ sve_brka(p1, p2, p3, true);\",                     \"brka\\tp1.b, p2\/m, p3.b\"],\n+                        [\"incp\",   \"__ sve_incp(r0, __ B, p2);\",                         \"incp\\tx0, p2.b\"],\n+                        [\"whilelt\",   \"__ sve_whilelt(p0, __ B, r1, r28);\",              \"whilelt\\tp0.b, x1, x28\"],\n+                        [\"whilele\",   \"__ sve_whilele(p2, __ H, r11, r8);\",              \"whilele\\tp2.h, x11, x8\"],\n+                        [\"whilelo\",   \"__ sve_whilelo(p3, __ S, r7, r2);\",               \"whilelo\\tp3.s, x7, x2\"],\n+                        [\"whilels\",   \"__ sve_whilels(p4, __ D, r17, r10);\",             \"whilels\\tp4.d, x17, x10\"],\n@@ -1599,8 +1621,0 @@\n-                        [\"whilelt\", \"__ sve_whilelt(p0, __ B, r1, r2);\",                  \"whilelt\\tp0.b, x1, x2\"],\n-                        [\"whilelt\", \"__ sve_whileltw(p1, __ H, r3, r4);\",                 \"whilelt\\tp1.h, w3, w4\"],\n-                        [\"whilele\", \"__ sve_whilele(p2, __ S, r5, r6);\",                  \"whilele\\tp2.s, x5, x6\"],\n-                        [\"whilele\", \"__ sve_whilelew(p3, __ D, r10, r11);\",               \"whilele\\tp3.d, w10, w11\"],\n-                        [\"whilelo\", \"__ sve_whilelo(p4, __ B, r1, r2);\",                  \"whilelo\\tp4.b, x1, x2\"],\n-                        [\"whilelo\", \"__ sve_whilelow(p0, __ H, r3, r4);\",                 \"whilelo\\tp0.h, w3, w4\"],\n-                        [\"whilels\", \"__ sve_whilels(p1, __ S, r5, r6);\",                  \"whilels\\tp1.s, x5, x6\"],\n-                        [\"whilels\", \"__ sve_whilelsw(p2, __ D, r10, r11);\",               \"whilels\\tp2.d, w10, w11\"],\n@@ -1667,30 +1681,30 @@\n-                       [\"abs\", \"ZPZ\"],\n-                       [\"add\", \"ZPZ\", \"dn\"],\n-                       [\"asr\", \"ZPZ\", \"dn\"],\n-                       [\"cnt\", \"ZPZ\"],\n-                       [\"lsl\", \"ZPZ\", \"dn\"],\n-                       [\"lsr\", \"ZPZ\", \"dn\"],\n-                       [\"mul\", \"ZPZ\", \"dn\"],\n-                       [\"neg\", \"ZPZ\"],\n-                       [\"not\", \"ZPZ\"],\n-                       [\"smax\", \"ZPZ\", \"dn\"],\n-                       [\"smin\", \"ZPZ\", \"dn\"],\n-                       [\"sub\", \"ZPZ\", \"dn\"],\n-                       [\"fabs\", \"ZPZ\"],\n-                       [\"fadd\", \"ZPZ\", \"dn\"],\n-                       [\"fdiv\", \"ZPZ\", \"dn\"],\n-                       [\"fmax\", \"ZPZ\", \"dn\"],\n-                       [\"fmin\", \"ZPZ\", \"dn\"],\n-                       [\"fmul\", \"ZPZ\", \"dn\"],\n-                       [\"fneg\", \"ZPZ\"],\n-                       [\"frintm\", \"ZPZ\"],\n-                       [\"frintn\", \"ZPZ\"],\n-                       [\"frintp\", \"ZPZ\"],\n-                       [\"fsqrt\", \"ZPZ\"],\n-                       [\"fsub\", \"ZPZ\", \"dn\"],\n-                       [\"fmla\", \"ZPZZ\"],\n-                       [\"fmls\", \"ZPZZ\"],\n-                       [\"fnmla\", \"ZPZZ\"],\n-                       [\"fnmls\", \"ZPZZ\"],\n-                       [\"mla\", \"ZPZZ\"],\n-                       [\"mls\", \"ZPZZ\"],\n+                       [\"abs\", \"ZPZ\", \"m\"],\n+                       [\"add\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"asr\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"cnt\", \"ZPZ\", \"m\"],\n+                       [\"lsl\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"lsr\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"mul\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"neg\", \"ZPZ\", \"m\"],\n+                       [\"not\", \"ZPZ\", \"m\"],\n+                       [\"smax\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"smin\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"sub\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fabs\", \"ZPZ\", \"m\"],\n+                       [\"fadd\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fdiv\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmax\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmin\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmul\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fneg\", \"ZPZ\", \"m\"],\n+                       [\"frintm\", \"ZPZ\", \"m\"],\n+                       [\"frintn\", \"ZPZ\", \"m\"],\n+                       [\"frintp\", \"ZPZ\", \"m\"],\n+                       [\"fsqrt\", \"ZPZ\", \"m\"],\n+                       [\"fsub\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmla\", \"ZPZZ\", \"m\"],\n+                       [\"fmls\", \"ZPZZ\", \"m\"],\n+                       [\"fnmla\", \"ZPZZ\", \"m\"],\n+                       [\"fnmls\", \"ZPZZ\", \"m\"],\n+                       [\"mla\", \"ZPZZ\", \"m\"],\n+                       [\"mls\", \"ZPZZ\", \"m\"],\n@@ -1701,0 +1715,4 @@\n+                       [\"cmpeq\", \"PPZZ\", \"z\"],\n+                       [\"cmpge\", \"PPZZ\", \"z\"],\n+                       [\"cmpgt\", \"PPZZ\", \"z\"],\n+                       [\"cmpne\", \"PPZZ\", \"z\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":61,"deletions":43,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -726,0 +726,1 @@\n+    __ fmovhid(r0, v1);                                \/\/       fmov    x0, v1.d[1]\n@@ -774,0 +775,11 @@\n+    __ sve_cntb(r9);                                   \/\/       cntb    x9\n+    __ sve_cnth(r10);                                  \/\/       cnth    x10\n+    __ sve_cntw(r11);                                  \/\/       cntw    x11\n+    __ sve_cntd(r12);                                  \/\/       cntd    x12\n+    __ sve_brka(p2, p0, p2, false);                    \/\/       brka    p2.b, p0\/z, p2.b\n+    __ sve_brka(p1, p2, p3, true);                     \/\/       brka    p1.b, p2\/m, p3.b\n+    __ sve_incp(r0, __ B, p2);                         \/\/       incp    x0, p2.b\n+    __ sve_whilelt(p0, __ B, r1, r28);                 \/\/       whilelt p0.b, x1, x28\n+    __ sve_whilele(p2, __ H, r11, r8);                 \/\/       whilele p2.h, x11, x8\n+    __ sve_whilelo(p3, __ S, r7, r2);                  \/\/       whilelo p3.s, x7, x2\n+    __ sve_whilels(p4, __ D, r17, r10);                \/\/       whilels p4.d, x17, x10\n@@ -798,8 +810,0 @@\n-    __ sve_whilelt(p0, __ B, r1, r2);                  \/\/       whilelt p0.b, x1, x2\n-    __ sve_whileltw(p1, __ H, r3, r4);                 \/\/       whilelt p1.h, w3, w4\n-    __ sve_whilele(p2, __ S, r5, r6);                  \/\/       whilele p2.s, x5, x6\n-    __ sve_whilelew(p3, __ D, r10, r11);               \/\/       whilele p3.d, w10, w11\n-    __ sve_whilelo(p4, __ B, r1, r2);                  \/\/       whilelo p4.b, x1, x2\n-    __ sve_whilelow(p0, __ H, r3, r4);                 \/\/       whilelo p0.h, w3, w4\n-    __ sve_whilels(p1, __ S, r5, r6);                  \/\/       whilels p1.s, x5, x6\n-    __ sve_whilelsw(p2, __ D, r10, r11);               \/\/       whilels p2.d, w10, w11\n@@ -1006,2 +1010,6 @@\n-    __ sve_uzp1(z21, __ S, z24, z5);                   \/\/       uzp1    z21.s, z24.s, z5.s\n-    __ sve_uzp2(z21, __ S, z17, z22);                  \/\/       uzp2    z21.s, z17.s, z22.s\n+    __ sve_cmpeq(p5, __ S, p6, z5, z19);               \/\/       cmpeq   p5.s, p6\/z, z5.s, z19.s\n+    __ sve_cmpge(p4, __ S, p5, z16, z29);              \/\/       cmpge   p4.s, p5\/z, z16.s, z29.s\n+    __ sve_cmpgt(p5, __ D, p0, z4, z17);               \/\/       cmpgt   p5.d, p0\/z, z4.d, z17.d\n+    __ sve_cmpne(p1, __ D, p5, z4, z23);               \/\/       cmpne   p1.d, p5\/z, z4.d, z23.d\n+    __ sve_uzp1(z19, __ H, z2, z8);                    \/\/       uzp1    z19.h, z2.h, z8.h\n+    __ sve_uzp2(z14, __ D, z24, z17);                  \/\/       uzp2    z14.d, z24.d, z17.d\n@@ -1010,9 +1018,9 @@\n-    __ sve_andv(v29, __ B, p5, z19);                   \/\/       andv b29, p5, z19.b\n-    __ sve_orv(v4, __ B, p4, z23);                     \/\/       orv b4, p4, z23.b\n-    __ sve_eorv(v19, __ D, p1, z23);                   \/\/       eorv d19, p1, z23.d\n-    __ sve_smaxv(v19, __ H, p0, z8);                   \/\/       smaxv h19, p0, z8.h\n-    __ sve_sminv(v14, __ D, p6, z17);                  \/\/       sminv d14, p6, z17.d\n-    __ sve_fminv(v21, __ S, p1, z30);                  \/\/       fminv s21, p1, z30.s\n-    __ sve_fmaxv(v10, __ S, p5, z12);                  \/\/       fmaxv s10, p5, z12.s\n-    __ sve_fadda(v9, __ D, p1, z24);                   \/\/       fadda d9, p1, d9, z24.d\n-    __ sve_uaddv(v4, __ H, p6, z6);                    \/\/       uaddv d4, p6, z6.h\n+    __ sve_andv(v21, __ B, p1, z30);                   \/\/       andv b21, p1, z30.b\n+    __ sve_orv(v10, __ B, p5, z12);                    \/\/       orv b10, p5, z12.b\n+    __ sve_eorv(v9, __ S, p1, z24);                    \/\/       eorv s9, p1, z24.s\n+    __ sve_smaxv(v4, __ H, p6, z6);                    \/\/       smaxv h4, p6, z6.h\n+    __ sve_sminv(v27, __ S, p6, z13);                  \/\/       sminv s27, p6, z13.s\n+    __ sve_fminv(v30, __ D, p5, z22);                  \/\/       fminv d30, p5, z22.d\n+    __ sve_fmaxv(v30, __ S, p7, z9);                   \/\/       fmaxv s30, p7, z9.s\n+    __ sve_fadda(v19, __ D, p1, z20);                  \/\/       fadda d19, p1, d19, z20.d\n+    __ sve_uaddv(v9, __ H, p2, z13);                   \/\/       uaddv d9, p2, z13.h\n@@ -1037,7 +1045,7 @@\n-    0x14000000,     0x17ffffd7,     0x14000344,     0x94000000,\n-    0x97ffffd4,     0x94000341,     0x3400000a,     0x34fffa2a,\n-    0x340067ca,     0x35000008,     0x35fff9c8,     0x35006768,\n-    0xb400000b,     0xb4fff96b,     0xb400670b,     0xb500001d,\n-    0xb5fff91d,     0xb50066bd,     0x10000013,     0x10fff8b3,\n-    0x10006653,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363065d6,     0x3758000c,     0x375ff7cc,     0x3758656c,\n+    0x14000000,     0x17ffffd7,     0x1400034c,     0x94000000,\n+    0x97ffffd4,     0x94000349,     0x3400000a,     0x34fffa2a,\n+    0x340068ca,     0x35000008,     0x35fff9c8,     0x35006868,\n+    0xb400000b,     0xb4fff96b,     0xb400680b,     0xb500001d,\n+    0xb5fff91d,     0xb50067bd,     0x10000013,     0x10fff8b3,\n+    0x10006753,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363066d6,     0x3758000c,     0x375ff7cc,     0x3758666c,\n@@ -1048,13 +1056,13 @@\n-    0x54006340,     0x54000001,     0x54fff541,     0x540062e1,\n-    0x54000002,     0x54fff4e2,     0x54006282,     0x54000002,\n-    0x54fff482,     0x54006222,     0x54000003,     0x54fff423,\n-    0x540061c3,     0x54000003,     0x54fff3c3,     0x54006163,\n-    0x54000004,     0x54fff364,     0x54006104,     0x54000005,\n-    0x54fff305,     0x540060a5,     0x54000006,     0x54fff2a6,\n-    0x54006046,     0x54000007,     0x54fff247,     0x54005fe7,\n-    0x54000008,     0x54fff1e8,     0x54005f88,     0x54000009,\n-    0x54fff189,     0x54005f29,     0x5400000a,     0x54fff12a,\n-    0x54005eca,     0x5400000b,     0x54fff0cb,     0x54005e6b,\n-    0x5400000c,     0x54fff06c,     0x54005e0c,     0x5400000d,\n-    0x54fff00d,     0x54005dad,     0x5400000e,     0x54ffefae,\n-    0x54005d4e,     0x5400000f,     0x54ffef4f,     0x54005cef,\n+    0x54006440,     0x54000001,     0x54fff541,     0x540063e1,\n+    0x54000002,     0x54fff4e2,     0x54006382,     0x54000002,\n+    0x54fff482,     0x54006322,     0x54000003,     0x54fff423,\n+    0x540062c3,     0x54000003,     0x54fff3c3,     0x54006263,\n+    0x54000004,     0x54fff364,     0x54006204,     0x54000005,\n+    0x54fff305,     0x540061a5,     0x54000006,     0x54fff2a6,\n+    0x54006146,     0x54000007,     0x54fff247,     0x540060e7,\n+    0x54000008,     0x54fff1e8,     0x54006088,     0x54000009,\n+    0x54fff189,     0x54006029,     0x5400000a,     0x54fff12a,\n+    0x54005fca,     0x5400000b,     0x54fff0cb,     0x54005f6b,\n+    0x5400000c,     0x54fff06c,     0x54005f0c,     0x5400000d,\n+    0x54fff00d,     0x54005ead,     0x5400000e,     0x54ffefae,\n+    0x54005e4e,     0x5400000f,     0x54ffef4f,     0x54005def,\n@@ -1092,1 +1100,1 @@\n-    0xbd1b1869,     0x58004d3b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x58004e3b,     0x1800000b,     0xf8945060,\n@@ -1179,13 +1187,16 @@\n-    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x4cc0ac3f,\n-    0x05a08020,     0x05104fe0,     0x05505001,     0x05906fe2,\n-    0x05d03005,     0x05101fea,     0x05901feb,     0x04b0e3e0,\n-    0x0470e7e1,     0x042f9c20,     0x043f9c35,     0x047f9c20,\n-    0x04ff9c20,     0x04299420,     0x04319160,     0x0461943e,\n-    0x04a19020,     0x042053ff,     0x047f5401,     0x25208028,\n-    0x2538cfe0,     0x2578d001,     0x25b8efe2,     0x25f8f007,\n-    0x2538dfea,     0x25b8dfeb,     0xa400a3e0,     0xa420a7e0,\n-    0xa4484be0,     0xa467afe0,     0xa4a8a7ea,     0xa547a814,\n-    0xa4084ffe,     0xa55c53e0,     0xa5e1540b,     0xe400fbf6,\n-    0xe408ffff,     0xe420e7e0,     0xe4484be0,     0xe460efe0,\n-    0xe547e400,     0xe4014be0,     0xe4a84fe0,     0xe5f15000,\n-    0x858043e0,     0x85a043ff,     0xe59f5d08,     0x0522c020,\n+    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x9eae0020,\n+    0x4cc0ac3f,     0x05a08020,     0x05104fe0,     0x05505001,\n+    0x05906fe2,     0x05d03005,     0x05101fea,     0x05901feb,\n+    0x04b0e3e0,     0x0470e7e1,     0x042f9c20,     0x043f9c35,\n+    0x047f9c20,     0x04ff9c20,     0x04299420,     0x04319160,\n+    0x0461943e,     0x04a19020,     0x042053ff,     0x047f5401,\n+    0x25208028,     0x2538cfe0,     0x2578d001,     0x25b8efe2,\n+    0x25f8f007,     0x2538dfea,     0x25b8dfeb,     0xa400a3e0,\n+    0xa420a7e0,     0xa4484be0,     0xa467afe0,     0xa4a8a7ea,\n+    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n+    0xe400fbf6,     0xe408ffff,     0xe420e7e0,     0xe4484be0,\n+    0xe460efe0,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0xe5f15000,     0x858043e0,     0x85a043ff,     0xe59f5d08,\n+    0x0420e3e9,     0x0460e3ea,     0x04a0e3eb,     0x04e0e3ec,\n+    0x25104042,     0x25104871,     0x252c8840,     0x253c1420,\n+    0x25681572,     0x25a21ce3,     0x25ea1e34,     0x0522c020,\n@@ -1197,3 +1208,1 @@\n-    0x05b238a4,     0x05f138e6,     0x0570396a,     0x25221420,\n-    0x25640461,     0x25a614b2,     0x25eb0553,     0x25221c24,\n-    0x25640c60,     0x25a61cb1,     0x25eb0d52,     0x65d0a001,\n+    0x05b238a4,     0x05f138e6,     0x0570396a,     0x65d0a001,\n@@ -1243,4 +1252,5 @@\n-    0x04bc3162,     0x047a3027,     0x04e831d1,     0x05a56b15,\n-    0x05b66e35,     0x041a367d,     0x041832e4,     0x04d926f3,\n-    0x04482113,     0x04ca3a2e,     0x658727d5,     0x6586358a,\n-    0x65d82709,     0x044138c4,\n+    0x04bc3162,     0x047a3027,     0x04e831d1,     0x2493b8a5,\n+    0x249d9604,     0x24d18095,     0x24d7b491,     0x05686853,\n+    0x05f16f0e,     0x041a27d5,     0x0418358a,     0x04992709,\n+    0x044838c4,     0x048a39bb,     0x65c736de,     0x65863d3e,\n+    0x65d82693,     0x044129a9,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":70,"deletions":60,"binary":false,"changes":130,"status":"modified"}]}