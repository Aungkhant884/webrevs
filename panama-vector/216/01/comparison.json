{"files":[{"patch":"@@ -2236,0 +2236,55 @@\n+void Assembler::evcvtph2pd(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16((unsigned char)0x5A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtph2pd(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtph2pd(dst, k0, src, vector_len);\n+}\n+\n+void Assembler::evcvtpd2ph(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16((unsigned char)0x5A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtpd2ph(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtpd2ph(dst, k0, src, vector_len);\n+}\n+\n+void Assembler::evcvtps2ph(XMMRegister dst, KRegister mask, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1D, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  evcvtps2ph(dst, k0, src, imm8, vector_len);\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x13, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtph2ps(dst, k0, src, vector_len);\n+}\n@@ -6495,0 +6550,9 @@\n+void Assembler::evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x58);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+}\n+\n@@ -6684,0 +6748,14 @@\n+void Assembler::evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evaddph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -6735,0 +6813,14 @@\n+void Assembler::evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evsubph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -6797,0 +6889,47 @@\n+void Assembler::evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evmulph(dst, k0, nds, src, vector_len);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, XMMRegister src2, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_fma(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16((unsigned char)0xB8, (0xC0 | encode));\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+  evfmadd231ph(dst, k0, src1, src2, vector_len);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, Address src2, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_fma(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int8((unsigned char)0xB8);\n+  emit_operand(dst, src2, 0);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  evfmadd231ph(dst, k0, src1, src2, vector_len);\n+}\n+\n@@ -6882,0 +7021,14 @@\n+void Assembler::evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evdivph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -11402,2 +11555,2 @@\n-  \/\/ confine opc opcode extensions in mm bits to lower two bits\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ confine opc opcode extensions in mmm bits to lower three bits\n+  \/\/ of form {0F, 0F_38, 0F_3A, MAP5, MAP6}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":155,"deletions":2,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -546,0 +546,2 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n+    VEX_OPCODE_MAP6  = 0x6,\n@@ -1209,0 +1211,10 @@\n+  \/\/ convert vector HF and double\n+  void evcvtph2pd(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtph2pd(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void evcvtps2ph(XMMRegister dst, KRegister mask, XMMRegister src, int imm8, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evcvtpd2ph(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtpd2ph(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+\n@@ -2251,0 +2263,1 @@\n+  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n@@ -2305,0 +2318,2 @@\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2313,0 +2328,2 @@\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2322,0 +2339,2 @@\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2327,0 +2346,4 @@\n+  void evfmadd231ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, int vector_len);\n@@ -2335,0 +2358,2 @@\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2122,0 +2122,20 @@\n+void C2_MacroAssembler::reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2) {\n+  movdl(vtmp1, dst);\n+  evaddsh(vtmp1, vtmp1, src);\n+  pshuflw(vtmp, src, 0x01);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, src, 0x02);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, src, 0x03);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshufd(vtmp2, src, 0x0E);\n+  evaddsh(vtmp1, vtmp1, vtmp2);\n+  pshuflw(vtmp, vtmp2, 0x01);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, vtmp2, 0x02);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, vtmp2, 0x03);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  movdl(dst, vtmp1);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  void reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2273,0 +2273,16 @@\n+\/\/ dst = c = a * b + c\n+void MacroAssembler::evfmahf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {\n+  Assembler::evfmadd231ph(c, a, b, vector_len);\n+  if (dst != c) {\n+    vmovdqu(dst, c);\n+  }\n+}\n+\n+\/\/ dst = c = a * b + c\n+void MacroAssembler::evfmahf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {\n+  Assembler::evfmadd231ph(c, a, b, vector_len);\n+  if (dst != c) {\n+    vmovdqu(dst, c);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -501,0 +501,2 @@\n+  void evfmahf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);\n+  void evfmahf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -889,0 +889,25 @@\n+  address generate_vector_fp_mask(const char *stub_name, int32_t mask) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+    __ emit_data(mask, relocInfo::none, 0);\n+\n+    return start;\n+  }\n+\n@@ -4207,0 +4232,3 @@\n+    StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_fp_mask(\"vector_halffloat_sign_mask\", 0x7FFF7FFF);\n+    StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_fp_mask(\"vector_halffloat_sign_flip\", 0x80008000);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4032,0 +4032,3 @@\n+  StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_fp_mask(\"vector_halffloat_sign_mask\", 0x7FFF7FFF7FFF7FFF);\n+  StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_fp_mask(\"vector_halffloat_sign_flip\", 0x8000800080008000);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+address StubRoutines::x86::_vector_halffloat_sign_mask = nullptr;\n+address StubRoutines::x86::_vector_halffloat_sign_flip = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,0 +180,2 @@\n+  static address _vector_halffloat_sign_flip;\n+  static address _vector_halffloat_sign_mask;\n@@ -317,0 +319,8 @@\n+\n+  static address vector_halffloat_sign_mask() {\n+    return _vector_halffloat_sign_mask;\n+  }\n+\n+  static address vector_halffloat_sign_flip() {\n+    return _vector_halffloat_sign_flip;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -952,0 +952,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -2958,0 +2959,2 @@\n+      if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+          result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,0 +277,2 @@\n+               avx512_fp16 : 1,\n+                           : 8,\n@@ -393,1 +395,2 @@\n-    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/\n+    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/ \\\n+    decl(AVX512_FP16,       \"avx512_fp16\",       50) \/* Vector FP16 instructions*\/\n@@ -706,0 +709,1 @@\n+  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1397,0 +1397,2 @@\n+  static address vector_halffloat_signmask() { return StubRoutines::x86::vector_halffloat_sign_mask();}\n+  static address vector_halffloat_signflip() { return StubRoutines::x86::vector_halffloat_sign_flip();}\n@@ -1908,8 +1910,0 @@\n-    case Op_VectorCastF2HF:\n-    case Op_VectorCastHF2F:\n-      if (!VM_Version::supports_f16c() &&\n-         ((!VM_Version::supports_evex() ||\n-         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n-        return false;\n-      }\n-      break;\n@@ -2007,0 +2001,18 @@\n+    case Op_AddVHF:\n+    case Op_SubVHF:\n+    case Op_MulVHF:\n+    case Op_DivVHF:\n+    case Op_AbsVHF:\n+    case Op_NegVHF:\n+      if (bt != T_SHORT && !VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+    case Op_VectorCastD2HF:\n+    case Op_VectorCastHF2D:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -2165,0 +2177,1 @@\n+\n@@ -4989,0 +5002,11 @@\n+\/\/ =======================Half Float Reduction==========================================\n+instruct reduction8HF(rRegI dst, vec src2, vec vtmp, vec vtmp1, vec vtmp2) %{\n+  match(Set dst (AddReductionVHF dst src2));\n+  effect(TEMP vtmp, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"reduction_halffloat  $dst, $src2\\t using $vtmp, $vtmp1, $vtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reduce8HF($dst$$Register, $src2$$XMMRegister, $vtmp$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5503,0 +5527,11 @@\n+\/\/ Halffloat vector add\n+instruct vaddHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"evaddph  $dst,$src1,$src2\\t! add packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evaddph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5711,0 +5746,11 @@\n+\/\/ Halffloat vector sub\n+instruct vsubHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"evsubph  $dst,$src1,$src2\\t! sub packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsubph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5990,0 +6036,11 @@\n+\/\/Halffloat vector mul\n+instruct vmulHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (MulVHF src1 src2));\n+  format %{ \"evmulph  $dst,$src1,$src2\\t! mul packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evmulph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6096,0 +6153,11 @@\n+\/\/ Halffloat vector div\n+instruct vdivHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"evdivph  $dst,$src1,$src2\\t! div packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evdivph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7496,0 +7564,47 @@\n+\/\/ Convert from Halffloat to other types\n+instruct vcvtHFtoD_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastHF2D src));\n+  format %{ \"evcvtph2pd   $dst,$src\\t! convert HF to D vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtph2pd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcvtHFtoF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastHF2F src));\n+  format %{ \"evcvtph2ps   $dst,$src\\t! convert HF to F vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Convert from other types to Halffloat\n+instruct vcvtFtoHF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"evcvtps2ph   $dst,$src\\t! convert F to HF vector\" %}\n+  ins_encode %{\n+    int midx = 0;\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, midx, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcvtDtoHF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastD2HF src));\n+  format %{ \"evcvtpd2ph   $dst,$src\\t! convert D to HF vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtpd2ph($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8012,0 +8127,22 @@\n+\/\/ Half float abs\n+instruct vabsHF_reg(vec dst, vec src) %{\n+  match(Set dst (AbsVHF  src));\n+  format %{ \"vandps $dst,$src\\t# $dst = |$src| abs packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vandps($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_halffloat_signmask()), vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Halffloat neg\n+instruct vnegHF_reg(vec dst, vec src) %{\n+  match(Set dst (NegVHF src));\n+  format %{\"vxorps $dst, $src\\t $dst = -$src neg packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vxorps($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_halffloat_signflip()), vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8745,0 +8882,27 @@\n+\/\/ a * b + c\n+instruct vfmaHF_reg(vecX a, vecX b, vecX c) %{\n+  match(Set c (FmaVHF  c (Binary a b)));\n+  format %{ \"evfmaph $a,$b,$c\\t# $c = $a * $b + $c fma packedHF\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    assert(UseFMA, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmahf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ a * b + c\n+instruct vfmaHF_mem(vecX a, memory b, vecX c) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n+  match(Set c (FmaVHF  c (Binary a (LoadVector b))));\n+  format %{ \"evfmaph $a,$b,$c\\t# $c = $a * $b + $c fma packedHF\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    assert(UseFMA, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmahf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":172,"deletions":8,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -4103,0 +4103,1 @@\n+        strcmp(opType,\"AddReductionVHF\")==0 ||\n@@ -4215,1 +4216,1 @@\n-    \"AddReductionVF\", \"AddReductionVD\",\n+    \"AddReductionVF\", \"AddReductionVD\",\"AddReductionVHF\",\n@@ -4233,0 +4234,1 @@\n+    \"VectorCastHF2F\", \"VectorCastF2HF\", \"VectorCastD2HF\", \"VectorCastHF2D\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,0 +156,2 @@\n+macro(ConvHF2D)\n+macro(ConvD2HF)\n@@ -189,0 +191,1 @@\n+macro(FmaVHF)\n@@ -381,0 +384,1 @@\n+macro(AddVHF)\n@@ -382,0 +386,1 @@\n+macro(AddReductionVHF)\n@@ -390,0 +395,1 @@\n+macro(SubVHF)\n@@ -401,0 +407,1 @@\n+macro(MulVHF)\n@@ -405,0 +412,1 @@\n+macro(DivVHF)\n@@ -411,0 +419,1 @@\n+macro(AbsVHF)\n@@ -415,0 +424,1 @@\n+macro(NegVHF)\n@@ -513,0 +523,2 @@\n+macro(VectorCastD2HF)\n+macro(VectorCastHF2D)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,10 @@\n+\/\/------------------------------ConvD2HFNode------------------------------------\n+\/\/ Convert Double to Halffloat\n+class ConvD2HFNode : public Node {\n+  public:\n+  ConvD2HFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -141,0 +151,10 @@\n+\/\/------------------------------ConvHF2DNode------------------------------------\n+\/\/ Convert Halffloat to Double\n+class ConvHF2DNode : public Node {\n+  public:\n+  ConvHF2DNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual uint  ideal_reg() const { return Op_RegD; }\n+};\n+\n@@ -142,1 +162,1 @@\n-\/\/ Convert Halffloat to float\n+\/\/ Convert Halffloat to Float\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2271,0 +2271,1 @@\n+    case Op_FmaVHF:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -604,0 +604,6 @@\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -299,0 +299,41 @@\n+\/\/ Return the vector operator for the specified scalar operation\n+\/\/ and vector length for half float\n+int VectorNode::opcode(int sopc) {\n+  switch (sopc) {\n+    case Op_AddI:\n+      return Op_AddVHF;\n+    case Op_SubI:\n+      return Op_SubVHF;\n+    case Op_MulI:\n+      return Op_MulVHF;\n+    case Op_DivI:\n+      return Op_DivVHF;\n+    case Op_AbsI:\n+      return Op_AbsVHF;\n+    case Op_NegI:\n+      return Op_NegVHF;\n+    case Op_FmaF:\n+      return Op_FmaVHF;\n+    default:\n+      return 0; \/\/ Unimplemented\n+  }\n+}\n+\n+\/\/ Make a vectornode for half float unary\/binary operations\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, uint vlen) {\n+  const TypeVect* vt = TypeVect::make(T_SHORT, vlen);\n+  \/\/ This method should not be called for unimplemented vectors.\n+  switch (vopc) {\n+    case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n+    case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+    case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+    case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+    case Op_AbsVHF: return new AbsVHFNode(n1, vt);\n+    case Op_NegVHF: return new NegVHFNode(n1, vt);\n+\n+  default:\n+    fatal(\"Missed vector creation for '%s'\", NodeClassNames[vopc]);\n+    return NULL;\n+  }\n+}\n+\n@@ -738,0 +779,13 @@\n+\/\/ Make a vectornode for half float ternary operation\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, Node* n3, uint vlen) {\n+  const TypeVect* vt = TypeVect::make(T_SHORT, vlen);\n+  \/\/ This method should not be called for unimplemented vectors.\n+  guarantee(vopc > 0, \"Vector for '%s' is not implemented\", NodeClassNames[vopc]);\n+  switch (vopc) {\n+  case Op_FmaVHF: return new FmaVHFNode(n1, n2, n3, vt);\n+  default:\n+    fatal(\"Missed vector creation for '%s'\", NodeClassNames[vopc]);\n+    return NULL;\n+  }\n+}\n+\n@@ -1267,0 +1321,16 @@\n+\/\/Haffloat reduction nodes.\n+int ReductionNode::opcode(int opc) {\n+  int vopc = opc;\n+  switch (opc) {\n+    case Op_AddI:\n+      vopc = Op_AddReductionVHF;\n+      break;\n+    case Op_MulI:\n+      vopc = Op_MulReductionVF;\n+      break;\n+    default: ShouldNotReachHere(); return 0;\n+  }\n+  return vopc;\n+}\n+\n+\n@@ -1303,0 +1373,11 @@\n+\/\/ Return the appropriate reduction node for halffloat\n+ReductionNode* ReductionNode::make(int vopc, Node *ctrl, Node* n1, Node* n2) {\n+  switch (vopc) {\n+  case Op_AddReductionVHF: return new AddReductionVHFNode(ctrl, n1, n2);\n+  case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);\n+  default:\n+    assert(false,\"Missed vector creation for '%s'\", NodeClassNames[vopc]);\n+    return NULL;\n+  }\n+}\n+\n@@ -1343,0 +1424,2 @@\n+    case Op_VectorCastD2HF: return new VectorCastD2HFNode(n1, vt);\n+    case Op_VectorCastHF2D: return new VectorCastHF2DNode(n1, vt);\n@@ -1360,0 +1443,6 @@\n+    case Op_ConvD2HF:\n+      assert(bt == T_DOUBLE, \"\");\n+      return Op_VectorCastD2HF;\n+    case Op_ConvHF2D:\n+      assert(bt == T_SHORT, \"\");\n+      return Op_VectorCastHF2D;\n@@ -1361,1 +1450,1 @@\n-      \/\/ Handled normally below\n+      \/\/ handled below\n@@ -1422,0 +1511,1 @@\n+    case Op_AddReductionVHF:\/\/ fallthrough\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, uint vlen);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, Node* n3, uint vlen);\n@@ -94,0 +96,1 @@\n+  static int opcode(int opc);\n@@ -185,0 +188,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add halffloat\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -197,0 +208,1 @@\n+  static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2);\n@@ -198,0 +210,1 @@\n+  static int  opcode(int opc);\n@@ -243,0 +256,10 @@\n+\/\/------------------------------AddReductionVHFNode--------------------------------------\n+\/\/ Vector add halffloat as a reduction\n+class AddReductionVHFNode : public ReductionNode {\n+public:\n+  AddReductionVHFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -299,0 +322,8 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector sub halffloat\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -355,0 +386,9 @@\n+\/\/------------------------------MulVHFNode--------------------------------------\n+\/\/ Vector mul halffloat\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -371,0 +411,9 @@\n+\/\/------------------------------FmaVHFNode-------------------------------------\n+\/\/ Vector multiply halffloat\n+class FmaVHFNode : public VectorNode {\n+public:\n+  FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -435,0 +484,8 @@\n+\/\/------------------------------DivVHFNode--------------------------------------\n+\/\/ Vector div halffloat\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -451,0 +508,8 @@\n+\/\/------------------------------AbsVHFNode--------------------------------------\n+\/\/ Vector Abs Halffloat\n+class AbsVHFNode : public VectorNode {\n+public:\n+  AbsVHFNode(Node * in, const TypeVect * vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -543,0 +608,8 @@\n+\/\/------------------------------NegVHFNode--------------------------------------\n+\/\/ Vector Neg double\n+class NegVHFNode : public VectorNode {\n+public:\n+  NegVHFNode(Node * in, const TypeVect * vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -1598,0 +1671,16 @@\n+class VectorCastHF2DNode : public VectorCastNode {\n+ public:\n+  VectorCastHF2DNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastD2HFNode : public VectorCastNode {\n+ public:\n+  VectorCastD2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1735,0 +1735,1 @@\n+  declare_c2_type(AbsVHFNode, VectorNode)                                 \\\n@@ -1738,0 +1739,1 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n@@ -1743,0 +1745,1 @@\n+  declare_c2_type(AddReductionVHFNode, ReductionNode)                     \\\n@@ -1751,0 +1754,1 @@\n+  declare_c2_type(SubVHFNode, VectorNode)                                 \\\n@@ -1754,0 +1758,1 @@\n+  declare_c2_type(MulVHFNode, VectorNode)                                 \\\n@@ -1765,0 +1770,1 @@\n+  declare_c2_type(NegVHFNode, VectorNode)                                 \\\n@@ -1777,0 +1783,1 @@\n+  declare_c2_type(DivVHFNode, VectorNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,6 +142,7 @@\n-        T_FLOAT   = 6,\n-        T_DOUBLE  = 7,\n-        T_BYTE    = 8,\n-        T_SHORT   = 9,\n-        T_INT     = 10,\n-        T_LONG    = 11;\n+        T_HALFFLOAT = 5,\n+        T_FLOAT     = 6,\n+        T_DOUBLE    = 7,\n+        T_BYTE      = 8,\n+        T_SHORT     = 9,\n+        T_INT       = 10,\n+        T_LONG      = 11;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -317,2 +317,8 @@\n-        VectorMask<E> badMask =\n-            iota.compare(GE, iota.broadcast(indexLimit));\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Halffloat.class) {\n+            badMask =\n+                iota.compare(GE, Float.floatToFloat16((float)indexLimit));\n+        } else {\n+            badMask =\n+                iota.compare(GE, iota.broadcast(indexLimit));\n+        }\n@@ -327,2 +333,7 @@\n-            VectorMask<E> badMask2 =\n-                iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            if (vectorSpecies().elementType() == Halffloat.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            }\n@@ -392,1 +403,6 @@\n-        VectorMask<E> badMask =\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Halffloat.class) {\n+            badMask =\n+                iota.compare(GE, Float.floatToFloat16((float)indexLimit));\n+        } else {\n+            badMask =\n@@ -394,0 +410,1 @@\n+        }\n@@ -403,1 +420,5 @@\n-            VectorMask<E> badMask2 =\n+            if (vectorSpecies().elementType() == Halffloat.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n@@ -405,0 +426,1 @@\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -323,1 +323,9 @@\n-        Object za = Array.newInstance(elementType(), laneCount);\n+        Object za;\n+        \/\/ FIXME: Remove the following special handling for\n+        \/\/ Halffloat till Valhalla integration when Halffloat\n+        \/\/ will become a primitive class.\n+        if (elementType() == Halffloat.class) {\n+           za = Array.newInstance(short.class, laneCount);\n+        } else {\n+           za = Array.newInstance(elementType(), laneCount);\n+        }\n@@ -426,12 +434,24 @@\n-        Object ia = Array.newInstance(laneType.elementType,\n-                                      laneCount);\n-        assert(ia.getClass() == laneType.arrayType);\n-        checkValue(laneCount-1);  \/\/ worst case\n-        for (int i = 0; i < laneCount; i++) {\n-            if ((byte)i == i)\n-                Array.setByte(ia, i, (byte)i);\n-            else if ((short)i == i)\n-                Array.setShort(ia, i, (short)i);\n-            else\n-                Array.setInt(ia, i, i);\n-            assert(Array.getDouble(ia, i) == i);\n+        Object ia = null;\n+        if (elementType() == Halffloat.class) {\n+            ia = Array.newInstance(short.class, laneCount);\n+            checkValue(laneCount-1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                \/\/ All the numbers in the range [0 2048] are directly representable in FP16 format without the precision loss.\n+                if (i < 2049)\n+                    Array.setShort(ia, i, Float.floatToFloat16((float)i));\n+                else\n+                    assert(Array.getShort(ia, i) == i);\n+            }\n+        } else {\n+            ia = Array.newInstance(laneType.elementType, laneCount);\n+            assert(ia.getClass() == laneType.arrayType);\n+            checkValue(laneCount-1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                if ((byte)i == i)\n+                    Array.setByte(ia, i, (byte)i);\n+                else if ((short)i == i)\n+                    Array.setShort(ia, i, (short)i);\n+                else\n+                    Array.setInt(ia, i, i);\n+                assert(Array.getDouble(ia, i) == i);\n+            }\n@@ -635,0 +655,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            s = HalffloatVector.species(shape); break;\n@@ -647,1 +669,3 @@\n-        assert(s.laneType == laneType) : s + \"!=\" + laneType;\n+        \/\/ FIXME: Remove the additional check for Halffloat laneTypes from following assertion after proper fix.\n+        \/\/ Currently the incoming laneType does not comply with the laneType of Halffloat species.\n+        assert(s.laneType == laneType) || laneType.switchKey == LaneType.SK_HALFFLOAT : s + \"!=\" + laneType;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -304,0 +304,9 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public HalffloatVector reinterpretAsHalffloats() {\n+        return (HalffloatVector) asVectorRaw(LaneType.HALFFLOAT);\n+    }\n+\n@@ -575,0 +584,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            return HalffloatVector.fromMemorySegment(rsp.check(Halffloat.class), ms, 0, bo, m.check(Halffloat.class)).check0(rsp);\n@@ -637,0 +648,7 @@\n+            case LaneType.SK_HALFFLOAT: {\n+                short[] a = new short[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Halffloat.valueOf((float) lanes[i]);\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Halffloat.class), a, 0).check0(dsp);\n+            }\n@@ -687,0 +705,7 @@\n+            case LaneType.SK_HALFFLOAT: {\n+                short[] a = new short[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Halffloat.valueOf((float) lanes[i]);\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Halffloat.class), a, 0).check0(dsp);\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-                Byte128Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-                Byte256Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -768,1 +768,1 @@\n-                Byte512Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-                Byte64Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n+                ByteMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -633,1 +633,1 @@\n-                Double128Mask.class, double.class, VLENGTH, offset, limit,\n+                Double128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-                Double256Mask.class, double.class, VLENGTH, offset, limit,\n+                Double256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-                Double512Mask.class, double.class, VLENGTH, offset, limit,\n+                Double512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-                Double64Mask.class, double.class, VLENGTH, offset, limit,\n+                Double64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n+                DoubleMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-                Float128Mask.class, float.class, VLENGTH, offset, limit,\n+                Float128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-                Float256Mask.class, float.class, VLENGTH, offset, limit,\n+                Float256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -661,1 +661,1 @@\n-                Float512Mask.class, float.class, VLENGTH, offset, limit,\n+                Float512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -633,1 +633,1 @@\n-                Float64Mask.class, float.class, VLENGTH, offset, limit,\n+                Float64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n+                FloatMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code short} values.\n+ * @author abc\n+ * @version 1.0\n+ * @since  10\/01\/2021\n+ *\/\n+@SuppressWarnings(\"serial\")\n+public final class Halffloat extends Number implements Comparable<Halffloat>{\n+    \/** Definitions for FP16*\/\n+    public static final short MAX_VALUE = 0x7bff;\n+    \/** Definitions for FP16 *\/\n+    public static final short MIN_VALUE = 0x400;\n+    \/** Definitions for FP16 *\/\n+    public static final short POSITIVE_INFINITY = 0x7c00;\n+    \/** Definitions for FP16 *\/\n+    public static final short NEGATIVE_INFINITY = (short)0xfc00;\n+    \/** Definitions for FP16*\/\n+    public static final short NaN = (short)0x7e00;\n+    \/** Definitions for FP16*\/\n+    private static final float MAX_FLOAT_VALUE = 0x1.ffep+15f;\n+    \/** Definitions for FP16*\/\n+    private static final float MIN_FLOAT_VALUE = 0x1.004p-14f;\n+    \/** Definitions for FP16 *\/\n+    public static final int SIZE = 16;\n+    \/** Definitions for FP16 *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+    \/** Definitions for FP16 *\/\n+    private final short value;\n+\n+    \/**\n+    * Returns a new Halffloat.\n+    * @param f the species describing the element type\n+    * @return short value of float provided\n+    *\/\n+    public static Halffloat valueOf(short f) {\n+        return new Halffloat(f);\n+    }\n+\n+    \/**\n+    * Halffloat constructor\n+    * @param value short value assigned to halffloat\n+    *\/\n+    public Halffloat(short value) {\n+        this.value = value;\n+    }\n+\n+    \/**\n+    * Halffloat constructor\n+    * @param f float value assigned to halffloat\n+    *\/\n+    public Halffloat(float f) {\n+        this.value = Float.floatToFloat16(f);\n+    }\n+\n+    \/**\n+    * Returns floatvalue of a given short value.\n+    * @return a float value of short provided\n+    *\/\n+    public float floatValue() {\n+       return Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Returns halffloat value of a given float.\n+     * @param f float value to be converted into halffloat\n+     * @return short value of float provided\n+    *\/\n+    public static short valueOf(float f) {\n+        if (Float.isNaN(f)) {\n+            return Halffloat.NaN;\n+        }\n+        return Float.floatToFloat16(f);\n+    }\n+\n+    \/** doublevalue *\/\n+    public double doubleValue() {\n+       return (double) floatValue();\n+    }\n+\n+    \/** longValue *\/\n+    public long longValue() {\n+       return (long) value;\n+    }\n+\n+    \/** IntValue *\/\n+    public int intValue() {\n+       return (int) value;\n+    }\n+\n+    \/**\n+     * Returns the size, in bits, of vectors of this shape.\n+     * @param bits the species describing the element type\n+     * @return short value of float provided\n+    *\/\n+    public static short shortBitsToHalffloat(short bits) {\n+        return bits;\n+    }\n+    \/**\n+     * Returns the size, in bits, of vectors of this shape.\n+     * @param bits the species describing the element type\n+     * @return short value of float provided\n+    *\/\n+    public static short shortToRawShortBits(short bits) {\n+        return bits;\n+    }\n+    \/**\n+     * Returns the size, in bits, of vectors of this shape.\n+     * @param bits the species describing the element type\n+     * @return short value of float provided\n+    *\/\n+    public static short shortToShortBits(short bits) {\n+        return shortToRawShortBits(bits);\n+    }\n+\n+    \/**\n+       Compares two halffloats\n+     * @param hf value to be compared\n+     * @return 0, 1, -1\n+    *\/\n+    public int compareTo(Halffloat hf) {\n+        float f1 = floatValue();\n+        float f2 = hf.floatValue();\n+        return Float.compare(f1, f2);\n+    }\n+\n+    \/**\n+       Compares two halffloats\n+     * @param h1 value to be compared\n+     * @param h2 value to be compared\n+     * @return 0, 1, -1\n+    *\/\n+    public static int compare(short h1, short h2) {\n+        float f1 = Float.float16ToFloat(h1);\n+        float f2 = Float.float16ToFloat(h2);\n+        return Float.compare(f1, f2);\n+    }\n+\n+    \/**\n+     * Checks if value is NaN\n+     * @param hf value to be compared\n+     * @return boolean\n+    *\/\n+    public boolean isNaN(Halffloat hf) {\n+        float f1 = hf.floatValue();\n+        return Float.isNaN(f1);\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,951 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat128Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_128;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat128Vector> VCLASS = Halffloat128Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat128Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat128Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat128Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat128Vector ZERO = new Halffloat128Vector(new short[VLENGTH]);\n+    static final Halffloat128Vector IOTA = new Halffloat128Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(short e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(long e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat128Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle() { return Halffloat128Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat128Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat128Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector vectorFactory(short[] vec) {\n+        return new Halffloat128Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte128Vector asByteVectorRaw() {\n+        return (Byte128Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(FUnOp f) {\n+        return (Halffloat128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat128Vector)\n+            super.uOpTemplate((Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat128Vector) super.bOpTemplate((Halffloat128Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat128Vector)\n+            super.bOpTemplate((Halffloat128Vector)v, (Halffloat128Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              (Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v1, v2, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector addIndex(int scale) {\n+        return (Halffloat128Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n+        return super.toShuffleTemplate(dsp);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op) {\n+        return super.testTemplate(Halffloat128Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op, VectorMask<Halffloat> m) {\n+        return super.testTemplate(Halffloat128Mask.class, op, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v, (Halffloat128Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.blendTemplate(Halffloat128Mask.class,\n+                                (Halffloat128Vector) v,\n+                                (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.unsliceTemplate(Halffloat128Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    Halffloat128Mask.class,\n+                                    (Halffloat128Shuffle) shuffle,\n+                                    (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s,\n+                                    (Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector compress(VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.compressTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector expand(VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.expandTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v,\n+                                     (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat128Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat128Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat128Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat128Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat128Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat128Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat128Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat128Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat128Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat128Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask compress() {\n+            return (Halffloat128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat128Vector.class, Halffloat128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat128Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat128Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, Halffloat.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat128Mask  TRUE_MASK = new Halffloat128Mask(true);\n+        private static final Halffloat128Mask FALSE_MASK = new Halffloat128Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat128Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat128Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat128Shuffle IOTA = new Halffloat128Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        Short128Vector toBitsVector() {\n+            return (Short128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortVector toBitsVector0() {\n+            return Short128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {\n+        super.intoMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat128Vector.java","additions":951,"deletions":0,"binary":false,"changes":951,"status":"added"},{"patch":"@@ -0,0 +1,967 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat256Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_256;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat256Vector> VCLASS = Halffloat256Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat256Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat256Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat256Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat256Vector ZERO = new Halffloat256Vector(new short[VLENGTH]);\n+    static final Halffloat256Vector IOTA = new Halffloat256Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(short e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(long e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat256Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle() { return Halffloat256Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat256Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat256Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector vectorFactory(short[] vec) {\n+        return new Halffloat256Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte256Vector asByteVectorRaw() {\n+        return (Byte256Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(FUnOp f) {\n+        return (Halffloat256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat256Vector)\n+            super.uOpTemplate((Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat256Vector) super.bOpTemplate((Halffloat256Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat256Vector)\n+            super.bOpTemplate((Halffloat256Vector)v, (Halffloat256Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              (Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v1, v2, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector addIndex(int scale) {\n+        return (Halffloat256Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n+        return super.toShuffleTemplate(dsp);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op) {\n+        return super.testTemplate(Halffloat256Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op, VectorMask<Halffloat> m) {\n+        return super.testTemplate(Halffloat256Mask.class, op, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v, (Halffloat256Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.blendTemplate(Halffloat256Mask.class,\n+                                (Halffloat256Vector) v,\n+                                (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.unsliceTemplate(Halffloat256Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    Halffloat256Mask.class,\n+                                    (Halffloat256Shuffle) shuffle,\n+                                    (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s,\n+                                    (Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector compress(VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.compressTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector expand(VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.expandTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v,\n+                                     (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat256Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat256Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat256Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat256Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat256Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat256Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat256Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat256Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat256Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat256Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask compress() {\n+            return (Halffloat256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat256Vector.class, Halffloat256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat256Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat256Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, Halffloat.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat256Mask  TRUE_MASK = new Halffloat256Mask(true);\n+        private static final Halffloat256Mask FALSE_MASK = new Halffloat256Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat256Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat256Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat256Shuffle IOTA = new Halffloat256Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        Short256Vector toBitsVector() {\n+            return (Short256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortVector toBitsVector0() {\n+            return Short256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {\n+        super.intoMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat256Vector.java","additions":967,"deletions":0,"binary":false,"changes":967,"status":"added"},{"patch":"@@ -0,0 +1,999 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat512Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_512;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat512Vector> VCLASS = Halffloat512Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat512Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat512Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat512Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat512Vector ZERO = new Halffloat512Vector(new short[VLENGTH]);\n+    static final Halffloat512Vector IOTA = new Halffloat512Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(short e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(long e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat512Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle() { return Halffloat512Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat512Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat512Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector vectorFactory(short[] vec) {\n+        return new Halffloat512Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte512Vector asByteVectorRaw() {\n+        return (Byte512Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(FUnOp f) {\n+        return (Halffloat512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat512Vector)\n+            super.uOpTemplate((Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat512Vector) super.bOpTemplate((Halffloat512Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat512Vector)\n+            super.bOpTemplate((Halffloat512Vector)v, (Halffloat512Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              (Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v1, v2, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector addIndex(int scale) {\n+        return (Halffloat512Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n+        return super.toShuffleTemplate(dsp);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op) {\n+        return super.testTemplate(Halffloat512Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op, VectorMask<Halffloat> m) {\n+        return super.testTemplate(Halffloat512Mask.class, op, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v, (Halffloat512Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.blendTemplate(Halffloat512Mask.class,\n+                                (Halffloat512Vector) v,\n+                                (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.unsliceTemplate(Halffloat512Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    Halffloat512Mask.class,\n+                                    (Halffloat512Shuffle) shuffle,\n+                                    (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s,\n+                                    (Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector compress(VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.compressTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector expand(VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.expandTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v,\n+                                     (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat512Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat512Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat512Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat512Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat512Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat512Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat512Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat512Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat512Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat512Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask compress() {\n+            return (Halffloat512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat512Vector.class, Halffloat512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat512Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat512Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, Halffloat.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat512Mask  TRUE_MASK = new Halffloat512Mask(true);\n+        private static final Halffloat512Mask FALSE_MASK = new Halffloat512Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat512Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat512Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat512Shuffle IOTA = new Halffloat512Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        Short512Vector toBitsVector() {\n+            return (Short512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortVector toBitsVector0() {\n+            return Short512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {\n+        super.intoMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat512Vector.java","additions":999,"deletions":0,"binary":false,"changes":999,"status":"added"},{"patch":"@@ -0,0 +1,943 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat64Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_64;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat64Vector> VCLASS = Halffloat64Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat64Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat64Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat64Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat64Vector ZERO = new Halffloat64Vector(new short[VLENGTH]);\n+    static final Halffloat64Vector IOTA = new Halffloat64Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(short e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(long e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat64Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle() { return Halffloat64Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat64Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat64Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector vectorFactory(short[] vec) {\n+        return new Halffloat64Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte64Vector asByteVectorRaw() {\n+        return (Byte64Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(FUnOp f) {\n+        return (Halffloat64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat64Vector)\n+            super.uOpTemplate((Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat64Vector) super.bOpTemplate((Halffloat64Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat64Vector)\n+            super.bOpTemplate((Halffloat64Vector)v, (Halffloat64Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              (Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v1, v2, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector addIndex(int scale) {\n+        return (Halffloat64Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n+        return super.toShuffleTemplate(dsp);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op) {\n+        return super.testTemplate(Halffloat64Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op, VectorMask<Halffloat> m) {\n+        return super.testTemplate(Halffloat64Mask.class, op, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v, (Halffloat64Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.blendTemplate(Halffloat64Mask.class,\n+                                (Halffloat64Vector) v,\n+                                (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.unsliceTemplate(Halffloat64Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    Halffloat64Mask.class,\n+                                    (Halffloat64Shuffle) shuffle,\n+                                    (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s,\n+                                    (Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector compress(VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.compressTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector expand(VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.expandTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v,\n+                                     (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat64Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat64Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat64Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat64Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat64Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat64Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat64Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat64Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat64Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat64Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask compress() {\n+            return (Halffloat64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat64Vector.class, Halffloat64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat64Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat64Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, Halffloat.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat64Mask  TRUE_MASK = new Halffloat64Mask(true);\n+        private static final Halffloat64Mask FALSE_MASK = new Halffloat64Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat64Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat64Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat64Shuffle IOTA = new Halffloat64Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        Short64Vector toBitsVector() {\n+            return (Short64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortVector toBitsVector0() {\n+            return Short64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {\n+        super.intoMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat64Vector.java","additions":943,"deletions":0,"binary":false,"changes":943,"status":"added"},{"patch":"@@ -0,0 +1,936 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class HalffloatMaxVector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<HalffloatMaxVector> VCLASS = HalffloatMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    HalffloatMaxVector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as HalffloatMaxVector::new,\n+    \/\/ stored into species.vectorFactory.\n+    HalffloatMaxVector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final HalffloatMaxVector ZERO = new HalffloatMaxVector(new short[VLENGTH]);\n+    static final HalffloatMaxVector IOTA = new HalffloatMaxVector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(short e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(long e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxMask maskFromArray(boolean[] bits) {\n+        return new HalffloatMaxMask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle() { return HalffloatMaxShuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new HalffloatMaxShuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new HalffloatMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector vectorFactory(short[] vec) {\n+        return new HalffloatMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(FUnOp f) {\n+        return (HalffloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (HalffloatMaxVector)\n+            super.uOpTemplate((HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (HalffloatMaxVector) super.bOpTemplate((HalffloatMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (HalffloatMaxVector)\n+            super.bOpTemplate((HalffloatMaxVector)v, (HalffloatMaxMask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              (HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v1, v2, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector addIndex(int scale) {\n+        return (HalffloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n+        return super.toShuffleTemplate(dsp);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op) {\n+        return super.testTemplate(HalffloatMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op, VectorMask<Halffloat> m) {\n+        return super.testTemplate(HalffloatMaxMask.class, op, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, short s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v, (HalffloatMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.blendTemplate(HalffloatMaxMask.class,\n+                                (HalffloatMaxVector) v,\n+                                (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin, Vector<Halffloat> v) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.unsliceTemplate(HalffloatMaxMask.class,\n+                                  origin, w, part,\n+                                  (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> s) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    HalffloatMaxMask.class,\n+                                    (HalffloatMaxShuffle) shuffle,\n+                                    (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s,\n+                                    (HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector compress(VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.compressTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector expand(VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.expandTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Halffloat> v) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v,\n+                                     (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        short bits = laneHelper(i);\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public HalffloatMaxVector withLane(int i, short e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public HalffloatMaxVector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class HalffloatMaxMask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        HalffloatMaxMask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        HalffloatMaxMask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        HalffloatMaxMask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        HalffloatMaxMask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @Override\n+        HalffloatMaxMask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((HalffloatMaxMask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        HalffloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (HalffloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                HalffloatMaxMask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (HalffloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask compress() {\n+            return (HalffloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                HalffloatMaxVector.class, HalffloatMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, Halffloat.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, Halffloat.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, Halffloat.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static HalffloatMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, Halffloat.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final HalffloatMaxMask  TRUE_MASK = new HalffloatMaxMask(true);\n+        private static final HalffloatMaxMask FALSE_MASK = new HalffloatMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class HalffloatMaxShuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        HalffloatMaxShuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        HalffloatMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        HalffloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final HalffloatMaxShuffle IOTA = new HalffloatMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        ShortMaxVector toBitsVector() {\n+            return (ShortMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortVector toBitsVector0() {\n+            return ShortMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m) {\n+        super.intoMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatMaxVector.java","additions":936,"deletions":0,"binary":false,"changes":936,"status":"added"},{"patch":"@@ -0,0 +1,4200 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+import static jdk.incubator.vector.VectorIntrinsics.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code short} values.\n+ *\/\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+public abstract class HalffloatVector extends AbstractVector<Halffloat> {\n+\n+    HalffloatVector(short[] vec) {\n+        super(vec);\n+    }\n+\n+    static final int FORBID_OPCODE_KIND = VO_NOFP;\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n+    @ForceInline\n+    static int opCode(Operator op) {\n+        return VectorOperators.opCode(op, VO_OPCODE_VALID, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static int opCode(Operator op, int requireKind) {\n+        requireKind |= VO_OPCODE_VALID;\n+        return VectorOperators.opCode(op, requireKind, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static boolean opKind(Operator op, int bit) {\n+        return VectorOperators.opKind(op, bit);\n+    }\n+\n+    \/\/ Virtualized factories and operators,\n+    \/\/ coded with portable definitions.\n+    \/\/ These are all @ForceInline in case\n+    \/\/ they need to be used performantly.\n+    \/\/ The various shape-specific subclasses\n+    \/\/ also specialize them by wrapping\n+    \/\/ them in a call like this:\n+    \/\/    return (Byte128Vector)\n+    \/\/       super.bOp((Byte128Vector) o);\n+    \/\/ The purpose of that is to forcibly inline\n+    \/\/ the generic definition from this file\n+    \/\/ into a sharply type- and size-specific\n+    \/\/ wrapper in the subclass file, so that\n+    \/\/ the JIT can specialize the code.\n+    \/\/ The code is only inlined and expanded\n+    \/\/ if it gets hot.  Think of it as a cheap\n+    \/\/ and lazy version of C++ templates.\n+\n+    \/\/ Virtualized getter\n+\n+    \/*package-private*\/\n+    abstract short[] vec();\n+\n+    \/\/ Virtualized constructors\n+\n+    \/**\n+     * Build a vector directly using my own constructor.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    abstract HalffloatVector vectorFactory(short[] vec);\n+\n+    \/**\n+     * Build a mask directly using my species.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Halffloat> maskFactory(boolean[] bits) {\n+        return vspecies().maskFactory(bits);\n+    }\n+\n+    \/\/ Constant loader (takes dummy as vector arg)\n+    interface FVOp {\n+        short apply(int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(FVOp f) {\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(VectorMask<Halffloat> m, FVOp f) {\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Unary operator\n+\n+    \/*package-private*\/\n+    interface FUnOp {\n+        short apply(int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(FUnOp f) {\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(VectorMask<Halffloat> m,\n+                             FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(VectorMask<Halffloat> m,\n+                                     FUnOp f) {\n+        if (m == null) {\n+            return uOpTemplate(f);\n+        }\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Binary operator\n+\n+    \/*package-private*\/\n+    interface FBinOp {\n+        short apply(int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Halffloat> o,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Halffloat> o,\n+                                     FBinOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Halffloat> o,\n+                             VectorMask<Halffloat> m,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Halffloat> o,\n+                                     VectorMask<Halffloat> m,\n+                                     FBinOp f) {\n+        if (m == null) {\n+            return bOpTemplate(o, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    \/*package-private*\/\n+    interface FTriOp {\n+        short apply(int i, short a, short b, short c);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Halffloat> o1,\n+                             Vector<Halffloat> o2,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Halffloat> o1,\n+                                     Vector<Halffloat> o2,\n+                                     FTriOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Halffloat> o1,\n+                             Vector<Halffloat> o2,\n+                             VectorMask<Halffloat> m,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Halffloat> o1,\n+                                     Vector<Halffloat> o2,\n+                                     VectorMask<Halffloat> m,\n+                                     FTriOp f) {\n+        if (m == null) {\n+            return tOpTemplate(o1, o2, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Reduction operator\n+\n+    \/*package-private*\/\n+    abstract\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f);\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        if (m == null) {\n+            return rOpTemplate(v, f);\n+        }\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        }\n+        return v;\n+    }\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, FBinOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = f.apply(i, v, vec[i]);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Memory reference\n+\n+    \/*package-private*\/\n+    interface FLdOp<M> {\n+        short apply(M memory, int offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  FLdOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  VectorMask<Halffloat> m,\n+                                  FLdOp<M> f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        short apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Halffloat> m,\n+                                  FLdLongOp f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n+    }\n+\n+    interface FStOp<M> {\n+        void apply(M memory, int offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  VectorMask<Halffloat> m,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Halffloat> m,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, short e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 2L, e);\n+    }\n+\n+    \/\/ Binary test\n+\n+    \/*package-private*\/\n+    interface FBinTest {\n+        boolean apply(int cond, int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Halffloat> bTest(int cond,\n+                                  Vector<Halffloat> o,\n+                                  FBinTest f) {\n+        short[] vec1 = vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] bits = new boolean[length()];\n+        for (int i = 0; i < length(); i++){\n+            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        }\n+        return maskFactory(bits);\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    abstract HalffloatSpecies vspecies();\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long toBits(short e) {\n+        return  Halffloat.shortToRawShortBits(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short fromBits(long bits) {\n+        return Halffloat.shortBitsToHalffloat((short)bits);\n+    }\n+\n+    static HalffloatVector expandHelper(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        VectorSpecies<Halffloat> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static HalffloatVector compressHelper(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        VectorSpecies<Halffloat> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    \/\/ Static factories (other than memory operations)\n+\n+    \/\/ Note: A surprising behavior in javadoc\n+    \/\/ sometimes makes a lone \/** {@inheritDoc} *\/\n+    \/\/ comment drop the method altogether,\n+    \/\/ apparently if the method mentions an\n+    \/\/ parameter or return type of Vector<Halffloat>\n+    \/\/ instead of Vector<E> as originally specified.\n+    \/\/ Adding an empty HTML fragment appears to\n+    \/\/ nudge javadoc into providing the desired\n+    \/\/ inherited documentation.  We use the HTML\n+    \/\/ comment <!--workaround--> for this.\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * zero, the default primitive value.\n+     *\n+     * @param species species of the desired zero vector\n+     * @return a zero vector\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector zero(VectorSpecies<Halffloat> species) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), Halffloat.class, species.length(),\n+                        toBits((short)0), MODE_BROADCAST, vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+    }\n+\n+    \/**\n+     * Returns a vector of the same species as this one\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The contents of the current vector are discarded;\n+     * only the species is relevant to this operation.\n+     *\n+     * <p> This method returns the value of this expression:\n+     * {@code HalffloatVector.broadcast(this.species(), e)}.\n+     *\n+     * @apiNote\n+     * Unlike the similar method named {@code broadcast()}\n+     * in the supertype {@code Vector}, this method does not\n+     * need to validate its argument, and cannot throw\n+     * {@code IllegalArgumentException}.  This method is\n+     * therefore preferable to the supertype method.\n+     *\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(VectorSpecies,long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    public abstract HalffloatVector broadcast(short e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Halffloat> species, short e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(short e) {\n+        HalffloatSpecies vsp = vspecies();\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #broadcast(short) the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.broadcast((short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @Override\n+    public abstract HalffloatVector broadcast(long e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The {@code long} value must be accurately representable\n+     * by the {@code ETYPE} of the vector species, so that\n+     * {@code e==(long)(ETYPE)e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @throws IllegalArgumentException\n+     *         if the given {@code long} value cannot\n+     *         be represented by the vector's {@code ETYPE}\n+     * @see #broadcast(VectorSpecies,short)\n+     * @see VectorSpecies#checkValue(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Halffloat> species, long e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(long e) {\n+        return vspecies().broadcast(e);\n+    }\n+\n+    \/\/ Unary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op);\n+\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op) {\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0));\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op,\n+                                  VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op,\n+                                          Class<? extends VectorMask<Halffloat>> maskClass,\n+                                          VectorMask<Halffloat> m) {\n+        m.check(maskClass, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0, m));\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        UN_IMPL = new ImplCache<>(Unary.class, HalffloatVector.class);\n+\n+    private static UnaryOperation<HalffloatVector, VectorMask<Halffloat>> unaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_NEG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) -a);\n+            case VECTOR_OP_ABS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.abs(a));\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ Binary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Halffloat> v);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Vector<Halffloat> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                VectorMask<Short> mask\n+                    = this.viewAsIntegralLanes().compare(EQ, (short) 0);\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Halffloat> v,\n+                                  VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Halffloat>> maskClass,\n+                                          Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskClass, this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                ShortVector bits = this.viewAsIntegralLanes();\n+                VectorMask<Short> mask\n+                    = bits.compare(EQ, (short) 0, m.cast(bits.vspecies()));\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        BIN_IMPL = new ImplCache<>(Binary.class, HalffloatVector.class);\n+\n+    private static BinaryOperation<HalffloatVector, VectorMask<Halffloat>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ FIXME: Maybe all of the public final methods in this file (the\n+    \/\/ simple ones that just call lanewise) should be pushed down to\n+    \/\/ the X-VectorBits template.  They can't optimize properly at\n+    \/\/ this level, and must rely on inlining.  Does it work?\n+    \/\/ (If it works, of course keep the code here.)\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e))}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the two input vectors\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e) {\n+        return lanewise(op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e), m)}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e,m)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e, VectorMask<Halffloat> m) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1, m);\n+    }\n+\n+\n+    \/\/ Ternary lanewise support\n+\n+    \/\/ Ternary operators come in eight variations:\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2])\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2], mask)\n+\n+    \/\/ It is annoying to support all of these variations of masking\n+    \/\/ and broadcast, but it would be more surprising not to continue\n+    \/\/ the obvious pattern started by unary and binary.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                                  Vector<Halffloat> v1,\n+                                                  Vector<Halffloat> v2);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Vector<Halffloat> v1,\n+                                          Vector<Halffloat> v2) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                  Vector<Halffloat> v1,\n+                                  Vector<Halffloat> v2,\n+                                  VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Class<? extends VectorMask<Halffloat>> maskClass,\n+                                          Vector<Halffloat> v1,\n+                                          Vector<Halffloat> v2,\n+                                          VectorMask<Halffloat> m) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        m.check(maskClass, this);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        TERN_IMPL = new ImplCache<>(Ternary.class, HalffloatVector.class);\n+\n+    private static TernaryOperation<HalffloatVector, VectorMask<Halffloat>> ternaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                    Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2)\n+                                  short e1,\n+                                  short e2) {\n+        return lanewise(op, broadcast(e1), broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2,m)\n+                                  short e1,\n+                                  short e2,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, broadcast(e1), broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2)\n+                                  Vector<Halffloat> v1,\n+                                  short e2) {\n+        return lanewise(op, v1, broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2,m)\n+                                  Vector<Halffloat> v1,\n+                                  short e2,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, v1, broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2)\n+                                  short e1,\n+                                  Vector<Halffloat> v2) {\n+        return lanewise(op, broadcast(e1), v2);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2, m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2,m)\n+                                  short e1,\n+                                  Vector<Halffloat> v2,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, broadcast(e1), v2, m);\n+    }\n+\n+    \/\/ (Thus endeth the Great and Mighty Ternary Ogdoad.)\n+    \/\/ https:\/\/en.wikipedia.org\/wiki\/Ogdoad\n+\n+    \/\/\/ FULL-SERVICE BINARY METHODS: ADD, SUB, MUL, DIV\n+    \/\/\n+    \/\/ These include masked and non-masked versions.\n+    \/\/ This subclass adds broadcast (masked or not).\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Halffloat> v) {\n+        return lanewise(ADD, v);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector)\n+     * @see #broadcast(short)\n+     * @see #add(short,VectorMask)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector add(short e) {\n+        return lanewise(ADD, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(ADD, v, m);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #add(short)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector add(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(ADD, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Halffloat> v) {\n+        return lanewise(SUB, v);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector)\n+     * @see #broadcast(short)\n+     * @see #sub(short,VectorMask)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e) {\n+        return lanewise(SUB, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(SUB, v, m);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #sub(short)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(SUB, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Halffloat> v) {\n+        return lanewise(MUL, v);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #mul(Vector)\n+     * @see #broadcast(short)\n+     * @see #mul(short,VectorMask)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e) {\n+        return lanewise(MUL, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(MUL, v, m);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of muling each lane of this vector to the scalar\n+     * @see #mul(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #mul(short)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(MUL, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Halffloat> v) {\n+        return lanewise(DIV, v);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , e)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector)\n+     * @see #broadcast(short)\n+     * @see #div(short,VectorMask)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e) {\n+        return lanewise(DIV, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #div(short,VectorMask)\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(DIV, v, m);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , s, m)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #div(short)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(DIV, e, m);\n+    }\n+\n+    \/\/\/ END OF FULL-SERVICE BINARY METHODS\n+\n+    \/\/\/ SECOND-TIER BINARY METHODS\n+    \/\/\n+    \/\/ There are no masked versions.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector min(Vector<Halffloat> v) {\n+        return lanewise(MIN, v);\n+    }\n+\n+    \/\/ FIXME:  \"broadcast of an input scalar\" is really wordy.  Reduce?\n+    \/**\n+     * Computes the smaller of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.min()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MIN\n+     *    MIN}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #min(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MIN\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector min(short e) {\n+        return lanewise(MIN, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector max(Vector<Halffloat> v) {\n+        return lanewise(MAX, v);\n+    }\n+\n+    \/**\n+     * Computes the larger of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.max()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MAX\n+     *    MAX}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #max(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MAX\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector max(short e) {\n+        return lanewise(MAX, e);\n+    }\n+\n+\n+    \/\/ common FP operator: pow\n+    \/**\n+     * Raises this vector to the power of a second input vector.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * <p>\n+     * This is not a full-service named operation like\n+     * {@link #add(Vector) add}.  A masked version of\n+     * this operation is not directly available\n+     * but may be obtained via the masked version of\n+     * {@code lanewise}.\n+     *\n+     * @param b a vector exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(short)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(Vector<Halffloat> b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/**\n+     * Raises this vector to a scalar power.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * @param b a scalar exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(Vector)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(short b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/\/\/ UNARY METHODS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector neg() {\n+        return lanewise(NEG);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector abs() {\n+        return lanewise(ABS);\n+    }\n+\n+\n+\n+    \/\/ sqrt\n+    \/**\n+     * Computes the square root of this vector.\n+     *\n+     * This is a lane-wise unary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#sqrt Math.sqrt(a)}\n+     * to each lane value.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *    lanewise}{@code (}{@link VectorOperators#SQRT\n+     *    SQRT}{@code )}.\n+     *\n+     * @return the square root of this vector\n+     * @see VectorOperators#SQRT\n+     * @see #lanewise(VectorOperators.Unary,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sqrt() {\n+        return lanewise(SQRT);\n+    }\n+\n+    \/\/\/ COMPARISONS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> eq(Vector<Halffloat> v) {\n+        return compare(EQ, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is equal to an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive equals operation ({@code ==}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.Comparison.EQ, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result mask of testing if this vector\n+     *         is equal to {@code e}\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> eq(short e) {\n+        return compare(EQ, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> lt(Vector<Halffloat> v) {\n+        return compare(LT, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is less than an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive less than operation ({@code <}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.LT, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the mask result of testing if this vector\n+     *         is less than the input scalar\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> lt(short e) {\n+        return compare(LT, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> test(VectorOperators.Test op);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M testTemplate(Class<M> maskType, Test op) {\n+        HalffloatSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Halffloat.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits);\n+                } else {\n+                    m = bits.compare(EQ, infbits);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> test(VectorOperators.Test op,\n+                                  VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        HalffloatSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m = mask.cast(ShortVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Halffloat.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> compare(VectorOperators.Comparison op, Vector<Halffloat> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Halffloat> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, Halffloat.class, length(),\n+            this, that, null,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Halffloat> m\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) m;\n+                return m2;\n+            });\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Halffloat> v, M m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskType, this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, Halffloat.class, length(),\n+            this, that, m,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Halffloat> cmpM\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) cmpM.and(m1);\n+                return m2;\n+            });\n+    }\n+\n+    @ForceInline\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the comparison operation to each lane.\n+     * <p>\n+     * The result is the same as\n+     * {@code compare(op, broadcast(species(), e))}.\n+     * That is, the scalar may be regarded as broadcast to\n+     * a vector of the same species, and then compared\n+     * against the original vector, using the selected\n+     * comparison operation.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector)\n+     * @see #eq(short)\n+     * @see #lt(short)\n+     *\/\n+    public abstract\n+    VectorMask<Halffloat> compare(Comparison op, short e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, short e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation,\n+     * in lanes selected by a mask.\n+     *\n+     * This is a masked lane-wise binary test operation which applies\n+     * to each pair of corresponding lane values.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code compare(op,s).and(m)}.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator,\n+     *         and only in the lanes selected by the mask\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final VectorMask<Halffloat> compare(VectorOperators.Comparison op,\n+                                               short e,\n+                                               VectorMask<Halffloat> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> compare(Comparison op, long e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, long e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> compare(Comparison op, long e, VectorMask<Halffloat> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract\n+    HalffloatVector blend(Vector<Halffloat> v, VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector\n+    blendTemplate(Class<M> maskType, HalffloatVector v, M m) {\n+        v.check(this);\n+        return VectorSupport.blend(\n+            getClass(), maskType, Halffloat.class, length(),\n+            this, v, m,\n+            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract HalffloatVector addIndex(int scale);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector addIndexTemplate(int scale) {\n+        HalffloatSpecies vsp = vspecies();\n+        \/\/ make sure VLENGTH*scale doesn't overflow:\n+        vsp.checkScale(scale);\n+        return VectorSupport.indexVector(\n+            getClass(), Halffloat.class, length(),\n+            this, scale, vsp,\n+            (v, scale_, s)\n+            -> {\n+                \/\/ If the platform doesn't support an INDEX\n+                \/\/ instruction directly, load IOTA from memory\n+                \/\/ and multiply.\n+                HalffloatVector iota = s.iota();\n+                short sc = (short) scale_;\n+                return v.add(sc == 1 ? iota : iota.mul(Float.floatToFloat16((float) sc)));\n+            });\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(short e,\n+                                            VectorMask<Halffloat> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(long e,\n+                                            VectorMask<Halffloat> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin, Vector<Halffloat> v1);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin, Vector<Halffloat> v1) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector slice(int origin,\n+                               Vector<Halffloat> w,\n+                               VectorMask<Halffloat> m) {\n+        return broadcast(0).blend(slice(origin, w), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Halffloat> w, int part);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin, Vector<Halffloat> w, int part) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((short)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector\n+    unsliceTemplate(Class<M> maskType, int origin, Vector<Halffloat> w, int part, M m) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        HalffloatVector slice = that.sliceTemplate(origin, that);\n+        slice = slice.blendTemplate(maskType, this, m);\n+        return slice.unsliceTemplate(origin, w, part);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m);\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((short)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    private ArrayIndexOutOfBoundsException\n+    wrongPartForSlice(int part) {\n+        String msg = String.format(\"bad part number %d for slice operation\",\n+                                   part);\n+        return new ArrayIndexOutOfBoundsException(msg);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Halffloat>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {\n+        shuffle.checkIndexes();\n+        return VectorSupport.rearrangeOp(\n+            getClass(), shuffletype, null, Halffloat.class, length(),\n+            this, shuffle, null,\n+            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                int ei = s_.laneSource(i);\n+                return v1.lane(ei);\n+            }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Halffloat> s,\n+                                   VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Halffloat>, M extends VectorMask<Halffloat>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           Class<M> masktype,\n+                                           S shuffle,\n+                                           M m) {\n+\n+        m.check(masktype, this);\n+        VectorMask<Halffloat> valid = shuffle.laneIsValid();\n+        if (m.andNot(valid).anyTrue()) {\n+            shuffle.checkIndexes();\n+            throw new AssertionError();\n+        }\n+        return VectorSupport.rearrangeOp(\n+                   getClass(), shuffletype, masktype, Halffloat.class, length(),\n+                   this, shuffle, m,\n+                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                        int ei = s_.laneSource(i);\n+                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                   }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Halffloat> s,\n+                                   Vector<Halffloat> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Halffloat>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           S shuffle,\n+                                           HalffloatVector v) {\n+        VectorMask<Halffloat> valid = shuffle.laneIsValid();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n+        HalffloatVector r0 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, Halffloat.class, length(),\n+                this, ws, null,\n+                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                    int ei = s_.laneSource(i);\n+                    return v0.lane(ei);\n+                }));\n+        HalffloatVector r1 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, Halffloat.class, length(),\n+                v, ws, null,\n+                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                    int ei = s_.laneSource(i);\n+                    return v1.lane(ei);\n+                }));\n+        return r1.blend(r0, valid);\n+    }\n+\n+    @ForceInline\n+    final <F>\n+    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+        short[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector compress(VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Halffloat>>\n+    HalffloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        Halffloat.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector expand(VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Halffloat>>\n+    HalffloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        Halffloat.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Halffloat> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v) {\n+        return v.rearrange(this.toShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Halffloat> s, VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v,\n+                                                  AbstractMask<Halffloat> m) {\n+        return v.rearrange(this.toShuffle(), m);\n+    }\n+\n+    \/\/\/ Ternary operations\n+\n+\n+    \/**\n+     * Multiplies this vector by a second input vector, and sums\n+     * the result with a third.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the second input vector, supplying multiplier values\n+     * @param c the third input vector, supplying addend values\n+     * @return the product of this vector and the second input vector\n+     *         summed with the third input vector, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(short,short)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(Vector<Halffloat> b, Vector<Halffloat> c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by a scalar multiplier, and sums\n+     * the result with a scalar addend.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the scalar multiplier\n+     * @param c the scalar addend\n+     * @return the product of this vector and the scalar multiplier\n+     *         summed with scalar addend, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(Vector,Vector)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(short b, short c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/\/ Don't bother with (Vector,short) and (short,Vector) overloadings.\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    \/**\n+     * Returns a value accumulated from all the lanes of this vector.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to all the lane elements.\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @return the accumulated result\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative,VectorMask)\n+     * @see #add(Vector)\n+     * @see #mul(Vector)\n+     * @see #min(Vector)\n+     * @see #max(Vector)\n+     * @see VectorOperators#FIRST_NONZERO\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op);\n+\n+    \/**\n+     * Returns a value accumulated from selected lanes of this vector,\n+     * controlled by a mask.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to the selected lane elements.\n+     * <p>\n+     * If no elements are selected, an operation-specific identity\n+     * value is returned.\n+     * <ul>\n+     * <li>\n+     * If the operation is\n+     *  {@code ADD}\n+     * or {@code FIRST_NONZERO},\n+     * then the identity value is positive zero, the default {@code short} value.\n+     * <li>\n+     * If the operation is {@code MUL},\n+     * then the identity value is one.\n+     * <li>\n+     * If the operation is {@code MAX},\n+     * then the identity value is {@code Halffloat.NEGATIVE_INFINITY}.\n+     * <li>\n+     * If the operation is {@code MIN},\n+     * then the identity value is {@code Halffloat.POSITIVE_INFINITY}.\n+     * <\/ul>\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param m the mask controlling lane selection\n+     * @return the reduced result accumulated from the selected lane values\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative)\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op,\n+                                       VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op,\n+                               Class<? extends VectorMask<Halffloat>> maskClass,\n+                               VectorMask<Halffloat> m) {\n+        m.check(maskClass, this);\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            HalffloatVector v = broadcast((short) 0).blend(this, m);\n+            return v.reduceLanesTemplate(op);\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op) {\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            VectorMask<Short> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (short) 0;\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    private static final\n+    ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        REDUCE_IMPL = new ImplCache<>(Associative.class, HalffloatVector.class);\n+\n+    private static ReductionOperation<HalffloatVector, VectorMask<Halffloat>> reductionOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp((short)1, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(b) * Float.float16ToFloat(b))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+            default: return null;\n+        }\n+    }\n+\n+    private static final short MIN_OR_INF = Halffloat.NEGATIVE_INFINITY;\n+    private static final short MAX_OR_INF = Halffloat.POSITIVE_INFINITY;\n+\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op);\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op,\n+                                                     VectorMask<Halffloat> m);\n+\n+    \/\/ Type specific accessors\n+\n+    \/**\n+     * Gets the lane element at lane index {@code i}\n+     *\n+     * @param i the lane index\n+     * @return the lane element at lane index {@code i}\n+     * @throws IllegalArgumentException if the index is is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract short lane(int i);\n+\n+    \/**\n+     * Replaces the lane element of this vector at lane index {@code i} with\n+     * value {@code e}.\n+     *\n+     * This is a cross-lane operation and behaves as if it returns the result\n+     * of blending this vector with an input vector that is the result of\n+     * broadcasting {@code e} and a mask that has only one lane set at lane\n+     * index {@code i}.\n+     *\n+     * @param i the lane index of the lane element to be replaced\n+     * @param e the value to be placed\n+     * @return the result of replacing the lane element of this vector at lane\n+     * index {@code i} with value {@code e}.\n+     * @throws IllegalArgumentException if the index is is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract HalffloatVector withLane(int i, short e);\n+\n+    \/\/ Memory load operations\n+\n+    \/**\n+     * Returns an array of type {@code short[]}\n+     * containing all the lane values.\n+     * The array length is the same as the vector length.\n+     * The array elements are stored in lane order.\n+     * <p>\n+     * This method behaves as if it stores\n+     * this vector into an allocated array\n+     * (using {@link #intoArray(short[], int) intoArray})\n+     * and returns the array as follows:\n+     * <pre>{@code\n+     *   short[] a = new short[this.length()];\n+     *   this.intoArray(a, 0);\n+     *   return a;\n+     * }<\/pre>\n+     *\n+     * @return an array containing the lane values of this vector\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final short[] toArray() {\n+        short[] a = new short[vspecies().laneCount()];\n+        intoArray(a, 0);\n+        return a;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final int[] toIntArray() {\n+        short[] a = toArray();\n+        int[] res = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = a[i];\n+            res[i] = (int) HalffloatSpecies.toIntegralChecked(e, true);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final long[] toLongArray() {\n+        short[] a = toArray();\n+        long[] res = new long[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = (short) Halffloat.valueOf(a[i]).floatValue();\n+            res[i] = HalffloatSpecies.toIntegralChecked(e, false);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     * @implNote\n+     * When this method is used on used on vectors\n+     * of type {@code HalffloatVector},\n+     * there will be no loss of precision.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final double[] toDoubleArray() {\n+        short[] a = toArray();\n+        double[] res = new double[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            res[i] = (double) Halffloat.valueOf(a[i]).floatValue();\n+        }\n+        return res;\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N} is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N} is placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset,\n+                                   VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset,\n+                                   VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Halffloat> m) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Halffloat> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * short[] ar = new short[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * HalffloatVector r = HalffloatVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Halffloat> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+        }\n+\n+        checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            }\n+            intoArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<Halffloat> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            }\n+            intoCharArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Halffloat> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+                checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+            }\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Low-level memory operations.\n+    \/\/\n+    \/\/ Note that all of these operations *must* inline into a context\n+    \/\/ where the exact species of the involved vector is a\n+    \/\/ compile-time constant.  Otherwise, the intrinsic generation\n+    \/\/ will fail and performance will suffer.\n+    \/\/\n+    \/\/ In many cases this is achieved by re-deriving a version of the\n+    \/\/ method in each concrete subclass (per species).  The re-derived\n+    \/\/ method simply calls one of these generic methods, with exact\n+    \/\/ parameters for the controlling metadata, which is either a\n+    \/\/ typed vector or constant species instance.\n+\n+    \/\/ Unchecked loading operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m, offsetInRange,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromCharArray0Template(char[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                a, charArrayAddress(a, offset), m, offsetInRange,\n+                a, offset, vsp,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Halffloat> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m, int offsetInRange) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    \/\/ Unchecked storing operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    abstract\n+    void intoArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    void intoArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+    }\n+\n+    abstract\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+\n+\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/\/ End of low-level memory operations.\n+\n+    private static\n+    void checkMaskFromIndexSize(int offset,\n+                                HalffloatSpecies vsp,\n+                                VectorMask<Halffloat> m,\n+                                int scale,\n+                                int limit) {\n+        ((AbstractMask<Halffloat>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                HalffloatSpecies vsp,\n+                                VectorMask<Halffloat> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Halffloat>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n+    @ForceInline\n+    private void conditionalStoreNYI(int offset,\n+                                     HalffloatSpecies vsp,\n+                                     VectorMask<Halffloat> m,\n+                                     int scale,\n+                                     int limit) {\n+        if (offset < 0 || offset + vsp.laneCount() * scale > limit) {\n+            String msg =\n+                String.format(\"unimplemented: store @%d in [0..%d), %s in %s\",\n+                              offset, limit, m, vsp);\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    final\n+    HalffloatVector maybeSwap(ByteOrder bo) {\n+        if (bo != NATIVE_ENDIAN) {\n+            return this.reinterpretAsBytes()\n+                .rearrange(swapBytesShuffle())\n+                .reinterpretAsHalffloats();\n+        }\n+        return this;\n+    }\n+\n+    static final int ARRAY_SHIFT =\n+        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+    static final long ARRAY_BASE =\n+        Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long arrayAddress(short[] a, int index) {\n+        return ARRAY_BASE + (((long)index) << ARRAY_SHIFT);\n+    }\n+\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n+\n+    @ForceInline\n+    static long byteArrayAddress(byte[] a, int index) {\n+        return Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Reinterpreting view methods:\n+    \/\/   lanewise reinterpret: viewAsXVector()\n+    \/\/   keep shape, redraw lanes: reinterpretAsEs()\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ByteVector reinterpretAsBytes() {\n+         \/\/ Going to ByteVector, pay close attention to byte order.\n+         assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);\n+         return asByteVectorRaw();\n+         \/\/return asByteVectorRaw().rearrange(swapBytesShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ShortVector viewAsIntegralLanes() {\n+        LaneType ilt = LaneType.SHORT.asIntegral();\n+        return (ShortVector) asVectorRaw(ilt);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\n+     * @implNote This method always throws\n+     * {@code UnsupportedOperationException}, because there is no floating\n+     * point type of the same size as {@code short}.  The return type\n+     * of this method is arbitrarily designated as\n+     * {@code Vector<?>}.  Future versions of this API may change the return\n+     * type if additional floating point types become available.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final\n+    HalffloatVector\n+    viewAsFloatingLanes() {\n+        return this;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Object methods: toString, equals, hashCode\n+    \/\/\n+    \/\/ Object methods are defined as if via Arrays.toString, etc.,\n+    \/\/ is applied to the array of elements.  Two equal vectors\n+    \/\/ are required to have equal species and equal lane values.\n+\n+    \/**\n+     * Returns a string representation of this vector, of the form\n+     * {@code \"[0,1,2...]\"}, reporting the lane values of this vector,\n+     * in lane order.\n+     *\n+     * The string is produced as if by a call to {@link\n+     * java.util.Arrays#toString(short[]) Arrays.toString()},\n+     * as appropriate to the {@code short} array returned by\n+     * {@link #toArray this.toArray()}.\n+     *\n+     * @return a string of the form {@code \"[0,1,2...]\"}\n+     * reporting the lane values of this vector\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    String toString() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Arrays.toString(toArray());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    boolean equals(Object obj) {\n+        if (obj instanceof Vector) {\n+            Vector<?> that = (Vector<?>) obj;\n+            if (this.species().equals(that.species())) {\n+                return this.eq(that.check(this.species())).allTrue();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    int hashCode() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Objects.hash(species(), Arrays.hashCode(toArray()));\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Species\n+\n+    \/**\n+     * Class representing {@link HalffloatVector}'s of the same {@link VectorShape VectorShape}.\n+     *\/\n+    \/*package-private*\/\n+    static final class HalffloatSpecies extends AbstractSpecies<Halffloat> {\n+        private HalffloatSpecies(VectorShape shape,\n+                Class<? extends HalffloatVector> vectorType,\n+                Class<? extends AbstractMask<Halffloat>> maskType,\n+                Class<? extends AbstractShuffle<Halffloat>> shuffleType,\n+                Function<Object, HalffloatVector> vectorFactory) {\n+            super(shape, LaneType.of(Halffloat.class),\n+                  vectorType, maskType, shuffleType,\n+                  vectorFactory);\n+            assert(this.elementSize() == Halffloat.SIZE);\n+        }\n+\n+        \/\/ Specializing overrides:\n+\n+        @Override\n+        @ForceInline\n+        public final Class<Halffloat> elementType() {\n+            return Halffloat.class;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        final Class<Halffloat> genericElementType() {\n+            return Halffloat.class;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        @ForceInline\n+        public final Class<? extends HalffloatVector> vectorType() {\n+            return (Class<? extends HalffloatVector>) vectorType;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final long checkValue(long e) {\n+            longToElementBits(e);  \/\/ only for exception\n+            return e;\n+        }\n+\n+        \/*package-private*\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector broadcastBits(long bits) {\n+            return (HalffloatVector)\n+                VectorSupport.fromBitsCoerced(\n+                    vectorType, Halffloat.class, laneCount,\n+                    bits, MODE_BROADCAST, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        final HalffloatVector broadcast(short e) {\n+            return broadcastBits(toBits(e));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector broadcast(long e) {\n+            return broadcastBits(longToElementBits(e));\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        long longToElementBits(long value) {\n+            \/\/ Do the conversion, and then test it for failure.\n+            short e = (short) value;\n+            if ((long) e != value) {\n+                throw badElementBits(value, e);\n+            }\n+            return toBits(e);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        static long toIntegralChecked(short e, boolean convertToInt) {\n+            long value = convertToInt ? (int) e : (long) e;\n+            if ((short) value != e) {\n+                throw badArrayBits(e, convertToInt, value);\n+            }\n+            return value;\n+        }\n+\n+        \/* this non-public one is for internal conversions *\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector fromIntValues(int[] values) {\n+            VectorIntrinsics.requireLength(values.length, laneCount);\n+            short[] va = new short[laneCount()];\n+            for (int i = 0; i < va.length; i++) {\n+                int lv = values[i];\n+                short v = Float.floatToFloat16((float) lv);\n+                va[i] = v;\n+                if ((int) Float.float16ToFloat(v) != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+            }\n+            return dummyVector().fromArray0(va, 0);\n+        }\n+\n+        \/\/ Virtual constructors\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromArray(Object a, int offset) {\n+            \/\/ User entry point:  Be careful with inputs.\n+            return HalffloatVector\n+                .fromArray(this, (short[]) a, offset);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        HalffloatVector dummyVector() {\n+            return (HalffloatVector) super.dummyVector();\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        HalffloatVector rvOp(RVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                short bits = (short) f.apply(i);\n+                res[i] = fromBits(bits);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(FVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(VectorMask<Halffloat> m, FVOp f) {\n+            short[] res = new short[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(i);\n+                }\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      VectorMask<Halffloat> m,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Halffloat> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset, FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset,\n+                      AbstractMask<Halffloat> m,\n+                      FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Halffloat> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n+        \/\/ N.B. Make sure these constant vectors and\n+        \/\/ masks load up correctly into registers.\n+        \/\/\n+        \/\/ Also, see if we can avoid all that switching.\n+        \/\/ Could we cache both vectors and both masks in\n+        \/\/ this species object?\n+\n+        \/\/ Zero and iota vector access\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector zero() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.ZERO;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.ZERO;\n+                case 128: return Halffloat128Vector.ZERO;\n+                case 256: return Halffloat256Vector.ZERO;\n+                case 512: return Halffloat512Vector.ZERO;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector iota() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.IOTA;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.IOTA;\n+                case 128: return Halffloat128Vector.IOTA;\n+                case 256: return Halffloat256Vector.IOTA;\n+                case 512: return Halffloat512Vector.IOTA;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        \/\/ Mask access\n+        @Override\n+        @ForceInline\n+        public final VectorMask<Halffloat> maskAll(boolean bit) {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.HalffloatMaxMask.maskAll(bit);\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.Halffloat64Mask.maskAll(bit);\n+                case 128: return Halffloat128Vector.Halffloat128Mask.maskAll(bit);\n+                case 256: return Halffloat256Vector.Halffloat256Mask.maskAll(bit);\n+                case 512: return Halffloat512Vector.Halffloat512Mask.maskAll(bit);\n+            }\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Finds a species for an element type of {@code short} and shape.\n+     *\n+     * @param s the shape\n+     * @return a species for an element type of {@code short} and shape\n+     * @throws IllegalArgumentException if no such species exists for the shape\n+     *\/\n+    static HalffloatSpecies species(VectorShape s) {\n+        Objects.requireNonNull(s);\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (HalffloatSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (HalffloatSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (HalffloatSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (HalffloatSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (HalffloatSpecies) SPECIES_MAX;\n+            default: throw new IllegalArgumentException(\"Bad shape: \" + s);\n+        }\n+    }\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_64_BIT VectorShape.S_64_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_64\n+        = new HalffloatSpecies(VectorShape.S_64_BIT,\n+                            Halffloat64Vector.class,\n+                            Halffloat64Vector.Halffloat64Mask.class,\n+                            Halffloat64Vector.Halffloat64Shuffle.class,\n+                            Halffloat64Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_128_BIT VectorShape.S_128_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_128\n+        = new HalffloatSpecies(VectorShape.S_128_BIT,\n+                            Halffloat128Vector.class,\n+                            Halffloat128Vector.Halffloat128Mask.class,\n+                            Halffloat128Vector.Halffloat128Shuffle.class,\n+                            Halffloat128Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_256_BIT VectorShape.S_256_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_256\n+        = new HalffloatSpecies(VectorShape.S_256_BIT,\n+                            Halffloat256Vector.class,\n+                            Halffloat256Vector.Halffloat256Mask.class,\n+                            Halffloat256Vector.Halffloat256Shuffle.class,\n+                            Halffloat256Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_512_BIT VectorShape.S_512_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_512\n+        = new HalffloatSpecies(VectorShape.S_512_BIT,\n+                            Halffloat512Vector.class,\n+                            Halffloat512Vector.Halffloat512Mask.class,\n+                            Halffloat512Vector.Halffloat512Shuffle.class,\n+                            Halffloat512Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_MAX\n+        = new HalffloatSpecies(VectorShape.S_Max_BIT,\n+                            HalffloatMaxVector.class,\n+                            HalffloatMaxVector.HalffloatMaxMask.class,\n+                            HalffloatMaxVector.HalffloatMaxShuffle.class,\n+                            HalffloatMaxVector::new);\n+\n+    \/**\n+     * Preferred species for {@link HalffloatVector}s.\n+     * A preferred species is a species of maximal bit-size for the platform.\n+     *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_PREFERRED\n+        = (HalffloatSpecies) VectorSpecies.ofPreferred(Halffloat.class);\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":4200,"deletions":0,"binary":false,"changes":4200,"status":"added"},{"patch":"@@ -648,1 +648,1 @@\n-                Int128Mask.class, int.class, VLENGTH, offset, limit,\n+                Int128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-                Int256Mask.class, int.class, VLENGTH, offset, limit,\n+                Int256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-                Int512Mask.class, int.class, VLENGTH, offset, limit,\n+                Int512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -644,1 +644,1 @@\n-                Int64Mask.class, int.class, VLENGTH, offset, limit,\n+                Int64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n+                IntMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG);\n+    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG),\n+    HALFFLOAT(Halffloat.class, Short.class, short[].class, 'F', 11, Halffloat.SIZE, T_HALFFLOAT);\n@@ -69,1 +70,6 @@\n-        assert(\"FDBSIL\".indexOf(typeChar) == ordinal()) : this;\n+        if (basicType == T_HALFFLOAT) {\n+          assert(\"FDBSILS\".indexOf(typeChar, \"FDBSILS\".indexOf(typeChar) + 1) == ordinal()) : this;\n+        }\n+        else {\n+          assert(\"FDBSILS\".indexOf(typeChar) == ordinal()) : this;\n+        }\n@@ -75,1 +81,1 @@\n-        assert(\"....zcFDBSILoav..\".charAt(basicType) == typeChar);\n+        assert(\"....zSFDBSILSoav..\".charAt(basicType) == typeChar);\n@@ -181,7 +187,8 @@\n-        SK_FLOAT    = 1,\n-        SK_DOUBLE   = 2,\n-        SK_BYTE     = 3,\n-        SK_SHORT    = 4,\n-        SK_INT      = 5,\n-        SK_LONG     = 6,\n-        SK_LIMIT    = 7;\n+        SK_FLOAT     = 1,\n+        SK_DOUBLE    = 2,\n+        SK_BYTE      = 3,\n+        SK_SHORT     = 4,\n+        SK_INT       = 5,\n+        SK_LONG      = 6,\n+        SK_HALFFLOAT = 7,\n+        SK_LIMIT     = 8;\n@@ -249,1 +256,2 @@\n-            } else {\n+            } else if (value.basicType != T_SHORT) {\n+                \/\/ FIXME: Support asFloating for short to be Halffloat\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LaneType.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-                Long128Mask.class, long.class, VLENGTH, offset, limit,\n+                Long128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-                Long256Mask.class, long.class, VLENGTH, offset, limit,\n+                Long256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-                Long512Mask.class, long.class, VLENGTH, offset, limit,\n+                Long512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-                Long64Mask.class, long.class, VLENGTH, offset, limit,\n+                Long64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n+                LongMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-                Short128Mask.class, short.class, VLENGTH, offset, limit,\n+                Short128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-                Short256Mask.class, short.class, VLENGTH, offset, limit,\n+                Short256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-                Short512Mask.class, short.class, VLENGTH, offset, limit,\n+                Short512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-                Short64Mask.class, short.class, VLENGTH, offset, limit,\n+                Short64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n+                ShortMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4006,1 +4006,1 @@\n-    Vector<?>\n+    HalffloatVector\n@@ -4008,3 +4008,2 @@\n-        LaneType flt = LaneType.SHORT.asFloating();\n-        \/\/ asFloating() will throw UnsupportedOperationException for the unsupported type short\n-        throw new AssertionError(\"Cannot reach here\");\n+        LaneType flt = LaneType.HALFFLOAT.asFloating();\n+        return (HalffloatVector) asVectorRaw(flt);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3030,0 +3030,13 @@\n+    \/**\n+     * Reinterprets this vector as a vector of the same shape\n+     * and contents but a lane type of {@code halffloat},\n+     * where the lanes are assembled from successive bytes\n+     * according to little-endian order.\n+     * It is a convenience method for the expression\n+     * {@code reinterpretShape(species().withLanes(halffloat.class))}.\n+     * It may be considered an inverse to {@link Vector#reinterpretAsBytes()}.\n+     *\n+     * @return a {@code HalffloatVector} with the same shape and information content\n+     *\/\n+    public abstract HalffloatVector reinterpretAsHalffloats();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -34,0 +35,2 @@\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n@@ -150,0 +153,4 @@\n+    static <V> V maybeRebox(V v) {\n+        U.loadFence();\n+        return v;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -667,0 +667,2 @@\n+    \/** Convert {@code byteVal} to {@code (halffloat)byteVal}. *\/\n+    public static final Conversion<Byte,Halffloat> B2H = convert(\"B2H\", 'C', byte.class, Halffloat.class, VO_KIND_CAST, VO_ALL);\n@@ -677,0 +679,2 @@\n+    \/** Convert {@code doubleVal} to {@code (halffloat)doubleVal}. *\/\n+    public static final Conversion<Double,Halffloat> D2H = convert(\"D2H\", 'C', double.class, Halffloat.class, VO_KIND_CAST, VO_ALL);\n@@ -687,0 +691,2 @@\n+    \/** Convert {@code floatVal} to {@code (halffloat)floatVal}. *\/\n+    public static final Conversion<Float,Halffloat> F2H = convert(\"F2H\", 'C', float.class, Halffloat.class, VO_KIND_CAST, VO_ALL);\n@@ -697,0 +703,2 @@\n+    \/** Convert {@code intVal} to {@code (halffloat)intVal}. *\/\n+    public static final Conversion<Integer,Halffloat> I2H = convert(\"I2H\", 'C', int.class, Halffloat.class, VO_KIND_CAST, VO_ALL);\n@@ -707,0 +715,2 @@\n+    \/** Convert {@code longVal} to {@code (halffloat)longVal}. *\/\n+    public static final Conversion<Long,Halffloat> L2H = convert(\"L2H\", 'C', long.class, Halffloat.class, VO_KIND_CAST, VO_ALL);\n@@ -717,0 +727,15 @@\n+    \/** Convert {@code shortVal} to {@code (halffloat)shortVal}. *\/\n+    public static final Conversion<Short,Halffloat> S2H = convert(\"S2H\", 'C', short.class, Halffloat.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (byte)halffloatVal}. *\/\n+    public static final Conversion<Halffloat,Byte> H2B = convert(\"H2B\", 'C', Halffloat.class, byte.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (short)halffloatVal}. *\/\n+    public static final Conversion<Halffloat,Short> H2S = convert(\"H2S\", 'C', Halffloat.class, short.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (double)halffloatVal}. *\/\n+    public static final Conversion<Halffloat,Double> H2D = convert(\"H2D\", 'C', Halffloat.class, double.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (float)halffloatVal}. *\/\n+    public static final Conversion<Halffloat,Float> H2F = convert(\"H2F\", 'C', Halffloat.class, float.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (int)halffloatVal}. *\/\n+    public static final Conversion<Halffloat,Integer> H2I = convert(\"H2I\", 'C', Halffloat.class, int.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (long)halffloatVal}. *\/\n+    public static final Conversion<Halffloat,Long> H2L = convert(\"H2L\", 'C', Halffloat.class, long.class, VO_KIND_CAST, VO_ALL);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -266,0 +266,3 @@\n+        if (etype == Halffloat.class) {\n+            etype = short.class;\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+    static final ValueLayout.Of$Elemtype$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n@@ -578,0 +578,5 @@\n+#if[short]\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), Halffloat.class, species.length(),\n+                        toBits((short)0), MODE_BROADCAST, vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+#else[short]\n@@ -581,0 +586,1 @@\n+#end[short]\n@@ -709,1 +715,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -739,1 +745,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -785,0 +791,1 @@\n+#if[!short]\n@@ -817,0 +824,34 @@\n+#else[!short]\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+#end[!short]\n@@ -869,1 +910,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -930,1 +971,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -941,0 +982,14 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+#else[FP16]\n@@ -953,0 +1008,1 @@\n+#end[FP16]\n@@ -978,0 +1034,1 @@\n+#if[!short]\n@@ -986,0 +1043,8 @@\n+#else[!short]\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+#end[!short]\n@@ -1158,1 +1223,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -1242,1 +1307,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -1284,1 +1349,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -1296,0 +1361,4 @@\n+#if[short]\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                    Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+#else[short]\n@@ -1298,0 +1367,1 @@\n+#end[short]\n@@ -2416,1 +2486,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $elemtype$.class, length(),\n@@ -2438,1 +2508,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $elemtype$.class, length(),\n@@ -2453,0 +2523,2 @@\n+#if[FP]\n+#if[!short]\n@@ -2459,0 +2531,17 @@\n+#end[!short]\n+#if[short]\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n+#end[short]\n+#else[FP]\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+#end[FP]\n@@ -2573,1 +2662,1 @@\n-            getClass(), maskType, $type$.class, length(),\n+            getClass(), maskType, $elemtype$.class, length(),\n@@ -2590,1 +2679,1 @@\n-            getClass(), $type$.class, length(),\n+            getClass(), $elemtype$.class, length(),\n@@ -2599,0 +2688,3 @@\n+#if[FP16]\n+                return v.add(sc == 1 ? iota : iota.mul(Float.floatToFloat16((float) sc)));\n+#else[FP16]\n@@ -2600,0 +2692,1 @@\n+#end[FP16]\n@@ -2782,1 +2875,1 @@\n-            getClass(), shuffletype, null, $type$.class, length(),\n+            getClass(), shuffletype, null, $elemtype$.class, length(),\n@@ -2814,1 +2907,1 @@\n-                   getClass(), shuffletype, masktype, $type$.class, length(),\n+                   getClass(), shuffletype, masktype, $elemtype$.class, length(),\n@@ -2842,1 +2935,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $elemtype$.class, length(),\n@@ -2850,1 +2943,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $elemtype$.class, length(),\n@@ -2885,1 +2978,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $elemtype$.class, length(), this, m,\n@@ -2904,1 +2997,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $elemtype$.class, length(), this, m,\n@@ -3281,1 +3374,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -3299,1 +3392,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -3310,0 +3403,10 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(($type$)1, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(b) * Float.float16ToFloat(b))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+#else[FP16]\n@@ -3318,0 +3421,1 @@\n+#end[FP16]\n@@ -3469,0 +3573,3 @@\n+#if[FP16]\n+            $type$ e = (short) Halffloat.valueOf(a[i]).floatValue();\n+#else[FP16]\n@@ -3470,0 +3577,1 @@\n+#end[FP16]\n@@ -3510,0 +3618,3 @@\n+#if[FP16]\n+            res[i] = (double) Halffloat.valueOf(a[i]).floatValue();\n+#else[FP16]\n@@ -3511,0 +3622,1 @@\n+#end[FP16]\n@@ -5256,1 +5368,9 @@\n-    {#if[byteOrShort]?Vector<?>:$Fptype$Vector}\n+#if[FP]\n+#if[short]\n+    $Type$Vector\n+#else[short]\n+    $Fptype$Vector\n+#end[short]\n+#else[FP]\n+    {#if[byte]?Vector<?>:$Fptype$Vector}\n+#end[FP]\n@@ -5261,0 +5381,3 @@\n+#if[short]\n+        LaneType flt = LaneType.HALFFLOAT.asFloating();\n+#else[short]\n@@ -5262,1 +5385,2 @@\n-#if[!byteOrShort]\n+#end[short]\n+#if[!byte]\n@@ -5264,1 +5388,1 @@\n-#else[!byteOrShort]\n+#else[!byte]\n@@ -5267,1 +5391,1 @@\n-#end[!byteOrShort]\n+#end[!byte]\n@@ -5341,1 +5465,1 @@\n-            super(shape, LaneType.of($type$.class),\n+            super(shape, LaneType.of($elemtype$.class),\n@@ -5352,1 +5476,1 @@\n-            return $type$.class;\n+            return $elemtype$.class;\n@@ -5381,1 +5505,1 @@\n-                    vectorType, $type$.class, laneCount,\n+                    vectorType, $elemtype$.class, laneCount,\n@@ -5435,0 +5559,7 @@\n+#if[FP16]\n+                $type$ v = Float.floatToFloat16((float) lv);\n+                va[i] = v;\n+                if ((int) Float.float16ToFloat(v) != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+#else[FP16]\n@@ -5440,0 +5571,1 @@\n+#end[FP16]\n@@ -5665,1 +5797,1 @@\n-        = ($Type$Species) VectorSpecies.ofPreferred($type$.class);\n+        = ($Type$Species) VectorSpecies.ofPreferred($elemtype$.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":160,"deletions":28,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+    static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ used by the JVM\n@@ -91,1 +91,1 @@\n-    public final Class<$Boxtype$> elementType() { return $type$.class; }\n+    public final Class<$Boxtype$> elementType() { return $elemtype$.class; }\n@@ -530,0 +530,18 @@\n+#if[!16L]\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+#end[!16L]\n@@ -580,0 +598,18 @@\n+#if[!16L]\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+#end[!16L]\n@@ -813,1 +849,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ used by the JVM\n@@ -915,1 +951,1 @@\n-                $masktype$.class, $type$.class, VLENGTH, offset, limit,\n+                $masktype$.class, ETYPE, VLENGTH, offset, limit,\n@@ -932,0 +968,3 @@\n+#if[FP16]\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+#else[FP16]\n@@ -933,0 +972,1 @@\n+#end[FP16]\n@@ -943,1 +983,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $maskbitstype$.class, VLENGTH,\n@@ -953,1 +993,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $maskbitstype$.class, VLENGTH,\n@@ -963,1 +1003,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $maskbitstype$.class, VLENGTH,\n@@ -973,1 +1013,1 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -980,1 +1020,1 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -987,1 +1027,1 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -997,1 +1037,1 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -1006,1 +1046,1 @@\n-            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.test(BT_ne, $masktype$.class, $maskbitstype$.class, VLENGTH,\n@@ -1014,1 +1054,1 @@\n-            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.test(BT_overflow, $masktype$.class, $maskbitstype$.class, VLENGTH,\n@@ -1022,1 +1062,1 @@\n-            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced($masktype$.class, $maskbitstype$.class, VLENGTH,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":54,"deletions":14,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-for type in byte short int long float double\n+for type in byte short int long float double halffloat\n@@ -58,0 +58,1 @@\n+\n@@ -60,0 +61,8 @@\n+\n+  case $type in\n+    halffloat)\n+       type=short\n+       TYPE=SHORT\n+       ;;\n+  esac\n+\n@@ -69,0 +78,1 @@\n+  maskbitstype=$type\n@@ -75,0 +85,3 @@\n+  elemtype=$type\n+  Elemtype=$Type\n+  FPtype=$type\n@@ -76,2 +89,2 @@\n-  case $type in\n-    byte)\n+  case $Type in\n+    Byte)\n@@ -82,1 +95,4 @@\n-    short)\n+    Short)\n+      fptype=halffloat\n+      Fptype=Halffloat\n+      Boxfptype=Halffloat\n@@ -87,1 +103,1 @@\n-    int)\n+    Int)\n@@ -97,1 +113,1 @@\n-    long)\n+    Long)\n@@ -104,1 +120,1 @@\n-    float)\n+    Float)\n@@ -107,0 +123,1 @@\n+      maskbitstype=int\n@@ -111,0 +128,1 @@\n+      FPtype=FP32\n@@ -112,1 +130,1 @@\n-    double)\n+    Double)\n@@ -115,0 +133,1 @@\n+      maskbitstype=long\n@@ -119,0 +138,13 @@\n+      FPtype=FP64\n+      ;;\n+    Halffloat)\n+      kind=FP\n+      bitstype=short\n+      maskbitstype=Halffloat\n+      Bitstype=Short\n+      Boxbitstype=Short\n+      sizeInBytes=2\n+      elemtype=Halffloat\n+      Elemtype=Short\n+      FPtype=FP16\n+      args=\"$args -KbyteOrShort -KshortOrFP -KshortOrHalffloat\"\n@@ -122,2 +154,2 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n+  args=\"$args -K$FPtype -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -Dbitstype=$bitstype -Dmaskbitstype=$maskbitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n@@ -126,0 +158,1 @@\n+  args=\"$args -Delemtype=$elemtype -DElemtype=$Elemtype\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -235,0 +235,1 @@\n+        AVX512_FP16,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @requires (os.simpleArch == \"x64\" & (vm.cpu.features ~= \".*avx512f.*\" | vm.cpu.features ~= \".*f16c.*\")) | os.arch == \"aarch64\"\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx512_fp16.*\") | os.arch == \"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.incubator.vector.Halffloat;\n@@ -159,0 +160,25 @@\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill_halffloat(int s, ToHalffloatF f) {\n+        return fill_halffloat(new short[s], f);\n+    }\n+\n+    static short[] fill_halffloat(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        if (a.length > 7) {\n+            a[0] = Halffloat.MAX_VALUE;\n+            a[1] = Halffloat.MIN_VALUE;\n+            a[2] = Halffloat.NEGATIVE_INFINITY;\n+            a[3] = Halffloat.POSITIVE_INFINITY;\n+            a[4] = Halffloat.NaN;\n+            a[5] = (short)0.0;\n+            a[6] = Short.MIN_VALUE;\n+        }\n+        return a;\n+    }\n+\n+\n@@ -183,0 +209,4 @@\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat(i)\", (int s) -> fill_halffloat(s, i -> (short) (i * 100 + 1)))\n+    );\n+\n@@ -202,0 +232,3 @@\n+        else if (src == Halffloat.class) {\n+            return HALFFLOAT_GENERATORS;\n+        }\n@@ -209,1 +242,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Halffloat.class)) {\n@@ -213,1 +246,1 @@\n-            for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+            for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Halffloat.class)) {\n@@ -228,1 +261,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Halffloat.class)) {\n@@ -233,1 +266,1 @@\n-                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Halffloat.class)) {\n@@ -248,1 +281,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Halffloat.class)) {\n@@ -251,1 +284,1 @@\n-                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Halffloat.class)) {\n@@ -264,1 +297,0 @@\n-\n@@ -274,1 +306,2 @@\n-        else if (to == float.class)\n+        \/\/ Treat halffloat as float.\n+        else if (to == float.class || to == Halffloat.class)\n@@ -285,1 +318,1 @@\n-        else if (from == short.class)\n+        else if (from == short.class || from == Halffloat.class)\n@@ -302,1 +335,1 @@\n-        else if (to == short.class)\n+        else if (to == short.class || to == Halffloat.class)\n@@ -338,0 +371,2 @@\n+                                    VectorSpecies srcSpecies,\n+                                    VectorSpecies dstSpecies,\n@@ -339,0 +374,4 @@\n+        if (srcSpecies.elementType() == dstSpecies.elementType()) {\n+            System.arraycopy(src, srcPos, dest, destPos, length);\n+            return;\n+        }\n@@ -341,1 +380,8 @@\n-            Array.set(dest, destPos + i, c.apply(v));\n+            if (srcSpecies.elementType() == Halffloat.class) {\n+                v = (Number) Float.float16ToFloat(v.shortValue());\n+            }\n+            v = (Number) c.apply(v);\n+            if (dstSpecies.elementType() == Halffloat.class) {\n+                v = (Number) Halffloat.valueOf(v.floatValue());\n+            }\n+            Array.set(dest, destPos + i, v);\n@@ -423,2 +469,8 @@\n-        Object expected = Array.newInstance(destSpecies.elementType(), out_len);\n-        Object actual = Array.newInstance(destSpecies.elementType(), out_len);\n+        Object expected = null, actual = null;\n+        if (destSpecies.elementType() == Halffloat.class) {\n+            expected = Array.newInstance(short.class, out_len);\n+            actual = Array.newInstance(short.class, out_len);\n+        } else {\n+            expected = Array.newInstance(destSpecies.elementType(), out_len);\n+            actual = Array.newInstance(destSpecies.elementType(), out_len);\n+        }\n@@ -435,1 +487,1 @@\n-                copyConversionArray(in, i, expected, start_idx + j, src_species_len, convertValue);\n+                copyConversionArray(in, i, expected, start_idx + j, src_species_len, srcSpecies, destSpecies, convertValue);\n@@ -438,1 +490,1 @@\n-                copyConversionArray(in, start_idx + i, expected, j, dst_species_len, convertValue);\n+                copyConversionArray(in, start_idx + i, expected, j, dst_species_len, srcSpecies, destSpecies, convertValue);\n@@ -472,2 +524,8 @@\n-        Object expected = Array.newInstance(dstSpecies.elementType(), out_len);\n-        Object actual = Array.newInstance(dstSpecies.elementType(), out_len);\n+        Object expected = null, actual = null;\n+        if (dstSpecies.elementType() == Halffloat.class) {\n+            expected = Array.newInstance(short.class, out_len);\n+            actual = Array.newInstance(short.class, out_len);\n+        } else {\n+            expected = Array.newInstance(dstSpecies.elementType(), out_len);\n+            actual = Array.newInstance(dstSpecies.elementType(), out_len);\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorConversionTest.java","additions":75,"deletions":17,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -39,2 +40,2 @@\n-    static final VectorSpecies<Float> SPECIES =\n-            FloatVector.SPECIES_256;\n+    static final VectorSpecies<Halffloat> SPECIES =\n+            HalffloatVector.SPECIES_128;\n@@ -43,3 +44,3 @@\n-    static float[] a = new float[SIZE];\n-    static float[] b = new float[SIZE];\n-    static float[] c = new float[SIZE];\n+    static short[] a = new short[SIZE];\n+    static short[] b = new short[SIZE];\n+    static short[] c = new short[SIZE];\n@@ -49,2 +50,2 @@\n-            a[i] = 1f;\n-            b[i] = 2f;\n+            a[i] = Halffloat.valueOf((float)i);\n+            b[i] = Halffloat.valueOf((float)i);\n@@ -56,2 +57,2 @@\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n@@ -62,1 +63,1 @@\n-    static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SPECIES.length()).toArray();\n+    \/*static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SPECIES.length()).toArray();\n@@ -70,1 +71,1 @@\n-    }\n+    }*\/\n@@ -77,1 +78,6 @@\n-            if (c[i] != a[i] + b[i])\n+            Halffloat hfa = new Halffloat(a[i]);\n+            Halffloat hfb = new Halffloat(b[i]);\n+            Halffloat hfc = new Halffloat(c[i]);\n+\n+            if (hfc.floatValue() != (hfa.floatValue() + hfb.floatValue())) {\n+                System.out.println(\"RES: \" + hfc.floatValue() + \" EXPECTED: \" + (hfa.floatValue() + hfb.floatValue()));\n@@ -79,0 +85,1 @@\n+            }\n@@ -81,1 +88,1 @@\n-        Arrays.fill(c, 0.0f);\n+        \/*Arrays.fill(c, 0.0f);\n@@ -89,1 +96,1 @@\n-        }\n+        }*\/\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -905,0 +905,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -958,1 +962,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -962,1 +966,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -966,1 +970,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -978,0 +978,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -996,1 +1000,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1000,1 +1004,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1004,1 +1008,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1038,0 +1042,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1041,1 +1049,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1043,1 +1051,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1045,1 +1053,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1047,1 +1055,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1049,1 +1057,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1051,1 +1059,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1076,1 +1084,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1080,1 +1088,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1084,1 +1092,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -978,0 +978,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -996,1 +1000,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1000,1 +1004,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1004,1 +1008,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1038,0 +1042,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1041,1 +1049,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1043,1 +1051,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1045,1 +1053,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1047,1 +1055,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1049,1 +1057,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1051,1 +1059,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1087,1 +1095,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1091,1 +1099,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1095,1 +1103,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,849 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat128VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat128VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorLoadStoreTests.java","additions":849,"deletions":0,"binary":false,"changes":849,"status":"added"},{"patch":"@@ -0,0 +1,3134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat128VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat128VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SIN, Halffloat128VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXP, Halffloat128VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG1P, Halffloat128VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG, Halffloat128VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG10, Halffloat128VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXPM1, Halffloat128VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COS, Halffloat128VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TAN, Halffloat128VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SINH, Halffloat128VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COSH, Halffloat128VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TANH, Halffloat128VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ASIN, Halffloat128VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ACOS, Halffloat128VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ATAN, Halffloat128VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::CBRT, Halffloat128VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::HYPOT, Halffloat128VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::ATAN2, Halffloat128VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::ADDReduceLong, Halffloat128VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::ADDReduceLongMasked, Halffloat128VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat128VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_128_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":3134,"deletions":0,"binary":false,"changes":3134,"status":"added"},{"patch":"@@ -0,0 +1,849 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat256VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat256VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorLoadStoreTests.java","additions":849,"deletions":0,"binary":false,"changes":849,"status":"added"},{"patch":"@@ -0,0 +1,3134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat256VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat256VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SIN, Halffloat256VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXP, Halffloat256VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG1P, Halffloat256VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG, Halffloat256VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG10, Halffloat256VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXPM1, Halffloat256VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COS, Halffloat256VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TAN, Halffloat256VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SINH, Halffloat256VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COSH, Halffloat256VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TANH, Halffloat256VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ASIN, Halffloat256VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ACOS, Halffloat256VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ATAN, Halffloat256VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::CBRT, Halffloat256VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::HYPOT, Halffloat256VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::ATAN2, Halffloat256VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::ADDReduceLong, Halffloat256VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::ADDReduceLongMasked, Halffloat256VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat256VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_256_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":3134,"deletions":0,"binary":false,"changes":3134,"status":"added"},{"patch":"@@ -0,0 +1,849 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat512VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat512VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorLoadStoreTests.java","additions":849,"deletions":0,"binary":false,"changes":849,"status":"added"},{"patch":"@@ -0,0 +1,3134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat512VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat512VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SIN, Halffloat512VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXP, Halffloat512VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG1P, Halffloat512VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG, Halffloat512VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG10, Halffloat512VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXPM1, Halffloat512VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COS, Halffloat512VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TAN, Halffloat512VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SINH, Halffloat512VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COSH, Halffloat512VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TANH, Halffloat512VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ASIN, Halffloat512VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ACOS, Halffloat512VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ATAN, Halffloat512VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::CBRT, Halffloat512VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::HYPOT, Halffloat512VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::ATAN2, Halffloat512VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::ADDReduceLong, Halffloat512VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::ADDReduceLongMasked, Halffloat512VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat512VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_512_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":3134,"deletions":0,"binary":false,"changes":3134,"status":"added"},{"patch":"@@ -0,0 +1,849 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat64VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat64VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorLoadStoreTests.java","additions":849,"deletions":0,"binary":false,"changes":849,"status":"added"},{"patch":"@@ -0,0 +1,3134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat64VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat64VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SIN, Halffloat64VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXP, Halffloat64VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG1P, Halffloat64VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG, Halffloat64VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG10, Halffloat64VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXPM1, Halffloat64VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COS, Halffloat64VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TAN, Halffloat64VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SINH, Halffloat64VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COSH, Halffloat64VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TANH, Halffloat64VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ASIN, Halffloat64VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ACOS, Halffloat64VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ATAN, Halffloat64VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::CBRT, Halffloat64VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::HYPOT, Halffloat64VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::ATAN2, Halffloat64VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::ADDReduceLong, Halffloat64VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::ADDReduceLongMasked, Halffloat64VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat64VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_64_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":3134,"deletions":0,"binary":false,"changes":3134,"status":"added"},{"patch":"@@ -0,0 +1,856 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\n+ *      -XX:-TieredCompilation HalffloatMaxVectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class HalffloatMaxVectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Halffloat.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Halffloat.SIZE, SegmentScope.auto());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorLoadStoreTests.java","additions":856,"deletions":0,"binary":false,"changes":856,"status":"added"},{"patch":"@@ -0,0 +1,3123 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation HalffloatMaxVectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class HalffloatMaxVectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Halffloat.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Halffloat.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Halffloat> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Halffloat> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Halffloat> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Halffloat> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SIN, HalffloatMaxVectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXP, HalffloatMaxVectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG1P, HalffloatMaxVectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG, HalffloatMaxVectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG10, HalffloatMaxVectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXPM1, HalffloatMaxVectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COS, HalffloatMaxVectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TAN, HalffloatMaxVectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SINH, HalffloatMaxVectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COSH, HalffloatMaxVectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TANH, HalffloatMaxVectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ASIN, HalffloatMaxVectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ACOS, HalffloatMaxVectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ATAN, HalffloatMaxVectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::CBRT, HalffloatMaxVectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::HYPOT, HalffloatMaxVectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2HalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::ATAN2, HalffloatMaxVectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::ADDReduceLong, HalffloatMaxVectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::ADDReduceLongMasked, HalffloatMaxVectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloatMaxVectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloatMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_Max_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloatMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":3123,"deletions":0,"binary":false,"changes":3123,"status":"added"},{"patch":"@@ -900,0 +900,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -905,0 +905,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -948,1 +952,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -956,1 +960,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -862,0 +862,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -880,1 +884,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -884,1 +888,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -888,1 +892,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -938,1 +942,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -942,1 +946,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -946,1 +950,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -905,0 +905,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -948,1 +952,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -956,1 +960,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1390,1 +1394,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1392,1 +1396,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-generate_perf_tests=$1\n+generate_perf_tests=$2\n@@ -66,0 +66,1 @@\n+unary_math_hf_template=\"Unary-op-hf-math\"\n@@ -67,0 +68,1 @@\n+binary_math_hf_template=\"Binary-op-hf-math\"\n@@ -68,0 +70,1 @@\n+binary_math_hf_broadcast_template=\"Binary-Broadcast-op-hf-math\"\n@@ -401,180 +404,214 @@\n-# ALU binary ops.\n-# Here \"ADD+add+withMask\" says VectorOperator name is \"ADD\", and we have a dedicate method too named 'add', and add() is also available with mask variant.\n-gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n-gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n-gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n-gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n-gen_op_tmpl \"Binary-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_op_tmpl \"Binary-Masked-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n-gen_binary_alu_op \"AND+and\"   \"a \\& b\"  \"BITWISE\"\n-gen_binary_alu_op \"AND_NOT\" \"a \\& ~b\" \"BITWISE\"\n-gen_binary_alu_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n-# Missing:        \"OR_UNCHECKED\"\n-gen_binary_alu_op \"XOR\"   \"a ^ b\"   \"BITWISE\"\n-gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n-gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n-# Generate the broadcast versions\n-gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n-gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n-gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n-gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n-gen_op_tmpl \"Binary-Broadcast-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_op_tmpl \"Binary-Broadcast-Masked-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_binary_alu_bcst_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n-gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n-gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n-gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n-\n-# Shifts\n-gen_binary_alu_op \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0xF))\" \"short\"\n-gen_binary_alu_op \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0xF))\" \"short\"\n-gen_binary_alu_op \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_binary_alu_op \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 0xF))\" \"short\"\n-gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n-gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n-gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n-gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n-gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n-gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n-gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n-gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n-gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n-gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n-\n-# Constant Shifts\n-gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n-gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n-\n-# Masked reductions.\n-gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n-gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n-\n-# Reductions.\n-gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n-gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n-gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n-gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n-gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n-gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n-\n-# Boolean reductions.\n-gen_bool_reduction_op \"anyTrue\" \"|\" \"BITWISE\" \"false\"\n-gen_bool_reduction_op \"allTrue\" \"\\&\" \"BITWISE\" \"true\"\n-\n-#Insert\n-gen_with_op \"withLane\" \"\" \"\" \"\"\n-\n-# Tests\n-gen_op_tmpl $test_template \"IS_DEFAULT\" \"bits(a)==0\"\n-gen_op_tmpl $test_template \"IS_NEGATIVE\" \"bits(a)<0\"\n-gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n-\n-# Compares\n-gen_compare_op \"LT+lt\" \"lt\"\n-gen_compare_op \"GT\" \"gt\"\n-gen_compare_op \"EQ+eq\" \"eq\"\n-gen_compare_op \"NE\" \"neq\"\n-gen_compare_op \"LE\" \"le\"\n-gen_compare_op \"GE\" \"ge\"\n-\n-gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n-\n-\n-gen_compare_bcst_op \"LT\" \"<\"\n-gen_compare_bcst_op \"EQ\" \"==\"\n-\n-# Blend.\n-gen_op_tmpl $blend \"blend\" \"\"\n-\n-# Rearrange\n-gen_op_tmpl $rearrange_template \"rearrange\" \"\"\n-\n-# Compress\/Expand\n-gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n-\n-# Get\n-gen_get_op \"lane\" \"\"\n-\n-# Broadcast\n-gen_op_tmpl $broadcast_template \"broadcast\" \"\"\n-\n-# Zero\n-gen_op_tmpl $zero_template \"zero\" \"\"\n-\n-# Slice\n-gen_op_tmpl $slice_template \"sliceUnary\" \"\"\n-gen_op_tmpl $slice1_template \"sliceBinary\" \"\"\n-gen_op_tmpl $slice1_masked_template \"slice\" \"\"\n-\n-# Unslice\n-gen_op_tmpl $unslice_template \"unsliceUnary\" \"\"\n-gen_op_tmpl $unslice1_template \"unsliceBinary\" \"\"\n-gen_op_tmpl $unslice1_masked_template \"unslice\" \"\"\n-\n-# Math\n-gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-\n-# Ternary operations.\n-gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-gen_ternary_alu_bcst_op \"FMA\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-gen_ternary_alu_double_bcst_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_double_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-\n-# Unary operations.\n-gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n-gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n-gen_unary_alu_op \"NOT+not\" \"~((\\$type\\$)a)\" \"BITWISE\"\n-gen_unary_alu_op \"ZOMO\" \"(a==0?0:-1)\" \"BITWISE\"\n-gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n-gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n-gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n-gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n-gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n+if [ \"$1\" == \"ALL_PRIM_TYPES\" ]; then\n+  # ALU binary ops.\n+  # Here \"ADD+add+withMask\" says VectorOperator name is \"ADD\", and we have a dedicate method too named 'add', and add() is also available with mask variant.\n+  gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n+  gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n+  gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n+  gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n+  gen_op_tmpl \"Binary-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_op_tmpl \"Binary-Masked-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n+  gen_binary_alu_op \"AND+and\"   \"a \\& b\"  \"BITWISE\"\n+  gen_binary_alu_op \"AND_NOT\" \"a \\& ~b\" \"BITWISE\"\n+  gen_binary_alu_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n+  # Missing:        \"OR_UNCHECKED\"\n+  gen_binary_alu_op \"XOR\"   \"a ^ b\"   \"BITWISE\"\n+  gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n+  gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n+  # Generate the broadcast versions\n+  gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n+  gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n+  gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n+  gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n+  gen_op_tmpl \"Binary-Broadcast-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_op_tmpl \"Binary-Broadcast-Masked-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_binary_alu_bcst_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n+\n+  # Shifts\n+  gen_binary_alu_op \"LSHL\" \"(a << b)\" \"intOrLong\"\n+  gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0xF))\" \"short\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0xF))\" \"short\"\n+  gen_binary_alu_op \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+  gen_binary_alu_op \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 0xF))\" \"short\"\n+  gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n+  gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n+  gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+  gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n+  gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+  gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n+  gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+  gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n+  gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n+  gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n+\n+  # Constant Shifts\n+  gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n+  gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n+  gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n+  gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+\n+  # Masked reductions.\n+  gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n+  gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+  gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n+  gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+\n+  # Reductions.\n+  gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n+  gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n+  gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n+  gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n+  gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n+  gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n+  gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n+  gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n+\n+  # Boolean reductions.\n+  gen_bool_reduction_op \"anyTrue\" \"|\" \"BITWISE\" \"false\"\n+  gen_bool_reduction_op \"allTrue\" \"\\&\" \"BITWISE\" \"true\"\n+\n+  #Insert\n+  gen_with_op \"withLane\" \"\" \"\" \"\"\n+\n+  # Tests\n+  gen_op_tmpl $test_template \"IS_DEFAULT\" \"bits(a)==0\"\n+  gen_op_tmpl $test_template \"IS_NEGATIVE\" \"bits(a)<0\"\n+  gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n+  gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n+  gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n+\n+  # Compares\n+  gen_compare_op \"LT+lt\" \"lt\"\n+  gen_compare_op \"GT\" \"gt\"\n+  gen_compare_op \"EQ+eq\" \"eq\"\n+  gen_compare_op \"NE\" \"neq\"\n+  gen_compare_op \"LE\" \"le\"\n+  gen_compare_op \"GE\" \"ge\"\n+\n+  gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n+  gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n+  gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n+  gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n+\n+\n+  gen_compare_bcst_op \"LT\" \"<\"\n+  gen_compare_bcst_op \"EQ\" \"==\"\n+\n+  # Blend.\n+  gen_op_tmpl $blend \"blend\" \"\"\n+\n+  # Rearrange\n+  gen_op_tmpl $rearrange_template \"rearrange\" \"\"\n+\n+  # Compress\/Expand\n+  gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n+\n+  # Get\n+  gen_get_op \"lane\" \"\"\n+\n+  # Broadcast\n+  gen_op_tmpl $broadcast_template \"broadcast\" \"\"\n+\n+  # Zero\n+  gen_op_tmpl $zero_template \"zero\" \"\"\n+\n+  # Slice\n+  gen_op_tmpl $slice_template \"sliceUnary\" \"\"\n+  gen_op_tmpl $slice1_template \"sliceBinary\" \"\"\n+  gen_op_tmpl $slice1_masked_template \"slice\" \"\"\n+\n+  # Unslice\n+  gen_op_tmpl $unslice_template \"unsliceUnary\" \"\"\n+  gen_op_tmpl $unslice1_template \"unsliceBinary\" \"\"\n+  gen_op_tmpl $unslice1_masked_template \"unslice\" \"\"\n+\n+  # Math\n+  gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+\n+  # Ternary operations.\n+  gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+  gen_ternary_alu_bcst_op \"FMA\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+  gen_ternary_alu_double_bcst_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_double_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+\n+  # Unary operations.\n+  gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n+  gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n+  gen_unary_alu_op \"NOT+not\" \"~((\\$type\\$)a)\" \"BITWISE\"\n+  gen_unary_alu_op \"ZOMO\" \"(a==0?0:-1)\" \"BITWISE\"\n+  gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n+  gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n+\n+elif [ \"$1\" == \"HALF_FLOAT_TYPE\" ]; then\n+  gen_binary_alu_op \"ADD\" \"Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"SUB\" \"Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"MUL\" \"Float.floatToFloat16(Float.float16ToFloat(a) \\* Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"DIV\" \"Float.floatToFloat16(Float.float16ToFloat(a) \\\/ Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"MAX\" \"Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))\" \"Halffloat\"\n+  gen_binary_alu_op \"MIN\" \"Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))\" \"Halffloat\"\n+  gen_unary_alu_op \"ABS+abs\" \"Math.abs(a)\" \"Halffloat\"\n+  gen_unary_alu_op \"NEG+neg\" \"-a\" \"Halffloat\"\n+  gen_ternary_alu_op \"FMA+fma\" \"Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c)))\" \"Halffloat\"\n+  gen_unary_alu_op \"SQRT+sqrt\" \"Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a)))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"SIN\" \"Math.sin(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"EXP\" \"Math.exp(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG1P\" \"Math.log1p(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG\" \"Math.log(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG10\" \"Math.log10(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"EXPM1\" \"Math.expm1(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"COS\" \"Math.cos(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"TAN\" \"Math.tan(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"SINH\" \"Math.sinh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"COSH\" \"Math.cosh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"TANH\" \"Math.tanh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ASIN\" \"Math.asin(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ACOS\" \"Math.acos(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ATAN\" \"Math.atan(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"CBRT\" \"Math.cbrt(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"HYPOT\" \"Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"POW+pow\" \"Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"ATAN2\" \"Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $blend \"blend\" \"Halffloat\"\n+fi\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":218,"deletions":181,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -31,5 +31,2 @@\n-case $* in\n-'')             CLASS_FILTER='*';;\n---generate*)    CLASS_FILTER=${2-'*'};;\n---help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n-esac\n+generate_test_cases() {\n+  Log false \"Generating Vector API tests, $(date)\\n\"\n@@ -37,1 +34,5 @@\n-. config.sh\n+  # Compile SPP\n+  Log true \"Compiling SPP... \"\n+  compilation=$(${JAVAC} -d . \"${JDK_SRC_HOME}\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\")\n+  Log false \"$compilation\\n\"\n+  Log true \"done\\n\"\n@@ -39,5 +40,6 @@\n-# Detect whether to generate the performance tests\n-generate_perf_tests=false\n-if [ -d \"$PERF_DEST\" ]; then\n-  generate_perf_tests=true\n-fi\n+  array=()\n+  if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n+    array=(\"byte\" \"short\" \"int\" \"long\" \"float\" \"double\")\n+  elif [ $1 == \"HALF_FLOAT_TYPE\" ]; then\n+    array=(\"halffloat\")\n+  fi\n@@ -45,92 +47,2 @@\n-# First, generate the template file.\n-bash .\/gen-template.sh $generate_perf_tests\n-\n-Log false \"Generating Vector API tests, $(date)\\n\"\n-\n-# Compile SPP\n-Log true \"Compiling SPP... \"\n-compilation=$(${JAVAC} -d . \"${JDK_SRC_HOME}\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\")\n-Log false \"$compilation\\n\"\n-Log true \"done\\n\"\n-\n-# For each type\n-for type in byte short int long float double\n-do\n-  Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n-  TYPE=\"$(tr '[:lower:]' '[:upper:]' <<< ${type})\"\n-  args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n-\n-  Boxtype=$Type\n-  Wideboxtype=$Boxtype\n-  MaxValue=MAX_VALUE\n-  MinValue=MIN_VALUE\n-\n-  kind=BITWISE\n-\n-  bitstype=$type\n-  Bitstype=$Type\n-  Boxbitstype=$Boxtype\n-\n-  fptype=$type\n-  Fptype=$Type\n-  Boxfptype=$Boxtype\n-\n-  case $type in\n-    byte)\n-      Wideboxtype=Byte\n-      args=\"$args -KbyteOrShort\"\n-      ;;\n-    short)\n-      Wideboxtype=Short\n-      args=\"$args -KbyteOrShort\"\n-      ;;\n-    int)\n-      Boxtype=Integer\n-      Wideboxtype=Integer\n-      fptype=float\n-      Fptype=Float\n-      Boxfptype=Float\n-      args=\"$args -KintOrLong\"\n-      ;;\n-    long)\n-      Wideboxtype=Long\n-      fptype=double\n-      Fptype=Double\n-      Boxfptype=Double\n-      args=\"$args -KintOrLong\"\n-      ;;\n-    float)\n-      kind=FP\n-      bitstype=int\n-      Bitstype=Int\n-      Boxbitstype=Integer\n-      Wideboxtype=Float\n-      MaxValue=POSITIVE_INFINITY\n-      MinValue=NEGATIVE_INFINITY\n-      ;;\n-    double)\n-      kind=FP\n-      bitstype=long\n-      Bitstype=Long\n-      Boxbitstype=Long\n-      Wideboxtype=Double\n-      MaxValue=POSITIVE_INFINITY\n-      MinValue=NEGATIVE_INFINITY\n-      ;;\n-  esac\n-\n-  args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n-  args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n-\n-  abstractvectortype=${typeprefix}${Type}Vector\n-  abstractvectorteststype=${typeprefix}${Type}VectorTests\n-  abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n-  abstractfpvectortype=${typeprefix}${Fptype}Vector\n-  args=\"$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype\"\n-\n-  # Generate tests for operations\n-  # For each size\n-  Log true \"${Type}:\"\n-\n-  for bits in 64 128 256 512 Max\n+  # For each type\n+  for type in ${array[@]}\n@@ -138,29 +50,105 @@\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}Vector\n-    masktype=${typeprefix}${Type}${bits}Mask\n-    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n-    fpvectortype=${typeprefix}${Fptype}${bits}Vector\n-    shape=S${bits}Bit\n-    Shape=S_${bits}_BIT\n-    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n-      args=\"$args -KByteMax\"\n-    fi\n-    bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n-    if [ $bits == 'Max' ]; then\n-      bitargs=\"$bitargs -KMaxBit\"\n-    fi\n-\n-    # Generate jtreg tests\n-    case $vectorteststype in\n-    $CLASS_FILTER)\n-      Log true \" ${bits}_jtreg $vectorteststype.java\"\n-      Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java \"\n-      TEST_DEST_FILE=\"${vectorteststype}.java\"\n-      rm -f ${TEST_DEST_FILE}\n-      ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \\\n-        -i${TEMPLATE_FILE} \\\n-        -o${TEST_DEST_FILE}\n-      if [ VAR_OS_ENV==windows.cygwin ]; then\n-        tr -d  '\\r' < ${TEST_DEST_FILE} > temp\n-        mv temp ${TEST_DEST_FILE}\n+    Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n+    TYPE=\"$(tr '[:lower:]' '[:upper:]' <<< ${type})\"\n+    args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n+\n+    Boxtype=$Type\n+    Wideboxtype=$Boxtype\n+    MaxValue=MAX_VALUE\n+    MinValue=MIN_VALUE\n+    ElementType=$Type\n+    kind=BITWISE\n+    VecEleType=$Type\n+    bitstype=$type\n+    Bitstype=$Type\n+    Boxbitstype=$Boxtype\n+    fptype=$type\n+    Fptype=$Type\n+    Boxfptype=$Boxtype\n+    ClassType=$type\n+\n+    case $type in\n+      byte)\n+        Wideboxtype=Byte\n+        args=\"$args -KbyteOrShort\"\n+        ;;\n+      short)\n+        Wideboxtype=Short\n+        args=\"$args -KbyteOrShort\"\n+        ;;\n+      int)\n+        ElementType=Int\n+        VecEleType=Integer\n+        Boxtype=Integer\n+        Wideboxtype=Integer\n+        fptype=float\n+        Fptype=Float\n+        Boxfptype=Float\n+        args=\"$args -KintOrLong\"\n+        ;;\n+      long)\n+        Wideboxtype=Long\n+        fptype=double\n+        Fptype=Double\n+        Boxfptype=Double\n+        args=\"$args -KintOrLong\"\n+        ;;\n+      float)\n+        kind=FP\n+        bitstype=int\n+        Bitstype=Int\n+        Boxbitstype=Integer\n+        Wideboxtype=Float\n+        MaxValue=POSITIVE_INFINITY\n+        MinValue=NEGATIVE_INFINITY\n+        ;;\n+      double)\n+        kind=FP\n+        bitstype=long\n+        Bitstype=Long\n+        Boxbitstype=Long\n+        Wideboxtype=Double\n+        MaxValue=POSITIVE_INFINITY\n+        MinValue=NEGATIVE_INFINITY\n+        ;;\n+      halffloat)\n+        VecEleType=Short\n+        ClassType=Halffloat\n+        kind=FP\n+        bitstype=short\n+        Bitstype=Short\n+        Boxbitstype=Short\n+        Wideboxtype=Halffloat\n+        args=\"$args -Dtype=short -DType=Halffloat -DTYPE=HALFFLOAT -DElementType=Halffloat\"\n+        ;;\n+      esac\n+\n+    args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n+    args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype -DElementType=$Type -DVecEleType=$VecEleType -DClassType=$ClassType\"\n+    args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n+\n+    abstractvectortype=${typeprefix}${Type}Vector\n+    abstractvectorteststype=${typeprefix}${Type}VectorTests\n+    abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n+    abstractfpvectortype=${typeprefix}${Fptype}Vector\n+    args=\"$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype\"\n+\n+    # Generate tests for operations\n+    # For each size\n+    Log true \"${Type}:\"\n+\n+    for bits in 64 128 256 512 Max\n+    do\n+      vectortype=${typeprefix}${Type}${bits}Vector\n+      vectorteststype=${typeprefix}${Type}${bits}VectorTests\n+      vectorbenchtype=${typeprefix}${Type}${bits}Vector\n+      masktype=${typeprefix}${Type}${bits}Mask\n+      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n+      fpvectortype=${typeprefix}${Fptype}${bits}Vector\n+      shape=S${bits}Bit\n+      Shape=S_${bits}_BIT\n+      if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+        args=\"$args -KByteMax\"\n+      fi\n+      bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n+      if [ $bits == 'Max' ]; then\n+        bitargs=\"$bitargs -KMaxBit\"\n@@ -168,2 +156,0 @@\n-      ;;\n-    esac\n@@ -171,3 +157,2 @@\n-    if [ $generate_perf_tests == true ]; then\n-      # Generate jmh performance tests\n-      case $vectorbenchtype in\n+      # Generate jtreg tests\n+      case $vectorteststype in\n@@ -175,4 +160,4 @@\n-        Log true \" ${bits}_jmh $vectorbenchtype.java\"\n-        Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java \"\n-        PERF_DEST_FILE=\"${PERF_DEST}\/${vectorbenchtype}.java\"\n-        rm -f ${PERF_DEST_FILE}\n+        Log true \" ${bits}_jtreg $vectorteststype.java\"\n+        Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java \"\n+        TEST_DEST_FILE=\"${vectorteststype}.java\"\n+        rm -f ${TEST_DEST_FILE}\n@@ -180,0 +165,18 @@\n+          -i${TEMPLATE_FILE} \\\n+          -o${TEST_DEST_FILE}\n+        if [ VAR_OS_ENV==windows.cygwin ]; then\n+          tr -d  '\\r' < ${TEST_DEST_FILE} > temp\n+          mv temp ${TEST_DEST_FILE}\n+        fi\n+        ;;\n+      esac\n+\n+        if [ $generate_perf_tests == true ]; then\n+          # Generate jmh performance tests\n+          case $vectorbenchtype in\n+          $CLASS_FILTER)\n+          Log true \" ${bits}_jmh $vectorbenchtype.java\"\n+          Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java \"\n+          PERF_DEST_FILE=\"${PERF_DEST}\/${vectorbenchtype}.java\"\n+          rm -f ${PERF_DEST_FILE}\n+          ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \\\n@@ -182,0 +185,19 @@\n+          if [ VAR_OS_ENV==windows.cygwin ]; then\n+            tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n+            mv temp ${PERF_DEST_FILE}\n+          fi\n+            ;;\n+          esac\n+        fi\n+    done\n+\n+      if [ $generate_perf_tests == true ]; then\n+        # Generate jmh performance tests\n+        case ${Type}Scalar in\n+        $CLASS_FILTER)\n+        Log true \" scalar ${Type}Scalar.java\"\n+        PERF_DEST_FILE=\"${PERF_DEST}\/${Type}Scalar.java\"\n+        rm -f ${PERF_DEST_FILE}\n+        ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \\\n+        -i${PERF_SCALAR_TEMPLATE_FILE} \\\n+        -o${PERF_DEST_FILE}\n@@ -186,22 +208,22 @@\n-        ;;\n-      esac\n-    fi\n-  done\n-\n-  if [ $generate_perf_tests == true ]; then\n-    # Generate jmh performance tests\n-    case ${Type}Scalar in\n-    $CLASS_FILTER)\n-    Log true \" scalar ${Type}Scalar.java\"\n-    PERF_DEST_FILE=\"${PERF_DEST}\/${Type}Scalar.java\"\n-    rm -f ${PERF_DEST_FILE}\n-    ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \\\n-      -i${PERF_SCALAR_TEMPLATE_FILE} \\\n-      -o${PERF_DEST_FILE}\n-    if [ VAR_OS_ENV==windows.cygwin ]; then\n-      tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n-      mv temp ${PERF_DEST_FILE}\n-    fi\n-      ;;\n-    esac\n-  fi\n+          ;;\n+        esac\n+      fi\n+    # Generate tests for loads and stores\n+    # For each size\n+    for bits in 64 128 256 512 Max\n+    do\n+      vectortype=${typeprefix}${Type}${bits}Vector\n+      vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n+      vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n+      masktype=${typeprefix}${Type}${bits}Mask\n+      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n+      fpvectortype=${typeprefix}${Fptype}${bits}Vector\n+      shape=S${bits}Bit\n+      Shape=S_${bits}_BIT\n+      if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+        args=\"$args -KByteMax\"\n+      fi\n+      bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n+      if [ $bits == 'Max' ]; then\n+        bitargs=\"$bitargs -KMaxBit\"\n+      fi\n@@ -209,23 +231,3 @@\n-  # Generate tests for loads and stores\n-  # For each size\n-  for bits in 64 128 256 512 Max\n-  do\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n-    masktype=${typeprefix}${Type}${bits}Mask\n-    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n-    fpvectortype=${typeprefix}${Fptype}${bits}Vector\n-    shape=S${bits}Bit\n-    Shape=S_${bits}_BIT\n-    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n-      args=\"$args -KByteMax\"\n-    fi\n-    bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n-    if [ $bits == 'Max' ]; then\n-      bitargs=\"$bitargs -KMaxBit\"\n-    fi\n-\n-    # Generate\n-    case $vectorteststype in\n-    $CLASS_FILTER)\n+      # Generate\n+      case $vectorteststype in\n+      $CLASS_FILTER)\n@@ -237,2 +239,2 @@\n-        -itemplates\/X-LoadStoreTest.java.template \\\n-        -o${TEST_DEST_FILE}\n+      -itemplates\/X-LoadStoreTest.java.template \\\n+      -o${TEST_DEST_FILE}\n@@ -243,2 +245,7 @@\n-      ;;\n-    esac\n+        ;;\n+      esac\n+\n+      # TODO: Generate jmh performance tests for LoadStore variants\n+    done\n+\n+    Log true \" done\\n\"\n@@ -246,1 +253,0 @@\n-    # TODO: Generate jmh performance tests for LoadStore variants\n@@ -248,0 +254,7 @@\n+}\n+\n+case $* in\n+'')             CLASS_FILTER='*';;\n+--generate*)    CLASS_FILTER=${2-'*'};;\n+--help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n+esac\n@@ -249,1 +262,1 @@\n-  Log true \" done\\n\"\n+. config.sh\n@@ -251,1 +264,5 @@\n-done\n+# Detect whether to generate the performance tests\n+generate_perf_tests=true\n+if [ -d \"$PERF_DEST\" ]; then\n+  generate_perf_tests=true\n+fi\n@@ -253,0 +270,7 @@\n+# First, generate the template files.\n+gen_type=\"ALL_PRIM_TYPES\"\n+gen_half_type=\"HALF_FLOAT_TYPE\"\n+bash gen-template.sh \"ALL_PRIM_TYPES\" $generate_perf_tests\n+generate_test_cases \"ALL_PRIM_TYPES\"\n+bash gen-template.sh \"HALF_FLOAT_TYPE\" $generate_perf_tests\n+generate_test_cases \"HALF_FLOAT_TYPE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":217,"deletions":193,"binary":false,"changes":410,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op-hf-math.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op-math.template","status":"copied"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unary-op-hf-math.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unary-op-math.template","status":"copied"},{"patch":"@@ -31,0 +31,3 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+#end[Halffloat]\n@@ -50,1 +53,1 @@\n-    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+    $type$[] fill(IntFunction<$VecEleType$> f) {\n@@ -66,0 +69,8 @@\n+    static $type$ genValue(int i) {\n+#if[Halffloat]\n+        return Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -68,4 +79,4 @@\n-        as = fill(i -> ($type$)(2*i));\n-        bs = fill(i -> ($type$)(i+1));\n-        cs = fill(i -> ($type$)(i+5));\n-        rs = fill(i -> ($type$)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+#end[Halffloat]\n@@ -87,1 +90,1 @@\n-    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+    $type$[] fill(IntFunction<$VecEleType$> f) {\n@@ -99,0 +102,8 @@\n+    static $type$ genValue(int i) {\n+#if[Halffloat]\n+        return Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -102,6 +113,4 @@\n-\n-        a = fill(i -> ($type$)(2*i));\n-        b = fill(i -> ($type$)(i+1));\n-        c = fill(i -> ($type$)(i+5));\n-        r = fill(i -> ($type$)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+\n+    static $type$ [[TEST]]($type$ a, $type$ b) {\n+        return Halffloat.valueOf((float) [[TEST_OP]]);\n+    }\n+\n+    static $type$ strict[[TEST]]($type$ a, $type$ b) {\n+        return Halffloat.valueOf((float) Strict[[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-op-hf-math.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -13,0 +13,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+#else[Halffloat]\n@@ -14,0 +17,1 @@\n+#end[Halffloat]\n@@ -29,0 +33,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+#else[Halffloat]\n@@ -30,0 +37,1 @@\n+#end[Halffloat]\n@@ -126,0 +134,3 @@\n+#if[Halffloat]\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[Halffloat]\n@@ -127,0 +138,1 @@\n+#end[Halffloat]\n@@ -165,0 +177,3 @@\n+#if[Halffloat]\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[Halffloat]\n@@ -166,0 +181,1 @@\n+#end[Halffloat]\n@@ -684,1 +700,1 @@\n-        VectorSpecies species = vsh.withLanes($type$.class);\n+        VectorSpecies species = vsh.withLanes($ClassType$.class);\n@@ -691,1 +707,1 @@\n-        assert(av.species().elementType() == $type$.class);\n+        assert(av.species().elementType() == $ClassType$.class);\n@@ -709,1 +725,1 @@\n-        VectorSpecies species = av.species().withLanes($type$.class);\n+        VectorSpecies species = av.species().withLanes($ClassType$.class);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+\n+    static $type$ [[TEST]]($type$ a) {\n+        return Halffloat.valueOf((float) [[TEST_OP]]);\n+    }\n+\n+    static $type$ strict[[TEST]]($type$ a) {\n+        return Halffloat.valueOf((float) Strict[[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa) {\n+[[KERNEL]]\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unary-op-hf-math.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -2,0 +2,3 @@\n+#if[Halffloat]\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+#else[Halffloat]\n@@ -3,0 +6,1 @@\n+#end[Halffloat]\n@@ -45,0 +49,4 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[Halffloat]\n@@ -76,1 +84,1 @@\n-                $Type$Vector.SPECIES_MAX;\n+                $ElementType$Vector.SPECIES_MAX;\n@@ -79,1 +87,1 @@\n-                $Type$Vector.SPECIES_$bits$;\n+                $ElementType$Vector.SPECIES_$bits$;\n@@ -738,0 +746,20 @@\n+#if[Halffloat]\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+#else[Halffloat]\n@@ -754,0 +782,1 @@\n+#end[Halffloat]\n@@ -1009,0 +1038,8 @@\n+    static $type$ genValue(int i) {\n+#if[Halffloat]\n+        return (short) Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -1027,1 +1064,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1029,1 +1066,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1031,1 +1068,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1033,1 +1070,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1035,1 +1072,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1037,1 +1074,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1039,1 +1076,1 @@\n-            withToString(\"$type$[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$ClassType$[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1051,0 +1088,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1052,0 +1092,1 @@\n+#end[Halffloat]\n@@ -1075,0 +1116,8 @@\n+    static $type$ genValue(long i) {\n+#if[Halffloat]\n+        return (short) Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -1076,1 +1125,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1078,1 +1127,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1080,1 +1129,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1082,1 +1131,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1084,1 +1133,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1086,1 +1135,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1088,1 +1137,1 @@\n-            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1113,0 +1162,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1114,0 +1166,1 @@\n+#end[Halffloat]\n@@ -1125,0 +1178,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1126,0 +1182,1 @@\n+#end[Halffloat]\n@@ -1134,1 +1191,1 @@\n-        return {#if[FP]? $Type$.$type$To$Bitstype$Bits(e): e};\n+        return {#if[FP]? $Wideboxtype$.$type$To$Bitstype$Bits(e): e};\n@@ -1138,1 +1195,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1140,1 +1197,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1142,1 +1199,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1144,1 +1201,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1146,1 +1203,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1148,1 +1205,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1150,1 +1207,1 @@\n-            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$ClassType$[cornerCaseValue(i)]\", (int s) -> {\n@@ -1426,0 +1483,3 @@\n+#if[Halffloat]\n+                return Short.MIN_VALUE;\n+#else[Halffloat]\n@@ -1427,0 +1487,1 @@\n+#end[Halffloat]\n@@ -1549,0 +1610,38 @@\n+#if[Halffloat]\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+#else[Halffloat]\n@@ -1573,0 +1672,1 @@\n+#end[Halffloat]\n@@ -1593,1 +1693,1 @@\n-        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+        return $VecEleType$.compare(a, ($type$) 0) != 0 ? a : b;\n@@ -1598,0 +1698,17 @@\n+#if[Halffloat]\n+        $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        $abstractvectortype$ three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        $abstractvectortype$ higher = three.addIndex(scale);\n+        VectorMask<$Boxtype$> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        $type$ max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+#else[Halffloat]\n@@ -1620,0 +1737,1 @@\n+#end[Halffloat]\n@@ -1696,1 +1814,1 @@\n-#if[byteOrShort]\n+#if[byte]\n@@ -1702,1 +1820,1 @@\n-#else[byteOrShort]\n+#else[byte]\n@@ -1713,1 +1831,1 @@\n-#end[byteOrShort]\n+#end[byte]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":146,"deletions":28,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,0 +2,3 @@\n+#if[Halffloat]\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+#else[Halffloat]\n@@ -3,0 +6,1 @@\n+#end[Halffloat]\n@@ -42,0 +46,4 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[Halffloat]\n@@ -62,1 +70,1 @@\n-                $Type$Vector.SPECIES_MAX;\n+                $ElementType$Vector.SPECIES_MAX;\n@@ -65,1 +73,1 @@\n-                $Type$Vector.SPECIES_$bits$;\n+                $ElementType$Vector.SPECIES_$bits$;\n@@ -70,0 +78,3 @@\n+#if[Halffloat]\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+#else[Halffloat]\n@@ -71,0 +82,1 @@\n+#end[Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -66,4 +70,4 @@\n-        as = fill(i -> (byte)(2*i));\n-        bs = fill(i -> (byte)(i+1));\n-        cs = fill(i -> (byte)(i+5));\n-        rs = fill(i -> (byte)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -65,4 +69,4 @@\n-        as = fill(i -> (double)(2*i));\n-        bs = fill(i -> (double)(i+1));\n-        cs = fill(i -> (double)(i+5));\n-        rs = fill(i -> (double)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -65,4 +69,4 @@\n-        as = fill(i -> (float)(2*i));\n-        bs = fill(i -> (float)(i+1));\n-        cs = fill(i -> (float)(i+5));\n-        rs = fill(i -> (float)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat128Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat256Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat512Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat64Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class HalffloatMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/HalffloatMaxVector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,497 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import jdk.incubator.vector.Halffloat;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class HalffloatScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static short bits(short e) {\n+        return Halffloat.shortToShortBits(e);\n+    }\n+\n+    short[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> as;\n+    final IntFunction<short[]> fb = vl -> bs;\n+    final IntFunction<short[]> fc = vl -> cs;\n+    final IntFunction<short[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Math.abs(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Math.abs(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(-a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(-a) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a)))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/HalffloatScalar.java","additions":497,"deletions":0,"binary":false,"changes":497,"status":"added"},{"patch":"@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -66,4 +70,4 @@\n-        as = fill(i -> (int)(2*i));\n-        bs = fill(i -> (int)(i+1));\n-        cs = fill(i -> (int)(i+5));\n-        rs = fill(i -> (int)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -66,4 +70,4 @@\n-        as = fill(i -> (long)(2*i));\n-        bs = fill(i -> (long)(i+1));\n-        cs = fill(i -> (long)(i+5));\n-        rs = fill(i -> (long)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -66,4 +70,4 @@\n-        as = fill(i -> (short)(2*i));\n-        bs = fill(i -> (short)(i+1));\n-        cs = fill(i -> (short)(i+5));\n-        rs = fill(i -> (short)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}