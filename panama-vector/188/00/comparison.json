{"files":[{"patch":"@@ -2437,0 +2437,8 @@\n+    case Op_PopCountI:\n+    case Op_PopCountL:\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!UsePopCountInstruction) {\n+        ret_value = false;\n+      }\n+      break;\n@@ -8642,1 +8650,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8653,0 +8660,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8664,1 +8672,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8674,0 +8681,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8687,1 +8695,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8697,0 +8704,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8707,1 +8715,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8717,0 +8724,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5637,2 +5637,2 @@\n-instruct vpopcount4I(vecX dst, vecX src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == 4);\n+instruct vpopcountID(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() < 16);\n@@ -5640,4 +5640,37 @@\n-  format %{\n-    \"cnt     $dst, $src\\t# vector (16B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (16B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (8H)\"\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"vpopcountI  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg));\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n+                as_FloatRegister($dst$$reg));\n+    }\n+    if (bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n+                as_FloatRegister($dst$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vpopcountIX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (PopCountVI src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"vpopcountI  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg));\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n+                as_FloatRegister($dst$$reg));\n+    }\n+    if (bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n+                as_FloatRegister($dst$$reg));\n+    }\n@@ -5645,0 +5678,13 @@\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountLX\" rule.\n+instruct vpopcountLD(vecD dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() < 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vpopcountL  $dst, $src\\t# vector (2S)\" %}\n@@ -5646,0 +5692,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -5652,0 +5699,4 @@\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n+              as_FloatRegister($dst$$reg));\n+    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n+           as_FloatRegister($dst$$reg), __ T2D);\n@@ -5656,8 +5707,6 @@\n-instruct vpopcount2I(vecD dst, vecD src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == 2);\n-  match(Set dst (PopCountVI src));\n-  format %{\n-    \"cnt     $dst, $src\\t# vector (8B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (8B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (4H)\"\n-  %}\n+instruct vpopcountLX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vpopcountL  $dst, $src\\t# vector (2D)\" %}\n@@ -5665,1 +5714,2 @@\n-    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n@@ -5667,1 +5717,3 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n+              as_FloatRegister($dst$$reg));\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n@@ -5669,1 +5721,1 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":69,"deletions":17,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2388,13 +2388,21 @@\n-define(`VPOPCOUNT', `\n-instruct vpopcount$1$2`'(vec$5 dst, vec$5 src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == $1);\n-  match(Set dst (PopCountVI src));\n-  format %{\n-    \"cnt     $dst, $src\\t# vector ($3B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector ($3B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector ($4H)\"\n-  %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T$3B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T$3B,\n+define(`VPOPCOUNT', `dnl\n+ifelse($1$2, `LD', `\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountLX\" rule.', `')\n+instruct vpopcount$1$2`'(vec$2 dst, vec$3 src) %{\n+  predicate(n->as_Vector()->length_in_bytes() $4 16`'ifelse($1$2, `LD', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT', $1$2, `LX', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst (PopCountV$1 src));\n+  ins_cost($5 * INSN_COST);\n+  format %{ \"vpopcount$1  $dst, $src\\t# vector ($6)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ cnt(as_FloatRegister($dst$$reg), __ T`'ifelse($3, D, 8, 16)B,\n+           as_FloatRegister($src$$reg));dnl\n+ifelse($1, `L', `\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n@@ -2402,1 +2410,1 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T$4H,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n@@ -2404,0 +2412,13 @@\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n+              as_FloatRegister($dst$$reg));', `\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 8, 16)B,\n+                as_FloatRegister($dst$$reg));\n+    }\n+    if (bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 4, 8)H,\n+                as_FloatRegister($dst$$reg));\n+    }')dnl\n+ifelse($1$2, `LD', `\n+    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n+           as_FloatRegister($dst$$reg), __ T2D);', `')\n@@ -2407,3 +2428,5 @@\n-dnl       $1 $2 $3  $4 $5\n-VPOPCOUNT(4, I, 16, 8, X)\n-VPOPCOUNT(2, I, 8,  4, D)\n+dnl       $1 $2 $3 $4  $5 $6\n+VPOPCOUNT(I, D, D, <,  3, 8B\/4H\/2S)\n+VPOPCOUNT(I, X, X, ==, 3, 16B\/8H\/4S)\n+VPOPCOUNT(L, D, X, <,  5, 2S)\n+VPOPCOUNT(L, X, X, ==, 4, 2D)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":40,"deletions":17,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1995,1 +1995,1 @@\n-\/\/ popcount vector\n+\/\/ vector popcount\n@@ -1998,1 +1998,2 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n@@ -2000,1 +2001,72 @@\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\n\\t\"\n+            \"sve_dup $vtmp, #0\\n\\t\"\n+            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+\n+instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (PopCountVI dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n@@ -2002,1 +2074,3 @@\n-     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ D,\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1102,6 +1102,11 @@\n-\/\/ popcount vector\n-\n-instruct vpopcountI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopCountVI src));\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n+dnl\n+dnl VPOPCOUNT($1,          $2  )\n+dnl VPOPCOUNT(name_suffix, size)\n+define(`VPOPCOUNT', `\n+instruct vpopcount$1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector()`'ifelse($1, `L', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst (PopCountV$1 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) ($2)\" %}\n@@ -1109,1 +1114,33 @@\n-     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ sve_cnt(as_FloatRegister($dst$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector popcount\n+VPOPCOUNT(I, B\/H\/S)\n+VPOPCOUNT(L, D)\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\n\\t\"\n+            \"sve_dup $vtmp, #0\\n\\t\"\n+            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n@@ -1114,0 +1151,23 @@\n+dnl\n+dnl VPOPCOUNT_PREDICATE($1,          $2  )\n+dnl VPOPCOUNT_PREDICATE(name_suffix, size)\n+define(`VPOPCOUNT_PREDICATE', `\n+instruct vpopcount$1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0`'ifelse($1, `L', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst_src (PopCountV$1 dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\/\/ vector popcount - predicated\n+VPOPCOUNT_PREDICATE(I, B\/H\/S)\n+VPOPCOUNT_PREDICATE(L, D)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":67,"deletions":7,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1073,0 +1073,1 @@\n+      assert_different_registers(dst, tmp);\n@@ -1077,0 +1078,1 @@\n+      assert_different_registers(dst, tmp);\n@@ -1088,0 +1090,1 @@\n+      assert_different_registers(dst, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-* @requires vm.cpu.features ~= \".*avx512bw.*\"\n-* @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @requires vm.cpu.features ~= \".*avx512bw.*\" | vm.cpu.features ~= \".*sve.*\"\n+* @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -60,1 +60,1 @@\n-    @IR(counts = {\"PopCountVL\", \">= 1\"}) \/\/ Atleast one PopCountVL node is generated if vectorization is successful\n+    @IR(counts = {\"PopCountVL\", \">= 1\"}) \/\/ At least one PopCountVL node is generated if vectorization is successful\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}