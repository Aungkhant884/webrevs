{"files":[{"patch":"@@ -482,0 +482,9 @@\n+    case VECTOR_OP_POPCNT: {\n+     switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   return Op_PopCountI;\n+        case T_LONG:  return Op_PopCountL;\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    VECTOR_OP_POPCNT  = 3,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    public static final int VECTOR_OP_POPCNT = 3;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -447,0 +447,5 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static int popcount(int a) {\n+        return Integer.bitCount(a);\n+    }\n@@ -658,0 +663,2 @@\n+            case VECTOR_OP_POPCNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) popcount(a));\n@@ -1783,0 +1790,19 @@\n+    \/\/ Popcount\n+    \/**\n+     * Computes the number of one-bits in the two's complement\n+     * binary representation of the specified value\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *  lanewise}{@code (}{@link VectorOperators#POPCNT\n+     * }{@code )}.\n+     *\n+     * @return number of one-bits\n+     * @see VectorOperators#POPCNT\n+     * @see #lanewise(VectorOperators.Unary)\n+     *\/\n+    @ForceInline\n+    public final\n+    IntVector popcnt() {\n+        return lanewise(POPCNT);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -447,0 +447,5 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static int popcount(long a) {\n+        return Long.bitCount(a);\n+    }\n@@ -616,0 +621,2 @@\n+            case VECTOR_OP_POPCNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) popcount(a));\n@@ -1696,0 +1703,19 @@\n+    \/\/ Popcount\n+    \/**\n+     * Computes the number of one-bits in the two's complement\n+     * binary representation of the specified value\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *  lanewise}{@code (}{@link VectorOperators#POPCNT\n+     * }{@code )}.\n+     *\n+     * @return number of one-bits\n+     * @see VectorOperators#POPCNT\n+     * @see #lanewise(VectorOperators.Unary)\n+     *\/\n+    @ForceInline\n+    public final\n+    LongVector popcnt() {\n+        return lanewise(POPCNT);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -453,0 +453,2 @@\n+    \/** Produce {@code bitCount(a)} *\/\n+    public static final Unary POPCNT = unary(\"POPCNT\", \"popcnt\", VectorSupport.VECTOR_OP_POPCNT, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -461,0 +461,7 @@\n+#if[intOrLong]\n+    \/*package-private*\/\n+    @ForceInline\n+    static int popcount($type$ a) {\n+        return $Boxtype$.bitCount(a);\n+    }\n+#end[intOrLong]\n@@ -684,0 +691,4 @@\n+#if[intOrLong]\n+            case VECTOR_OP_POPCNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) popcount(a));\n+#end[intOrLong]\n@@ -2025,0 +2036,21 @@\n+#if[intOrLong]\n+    \/\/ Popcount\n+    \/**\n+     * Computes the number of one-bits in the two's complement\n+     * binary representation of the specified value\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *  lanewise}{@code (}{@link VectorOperators#POPCNT\n+     * }{@code )}.\n+     *\n+     * @return number of one-bits\n+     * @see VectorOperators#POPCNT\n+     * @see #lanewise(VectorOperators.Unary)\n+     *\/\n+    @ForceInline\n+    public final\n+    $abstractvectortype$ popcnt() {\n+        return lanewise(POPCNT);\n+    }\n+#end[intOrLong]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @requires vm.compiler2.enabled\n+ *\/\n+\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.Vector;\n+\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+public class PopcountUnitTest {\n+    static final VectorSpecies<Long> SPECIESL =\n+            LongVector.SPECIES_256;\n+    static final VectorSpecies<Integer> SPECIESI =\n+            IntVector.SPECIES_256;\n+\n+    static final int SIZE = 1024;\n+    static int[] a = new int[SIZE];\n+    static int[] b = new int[SIZE];\n+    static long[] c = new long[SIZE];\n+    static long[] d = new long[SIZE];\n+\n+    static {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = 7;\n+            c[i] = -63;\n+        }\n+    }\n+\n+    static void workload() {\n+        for (int i = 0; i < a.length; i += SPECIESI.length()) {\n+            IntVector av = IntVector.fromArray(SPECIESI, a, i);\n+            av.popcnt().intoArray(b, i);\n+        }\n+         for (int i = 0; i < c.length; i += SPECIESL.length()) {\n+            LongVector cv = LongVector.fromArray(SPECIESL, c, i);\n+            cv.popcnt().intoArray(d, i);\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        for (int i = 0; i < 30_0000; i++) {\n+            workload();\n+        }\n+        for (int i = 0; i < a.length; i++) {\n+            if (b[i] != Integer.bitCount(a[i]))\n+                throw new AssertionError();\n+        }\n+        for (int i = 0; i < c.length; i++) {\n+            if (d[i] != Long.bitCount(c[i]))\n+                throw new AssertionError();\n+        }\n+        System.out.println(\"b[0] = \" + b[0]);\n+        System.out.println(\"d[0] = \" + d[0]);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/PopcountUnitTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}