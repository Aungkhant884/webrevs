{"files":[{"patch":"@@ -2478,3 +2478,0 @@\n-    case Op_VectorMaskTrueCount:\n-    case Op_VectorMaskFirstTrue:\n-    case Op_VectorMaskLastTrue:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4065,2 +4065,5 @@\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (masksize < 16 && opc != Op_VectorMaskFirstTrue) {\n+    andq(tmp, (1 << masklen) - 1);\n@@ -4068,0 +4071,1 @@\n+\n@@ -4073,1 +4077,1 @@\n-      mov64(dst, -1);\n+      movl(dst, -1);\n@@ -4075,1 +4079,1 @@\n-      cmov(Assembler::notZero, dst, tmp);\n+      cmov32(Assembler::notZero, dst, tmp);\n@@ -4078,3 +4082,9 @@\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      assert(VM_Version::supports_bmi1(), \"\");\n+      if (masklen < 32) {\n+        orl(tmp, 1 << masklen);\n+        tzcntl(dst, tmp);\n+      } else if (masklen == 32) {\n+        tzcntl(dst, tmp);\n+      } else {\n+        tzcntq(dst, tmp);\n+      }\n@@ -4089,3 +4099,4 @@\n-                                              int masklen, BasicType bt, int vec_enc) {\n-  assert(VM_Version::supports_avx(), \"\");\n-  assert(masklen <= 32, \"\");\n+                                              Register tmp, int masklen, BasicType bt, int vec_enc) {\n+  assert(vec_enc == AVX_128bit && VM_Version::supports_avx() ||\n+         vec_enc == AVX_256bit && (VM_Version::supports_avx2() || type2aelembytes(bt) >= 4), \"\");\n+\n@@ -4094,0 +4105,7 @@\n+    case T_BOOLEAN:\n+      \/\/ While masks of other types contain 0, -1; boolean masks contain lane values of 0, 1\n+      vpxor(xtmp, xtmp, xtmp, vec_enc);\n+      vpsubb(xtmp, xtmp, mask, vec_enc);\n+      vpmovmskb(tmp, xtmp, vec_enc);\n+      need_clip = masklen < 16;\n+      break;\n@@ -4095,1 +4113,1 @@\n-      vpmovmskb(dst, mask, vec_enc);\n+      vpmovmskb(tmp, mask, vec_enc);\n@@ -4101,1 +4119,0 @@\n-        assert(masklen == 16, \"\");\n@@ -4104,1 +4121,1 @@\n-      vpmovmskb(dst, xtmp, Assembler::AVX_128bit);\n+      vpmovmskb(tmp, xtmp, Assembler::AVX_128bit);\n@@ -4109,1 +4126,1 @@\n-      vmovmskps(dst, mask, vec_enc);\n+      vmovmskps(tmp, mask, vec_enc);\n@@ -4114,1 +4131,1 @@\n-      vmovmskpd(dst, mask, vec_enc);\n+      vmovmskpd(tmp, mask, vec_enc);\n@@ -4119,0 +4136,8 @@\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (need_clip && opc != Op_VectorMaskFirstTrue) {\n+    \/\/ need_clip implies masklen < 32\n+    andq(tmp, (1 << masklen) - 1);\n+  }\n+\n@@ -4121,5 +4146,1 @@\n-      if (need_clip) {\n-        \/\/ need_clip implies masklen < 32\n-        andl(dst, (1 << masklen) - 1);\n-      }\n-      popcntl(dst, dst);\n+      popcntl(dst, tmp);\n@@ -4128,7 +4149,3 @@\n-      if (need_clip) {\n-        \/\/ need_clip implies masklen < 32\n-        andl(dst, (1 << masklen) - 1);\n-      }\n-      lzcntl(dst, dst);\n-      negl(dst);\n-      addl(dst, 31);\n+      movl(dst, -1);\n+      bsrl(tmp, tmp);\n+      cmov32(Assembler::notZero, dst, tmp);\n@@ -4137,2 +4154,16 @@\n-      if (masklen < 32) {\n-        orl(dst, 1 << masklen);\n+      if (VM_Version::supports_bmi1()) {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          tzcntl(dst, tmp);\n+        } else {\n+          tzcntl(dst, tmp);\n+        }\n+      } else {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          bsfl(dst, tmp);\n+        } else {\n+          movl(dst, masklen);\n+          bsfl(tmp, tmp);\n+          cmov32(Assembler::notZero, dst, tmp);\n+        }\n@@ -4140,1 +4171,0 @@\n-      tzcntl(dst, dst);\n@@ -4143,3 +4173,0 @@\n-      if (need_clip) {\n-        andq(dst, ((jlong)1 << masklen) - 1);\n-      }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":60,"deletions":33,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-                             int masklen, BasicType bt, int vec_enc);\n+                             Register tmp, int masklen, BasicType bt, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8655,1 +8655,1 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $dst$$Register,\n+    __ vector_mask_operation(opcode, noreg, $mask$$KRegister, $dst$$Register,\n@@ -8661,1 +8661,1 @@\n-instruct vmask_tolong_avx(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n+instruct vmask_tolong_bool(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n@@ -8664,0 +8664,16 @@\n+  format %{ \"vector_tolong_bool $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP xtmp, KILL cr);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, noreg, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_tolong_avx(rRegL dst, vec mask, immI size, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskToLong (VectorStoreMask mask size)));\n@@ -8671,2 +8687,2 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n-                             mask_len, mbt, vlen_enc);\n+    __ vector_mask_operation(opcode, noreg, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n@@ -8694,1 +8710,1 @@\n-instruct vmask_truecount_avx(rRegI dst, vec mask, vec xtmp, rFlagsReg cr) %{\n+instruct vmask_truecount_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8697,2 +8713,2 @@\n-  effect(TEMP_DEF dst, TEMP xtmp, KILL cr);\n-  format %{ \"vector_truecount_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8705,1 +8721,17 @@\n-                             mask_len, mbt, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_truecount_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n@@ -8728,1 +8760,1 @@\n-instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, vec xtmp, rFlagsReg cr) %{\n+instruct vmask_first_or_last_true_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8732,2 +8764,19 @@\n-  effect(TEMP_DEF dst, TEMP xtmp, KILL cr);\n-  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskFirstTrue (VectorStoreMask mask size)));\n+  match(Set dst (VectorMaskLastTrue (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8740,1 +8789,1 @@\n-                             mask_len, mbt, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":61,"deletions":12,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -701,0 +701,3 @@\n+  if (mask_vec->bottom_type()->isa_vectmask() == NULL) {\n+    mask_vec = gvn().transform(VectorStoreMaskNode::make(gvn(), mask_vec, elem_bt, num_elem));\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -925,0 +925,1 @@\n+    assert(Matcher::has_predicated_vectors() || mask->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN, \"\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}