{"files":[{"patch":"@@ -2478,0 +2478,3 @@\n+    case Op_VectorMaskTrueCount:\n+    case Op_VectorMaskFirstTrue:\n+    case Op_VectorMaskLastTrue:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4309,0 +4309,14 @@\n+void Assembler::vmovmskps(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovmskpd(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1777,0 +1777,2 @@\n+  void vmovmskps(Register dst, XMMRegister src, int vec_enc);\n+  void vmovmskpd(Register dst, XMMRegister src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4082,0 +4082,2 @@\n+    case Op_VectorMaskToLong:\n+      break;\n@@ -4087,2 +4089,1 @@\n-                                              XMMRegister xtmp1, Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n+                                              Register tmp, int masklen, BasicType bt, int vec_enc) {\n@@ -4090,5 +4091,33 @@\n-  vpxor(xtmp, xtmp, xtmp, vec_enc);\n-  vpsubb(xtmp, xtmp, mask, vec_enc);\n-  vpmovmskb(tmp, xtmp, vec_enc);\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+  switch(bt) {\n+    case T_BYTE:\n+      vpmovmskb(tmp, mask, vec_enc);\n+      if (masklen < 16) {\n+        andq(tmp, (((jlong)1 << masklen) - 1));\n+      }\n+      break;\n+    case T_SHORT:\n+      vpacksswb(xtmp, mask, mask, vec_enc);\n+      if (masklen >= 16) {\n+        assert(masklen == 16, \"\");\n+        vpermpd(xtmp, xtmp, 8, vec_enc);\n+      }\n+      vpmovmskb(tmp, xtmp, Assembler::AVX_128bit);\n+      if (masklen < 16) {\n+        andq(tmp, (((jlong)1 << masklen) - 1));\n+      }\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      vmovmskps(tmp, mask, vec_enc);\n+      if (masklen < 4) {\n+        andq(tmp, (((jlong)1 << masklen) - 1));\n+      }\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmovmskpd(tmp, mask, vec_enc);\n+      if (masklen < 2) {\n+        andq(tmp, 1);\n+      }\n+      break;\n+    default: assert(false, \"Unhandled type, %s\", type2name(bt));\n@@ -4110,0 +4139,2 @@\n+    case Op_VectorMaskToLong:\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp, XMMRegister xtmp1,\n-                             Register tmp, int masklen, int masksize, int vec_enc);\n+  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                             Register tmp, int masklen, BasicType bt, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8650,1 +8650,1 @@\n-    int mask_len = Matcher::vector_length(this, $mask);\n+    int opcode = this->ideal_Opcode();\n@@ -8652,8 +8652,1 @@\n-    if (VM_Version::supports_avx512vlbw()) {\n-      __ kmovql($dst$$Register, $mask$$KRegister);\n-    } else {\n-      assert(mask_len <= 16, \"\");\n-      __ kmovwl($dst$$Register, $mask$$KRegister);\n-    }\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8661,3 +8654,3 @@\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $dst$$Register,\n+                             mask_len, mask_size, vlen_enc);\n@@ -8669,2 +8662,1 @@\n-  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL &&\n-            n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL);\n@@ -8675,1 +8667,1 @@\n-    int mask_len = Matcher::vector_length(this, $mask);\n+    int opcode = this->ideal_Opcode();\n@@ -8677,0 +8669,1 @@\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8678,9 +8671,2 @@\n-    __ vpxor($xtmp$$XMMRegister, $xtmp$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n-    __ vpsubb($xtmp$$XMMRegister, $xtmp$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n-    __ vpmovmskb($dst$$Register, $xtmp$$XMMRegister, vlen_enc);\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n-    int mask_size = mask_len * type2aelembytes(mbt);\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n@@ -8708,1 +8694,1 @@\n-instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8711,2 +8697,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp and $xtmp as TEMP\" %}\n@@ -8717,1 +8703,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8720,1 +8705,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n@@ -8743,1 +8728,1 @@\n-instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8747,2 +8732,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp and $xtmp as TEMP\" %}\n@@ -8753,1 +8738,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8756,1 +8740,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":34,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -701,3 +701,0 @@\n-  if (mask_vec->bottom_type()->isa_vectmask() == NULL) {\n-    mask_vec = gvn().transform(VectorStoreMaskNode::make(gvn(), mask_vec, elem_bt, num_elem));\n-  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -925,1 +925,0 @@\n-    assert(Matcher::has_predicated_vectors() || mask->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN, \"\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}