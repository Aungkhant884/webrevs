{"files":[{"patch":"@@ -907,1 +907,1 @@\n-                                     \"I\"                                                                                                       \\\n+                                     \"J\"                                                                                                       \\\n@@ -922,1 +922,1 @@\n-                                            \"I\"                                                                                                \\\n+                                            \"J\"                                                                                                \\\n@@ -935,1 +935,3 @@\n-                                      \"Ljava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperation;)\"                        \\\n+                                      \"Ljava\/lang\/Object;\"                                                                                     \\\n+                                      \"J\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperation;)\"                                           \\\n@@ -949,1 +951,1 @@\n-                                             \"I\"                                                                                               \\\n+                                             \"J\"                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -917,1 +917,1 @@\n-\/\/         C container, int index, S s,     \/\/ Arguments for default implementation\n+\/\/         C container, long index, S s,     \/\/ Arguments for default implementation\n@@ -926,1 +926,1 @@\n-\/\/            C container, int index,      \/\/ Arguments for default implementation\n+\/\/            C container, long index,      \/\/ Arguments for default implementation\n@@ -1110,1 +1110,1 @@\n-\/\/              C container, int index, S s,  \/\/ Arguments for default implementation\n+\/\/              C container, long index, S s,  \/\/ Arguments for default implementation\n@@ -1121,1 +1121,1 @@\n-\/\/                  C container, int index,  \/\/ Arguments for default implementation\n+\/\/                  C container, long index,  \/\/ Arguments for default implementation\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -386,1 +386,1 @@\n-            return loadFromByteBufferScoped(\n+            return loadFromByteBufferScopedInternal(\n@@ -401,5 +401,5 @@\n-    V loadFromByteBufferScoped(ScopedMemoryAccess.Scope scope,\n-                          Class<? extends V> vmClass, Class<E> e, int length,\n-                          ByteBuffer bb, int offset,\n-                          S s,\n-                          VectorSupport.LoadOperation<ByteBuffer, V, S> defaultImpl) {\n+    V loadFromByteBufferScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                       Class<? extends V> vmClass, Class<E> e, int length,\n+                                       ByteBuffer bb, int offset,\n+                                       S s,\n+                                       VectorSupport.LoadOperation<ByteBuffer, V, S> defaultImpl) {\n@@ -430,1 +430,1 @@\n-            return loadFromByteBufferMaskedScoped(\n+            return loadFromByteBufferMaskedScopedInternal(\n@@ -446,5 +446,5 @@\n-    V loadFromByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n-                                     Class<M> maskClass, Class<E> e, int length,\n-                                     ByteBuffer bb, int offset, M m,\n-                                     S s,\n-                                     VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, S, M> defaultImpl) {\n+    V loadFromByteBufferMaskedScopedInternal(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n+                                             Class<M> maskClass, Class<E> e, int length,\n+                                             ByteBuffer bb, int offset, M m,\n+                                             S s,\n+                                             VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, S, M> defaultImpl) {\n@@ -473,1 +473,1 @@\n-            storeIntoByteBufferScoped(\n+            storeIntoByteBufferScopedInternal(\n@@ -488,5 +488,5 @@\n-    void storeIntoByteBufferScoped(ScopedMemoryAccess.Scope scope,\n-                                   Class<? extends V> vmClass, Class<E> e, int length,\n-                                   V v,\n-                                   ByteBuffer bb, int offset,\n-                                   VectorSupport.StoreVectorOperation<ByteBuffer, V> defaultImpl) {\n+    void storeIntoByteBufferScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                           Class<? extends V> vmClass, Class<E> e, int length,\n+                                           V v,\n+                                           ByteBuffer bb, int offset,\n+                                           VectorSupport.StoreVectorOperation<ByteBuffer, V> defaultImpl) {\n@@ -518,1 +518,1 @@\n-            storeIntoByteBufferMaskedScoped(\n+            storeIntoByteBufferMaskedScopedInternal(\n@@ -533,5 +533,5 @@\n-    void storeIntoByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope,\n-                                         Class<? extends V> vmClass, Class<M> maskClass,\n-                                         Class<E> e, int length, V v, M m,\n-                                         ByteBuffer bb, int offset,\n-                                         VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n+    void storeIntoByteBufferMaskedScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                                 Class<? extends V> vmClass, Class<M> maskClass,\n+                                                 Class<E> e, int length, V v, M m,\n+                                                 ByteBuffer bb, int offset,\n+                                                 VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n@@ -553,0 +553,185 @@\n+\n+\n+    @ForceInline\n+    public static\n+    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>\n+    V loadFromMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+                         MemorySegmentProxy msp, long offset,\n+                         S s,\n+                         VectorSupport.LoadOperation<MemorySegmentProxy, V, S> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        try {\n+            return loadFromMemorySegmentScopedInternal(\n+                    msp.scope(),\n+                    vmClass, e, length,\n+                    msp, offset,\n+                    s,\n+                    defaultImpl);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Scoped\n+    @ForceInline\n+    private static\n+    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>\n+    V loadFromMemorySegmentScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                          Class<? extends V> vmClass, Class<E> e, int length,\n+                                          MemorySegmentProxy msp, long offset,\n+                                          S s,\n+                                          VectorSupport.LoadOperation<MemorySegmentProxy, V, S> defaultImpl) {\n+        try {\n+            scope.checkValidState();\n+\n+            return VectorSupport.load(vmClass, e, length,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp, offset, s,\n+                    defaultImpl);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static\n+    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,\n+     M extends VectorSupport.VectorMask<E>>\n+    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+                                  int length, MemorySegmentProxy msp, long offset, M m, S s,\n+                                  VectorSupport.LoadVectorMaskedOperation<MemorySegmentProxy, V, S, M> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        try {\n+            return loadFromMemorySegmentMaskedScopedInternal(\n+                    msp.scope(),\n+                    vmClass, maskClass, e, length,\n+                    msp, offset, m,\n+                    s,\n+                    defaultImpl);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Scoped\n+    @ForceInline\n+    private static\n+    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,\n+     M extends VectorSupport.VectorMask<E>>\n+    V loadFromMemorySegmentMaskedScopedInternal(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n+                                                Class<M> maskClass, Class<E> e, int length,\n+                                                MemorySegmentProxy msp, long offset, M m,\n+                                                S s,\n+                                                VectorSupport.LoadVectorMaskedOperation<MemorySegmentProxy, V, S, M> defaultImpl) {\n+        try {\n+            scope.checkValidState();\n+\n+            return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, m,\n+                    msp, offset, s,\n+                    defaultImpl);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static\n+    <V extends VectorSupport.Vector<E>, E>\n+    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+                                V v,\n+                                MemorySegmentProxy msp, long offset,\n+                                VectorSupport.StoreVectorOperation<MemorySegmentProxy, V> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        try {\n+            storeIntoMemorySegmentScopedInternal(\n+                    msp.scope(),\n+                    vmClass, e, length,\n+                    v,\n+                    msp, offset,\n+                    defaultImpl);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Scoped\n+    @ForceInline\n+    private static\n+    <V extends VectorSupport.Vector<E>, E>\n+    void storeIntoMemorySegmentScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                              Class<? extends V> vmClass, Class<E> e, int length,\n+                                              V v,\n+                                              MemorySegmentProxy msp, long offset,\n+                                              VectorSupport.StoreVectorOperation<MemorySegmentProxy, V> defaultImpl) {\n+        try {\n+            scope.checkValidState();\n+\n+            VectorSupport.store(vmClass, e, length,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    v,\n+                    msp, offset,\n+                    defaultImpl);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static\n+    <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>\n+    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+                                      int length, V v, M m,\n+                                      MemorySegmentProxy msp, long offset,\n+                                      VectorSupport.StoreVectorMaskedOperation<MemorySegmentProxy, V, M> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        try {\n+            storeIntoMemorySegmentMaskedScopedInternal(\n+                    msp.scope(),\n+                    vmClass, maskClass, e, length,\n+                    v, m,\n+                    msp, offset,\n+                    defaultImpl);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Scoped\n+    @ForceInline\n+    private static\n+    <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>\n+    void storeIntoMemorySegmentMaskedScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                                    Class<? extends V> vmClass, Class<M> maskClass,\n+                                                    Class<E> e, int length, V v, M m,\n+                                                    MemorySegmentProxy msp, long offset,\n+                                                    VectorSupport.StoreVectorMaskedOperation<MemorySegmentProxy, V, M> defaultImpl) {\n+        try {\n+            scope.checkValidState();\n+\n+            VectorSupport.storeMasked(vmClass, maskClass, e, length,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    v, m,\n+                    msp, offset,\n+                    defaultImpl);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":210,"deletions":25,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-        VM load(C container, int index, S s);\n+        VM load(C container, long index, S s);\n@@ -392,1 +392,1 @@\n-            C container, int index, S s,\n+            C container, long index, S s,\n@@ -404,1 +404,1 @@\n-        V load(C container, int index, S s, M m);\n+        V load(C container, long index, S s, M m);\n@@ -417,1 +417,1 @@\n-                 M m, C container, int index, S s,\n+                 M m, C container, long index, S s,\n@@ -455,1 +455,1 @@\n-        void store(C container, int index, V v);\n+        void store(C container, long index, V v);\n@@ -465,1 +465,1 @@\n-               V v, C container, int index,\n+               V v, C container, long index,\n@@ -474,1 +474,1 @@\n-        void store(C container, int index, V v, M m);\n+        void store(C container, long index, V v, M m);\n@@ -486,1 +486,1 @@\n-                     V v, M m, C container, int index,\n+                     V v, M m, C container, long index,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -160,1 +160,2 @@\n-        jdk.incubator.foreign;\n+        jdk.incubator.foreign,\n+        jdk.incubator.vector;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, idx, s.length()));\n+            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));\n@@ -207,0 +207,9 @@\n+    @Override\n+    @ForceInline\n+    public VectorMask<E> indexInRange(long offset, long limit) {\n+        int vlength = length();\n+        Vector<E> iota = vectorSpecies().zero().addIndex(1);\n+        VectorMask<E> badMask = checkIndex0(offset, limit, iota, vlength);\n+        return this.andNot(badMask);\n+    }\n+\n@@ -230,1 +239,1 @@\n-    void checkIndexByLane(int offset, int alength,\n+    void checkIndexByLane(int offset, int length,\n@@ -244,1 +253,1 @@\n-            badMask = checkIndex0(offset, alength, iota, vlength);\n+            badMask = checkIndex0(offset, length, iota, vlength);\n@@ -248,1 +257,1 @@\n-            int elemCount = Math.min(vlength, (alength - offset) \/ esize);\n+            int elemCount = Math.min(vlength, (length - offset) \/ esize);\n@@ -252,1 +261,1 @@\n-            badMask = checkIndex0(clipOffset, alength,\n+            badMask = checkIndex0(clipOffset, length,\n@@ -260,1 +269,1 @@\n-                   .checkIndexFailed(offset, badLane, alength, esize);\n+                   .checkIndexFailed(offset, badLane, length, esize);\n@@ -266,1 +275,1 @@\n-    VectorMask<E> checkIndex0(int offset, int alength,\n+    VectorMask<E> checkIndex0(int offset, int length,\n@@ -269,1 +278,1 @@\n-        \/\/ alength-offset, since when added to offset it will step off\n+        \/\/ length-offset, since when added to offset it will step off\n@@ -273,1 +282,1 @@\n-        int indexLimit = Math.max(0, Math.min(alength - offset, vlength));\n+        int indexLimit = Math.max(0, Math.min(length - offset, vlength));\n@@ -295,2 +304,78 @@\n-    private IndexOutOfBoundsException checkIndexFailed(int offset, int lane,\n-                                                       int alength, int esize) {\n+    \/**\n+     * Test if a masked memory access at a given offset into an array\n+     * of the given length will stay within the array.\n+     * The per-lane offsets are iota*esize.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    void checkIndexByLane(long offset, long length,\n+                          Vector<E> iota,\n+                          int esize) {\n+        if (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK == 0) {\n+            return;\n+        }\n+        \/\/ Although the specification is simple, the implementation is\n+        \/\/ tricky, because the value iota*esize might possibly\n+        \/\/ overflow.  So we calculate our test values as scalars,\n+        \/\/ clipping to the range [-1..VLENGTH], and test them against\n+        \/\/ the unscaled iota vector, whose values are in [0..VLENGTH-1].\n+        int vlength = length();\n+        VectorMask<E> badMask;\n+        if (esize == 1) {\n+            badMask = checkIndex0(offset, length, iota, vlength);\n+        } else if (offset >= 0) {\n+            \/\/ Masked access to multi-byte lanes in byte array.\n+            \/\/ It could be aligned anywhere.\n+            \/\/ 0 <= elemCount <= vlength\n+            int elemCount = (int) Math.min(vlength, (length - offset) \/ esize);\n+            badMask = checkIndex0(0, elemCount, iota, vlength);\n+        } else {\n+            \/\/ -vlength * esize <= clipOffset <= 0\n+            int clipOffset = (int) Math.max(offset, -(vlength * esize));\n+            badMask = checkIndex0(clipOffset, length,\n+                    iota.lanewise(VectorOperators.MUL, esize),\n+                    vlength * esize);\n+        }\n+        badMask = badMask.and(this);\n+        if (badMask.anyTrue()) {\n+            int badLane = badMask.firstTrue();\n+            throw ((AbstractMask<E>)badMask)\n+                    .checkIndexFailed(offset, badLane, length, esize);\n+        }\n+    }\n+\n+    private\n+    @ForceInline\n+    VectorMask<E> checkIndex0(long offset, long length,\n+                              Vector<E> iota, int vlength) {\n+        \/\/ An active lane is bad if its number is greater than\n+        \/\/ length-offset, since when added to offset it will step off\n+        \/\/ of the end of the array.  To avoid overflow when\n+        \/\/ converting, clip the comparison value to [0..vlength]\n+        \/\/ inclusive.\n+        \/\/ 0 <= indexLimit <= vlength\n+        int indexLimit = (int) Math.max(0, Math.min(length - offset, vlength));\n+        VectorMask<E> badMask =\n+                iota.compare(GE, iota.broadcast(indexLimit));\n+        if (offset < 0) {\n+            \/\/ An active lane is bad if its number is less than\n+            \/\/ -offset, because when added to offset it will then\n+            \/\/ address an array element at a negative index.  To avoid\n+            \/\/ overflow when converting, clip the comparison value at\n+            \/\/ vlength.  This specific expression works correctly even\n+            \/\/ when offset is Integer.MIN_VALUE.\n+            \/\/ 0 <= firstGoodIndex <= vlength\n+            int firstGoodIndex = (int) -Math.max(offset, -vlength);\n+            VectorMask<E> badMask2 =\n+                    iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            if (indexLimit >= vlength) {\n+                badMask = badMask2;  \/\/ 1st badMask is all true\n+            } else {\n+                badMask = badMask.or(badMask2);\n+            }\n+        }\n+        return badMask;\n+    }\n+\n+    private IndexOutOfBoundsException checkIndexFailed(long offset, int lane,\n+                                                       long length, int esize) {\n@@ -299,2 +384,2 @@\n-                                   \"index %d+%d in array of length %d\",\n-                                   this, offset, lane * esize, alength);\n+                                   \"index %d+%d for length %d\",\n+                                   this, offset, lane * esize, length);\n@@ -302,1 +387,1 @@\n-            msg += String.format(\" (each lane spans %d array elements)\", esize);\n+            msg += String.format(\" (each lane spans %d elements)\", esize);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":99,"deletions":14,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -206,0 +206,6 @@\n+    @Override\n+    @ForceInline\n+    public final long loopBound(long length) {\n+        return VectorIntrinsics.roundDown(length, laneCount);\n+    }\n+\n@@ -212,0 +218,6 @@\n+    @Override\n+    @ForceInline\n+    public final VectorMask<E> indexInRange(long offset, long limit) {\n+        return maskAll(true).indexInRange(offset, limit);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -929,0 +930,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte128Mask.class, ms, offset, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -972,0 +987,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte128Mask.class, ms, offset, (Byte128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -961,0 +962,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte256Mask.class, ms, offset, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -1004,0 +1019,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte256Mask.class, ms, offset, (Byte256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -1025,0 +1026,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte512Mask.class, ms, offset, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -1068,0 +1083,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte512Mask.class, ms, offset, (Byte512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -913,0 +914,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte64Mask.class, ms, offset, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -956,0 +971,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte64Mask.class, ms, offset, (Byte64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -899,0 +900,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -942,0 +957,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        byte apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ByteVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        byte[] res = new byte[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ByteVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Byte> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/byte[] vec = vec();\n+        byte[] res = new byte[length()];\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -414,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, byte a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        byte[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Byte> m,\n+                  FStLongOp<M> f) {\n+        byte[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -3369,0 +3437,99 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*1 < 0}\n+     *         or {@code offset+N*1 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * byte[] ar = new byte[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * ByteVector r = ByteVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * The byte order argument is ignored.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*1 < 0}\n+     *         or {@code offset+N*1 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, ms.byteSize());\n+        var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Byte>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 1L));\n+    }\n+\n@@ -3396,1 +3563,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3547,1 +3714,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3749,0 +3916,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Byte> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            ByteSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3779,1 +3983,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3796,1 +4000,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3813,1 +4017,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3830,1 +4034,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3847,1 +4051,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3866,1 +4070,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3882,1 +4086,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3900,1 +4104,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3905,0 +4109,34 @@\n+    abstract\n+    ByteVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    ByteVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        ByteSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 1L));\n+                });\n+    }\n+\n+    abstract\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 1L));\n+                });\n+    }\n+\n@@ -3920,1 +4158,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3937,1 +4175,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3956,1 +4194,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3972,1 +4210,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3991,1 +4229,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -4005,1 +4243,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -4023,1 +4261,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -4028,0 +4266,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        ByteSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 1L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 1L, e));\n+                });\n+    }\n+\n@@ -4041,0 +4313,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                ByteSpecies vsp,\n+                                VectorMask<Byte> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Byte>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4360,0 +4642,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ByteVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ByteVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Byte> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4374,0 +4671,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Byte> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":328,"deletions":17,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -883,0 +884,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double128Mask.class, ms, offset, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -926,0 +941,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double128Mask.class, ms, offset, (Double128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -887,0 +888,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double256Mask.class, ms, offset, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -930,0 +945,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double256Mask.class, ms, offset, (Double256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -895,0 +896,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double512Mask.class, ms, offset, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -938,0 +953,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double512Mask.class, ms, offset, (Double512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -881,0 +882,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double64Mask.class, ms, offset, (Double64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -924,0 +939,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double64Mask.class, ms, offset, (Double64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -880,0 +881,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -923,0 +938,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        double apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> DoubleVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        double[] res = new double[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> DoubleVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Double> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/double[] vec = vec();\n+        double[] res = new double[length()];\n+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -414,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, double a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        double[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Double> m,\n+                  FStLongOp<M> f) {\n+        double[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -3051,0 +3119,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*8 < 0}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        DoubleSpecies vsp = (DoubleSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code double} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * double[] ar = new double[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_DOUBLE.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * DoubleVector r = DoubleVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*8 < 0}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Double> m) {\n+        DoubleSpecies vsp = (DoubleSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+        var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Double>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 8L));\n+    }\n+\n@@ -3078,1 +3250,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3302,0 +3474,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Double> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            DoubleSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3332,1 +3541,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3349,1 +3558,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3420,1 +3629,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3439,1 +3648,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3455,1 +3664,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3473,1 +3682,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3478,0 +3687,34 @@\n+    abstract\n+    DoubleVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    DoubleVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        DoubleSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                });\n+    }\n+\n+    abstract\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                });\n+    }\n+\n@@ -3493,1 +3736,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3510,1 +3753,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3580,1 +3823,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3599,1 +3842,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3613,1 +3856,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3631,1 +3874,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3636,0 +3879,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        DoubleSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                });\n+    }\n+\n@@ -3649,0 +3926,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                DoubleSpecies vsp,\n+                                VectorMask<Double> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Double>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3959,0 +4246,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> DoubleVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> DoubleVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Double> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3973,0 +4275,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Double> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":329,"deletions":13,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -887,0 +888,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float128Mask.class, ms, offset, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -930,0 +945,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float128Mask.class, ms, offset, (Float128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -895,0 +896,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float256Mask.class, ms, offset, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -938,0 +953,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float256Mask.class, ms, offset, (Float256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -911,0 +912,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float512Mask.class, ms, offset, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -954,0 +969,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float512Mask.class, ms, offset, (Float512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -883,0 +884,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float64Mask.class, ms, offset, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -926,0 +941,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float64Mask.class, ms, offset, (Float64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -880,0 +881,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -923,0 +938,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        float apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> FloatVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        float[] res = new float[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> FloatVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Float> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/float[] vec = vec();\n+        float[] res = new float[length()];\n+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -414,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, float a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        float[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Float> m,\n+                  FStLongOp<M> f) {\n+        float[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -3057,0 +3125,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*4 < 0}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        FloatSpecies vsp = (FloatSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code float} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * float[] ar = new float[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_FLOAT.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * FloatVector r = FloatVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*4 < 0}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Float> m) {\n+        FloatSpecies vsp = (FloatSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+        var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Float>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 4L));\n+    }\n+\n@@ -3084,1 +3256,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3289,0 +3461,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Float> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            FloatSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3319,1 +3528,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3336,1 +3545,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3389,1 +3598,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3408,1 +3617,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3424,1 +3633,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3442,1 +3651,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3447,0 +3656,34 @@\n+    abstract\n+    FloatVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    FloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        FloatSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                });\n+    }\n+\n+    abstract\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        FloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                });\n+    }\n+\n@@ -3462,1 +3705,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3479,1 +3722,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3530,1 +3773,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3549,1 +3792,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3563,1 +3806,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3581,1 +3824,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3586,0 +3829,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        FloatSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        FloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                });\n+    }\n+\n@@ -3599,0 +3876,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                FloatSpecies vsp,\n+                                VectorMask<Float> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Float>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3909,0 +4196,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> FloatVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> FloatVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Float> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3923,0 +4225,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Float> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":329,"deletions":13,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -898,0 +899,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int128Mask.class, ms, offset, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -941,0 +956,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int128Mask.class, ms, offset, (Int128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -906,0 +907,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int256Mask.class, ms, offset, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -949,0 +964,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int256Mask.class, ms, offset, (Int256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -922,0 +923,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int512Mask.class, ms, offset, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -965,0 +980,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int512Mask.class, ms, offset, (Int512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -894,0 +895,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int64Mask.class, ms, offset, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -937,0 +952,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int64Mask.class, ms, offset, (Int64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -903,0 +904,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -946,0 +961,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        int apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> IntVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        int[] res = new int[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> IntVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Integer> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/int[] vec = vec();\n+        int[] res = new int[length()];\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -414,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, int a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        int[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Integer> m,\n+                  FStLongOp<M> f) {\n+        int[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -3215,0 +3283,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*4 < 0}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        IntSpecies vsp = (IntSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code int} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * int[] ar = new int[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * IntVector r = IntVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*4 < 0}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Integer> m) {\n+        IntSpecies vsp = (IntSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+        var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Integer>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 4L));\n+    }\n+\n@@ -3242,1 +3414,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3447,0 +3619,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Integer> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            IntSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3477,1 +3686,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3494,1 +3703,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3547,1 +3756,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3566,1 +3775,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3582,1 +3791,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3600,1 +3809,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3605,0 +3814,34 @@\n+    abstract\n+    IntVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    IntVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        IntSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                });\n+    }\n+\n+    abstract\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                });\n+    }\n+\n@@ -3620,1 +3863,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3637,1 +3880,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3688,1 +3931,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3707,1 +3950,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3721,1 +3964,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3739,1 +3982,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3744,0 +3987,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        IntSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                });\n+    }\n+\n@@ -3757,0 +4034,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                IntSpecies vsp,\n+                                VectorMask<Integer> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Integer>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4067,0 +4354,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> IntVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> IntVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Integer> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4081,0 +4383,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Integer> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":329,"deletions":13,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -884,0 +885,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long128Mask.class, ms, offset, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -927,0 +942,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long128Mask.class, ms, offset, (Long128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -888,0 +889,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long256Mask.class, ms, offset, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -931,0 +946,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long256Mask.class, ms, offset, (Long256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -896,0 +897,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long512Mask.class, ms, offset, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -939,0 +954,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long512Mask.class, ms, offset, (Long512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -882,0 +883,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long64Mask.class, ms, offset, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -925,0 +940,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long64Mask.class, ms, offset, (Long64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -882,0 +883,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -925,0 +940,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        long apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> LongVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        long[] res = new long[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> LongVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Long> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/long[] vec = vec();\n+        long[] res = new long[length()];\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -414,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, long a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        long[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Long> m,\n+                  FStLongOp<M> f) {\n+        long[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -3094,0 +3162,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*8 < 0}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromMemorySegment(VectorSpecies<Long> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        LongSpecies vsp = (LongSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code long} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * long[] ar = new long[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * LongVector r = LongVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*8 < 0}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromMemorySegment(VectorSpecies<Long> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Long> m) {\n+        LongSpecies vsp = (LongSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+        var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Long>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 8L));\n+    }\n+\n@@ -3121,1 +3293,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3345,0 +3517,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Long> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            LongSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3375,1 +3584,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3392,1 +3601,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3463,1 +3672,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3482,1 +3691,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3498,1 +3707,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3516,1 +3725,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3521,0 +3730,34 @@\n+    abstract\n+    LongVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    LongVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        LongSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                });\n+    }\n+\n+    abstract\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                });\n+    }\n+\n@@ -3536,1 +3779,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3553,1 +3796,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3623,1 +3866,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3642,1 +3885,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3656,1 +3899,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3674,1 +3917,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3679,0 +3922,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        LongSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                });\n+    }\n+\n@@ -3692,0 +3969,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                LongSpecies vsp,\n+                                VectorMask<Long> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Long>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3993,0 +4280,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> LongVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> LongVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Long> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4007,0 +4309,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Long> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":329,"deletions":13,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -913,0 +914,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short128Mask.class, ms, offset, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -950,0 +965,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short128Mask.class, ms, offset, (Short128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -929,0 +930,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short256Mask.class, ms, offset, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -966,0 +981,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short256Mask.class, ms, offset, (Short256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -961,0 +962,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short512Mask.class, ms, offset, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -998,0 +1013,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short512Mask.class, ms, offset, (Short512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -905,0 +906,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short64Mask.class, ms, offset, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -942,0 +957,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short64Mask.class, ms, offset, (Short64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -899,0 +900,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -936,0 +951,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        short apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ShortVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ShortVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Short> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -414,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Short> m,\n+                  FStLongOp<M> f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -3369,0 +3437,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * short[] ar = new short[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * ShortVector r = ShortVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+        var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Short>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 2L));\n+    }\n+\n@@ -3396,1 +3568,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3542,1 +3714,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3736,0 +3908,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Short> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            ShortSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3766,1 +3975,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3783,1 +3992,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3799,1 +4008,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3816,1 +4025,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3834,1 +4043,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3853,1 +4062,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3869,1 +4078,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3887,1 +4096,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3892,0 +4101,34 @@\n+    abstract\n+    ShortVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    ShortVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        ShortSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 2L));\n+                });\n+    }\n+\n+    abstract\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 2L));\n+                });\n+    }\n+\n@@ -3907,1 +4150,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3924,1 +4167,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3942,1 +4185,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3961,1 +4204,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3975,1 +4218,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3993,1 +4236,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3998,0 +4241,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        ShortSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 2L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 2L, e));\n+                });\n+    }\n+\n@@ -4012,1 +4289,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -4028,0 +4305,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                ShortSpecies vsp,\n+                                VectorMask<Short> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Short>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4355,0 +4642,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ShortVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ShortVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Short> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4369,0 +4671,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Short> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":333,"deletions":17,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.MemorySegment;\n+\n@@ -3512,0 +3514,86 @@\n+\n+    \/**\n+     * Stores this vector into a {@linkplain MemorySegment memory segment}\n+     * starting at an offset using explicit byte order.\n+     * <p>\n+     * Bytes are extracted from primitive lane elements according\n+     * to the specified byte ordering.\n+     * The lanes are stored according to their\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it calls\n+     * {@link #intoMemorySegment(MemorySegment,long,ByteOrder,VectorMask)\n+     * intoMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = maskAll(true);\n+     * intoMemorySegment(ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*ESIZE < 0}\n+     *         or {@code offset+(N+1)*ESIZE > ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws UnsupportedOperationException\n+     *         if the memory segment is read-only\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    public abstract void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo);\n+\n+    \/**\n+     * Stores this vector into a {@linkplain MemorySegment memory segment}\n+     * starting at an offset using explicit byte order and a mask.\n+     * <p>\n+     * Bytes are extracted from primitive lane elements according\n+     * to the specified byte ordering.\n+     * The lanes are stored according to their\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior, where\n+     * {@code JAVA_E} is the layout of the primitive element type, {@code ETYPE} is the\n+     * primitive element type, and {@code EVector} is the primitive\n+     * vector type for this vector:\n+     * <pre>{@code\n+     * ETYPE[] a = this.toArray();\n+     * var slice = ms.asSlice(offset)\n+     * for (int n = 0; n < a.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         slice.setAtIndex(ValueLayout.JAVA_E.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * }<\/pre>\n+     *\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     * In the special case where {@code ETYPE} is\n+     * {@code byte}, the byte order argument is\n+     * ignored.\n+     *\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*ESIZE < 0}\n+     *         or {@code offset+(N+1)*ESIZE > ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws UnsupportedOperationException\n+     *         if the memory segment is read-only\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    public abstract void intoMemorySegment(MemorySegment ms, long offset,\n+                                           ByteOrder bo, VectorMask<E> m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":89,"deletions":1,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -57,0 +57,10 @@\n+    @ForceInline\n+    static long checkFromIndexSize(long ix, long vlen, long length) {\n+        switch (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK) {\n+            case 0: return ix; \/\/ no range check\n+            case 1: return Objects.checkFromIndexSize(ix, vlen, length);\n+            case 2: return Objects.checkIndex(ix, length - (vlen - 1));\n+            default: throw new InternalError();\n+        }\n+    }\n+\n@@ -95,1 +105,1 @@\n-            return index - Math.floorMod(index, Math.abs(size));\n+            return index - Math.floorMod(index, size);\n@@ -98,0 +108,21 @@\n+\n+    \/\/ If the index is not already a multiple of size,\n+    \/\/ round it down to the next smaller multiple of size.\n+    \/\/ It is an error if size is less than zero.\n+    @ForceInline\n+    static long roundDown(long index, int size) {\n+        if ((size & (size - 1)) == 0) {\n+            \/\/ Size is zero or a power of two, so we got this.\n+            return index & ~(size - 1);\n+        } else {\n+            return roundDownNPOT(index, size);\n+        }\n+    }\n+    private static long roundDownNPOT(long index, int size) {\n+        if (index >= 0) {\n+            return index - (index % size);\n+        } else {\n+            return index - Math.floorMod(index, size);\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-                  -> s.opm(n -> c[idx + n]));\n+                  -> s.opm(n -> c[((int )idx) + n]));\n@@ -474,0 +474,32 @@\n+    \/**\n+     * Removes lanes numbered {@code N} from this mask where the\n+     * adjusted index {@code N+offset}, is not in the range\n+     * {@code [0..limit-1]}.\n+     *\n+     * <p> In all cases the series of set and unset lanes is assigned\n+     * as if by using infinite precision or {@code VLENGTH-}saturating\n+     * additions or subtractions, without overflow or wrap-around.\n+     *\n+     * @apiNote\n+     *\n+     * This method performs a SIMD emulation of the check performed by\n+     * {@link Objects#checkIndex(long,long)}, on the index numbers in\n+     * the range {@code [offset..offset+VLENGTH-1]}.  If an exception\n+     * is desired, the resulting mask can be compared with the\n+     * original mask; if they are not equal, then at least one lane\n+     * was out of range, and exception processing can be performed.\n+     *\n+     * <p> A mask which is a series of {@code N} set lanes followed by\n+     * a series of unset lanes can be obtained by calling\n+     * {@code allTrue.indexInRange(0, N)}, where {@code allTrue} is a\n+     * mask of all true bits.  A mask of {@code N1} unset lanes\n+     * followed by {@code N2} set lanes can be obtained by calling\n+     * {@code allTrue.indexInRange(-N1, N2)}.\n+     *\n+     * @param offset the starting index\n+     * @param limit the upper-bound (exclusive) of index range\n+     * @return the original mask, with out-of-range lanes unset\n+     * @see VectorSpecies#indexInRange(long, long)\n+     *\/\n+    public abstract VectorMask<E> indexInRange(long offset, long limit);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-               negative and the result would overflow to a positive value\n+     *         negative and the result would overflow to a positive value\n@@ -157,0 +157,25 @@\n+    \/**\n+     * Loop control function which returns the largest multiple of\n+     * {@code VLENGTH} that is less than or equal to the given\n+     * {@code length} value.\n+     * Here, {@code VLENGTH} is the result of {@code this.length()},\n+     * and {@code length} is interpreted as a number of lanes.\n+     * The resulting value {@code R} satisfies this inequality:\n+     * <pre>{@code R <= length < R+VLENGTH}\n+     * <\/pre>\n+     * <p> Specifically, this method computes\n+     * {@code length - floorMod(length, VLENGTH)}, where\n+     * {@link Math#floorMod(long,int) floorMod} computes a remainder\n+     * value by rounding its quotient toward negative infinity.\n+     * As long as {@code VLENGTH} is a power of two, then the result\n+     * is also equal to {@code length & ~(VLENGTH - 1)}.\n+     *\n+     * @param length the input length\n+     * @return the largest multiple of the vector length not greater\n+     *         than the given length\n+     * @throws IllegalArgumentException if the {@code length} is\n+     *         negative and the result would overflow to a positive value\n+     * @see Math#floorMod(long, int)\n+     *\/\n+    long loopBound(long length);\n+\n@@ -174,0 +199,17 @@\n+    \/**\n+     * Returns a mask of this species where only\n+     * the lanes at index N such that the adjusted index\n+     * {@code N+offset} is in the range {@code [0..limit-1]}\n+     * are set.\n+     *\n+     * <p>\n+     * This method returns the value of the expression\n+     * {@code maskAll(true).indexInRange(offset, limit)}\n+     *\n+     * @param offset the starting index\n+     * @param limit the upper-bound (exclusive) of index range\n+     * @return a mask with out-of-range lanes unset\n+     * @see VectorMask#indexInRange(long, long)\n+     *\/\n+    VectorMask<E> indexInRange(long offset, long limit);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorSpecies.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -358,0 +361,35 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        $type$ apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        $type$[] res = new $type$[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                  VectorMask<$Boxtype$> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/$type$[] vec = vec();\n+        $type$[] res = new $type$[length()];\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -418,0 +456,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, $type$ a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        $type$[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<$Boxtype$> m,\n+                  FStLongOp<M> f) {\n+        $type$[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -4175,0 +4243,108 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * $type$[] ar = new $type$[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+#if[!byte]\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+#else[!byte]\n+     * The byte order argument is ignored.\n+#end[!byte]\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, ms.byteSize());\n+        var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<$Boxtype$>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * $sizeInBytes$L));\n+    }\n+\n@@ -4202,1 +4378,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4419,1 +4595,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4578,1 +4754,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4781,0 +4957,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -4811,1 +5024,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4828,1 +5041,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4905,1 +5118,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4922,1 +5135,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4939,1 +5152,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4956,1 +5169,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4974,1 +5187,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -4993,1 +5206,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -5009,1 +5222,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -5027,1 +5240,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -5032,0 +5245,34 @@\n+    abstract\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        $Type$Species vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * $sizeInBytes$L));\n+                });\n+    }\n+\n+    abstract\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * $sizeInBytes$L));\n+                });\n+    }\n+\n@@ -5047,1 +5294,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -5064,1 +5311,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -5145,1 +5392,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -5162,1 +5409,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -5181,1 +5428,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -5195,1 +5442,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -5213,1 +5460,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -5218,0 +5465,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        $Type$Species vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * $sizeInBytes$L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * $sizeInBytes$L, e));\n+                });\n+    }\n+\n@@ -5233,1 +5514,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -5250,0 +5531,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                $Type$Species vsp,\n+                                VectorMask<$Boxtype$> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<$Boxtype$>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -5618,0 +5909,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                      VectorMask<$Boxtype$> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -5631,0 +5937,14 @@\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<$Boxtype$> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":341,"deletions":21,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -1212,0 +1213,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m) {\n+        return super.fromMemorySegment0Template($masktype$.class, ms, offset, ($masktype$) m);  \/\/ specialize\n+    }\n+\n@@ -1265,0 +1280,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m) {\n+        super.intoMemorySegment0Template($masktype$.class, ms, offset, ($masktype$) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+    requires transitive jdk.incubator.foreign;\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,11 @@\n+\n+    static final List<IntFunction<MemorySegment>> MEMORY_SEGMENT_GENERATORS = List.of(\n+            withToString(\"HMS\", (int s) -> {\n+                return MemorySegment.allocateNative(s, ResourceScope.newImplicitScope());\n+            }),\n+            withToString(\"DMS\", (int s) -> {\n+                byte[] b = new byte[s];\n+                return MemorySegment.ofArray(b);\n+            })\n+    );\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -200,0 +203,21 @@\n+    @DataProvider\n+    public Object[][] byteMemorySegmentProvider() {\n+        return BYTE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -253,0 +277,12 @@\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n+    }\n+\n@@ -338,0 +374,19 @@\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -732,0 +787,206 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        byte[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5981,0 +5981,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5999,0 +6013,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -200,0 +203,21 @@\n+    @DataProvider\n+    public Object[][] byteMemorySegmentProvider() {\n+        return BYTE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -253,0 +277,12 @@\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n+    }\n+\n@@ -338,0 +374,19 @@\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -732,0 +787,206 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        byte[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5981,0 +5981,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5999,0 +6013,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -200,0 +203,21 @@\n+    @DataProvider\n+    public Object[][] byteMemorySegmentProvider() {\n+        return BYTE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -253,0 +277,12 @@\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n+    }\n+\n@@ -338,0 +374,19 @@\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -732,0 +787,206 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        byte[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5981,0 +5981,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5999,0 +6013,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -200,0 +203,21 @@\n+    @DataProvider\n+    public Object[][] byteMemorySegmentProvider() {\n+        return BYTE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -253,0 +277,12 @@\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n+    }\n+\n@@ -338,0 +374,19 @@\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -732,0 +787,206 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        byte[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5981,0 +5981,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5999,0 +6013,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -209,0 +212,21 @@\n+    @DataProvider\n+    public Object[][] byteMemorySegmentProvider() {\n+        return BYTE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -262,0 +286,12 @@\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n+    }\n+\n@@ -347,0 +383,19 @@\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -741,0 +796,206 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        byte[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5970,0 +5970,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByteMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5988,0 +6002,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByteMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentProvider() {\n+        return DOUBLE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        double[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5150,0 +5150,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5169,0 +5183,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentProvider() {\n+        return DOUBLE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        double[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5150,0 +5150,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5169,0 +5183,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentProvider() {\n+        return DOUBLE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        double[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5150,0 +5150,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5169,0 +5183,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentProvider() {\n+        return DOUBLE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        double[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5150,0 +5150,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5168,0 +5182,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -220,0 +223,21 @@\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentProvider() {\n+        return DOUBLE_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -273,0 +297,12 @@\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n+    }\n+\n@@ -358,0 +394,19 @@\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -752,0 +807,206 @@\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        double[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5139,0 +5139,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDoubleMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5158,0 +5172,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDoubleMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] floatMemorySegmentProvider() {\n+        return FLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floatMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        float[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5128,0 +5128,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5146,0 +5160,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] floatMemorySegmentProvider() {\n+        return FLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floatMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        float[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5128,0 +5128,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5146,0 +5160,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] floatMemorySegmentProvider() {\n+        return FLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floatMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        float[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5128,0 +5128,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5146,0 +5160,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] floatMemorySegmentProvider() {\n+        return FLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floatMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        float[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5128,0 +5128,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5146,0 +5160,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -220,0 +223,21 @@\n+    @DataProvider\n+    public Object[][] floatMemorySegmentProvider() {\n+        return FLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] floatMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -273,0 +297,12 @@\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n+    }\n+\n@@ -358,0 +394,19 @@\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -752,0 +807,206 @@\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        float[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5117,0 +5117,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5135,0 +5149,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] intMemorySegmentProvider() {\n+        return INT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        int[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5932,0 +5932,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5949,0 +5963,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] intMemorySegmentProvider() {\n+        return INT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        int[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5932,0 +5932,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5949,0 +5963,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] intMemorySegmentProvider() {\n+        return INT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        int[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5932,0 +5932,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5949,0 +5963,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] intMemorySegmentProvider() {\n+        return INT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        int[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5932,0 +5932,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5949,0 +5963,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -220,0 +223,21 @@\n+    @DataProvider\n+    public Object[][] intMemorySegmentProvider() {\n+        return INT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -273,0 +297,12 @@\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n+    }\n+\n@@ -358,0 +394,19 @@\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -752,0 +807,206 @@\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        int[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5921,0 +5921,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongIntMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5938,0 +5952,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongIntMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] longMemorySegmentProvider() {\n+        return LONG_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        long[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5816,0 +5816,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5834,0 +5848,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] longMemorySegmentProvider() {\n+        return LONG_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        long[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5816,0 +5816,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5834,0 +5848,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] longMemorySegmentProvider() {\n+        return LONG_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        long[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5816,0 +5816,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5834,0 +5848,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] longMemorySegmentProvider() {\n+        return LONG_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        long[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5816,0 +5816,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5834,0 +5848,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -220,0 +223,21 @@\n+    @DataProvider\n+    public Object[][] longMemorySegmentProvider() {\n+        return LONG_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -273,0 +297,12 @@\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n+    }\n+\n@@ -358,0 +394,19 @@\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -752,0 +807,206 @@\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        long[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5805,0 +5805,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLongMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5823,0 +5837,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLongMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5961,0 +5961,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5979,0 +5993,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5961,0 +5961,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5979,0 +5993,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5961,0 +5961,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5979,0 +5993,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -211,0 +214,21 @@\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -264,0 +288,12 @@\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n@@ -349,0 +385,19 @@\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -743,0 +798,206 @@\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5961,0 +5961,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5979,0 +5993,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -220,0 +223,21 @@\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -273,0 +297,12 @@\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n@@ -358,0 +394,19 @@\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -752,0 +807,206 @@\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -5950,0 +5950,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShortMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5968,0 +5982,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShortMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -548,0 +548,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong$vectorteststype$SmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -568,0 +582,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong$vectorteststype$SmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -239,0 +242,21 @@\n+    @DataProvider\n+    public Object[][] $type$MemorySegmentProvider() {\n+        return $TYPE$_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$MemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -292,0 +316,12 @@\n+    static MemorySegment toSegment($type$[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_$TYPE$, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static $type$[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_$TYPE$);\n+    }\n+\n@@ -381,0 +417,19 @@\n+    @DontInline\n+    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+        return $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n@@ -775,0 +830,206 @@\n+    @Test(dataProvider = \"$type$MemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<$type$[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$MemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<$type$[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        $type$[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$MemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<$type$[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<$Boxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":262,"deletions":1,"binary":false,"changes":263,"status":"modified"}]}