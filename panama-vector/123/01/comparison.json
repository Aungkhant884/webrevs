{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=panama\n@@ -6,1 +6,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,executable,symlink,message,whitespace\n@@ -9,2 +9,1 @@\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\\\.(?:0|[1-9][0-9]*)){0,4})(?:\\\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\\\d{1,3})?-(?:(?:b\\\\d{2,3})|(?:ga)))|(?:hs\\\\d\\\\d(?:\\\\.\\\\d{1,2})?-b\\\\d\\\\d)\n@@ -17,5 +16,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n-ignore-tabs=.*\\.gmk|Makefile\n-\n-[checks \"merge\"]\n-message=Merge\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java\n@@ -24,2 +19,1 @@\n-reviewers=1\n-ignore=duke\n+committers=1\n@@ -29,6 +23,0 @@\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1905,1 +1905,1 @@\n-  if (C->max_vector_size() >= 16) {\n+  if (C->max_vector_size() > 0) {\n@@ -2391,1 +2391,1 @@\n-  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+  if (!match_rule_supported(opcode)) {\n@@ -2399,1 +2399,1 @@\n-    return op_sve_supported(opcode);\n+    return op_sve_supported(opcode, vlen, bt);\n@@ -2441,0 +2441,3 @@\n+    case Op_LoadVectorGather:\n+    case Op_StoreVectorScatter:\n+      return false;\n@@ -2445,1 +2448,1 @@\n-  return true; \/\/ Per default match rules are supported.\n+  return vector_size_supported(bt, vlen);\n@@ -2491,0 +2494,1 @@\n+\n@@ -2493,15 +2497,8 @@\n-  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n-    \/\/ Currently vector length less than SVE vector register size is not supported.\n-    return max_size;\n-  } else { \/\/ NEON\n-    \/\/ Limit the vector size to 8 bytes\n-    int size = 8 \/ type2aelembytes(bt);\n-    if (bt == T_BYTE) {\n-      \/\/ To support vector api shuffle\/rearrange.\n-      size = 4;\n-    } else if (bt == T_BOOLEAN) {\n-      \/\/ To support vector api load\/store mask.\n-      size = 2;\n-    }\n-    if (size < 2) size = 2;\n-    return MIN2(size,max_size);\n+  \/\/ Limit the min vector size to 8 bytes.\n+  int size = 8 \/ type2aelembytes(bt);\n+  if (bt == T_BYTE) {\n+    \/\/ To support vector api shuffle\/rearrange.\n+    size = 4;\n+  } else if (bt == T_BOOLEAN) {\n+    \/\/ To support vector api load\/store mask.\n+    size = 2;\n@@ -2509,0 +2506,2 @@\n+  if (size < 2) size = 2;\n+  return MIN2(size, max_size);\n@@ -2518,1 +2517,1 @@\n-  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+  if (UseSVE > 0 && 2 <= len && len <= 256) {\n@@ -3723,1 +3722,1 @@\n-    if (Compile::current()->max_vector_size() >= 16 && uncommon_trap_request() == 0) {\n+    if (Compile::current()->max_vector_size() > 0 && uncommon_trap_request() == 0) {\n@@ -3735,1 +3734,1 @@\n-    } else if (Compile::current()->max_vector_size() >= 16) {\n+    } else if (Compile::current()->max_vector_size() > 0) {\n@@ -3773,1 +3772,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -3786,1 +3785,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -4159,0 +4158,10 @@\n+operand immI_gt_1()\n+%{\n+  predicate(n->get_int() > 1);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":33,"deletions":24,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 2);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 2);\n@@ -47,1 +47,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 4);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 4);\n@@ -58,1 +58,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 8);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 8);\n@@ -2476,3 +2476,4 @@\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n-             n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate(UseSVE == 0 &&\n+           (n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n+            n->as_Vector()->length() == 8) &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n@@ -2491,1 +2492,1 @@\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n@@ -2948,2 +2949,2 @@\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && (n->as_Vector()->length() == 8 ||\n+                            n->as_Vector()->length() == 4));\n@@ -2973,2 +2974,2 @@\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && (n->as_Vector()->length() == 8 ||\n+                            n->as_Vector()->length() == 4));\n@@ -2998,2 +2999,2 @@\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && (n->as_Vector()->length() == 4 ||\n+                            n->as_Vector()->length() == 2));\n@@ -3023,2 +3024,2 @@\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && (n->as_Vector()->length() == 4 ||\n+                            n->as_Vector()->length() == 2));\n@@ -3048,1 +3049,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -3072,1 +3073,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -3122,1 +3123,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -4252,2 +4253,2 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n+  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 4 ||\n+            n->as_Vector()->length_in_bytes() == 8));\n@@ -4264,1 +4265,1 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 16));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -72,3 +72,3 @@\n-VLoadStore(ldrh, H, load,  2,  D, 16,  dst, )\n-VLoadStore(ldrs, S, load,  4,  D, 32,  dst, )\n-VLoadStore(ldrd, D, load,  8,  D, 64,  dst, )\n+VLoadStore(ldrh, H, load,  2,  D, 16,  dst, UseSVE == 0 && )\n+VLoadStore(ldrs, S, load,  4,  D, 32,  dst, UseSVE == 0 && )\n+VLoadStore(ldrd, D, load,  8,  D, 64,  dst, UseSVE == 0 && )\n@@ -1199,4 +1199,5 @@\n-`predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n-             n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);')')dnl\n+`predicate(UseSVE == 0 &&\n+           (n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n+            n->as_Vector()->length() == 8) &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n+`predicate(UseSVE == 0 && n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);')')dnl\n@@ -1469,3 +1470,4 @@\n-  predicate(ifelse($8, UseSVE == 0 && , $8,\n-                   $8, , , $8`\n-            ')n->as_Vector()->length() == $3);\n+  predicate(UseSVE == 0 && ifelse($8, `',\n+                                  n->as_Vector()->length() == $3,\n+                                  (n->as_Vector()->length() == $3 ||`\n+                            'n->as_Vector()->length() == $8)));\n@@ -1497,18 +1499,18 @@\n-dnl        $1    $2    $3  $4 $5     $6 $7          $8                                $9\n-VREPLICATE(dup,  dup,  8,  B, ,      D, iRegIorL2I, n->as_Vector()->length() == 4 ||, B)\n-VREPLICATE(dup,  dup,  16, B, ,      X, iRegIorL2I, UseSVE == 0 && ,                  B)\n-VREPLICATE(movi, mov,  8,  B, _imm,  D, immI,       n->as_Vector()->length() == 4 ||, B)\n-VREPLICATE(movi, mov,  16, B, _imm,  X, immI,       UseSVE == 0 && ,                  B)\n-VREPLICATE(dup,  dup,  4,  S, ,      D, iRegIorL2I, n->as_Vector()->length() == 2 ||, H)\n-VREPLICATE(dup,  dup,  8,  S, ,      X, iRegIorL2I, UseSVE == 0 && ,                  H)\n-VREPLICATE(movi, mov,  4,  S, _imm,  D, immI,       n->as_Vector()->length() == 2 ||, H)\n-VREPLICATE(movi, mov,  8,  S,  _imm, X, immI,       UseSVE == 0 && ,                  H)\n-VREPLICATE(dup,  dup,  2,  I, ,      D, iRegIorL2I, ,                                 S)\n-VREPLICATE(dup,  dup,  4,  I, ,      X, iRegIorL2I, UseSVE == 0 && ,                  S)\n-VREPLICATE(movi, mov,  2,  I, _imm,  D, immI,       ,                                 S)\n-VREPLICATE(movi, mov,  4,  I,  _imm, X, immI,       UseSVE == 0 && ,                  S)\n-VREPLICATE(dup,  dup,  2,  L, ,      X, iRegL,      UseSVE == 0 && ,                  D)\n-VREPLICATE(movi, eor,  2,  L, _zero, X, immI0,      UseSVE == 0 && ,                  D)\n-VREPLICATE(dup,  dup,  2,  F, ,      D, vRegF,      ,                                 S)\n-VREPLICATE(dup,  dup,  4,  F, ,      X, vRegF,      UseSVE == 0 && ,                  S)\n-VREPLICATE(dup,  dup,  2,  D, ,      X, vRegD,      UseSVE == 0 && ,                  D)\n+dnl        $1    $2    $3  $4 $5     $6 $7          $8 $9\n+VREPLICATE(dup,  dup,  8,  B, ,      D, iRegIorL2I, 4, B)\n+VREPLICATE(dup,  dup,  16, B, ,      X, iRegIorL2I,  , B)\n+VREPLICATE(movi, mov,  8,  B, _imm,  D, immI,       4, B)\n+VREPLICATE(movi, mov,  16, B, _imm,  X, immI,        , B)\n+VREPLICATE(dup,  dup,  4,  S, ,      D, iRegIorL2I, 2, H)\n+VREPLICATE(dup,  dup,  8,  S, ,      X, iRegIorL2I,  , H)\n+VREPLICATE(movi, mov,  4,  S, _imm,  D, immI,       2, H)\n+VREPLICATE(movi, mov,  8,  S,  _imm, X, immI,        , H)\n+VREPLICATE(dup,  dup,  2,  I, ,      D, iRegIorL2I, ,  S)\n+VREPLICATE(dup,  dup,  4,  I, ,      X, iRegIorL2I, ,  S)\n+VREPLICATE(movi, mov,  2,  I, _imm,  D, immI,       ,  S)\n+VREPLICATE(movi, mov,  4,  I,  _imm, X, immI,       ,  S)\n+VREPLICATE(dup,  dup,  2,  L, ,      X, iRegL,      ,  D)\n+VREPLICATE(movi, eor,  2,  L, _zero, X, immI0,      ,  D)\n+VREPLICATE(dup,  dup,  2,  F, ,      D, vRegF,      ,  S)\n+VREPLICATE(dup,  dup,  4,  F, ,      X, vRegF,      ,  S)\n+VREPLICATE(dup,  dup,  2,  D, ,      X, vRegD,      ,  D)\n@@ -1887,2 +1889,2 @@\n-  predicate(ifelse($3, 8, n->as_Vector()->length_in_bytes() == 4 ||`\n-            ')n->as_Vector()->length_in_bytes() == $3);\n+  predicate(UseSVE == 0 && (ifelse($3, 8, n->as_Vector()->length_in_bytes() == 4 ||`\n+            ')n->as_Vector()->length_in_bytes() == $3));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  \/\/ (esize \/ msize) = 1\n@@ -46,0 +47,1 @@\n+  \/\/ (esize \/ msize) = 1\n@@ -60,1 +62,1 @@\n-  format %{ \"[$reg, $off, MUL VL]\" %}\n+  format %{ \"[$reg, $off]\" %}\n@@ -74,1 +76,1 @@\n-  format %{ \"[$reg, $off, MUL VL]\" %}\n+  format %{ \"[$reg, $off]\" %}\n@@ -83,0 +85,2 @@\n+\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n+\/\/ size equals to memory element (load from\/store to) size.\n@@ -86,1 +90,1 @@\n-  bool op_sve_supported(int opcode);\n+  bool op_sve_supported(int opcode, int vlen, BasicType bt);\n@@ -90,20 +94,0 @@\n-  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {\n-    switch(esize) {\n-      case 1:\n-        return Assembler::B;\n-      case 2:\n-        return Assembler::H;\n-      case 4:\n-        return Assembler::S;\n-      case 8:\n-        return Assembler::D;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-    return Assembler::INVALID;\n-  }\n-\n-  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {\n-    return elemBytes_to_regVariant(type2aelembytes(bt));\n-  }\n@@ -115,3 +99,3 @@\n-  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store,\n-                                   FloatRegister reg, PRegister pg, BasicType bt,\n-                                   int opcode, Register base, int index, int size, int disp) {\n+  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n+                                    int opcode, Register base, int index, int size, int disp) {\n@@ -119,2 +103,1 @@\n-    Assembler::SIMD_RegVariant type;\n-    int esize = type2aelembytes(bt);\n+    int mesize = type2aelembytes(mem_elem_bt);\n@@ -123,1 +106,1 @@\n-      switch(esize) {\n+      switch(mesize) {\n@@ -126,1 +109,0 @@\n-        type = Assembler::B;\n@@ -130,1 +112,0 @@\n-        type = Assembler::H;\n@@ -134,1 +115,0 @@\n-        type = Assembler::S;\n@@ -138,1 +118,0 @@\n-        type = Assembler::D;\n@@ -144,1 +123,2 @@\n-      (masm.*insn)(reg, type, pg, Address(base, disp \/ Matcher::scalable_vector_reg_size(T_BYTE)));\n+      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n@@ -151,1 +131,2 @@\n-  bool op_sve_supported(int opcode) {\n+  bool op_sve_supported(int opcode, int vlen, BasicType bt) {\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n@@ -154,1 +135,1 @@\n-        \/\/ No multiply reduction instructions\n+      \/\/ No multiply reduction instructions\n@@ -159,3 +140,1 @@\n-        \/\/ Others\n-      case Op_Extract:\n-      case Op_ExtractB:\n+      \/\/ Others\n@@ -163,5 +142,0 @@\n-      case Op_ExtractD:\n-      case Op_ExtractF:\n-      case Op_ExtractI:\n-      case Op_ExtractL:\n-      case Op_ExtractS:\n@@ -169,0 +143,1 @@\n+        return false;\n@@ -170,18 +145,0 @@\n-      case Op_AndReductionV:\n-      case Op_OrReductionV:\n-      case Op_XorReductionV:\n-      case Op_MaxReductionV:\n-      case Op_MinReductionV:\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_VectorBlend:\n-      case Op_VectorCast:\n-      case Op_VectorCastB2X:\n-      case Op_VectorCastD2X:\n-      case Op_VectorCastF2X:\n-      case Op_VectorCastI2X:\n-      case Op_VectorCastL2X:\n-      case Op_VectorCastS2X:\n-      case Op_VectorInsert:\n-      case Op_VectorLoadConst:\n-      case Op_VectorLoadMask:\n@@ -189,1 +146,0 @@\n-      case Op_VectorMaskCmp:\n@@ -191,7 +147,8 @@\n-      case Op_VectorReinterpret:\n-      case Op_VectorStoreMask:\n-      case Op_VectorTest:\n-      case Op_VectorMaskTrueCount:\n-      case Op_VectorMaskLastTrue:\n-      case Op_VectorMaskFirstTrue:\n-        return false;\n+        if (vlen < 4 || length_in_bytes > MaxVectorSize) {\n+          return false;\n+        } else {\n+          return true;\n+        }\n+      case Op_LoadVector:\n+      case Op_StoreVector:\n+        return Matcher::vector_size_supported(bt, vlen);\n@@ -199,1 +156,1 @@\n-        return true;\n+        break;\n@@ -201,0 +158,2 @@\n+    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n+    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n@@ -213,1 +172,1 @@\n-\/\/ Use predicated vector load\/store\n+\/\/ Unpredicated vector load\/store\n@@ -215,1 +174,2 @@\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16);\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16 &&\n+            n->as_LoadVector()->memory_size() == MaxVectorSize);\n@@ -217,2 +177,2 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n@@ -221,3 +181,4 @@\n-    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n-                         Matcher::vector_element_basic_type(this), $mem->opcode(),\n-                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                          bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -229,1 +190,2 @@\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16);\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16 &&\n+            n->as_StoreVector()->memory_size() == MaxVectorSize);\n@@ -231,2 +193,112 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n+                          bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (16 bits)\n+instruct loadV2_vreg(vReg dst, vmem2 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 2);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrh   $dst,$mem\\t# vector (16 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n+  ins_pipe(vload_reg_mem64);\n+%}\n+\n+\/\/ Store Vector (16 bits)\n+instruct storeV2_vreg(vReg src, vmem2 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 2);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"strh   $mem,$src\\t# vector (16 bits)\" %}\n+  ins_encode( aarch64_enc_strvH(src, mem) );\n+  ins_pipe(vstore_reg_mem64);\n+%}\n+\n+\/\/ Load Vector (32 bits)\n+instruct loadV4_vreg(vReg dst, vmem4 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 4);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrs   $dst,$mem\\t# vector (32 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n+  ins_pipe(vload_reg_mem64);\n+%}\n+\n+\/\/ Store Vector (32 bits)\n+instruct storeV4_vreg(vReg src, vmem4 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 4);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"strs   $mem,$src\\t# vector (32 bits)\" %}\n+  ins_encode( aarch64_enc_strvS(src, mem) );\n+  ins_pipe(vstore_reg_mem64);\n+%}\n+\n+\/\/ Load Vector (64 bits)\n+instruct loadV8_vreg(vReg dst, vmem8 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 8);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrd   $dst,$mem\\t# vector (64 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n+  ins_pipe(vload_reg_mem64);\n+%}\n+\n+\/\/ Store Vector (64 bits)\n+instruct storeV8_vreg(vReg src, vmem8 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 8);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"strd   $mem,$src\\t# vector (64 bits)\" %}\n+  ins_encode( aarch64_enc_strvD(src, mem) );\n+  ins_pipe(vstore_reg_mem64);\n+%}\n+\n+\/\/ Load Vector (128 bits)\n+instruct loadV16_vreg(vReg dst, vmem16 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrq   $dst,$mem\\t# vector (128 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n+  ins_pipe(vload_reg_mem128);\n+%}\n+\n+\/\/ Store Vector (128 bits)\n+instruct storeV16_vreg(vReg src, vmem16 mem)\n+%{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"strq   $mem,$src\\t# vector (128 bits)\" %}\n+  ins_encode( aarch64_enc_strvQ(src, mem) );\n+  ins_pipe(vstore_reg_mem128);\n+%}\n+\n+\/\/ Predicated vector load\/store, based on the vector length of the node.\n+\/\/ Only load\/store values in the range of the memory_size. This is needed\n+\/\/ when the memory_size is lower than the hardware supported max vector size.\n+\/\/ And this might happen for Vector API mask vector load\/store.\n+instruct loadV_partial(vReg dst, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16 &&\n+            n->as_LoadVector()->memory_size() < MaxVectorSize);\n+  match(Set dst (LoadVector mem));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(6 * SVE_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_ldr $dst, $pTmp, $mem\\t# load vector predicated\" %}\n@@ -234,0 +306,23 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+                          Matcher::vector_length(this));\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg,\n+                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_partial(vReg src, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16 &&\n+            n->as_StoreVector()->memory_size() < MaxVectorSize);\n+  match(Set mem (StoreVector mem src));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_str $src, $pTmp, $mem\\t# store vector predicated\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+                          Matcher::vector_length(this, $src));\n@@ -235,3 +330,39 @@\n-    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n-                         Matcher::vector_element_basic_type(this, $src), $mem->opcode(),\n-                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg,\n+                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector reinterpret\n+\n+instruct reinterpret(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==\n+                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpretResize(vReg dst, vReg src, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=\n+                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"reinterpretResize $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ B, length_in_bytes_resize);\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n@@ -245,1 +376,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16 &&\n+  predicate(UseSVE > 0 &&\n@@ -258,1 +389,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8 &&\n+  predicate(UseSVE > 0 &&\n@@ -271,1 +402,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+  predicate(UseSVE > 0 &&\n@@ -284,1 +415,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+  predicate(UseSVE > 0 &&\n@@ -297,1 +428,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+  predicate(UseSVE > 0 &&\n@@ -310,1 +441,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+  predicate(UseSVE > 0 &&\n@@ -325,1 +456,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  predicate(UseSVE > 0);\n@@ -338,1 +469,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  predicate(UseSVE > 0);\n@@ -351,1 +482,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -364,1 +495,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -377,1 +508,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -390,1 +521,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -405,1 +536,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -420,1 +551,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -435,1 +566,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -450,1 +581,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -464,1 +595,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -479,1 +610,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -494,1 +625,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -510,1 +641,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -522,1 +653,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -536,1 +667,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -542,1 +673,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -556,1 +687,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -562,1 +693,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -579,1 +710,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -592,1 +723,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -608,1 +739,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -623,1 +754,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -640,1 +771,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -655,1 +786,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -671,1 +802,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -684,1 +815,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -700,1 +831,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  predicate(UseSVE > 0);\n@@ -714,1 +845,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  predicate(UseSVE > 0);\n@@ -728,1 +859,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -742,1 +873,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -758,1 +889,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  predicate(UseSVE > 0);\n@@ -772,1 +903,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  predicate(UseSVE > 0);\n@@ -786,1 +917,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -800,1 +931,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -815,1 +946,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  predicate(UseSVE > 0);\n@@ -827,1 +958,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  predicate(UseSVE > 0);\n@@ -839,1 +970,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -851,1 +982,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -863,1 +994,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -876,1 +1007,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  predicate(UseSVE > 0);\n@@ -891,1 +1022,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -903,1 +1034,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -917,1 +1048,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -919,1 +1050,1 @@\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\"  %}\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n@@ -926,1 +1057,1 @@\n-\/\/ vector add reduction\n+\/\/ vector mask compare\n@@ -928,10 +1059,7 @@\n-instruct reduce_addB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\n\\t\"\n-            \"sxtb  $dst, $dst\\t # add reduction B\" %}\n+instruct vmaskcmp(vReg dst, vReg src1, vReg src2, immI cond, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmp $pTmp, $src1, $src2\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, -1\\t# vector mask cmp (sve)\" %}\n@@ -939,5 +1067,5 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pTmp$$reg), -1, false);\n@@ -948,10 +1076,9 @@\n-instruct reduce_addS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\n\\t\"\n-            \"sxth  $dst, $dst\\t # add reduction H\" %}\n+\/\/ vector blend\n+\n+instruct vblend(vReg dst, vReg src1, vReg src2, vReg src3, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) src3));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmpeq $pTmp, $src3, -1\\n\\t\"\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n@@ -959,5 +1086,6 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    Assembler::SIMD_RegVariant size =\n+      __ elemType_to_regVariant(Matcher::vector_element_basic_type(this));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($src3$$reg), -1);\n+    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg),\n+               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n@@ -968,9 +1096,10 @@\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\t # add reduction S\" %}\n+\/\/ vector blend with compare\n+\n+instruct vblend_maskcmp(vReg dst, vReg src1, vReg src2, vReg src3,\n+                        vReg src4, pRegGov pTmp, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) (VectorMaskCmp (Binary src3 src4) cond)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmp $pTmp, $src3, $src4\\t# vector cmp (sve)\\n\\t\"\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n@@ -978,4 +1107,6 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src3$$reg),\n+                   as_FloatRegister($src4$$reg), (int)$cond$$constant);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pTmp$$reg), as_FloatRegister($src2$$reg),\n+               as_FloatRegister($src1$$reg));\n@@ -986,5 +1117,6 @@\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AddReductionVL src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+\/\/ vector load mask\n+\n+instruct vloadmaskB(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n@@ -992,3 +1124,1 @@\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add  $dst, $dst, $src1\\t # add reduction D\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector load mask (B)\" %}\n@@ -996,4 +1126,1 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue, as_FloatRegister($src$$reg));\n@@ -1004,5 +1131,7 @@\n-instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n+instruct vloadmaskS(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorLoadMask src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to H)\" %}\n@@ -1010,2 +1139,2 @@\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ H, ptrue, as_FloatRegister($dst$$reg));\n@@ -1016,5 +1145,9 @@\n-instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set src1_dst (AddReductionVD src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n+instruct vloadmaskI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (VectorLoadMask src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to S)\" %}\n@@ -1022,2 +1155,3 @@\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg));\n@@ -1028,10 +1162,10 @@\n-\/\/ vector max reduction\n-\n-instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n-            \"fmaxs $dst, $dst, $src1\\t # max reduction F\" %}\n+instruct vloadmaskL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (VectorLoadMask src));\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n+            \"sve_uunpklo $dst, D, $dst\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to D)\" %}\n@@ -1039,3 +1173,4 @@\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg));\n@@ -1046,8 +1181,7 @@\n-instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n-            \"fmaxs $dst, $dst, $src1\\t # max reduction D\" %}\n+\/\/ vector store mask\n+\n+instruct vstoremaskB(vReg dst, vReg src, immI_1 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_neg $dst, $src\\t# vector store mask (B)\" %}\n@@ -1055,3 +1189,2 @@\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($src$$reg));\n@@ -1062,10 +1195,8 @@\n-\/\/ vector min reduction\n-\n-instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n-            \"fmins $dst, $dst, $src1\\t # min reduction F\" %}\n+instruct vstoremaskS(vReg dst, vReg src, vReg tmp, immI_2 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_dup $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1 $dst, B, $src, $tmp\\n\\t\"\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (H to B)\" %}\n@@ -1073,3 +1204,6 @@\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n+                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($dst$$reg));\n+\n@@ -1080,8 +1214,9 @@\n-instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n-            \"fmins $dst, $dst, $src1\\t # min reduction D\" %}\n+instruct vstoremaskI(vReg dst, vReg src, vReg tmp, immI_4 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_dup $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1 $dst, H, $src, $tmp\\n\\t\"\n+            \"sve_uzp1 $dst, B, $dst, $tmp\\n\\t\"\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (S to B)\" %}\n@@ -1089,3 +1224,7 @@\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n+                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n+                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($dst$$reg));\n@@ -1096,7 +1235,10 @@\n-\/\/ vector Math.rint, floor, ceil\n-\n-instruct vroundD(vReg dst, vReg src, immI rmode) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+instruct vstoremaskL(vReg dst, vReg src, vReg tmp, immI_8 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_dup $tmp, D, 0\\n\\t\"\n+            \"sve_uzp1 $dst, S, $src, $tmp\\n\\t\"\n+            \"sve_uzp1 $dst, H, $dst, $tmp\\n\\t\"\n+            \"sve_uzp1 $dst, B, $dst, $tmp\\n\\t\"\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (D to B)\" %}\n@@ -1104,14 +1246,9 @@\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-    }\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ D, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S,\n+                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n+                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n+                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($dst$$reg));\n@@ -1122,1 +1259,1 @@\n-\/\/ vector replicate\n+\/\/ load\/store mask vector\n@@ -1124,5 +1261,7 @@\n-instruct replicateB(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (ReplicateB src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (B)\" %}\n+instruct vloadmask_loadV_byte(vReg dst, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() == MaxVectorSize &&\n+            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_ld1b $dst, $mem\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# load vector mask (sve)\" %}\n@@ -1130,1 +1269,7 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_vect_variant = __ elemType_to_regVariant(to_vect_bt);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                          T_BOOLEAN, to_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_neg(dst_reg, to_vect_variant, ptrue, dst_reg);\n@@ -1135,5 +1280,7 @@\n-instruct replicateS(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (ReplicateS src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (H)\" %}\n+instruct vloadmask_loadV_non_byte(vReg dst, indirect mem) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() == MaxVectorSize &&\n+            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_ld1b $dst, $mem\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# load vector mask (sve)\" %}\n@@ -1141,1 +1288,7 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_vect_variant = __ elemType_to_regVariant(to_vect_bt);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                          T_BOOLEAN, to_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_neg(dst_reg, to_vect_variant, ptrue, dst_reg);\n@@ -1146,5 +1299,8 @@\n-instruct replicateI(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (S)\" %}\n+instruct storeV_vstoremask_byte(vmemA mem, vReg src, vReg tmp, immI_1 esize) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() *\n+                          n->as_StoreVector()->in(MemNode::ValueIn)->in(2)->get_int() == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_neg $tmp, $src\\n\\t\"\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve)\" %}\n@@ -1152,1 +1308,8 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));\n+    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant from_vect_variant = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_neg(as_FloatRegister($tmp$$reg), from_vect_variant, ptrue,\n+               as_FloatRegister($src$$reg));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),\n+                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -1157,5 +1320,8 @@\n-instruct replicateL(vReg dst, iRegL src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (ReplicateL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (D)\" %}\n+instruct storeV_vstoremask_non_byte(indirect mem, vReg src, vReg tmp, immI_gt_1 esize) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() *\n+                          n->as_StoreVector()->in(MemNode::ValueIn)->in(2)->get_int() == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_neg $tmp, $src\\n\\t\"\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve)\" %}\n@@ -1163,1 +1329,8 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));\n+    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant from_vect_variant = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_neg(as_FloatRegister($tmp$$reg), from_vect_variant, ptrue,\n+               as_FloatRegister($src$$reg));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),\n+                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -1168,3 +1341,6 @@\n-instruct replicateB_imm8(vReg dst, immI8 con) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (ReplicateB con));\n+\/\/ vector add reduction\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1172,1 +1348,1 @@\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (B)\" %}\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1174,1 +1350,12 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1179,3 +1366,5 @@\n-instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (ReplicateS con));\n+instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1183,1 +1372,1 @@\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (H)\" %}\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n@@ -1185,1 +1374,15 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1190,3 +1393,4 @@\n-instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (ReplicateI con));\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1194,1 +1398,1 @@\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction (sve)\" %}\n@@ -1196,1 +1400,3 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1201,3 +1407,5 @@\n-instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (ReplicateL con));\n+instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1205,1 +1413,1 @@\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n@@ -1207,1 +1415,6 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1212,3 +1425,4 @@\n-instruct replicateF(vReg dst, vRegF src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (ReplicateF src));\n+\n+instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n@@ -1216,1 +1430,1 @@\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n@@ -1218,2 +1432,2 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n@@ -1224,3 +1438,3 @@\n-instruct replicateD(vReg dst, vRegD src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (ReplicateD src));\n+instruct reduce_addF_partial(vRegF src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n@@ -1228,1 +1442,2 @@\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (D)\" %}\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_addF $src1_dst, $src1_dst, $src2\\t# addF reduction partial (sve) (S)\" %}\n@@ -1230,2 +1445,4 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ S,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1236,7 +1453,5 @@\n-\/\/ vector shift\n-\n-instruct vasrB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (RShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set src1_dst (AddReductionVD src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n@@ -1244,2 +1459,2 @@\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n@@ -1250,3 +1465,3 @@\n-instruct vasrS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (RShiftVS dst shift));\n+instruct reduce_addD_partial(vRegD src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set src1_dst (AddReductionVD src1_dst src2));\n@@ -1254,1 +1469,2 @@\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_addD $src1_dst, $src1_dst, $src2\\t# addD reduction partial (sve) (D)\" %}\n@@ -1256,2 +1472,4 @@\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1262,3 +1480,7 @@\n-instruct vasrI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (RShiftVI dst shift));\n+\/\/ vector and reduction\n+\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1266,1 +1488,1 @@\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1268,2 +1490,12 @@\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1274,3 +1506,6 @@\n-instruct vasrL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (RShiftVL dst shift));\n+instruct reduce_andI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1278,1 +1513,1 @@\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andI reduction partial (sve) (may extend)\" %}\n@@ -1280,2 +1515,15 @@\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), variant,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1286,3 +1534,5 @@\n-instruct vlslB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (LShiftVB dst shift));\n+instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1290,1 +1540,1 @@\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction (sve)\" %}\n@@ -1292,2 +1542,3 @@\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1298,3 +1549,6 @@\n-instruct vlslS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (LShiftVS dst shift));\n+instruct reduce_andL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1302,1 +1556,1 @@\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction partial (sve)\" %}\n@@ -1304,2 +1558,6 @@\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1310,3 +1568,7 @@\n-instruct vlslI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (LShiftVI dst shift));\n+\/\/ vector or reduction\n+\n+instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1314,1 +1576,1 @@\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1316,2 +1578,12 @@\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1322,3 +1594,6 @@\n-instruct vlslL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (LShiftVL dst shift));\n+instruct reduce_orI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1326,1 +1601,1 @@\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orI reduction partial (sve) (may extend)\" %}\n@@ -1328,2 +1603,15 @@\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), variant,\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1334,3 +1622,5 @@\n-instruct vlsrB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (URShiftVB dst shift));\n+instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1338,1 +1628,1 @@\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction (sve)\" %}\n@@ -1340,2 +1630,3 @@\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1346,3 +1637,6 @@\n-instruct vlsrS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (URShiftVS dst shift));\n+instruct reduce_orL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1350,1 +1644,1 @@\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction partial (sve)\" %}\n@@ -1352,2 +1646,6 @@\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D,\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1358,3 +1656,7 @@\n-instruct vlsrI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (URShiftVI dst shift));\n+\/\/ vector xor reduction\n+\n+instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1362,1 +1664,1 @@\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# xorB\/H\/I reduction (sve) (may extend)\" %}\n@@ -1364,2 +1666,12 @@\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1370,3 +1682,6 @@\n-instruct vlsrL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (URShiftVL dst shift));\n+instruct reduce_eorI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1374,1 +1689,1 @@\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# xorI reduction partial (sve) (may extend)\" %}\n@@ -1376,2 +1691,15 @@\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1382,3 +1710,5 @@\n-instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n+instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1386,1 +1716,1 @@\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# xorL reduction (sve)\" %}\n@@ -1388,9 +1718,3 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 8) con = 7;\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1401,3 +1725,6 @@\n-instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n+instruct reduce_eorL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1405,1 +1732,1 @@\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# xorL reduction partial (sve)\" %}\n@@ -1407,9 +1734,6 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 16) con = 15;\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -1420,3 +1744,10 @@\n-instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n+\n+\/\/ vector max reduction\n+\n+instruct reduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1424,1 +1755,1 @@\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_reduce_maxI $dst, $src1, $src2\\t# reduce maxB\/S\/I (sve)\" %}\n@@ -1426,8 +1757,6 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_smaxv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n@@ -1438,3 +1767,8 @@\n-instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (RShiftVL src (RShiftCntV shift)));\n+instruct reduce_maxI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1442,1 +1776,1 @@\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_reduce_maxI $dst, $src1, $src2\\t# reduce maxI partial (sve)\" %}\n@@ -1444,8 +1778,9 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_smaxv(as_FloatRegister($vtmp$$reg), variant,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n@@ -1456,3 +1791,5 @@\n-instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n+instruct reduce_maxL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1460,1 +1797,1 @@\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  format %{ \"sve_reduce_maxL $dst, $src1, $src2\\t# reduce maxL partial (sve)\" %}\n@@ -1462,13 +1799,4 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n+    __ sve_smaxv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n@@ -1479,3 +1807,6 @@\n-instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n+instruct reduce_maxL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -1483,1 +1814,1 @@\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  format %{ \"sve_reduce_maxL $dst, $src1, $src2\\t# reduce maxL partial (sve)\" %}\n@@ -1485,13 +1816,1479 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_smaxv(as_FloatRegister($vtmp$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t# max reduction F\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxF_partial(vRegF dst, vRegF src1, vReg src2,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_maxF $dst, $src1, $src2\\t# reduce max S partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ S,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,\n+         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (D)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t# max reduction D\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxD_partial(vRegD dst, vRegD src1, vReg src2,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_maxD $dst, $src1, $src2\\t# reduce max D partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n+         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min reduction\n+\n+instruct reduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MinReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_minI $dst, $src1, $src2\\t# reduce minB\/S\/I (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_sminv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MinReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_minI $dst, $src1, $src2\\t# reduce minI partial (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_sminv(as_FloatRegister($vtmp$$reg), variant,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MinReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_minL $dst, $src1, $src2\\t# reduce minL partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_sminv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MinReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_minL $dst, $src1, $src2\\t# reduce minL partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_sminv(as_FloatRegister($vtmp$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t# min reduction F\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minF_partial(vRegF dst, vRegF src1, vReg src2,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_minF $dst, $src1, $src2\\t# reduce min S partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ S,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,\n+         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (D)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t# min reduction D\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minD_partial(vRegD dst, vRegD src1, vReg src2,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_minD $dst, $src1, $src2\\t# reduce min D partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n+         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector replicate\n+\n+instruct replicateB(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateB src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateS src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateI src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL(vReg dst, iRegL src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateB_imm8(vReg dst, immI8 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateB con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateS con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateI con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateL con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateF(vReg dst, vRegF src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateD(vReg dst, vRegD src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ReplicateD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift\n+\n+instruct vasrB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) con = 7;\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 16) con = 15;\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 16) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con >= 16) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sqrt\n+\n+instruct vsqrtF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SqrtVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SqrtVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sub\n+\n+instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SubVB src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SubVS src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SubVI src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SubVL src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SubVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (SubVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n+            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+\/\/ ------------------------------ Vector cast -------------------------------\n+\n+instruct vcvtBtoS(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\t# convert B to S vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtBtoI(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, S, $dst\\t# convert B to I vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtBtoL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\t# convert B to L vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtBtoF(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n+            \"sve_scvtf  $dst, S, $dst, S\\t# convert B to F vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtBtoD(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n+            \"sve_scvtf  $dst, D, $dst, D\\t# convert B to D vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoB(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, B, 0\\n\\t\"\n+            \"sve_uzp1  $dst, B, $src, tmp\\t# convert S to B vector\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ B, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoI(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastS2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, S, $src\\t# convert S to I vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastS2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\t# convert S to L vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoF(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastS2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n+            \"sve_scvtf  $dst, S, $dst, S\\t# convert S to F vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoD(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastS2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n+            \"sve_scvtf  $dst, D, $dst, D\\t# convert S to D vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoB(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $src, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert I to B vector\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $src, tmp\\t# convert I to S vector\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, D, $src\\t# convert I to L vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoF(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_scvtf  $dst, S, $src, S\\t# convert I to F vector\" %}\n+  ins_encode %{\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoD(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n+            \"sve_scvtf  $dst, D, $dst, D\\t# convert I to D vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoB(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert L to B vector\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoS(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert L to S vector\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoI(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $src, tmp\\t# convert L to I vector\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_scvtf  $dst, S, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert L to F vector\" %}\n+  ins_encode %{\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoD(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastL2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_scvtf  $dst, D, $src, D\\t# convert L to D vector\" %}\n+  ins_encode %{\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoB(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n+            \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert F to B vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoS(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n+            \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\t# convert F to S vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoI(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastF2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\t# convert F to I vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastF2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\t# convert F to L vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoD(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastF2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n+            \"sve_fcvt  $dst, D, $dst, S\\t# convert F to D vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoB(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert D to B vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoS(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert D to S vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoI(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, tmp\\t# convert D to I vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, D, $src, D\\t# convert D to L vector\" %}\n+  ins_encode %{\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_fcvt  $dst, S, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert D to F vector\" %}\n+  ins_encode %{\n+    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\/\/ ------------------------------ Vector extract ---------------------------------\n+\n+instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractB src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, B, $pTmp, $src, $idx\\n\\t\"\n+            \"sbfmw $dst, $dst, 0U, 7U\\t# extract from vector(B)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_Register($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 7U);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractS src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, H, $pTmp, $src, $idx\\n\\t\"\n+            \"sbfmw $dst, $dst, 0U, 15U\\t# extract from vector(S)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_Register($dst$$reg), __ H, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 15U);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractI src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, S, $pTmp, $src, $idx\\t# extract from vector(I)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_Register($dst$$reg), __ S, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractL src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, D, $pTmp, $src, $idx\\t# extract from vector(L)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_Register($dst$$reg), __ D, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractF src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, S, $pTmp, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractD src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, D, $pTmp, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n@@ -1502,3 +3299,8 @@\n-instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n+\/\/ ------------------------------- VectorTest ----------------------------------\n+\n+instruct vtest_alltrue(iRegINoSp dst, vReg src1, vReg src2, pReg pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP pTmp, KILL cr);\n@@ -1506,1 +3308,2 @@\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_cmpeq $pTmp, $src1, 0\\n\\t\"\n+            \"csetw $dst, EQ\\t# VectorTest (sve) - alltrue\" %}\n@@ -1508,8 +3311,6 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n+    \/\/ \"src2\" is not used for sve.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($src1$$reg), 0);\n+    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n@@ -1520,3 +3321,6 @@\n-instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (URShiftVL src (RShiftCntV shift)));\n+instruct vtest_anytrue(iRegINoSp dst, vReg src1, vReg src2, pReg pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP pTmp, KILL cr);\n@@ -1524,1 +3328,2 @@\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_cmpeq $pTmp, $src1, -1\\n\\t\"\n+            \"csetw $dst, NE\\t# VectorTest (sve) - anytrue\" %}\n@@ -1526,8 +3331,6 @@\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n+    \/\/ \"src2\" is not used for sve.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($src1$$reg), -1);\n+    __ csetw(as_Register($dst$$reg), Assembler::NE);\n@@ -1538,3 +3341,6 @@\n-instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n+instruct vtest_alltrue_partial(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP pTmp, KILL cr);\n@@ -1542,1 +3348,1 @@\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  format %{ \"vtest_alltrue_partial $dst, $src1, $src2\\t# VectorTest partial (sve) - alltrue\" %}\n@@ -1544,8 +3350,8 @@\n-    int con = (int)$shift$$constant;\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n+    \/\/ \"src2\" is not used for sve.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), size,\n+                          Matcher::vector_length(this, $src1));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),\n+                 as_FloatRegister($src1$$reg), 0);\n+    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n@@ -1556,3 +3362,6 @@\n-instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n+instruct vtest_anytrue_partial(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP pTmp, KILL cr);\n@@ -1560,1 +3369,1 @@\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  format %{ \"vtest_anytrue_partial $dst, $src1, $src2\\t# VectorTest partial (sve) - anytrue\" %}\n@@ -1562,8 +3371,8 @@\n-    int con = (int)$shift$$constant;\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n+    \/\/ \"src2\" is not used for sve.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), size,\n+                          Matcher::vector_length(this, $src1));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),\n+                 as_FloatRegister($src1$$reg), -1);\n+    __ csetw(as_Register($dst$$reg), Assembler::NE);\n@@ -1574,5 +3383,38 @@\n-instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+\/\/ ------------------------------ Vector insert ---------------------------------\n+\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, -16, 1\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n@@ -1580,3 +3422,5 @@\n-    int con = (int)$shift$$constant;\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n+    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n@@ -1587,5 +3431,38 @@\n-instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (LShiftVL src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_dup $dst, $idx\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (L)\" %}\n@@ -1593,3 +3470,5 @@\n-    int con = (int)$shift$$constant;\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n+    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n@@ -1600,6 +3479,11 @@\n-instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (B)\" %}\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (D)\" %}\n@@ -1607,1 +3491,5 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));\n+    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n@@ -1612,7 +3500,34 @@\n-instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (H)\" %}\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n+            \"sve_dup $dst, S, $idx\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg),\n+               as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffleB(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst, $src, $src\\t# vector load shuffle (B)\" %}\n@@ -1620,1 +3535,5 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+                 as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+    }\n@@ -1625,6 +3544,6 @@\n-instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (S)\" %}\n+instruct loadshuffleS(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uunpklo $dst, $src\\t# vector load shuffle (B to H)\" %}\n@@ -1632,1 +3551,1 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n@@ -1637,6 +3556,9 @@\n-instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (D)\" %}\n+instruct loadshuffleI(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\t# vector load shuffle (B to S)\" %}\n@@ -1644,1 +3566,2 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n@@ -1649,1 +3572,17 @@\n-\/\/ vector sqrt\n+instruct loadshuffleL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n+            \"sve_uunpklo $dst, D, $dst\\t# vector load shuffle (B to D)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -1651,3 +3590,6 @@\n-instruct vsqrtF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n-  match(Set dst (SqrtVF src));\n+\/\/ ------------------------------ Vector rearrange -------------------------------\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorRearrange src shuffle));\n@@ -1655,1 +3597,1 @@\n-  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (S)\" %}\n+  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n@@ -1657,2 +3599,4 @@\n-    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n+               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n@@ -1663,3 +3607,8 @@\n-instruct vsqrtD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n-  match(Set dst (SqrtVD src));\n+\/\/ ------------------------------ Vector Load Gather ---------------------------------\n+\n+instruct gatherI(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (LoadVectorGather mem idx));\n@@ -1667,1 +3616,1 @@\n-  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (D)\" %}\n+  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (I\/F)\" %}\n@@ -1669,2 +3618,2 @@\n-    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue,\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1675,1 +3624,16 @@\n-\/\/ vector sub\n+instruct gatherL(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (LoadVectorGather mem idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (L\/D)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue,\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -1677,5 +3641,12 @@\n-instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n+\/\/ ------------------------------ Vector Load Gather Partial-------------------------------\n+\n+instruct gatherI_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (I\/F)\" %}\n@@ -1683,3 +3654,4 @@\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ S,\n+                          Matcher::vector_length(this));\n+    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg),\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1690,5 +3662,11 @@\n-instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n+instruct gatherL_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (L\/D)\" %}\n@@ -1696,3 +3674,5 @@\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ D,\n+                          Matcher::vector_length(this));\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg),\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1703,3 +3683,8 @@\n-instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (SubVI src1 src2));\n+\/\/ ------------------------------ Vector Store Scatter -------------------------------\n+\n+instruct scatterI(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n@@ -1707,1 +3692,1 @@\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (I\/F)\" %}\n@@ -1709,3 +3694,2 @@\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n+    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue,\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1716,5 +3700,9 @@\n-instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (SubVL src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+instruct scatterL(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (L\/D)\" %}\n@@ -1722,3 +3710,3 @@\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue,\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1729,5 +3717,12 @@\n-instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+\/\/ ------------------------------ Vector Store Scatter Partial-------------------------------\n+\n+instruct scatterI_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (I\/F)\" %}\n@@ -1735,3 +3730,4 @@\n-    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ S,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg),\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1742,5 +3738,11 @@\n-instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n-  match(Set dst (SubVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+instruct scatterL_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (L\/D)\" %}\n@@ -1748,3 +3750,5 @@\n-    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg),\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n@@ -1755,1 +3759,0 @@\n-\/\/ vector mask cast\n@@ -1757,6 +3760,8 @@\n-instruct vmaskcast(vReg dst) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+\/\/ ------------------------------ Vector Load Const -------------------------------\n+\n+instruct loadconB(vReg dst, immI0 src) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadConst src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_index $dst, 0, 1\\t# generate iota indices\" %}\n@@ -1764,1 +3769,1 @@\n-    \/\/ empty\n+    __ sve_index(as_FloatRegister($dst$$reg), __ B, 0, 1);\n@@ -1766,1 +3771,1 @@\n-  ins_pipe(pipe_class_empty);\n+  ins_pipe(pipe_slow);\n@@ -1808,0 +3813,201 @@\n+\/\/ ---------------------------- Vector mask reductions ---------------------------\n+\n+instruct vmask_truecount(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n+  ins_encode %{\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n+                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n+  ins_encode %{\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n+                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n+  ins_encode %{\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n+                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount_partial(iRegINoSp dst, vReg src, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ B,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n+                           as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_partial(iRegINoSp dst, vReg src, pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP pgtmp, TEMP ptmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ B,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n+                           as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue_partial(iRegINoSp dst, vReg src, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ B,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n+                           as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ----------------- Vector mask reductions combined with VectorMaskStore ---------------\n+\n+instruct vstoremask_truecount(iRegINoSp dst, vReg src, immI esize, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask src esize)));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"vstoremask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           ptrue, as_PRegister($ptmp$$reg), Matcher::vector_length(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_firsttrue(iRegINoSp dst, vReg src, immI esize, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskFirstTrue (VectorStoreMask src esize)));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vstoremask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           ptrue, as_PRegister($ptmp$$reg), Matcher::vector_length(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_lasttrue(iRegINoSp dst, vReg src, immI esize, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskLastTrue (VectorStoreMask src esize)));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"vstoremask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           ptrue, as_PRegister($ptmp$$reg), Matcher::vector_length(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_truecount_partial(iRegINoSp dst, vReg src, immI esize, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask src esize)));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vstoremask_truecount $dst, $src\\t# vector mask truecount partial (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg), MaxVectorSize \/ size);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_firsttrue_partial(iRegINoSp dst, vReg src, immI esize, pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskFirstTrue (VectorStoreMask src esize)));\n+  effect(TEMP pgtmp, TEMP ptmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"vstoremask_firsttrue $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), variant,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), MaxVectorSize \/ size);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_lasttrue_partial(iRegINoSp dst, vReg src, immI esize, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskLastTrue (VectorStoreMask src esize)));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"vstoremask_lasttrue $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg), MaxVectorSize \/ size);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":2859,"deletions":653,"binary":false,"changes":3512,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-\n-\/\/ 4 bit signed offset -- for predicated load\/store\n@@ -35,2 +33,11 @@\n-dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2,       $3     )\n-dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type, imm_len)\n+define(`TYPE2DATATYPE',\n+`ifelse($1, `B', `BYTE',\n+        $1, `S', `SHORT',\n+        $1, `I', `INT',\n+        $1, `L', `LONG',\n+        $1, `F', `FLOAT',\n+        $1, `D', `DOUBLE',\n+        `error($1)')')dnl\n+dnl\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2,       $3       $4   )\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type, imm_len, scale)\n@@ -40,0 +47,1 @@\n+  \/\/ (esize \/ msize) = $4\n@@ -41,1 +49,1 @@\n-            Matcher::scalable_vector_reg_size(T_BYTE)));\n+            Matcher::scalable_vector_reg_size(T_BYTE)ifelse($4, `1', `', ` \/ $4')));\n@@ -48,2 +56,4 @@\n-OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int,  4)\n-OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long, 4)\n+\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int,  4, 1)\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long, 4, 1)\n@@ -54,1 +64,1 @@\n-operand vmemA_indOff$1$2(iRegP reg, vmemA_imm$1Offset$2 off)\n+operand vmemA_indOff$1$2$3(iRegP reg, vmemA_imm$1Offset$2 off)\n@@ -59,1 +69,1 @@\n-  format %{ \"[$reg, $off, MUL VL]\" %}\n+  format %{ \"[$reg, $off]\" %}\n@@ -70,0 +80,2 @@\n+\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n+\/\/ size equals to memory element (load from\/store to) size.\n@@ -73,1 +85,1 @@\n-  bool op_sve_supported(int opcode);\n+  bool op_sve_supported(int opcode, int vlen, BasicType bt);\n@@ -77,20 +89,0 @@\n-  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {\n-    switch(esize) {\n-      case 1:\n-        return Assembler::B;\n-      case 2:\n-        return Assembler::H;\n-      case 4:\n-        return Assembler::S;\n-      case 8:\n-        return Assembler::D;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-    return Assembler::INVALID;\n-  }\n-\n-  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {\n-    return elemBytes_to_regVariant(type2aelembytes(bt));\n-  }\n@@ -102,3 +94,3 @@\n-  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store,\n-                                   FloatRegister reg, PRegister pg, BasicType bt,\n-                                   int opcode, Register base, int index, int size, int disp) {\n+  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n+                                    int opcode, Register base, int index, int size, int disp) {\n@@ -106,2 +98,1 @@\n-    Assembler::SIMD_RegVariant type;\n-    int esize = type2aelembytes(bt);\n+    int mesize = type2aelembytes(mem_elem_bt);\n@@ -110,1 +101,1 @@\n-      switch(esize) {\n+      switch(mesize) {\n@@ -113,1 +104,0 @@\n-        type = Assembler::B;\n@@ -117,1 +107,0 @@\n-        type = Assembler::H;\n@@ -121,1 +110,0 @@\n-        type = Assembler::S;\n@@ -125,1 +113,0 @@\n-        type = Assembler::D;\n@@ -131,1 +118,2 @@\n-      (masm.*insn)(reg, type, pg, Address(base, disp \/ Matcher::scalable_vector_reg_size(T_BYTE)));\n+      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n@@ -138,1 +126,2 @@\n-  bool op_sve_supported(int opcode) {\n+  bool op_sve_supported(int opcode, int vlen, BasicType bt) {\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n@@ -141,1 +130,1 @@\n-        \/\/ No multiply reduction instructions\n+      \/\/ No multiply reduction instructions\n@@ -146,3 +135,1 @@\n-        \/\/ Others\n-      case Op_Extract:\n-      case Op_ExtractB:\n+      \/\/ Others\n@@ -150,5 +137,0 @@\n-      case Op_ExtractD:\n-      case Op_ExtractF:\n-      case Op_ExtractI:\n-      case Op_ExtractL:\n-      case Op_ExtractS:\n@@ -156,0 +138,1 @@\n+        return false;\n@@ -157,18 +140,0 @@\n-      case Op_AndReductionV:\n-      case Op_OrReductionV:\n-      case Op_XorReductionV:\n-      case Op_MaxReductionV:\n-      case Op_MinReductionV:\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_VectorBlend:\n-      case Op_VectorCast:\n-      case Op_VectorCastB2X:\n-      case Op_VectorCastD2X:\n-      case Op_VectorCastF2X:\n-      case Op_VectorCastI2X:\n-      case Op_VectorCastL2X:\n-      case Op_VectorCastS2X:\n-      case Op_VectorInsert:\n-      case Op_VectorLoadConst:\n-      case Op_VectorLoadMask:\n@@ -176,1 +141,0 @@\n-      case Op_VectorMaskCmp:\n@@ -178,7 +142,8 @@\n-      case Op_VectorReinterpret:\n-      case Op_VectorStoreMask:\n-      case Op_VectorTest:\n-      case Op_VectorMaskTrueCount:\n-      case Op_VectorMaskLastTrue:\n-      case Op_VectorMaskFirstTrue:\n-        return false;\n+        if (vlen < 4 || length_in_bytes > MaxVectorSize) {\n+          return false;\n+        } else {\n+          return true;\n+        }\n+      case Op_LoadVector:\n+      case Op_StoreVector:\n+        return Matcher::vector_size_supported(bt, vlen);\n@@ -186,1 +151,1 @@\n-        return true;\n+        break;\n@@ -188,0 +153,2 @@\n+    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n+    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n@@ -208,1 +175,1 @@\n-\/\/ Use predicated vector load\/store\n+\/\/ Unpredicated vector load\/store\n@@ -210,1 +177,2 @@\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16);\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16 &&\n+            n->as_LoadVector()->memory_size() == MaxVectorSize);\n@@ -212,2 +180,2 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n@@ -216,3 +184,4 @@\n-    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n-                         Matcher::vector_element_basic_type(this), $mem->opcode(),\n-                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                          bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -224,1 +193,2 @@\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16);\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16 &&\n+            n->as_StoreVector()->memory_size() == MaxVectorSize);\n@@ -226,2 +196,66 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n+                          bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}dnl\n+\n+dnl\n+define(`VLoadStore', `\n+\/\/ ifelse(load, $3, Load, Store) Vector ($6 bits)\n+instruct $3V$4_vreg`'(vReg $7, vmem$4 mem)\n+%{\n+  predicate(UseSVE > 0 && `n->as_'ifelse(load, $3, Load, Store)Vector()->memory_size() == $4);\n+  match(Set ifelse(load, $3, dst (LoadVector mem), mem (StoreVector mem src)));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"$1   ifelse(load, $3, `$dst,$mem', `$mem,$src')\\t# vector ($6 bits)\" %}\n+  ins_encode( `aarch64_enc_'ifelse(load, $3, ldr, str)v$2($7, mem) );\n+  ins_pipe(v$3`_reg_mem'ifelse(eval($4 * 8), 128, 128, 64));\n+%}')dnl\n+dnl        $1    $2 $3     $4  $5 $6   $7\n+VLoadStore(ldrh, H, load,  2,  D, 16,  dst)\n+VLoadStore(strh, H, store, 2,  D, 16,  src)\n+VLoadStore(ldrs, S, load,  4,  D, 32,  dst)\n+VLoadStore(strs, S, store, 4,  D, 32,  src)\n+VLoadStore(ldrd, D, load,  8,  D, 64,  dst)\n+VLoadStore(strd, D, store, 8,  D, 64,  src)\n+VLoadStore(ldrq, Q, load, 16,  X, 128, dst)\n+VLoadStore(strq, Q, store, 16, X, 128, src)\n+\n+\/\/ Predicated vector load\/store, based on the vector length of the node.\n+\/\/ Only load\/store values in the range of the memory_size. This is needed\n+\/\/ when the memory_size is lower than the hardware supported max vector size.\n+\/\/ And this might happen for Vector API mask vector load\/store.\n+instruct loadV_partial(vReg dst, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16 &&\n+            n->as_LoadVector()->memory_size() < MaxVectorSize);\n+  match(Set dst (LoadVector mem));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(6 * SVE_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_ldr $dst, $pTmp, $mem\\t# load vector predicated\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+                          Matcher::vector_length(this));\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg,\n+                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_partial(vReg src, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16 &&\n+            n->as_StoreVector()->memory_size() < MaxVectorSize);\n+  match(Set mem (StoreVector mem src));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_str $src, $pTmp, $mem\\t# store vector predicated\" %}\n@@ -229,0 +263,3 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+                          Matcher::vector_length(this, $src));\n@@ -230,3 +267,3 @@\n-    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n-                         Matcher::vector_element_basic_type(this, $src), $mem->opcode(),\n-                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg,\n+                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -235,0 +272,15 @@\n+%}dnl\n+\n+\n+\/\/ vector reinterpret\n+\n+instruct reinterpret(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==\n+                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n@@ -237,0 +289,21 @@\n+instruct reinterpretResize(vReg dst, vReg src, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=\n+                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"reinterpretResize $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ B, length_in_bytes_resize);\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -242,1 +315,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5 &&\n+  predicate(UseSVE > 0 &&\n@@ -254,0 +327,1 @@\n+\n@@ -266,1 +340,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  predicate(UseSVE > 0);\n@@ -290,1 +364,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $3);\n+  predicate(UseSVE > 0);\n@@ -321,1 +395,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -346,1 +420,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -366,1 +440,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseSVE > 0);\n@@ -384,1 +458,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -390,1 +464,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -404,1 +478,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -410,1 +484,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -429,1 +503,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -451,1 +525,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -474,1 +548,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -496,1 +570,1 @@\n-  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseFMA && UseSVE > 0);\n@@ -518,1 +592,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseSVE > 0);\n@@ -542,1 +616,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  predicate(UseSVE > 0);\n@@ -564,1 +638,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  predicate(UseSVE > 0);\n@@ -588,1 +662,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $4);\n+  predicate(UseSVE > 0);\n@@ -606,1 +680,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  predicate(UseSVE > 0);\n@@ -608,1 +682,1 @@\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\"  %}\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n@@ -613,1 +687,1 @@\n-%}dnl\n+%}\n@@ -615,14 +689,9 @@\n-dnl\n-dnl REDUCE_ADD_EXT($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_ADD_EXT(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_ADD_EXT', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"smov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\n\\t\"\n-            \"$7  $dst, $dst\\t # add reduction $5\" %}\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp(vReg dst, vReg src1, vReg src2, immI cond, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmp $pTmp, $src1, $src2\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, -1\\t# vector mask cmp (sve)\" %}\n@@ -630,5 +699,5 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ $7($dst$$Register, $dst$$Register);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pTmp$$reg), -1, false);\n@@ -637,10 +706,49 @@\n-%}')dnl\n-dnl\n-dnl REDUCE_ADD($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_ADD(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_ADD', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+%}\n+\n+\/\/ vector blend\n+\n+instruct vblend(vReg dst, vReg src1, vReg src2, vReg src3, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) src3));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmpeq $pTmp, $src3, -1\\n\\t\"\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size =\n+      __ elemType_to_regVariant(Matcher::vector_element_basic_type(this));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($src3$$reg), -1);\n+    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg),\n+               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector blend with compare\n+\n+instruct vblend_maskcmp(vReg dst, vReg src1, vReg src2, vReg src3,\n+                        vReg src4, pRegGov pTmp, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) (VectorMaskCmp (Binary src3 src4) cond)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cmp $pTmp, $src3, $src4\\t# vector cmp (sve)\\n\\t\"\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src3$$reg),\n+                   as_FloatRegister($src4$$reg), (int)$cond$$constant);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+               as_PRegister($pTmp$$reg), as_FloatRegister($src2$$reg),\n+               as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load mask\n+\n+instruct vloadmaskB(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n@@ -648,3 +756,1 @@\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"$7  $dst, $dst, $src1\\t # add reduction $5\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector load mask (B)\" %}\n@@ -652,4 +758,1 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue, as_FloatRegister($src$$reg));\n@@ -658,8 +761,57 @@\n-%}')dnl\n-dnl\n-dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF', `\n-instruct $1($3 src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set src1_dst ($2 src1_dst src2));\n+%}\n+\n+instruct vloadmaskS(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorLoadMask src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to H)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ H, ptrue, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (VectorLoadMask src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to S)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (VectorLoadMask src));\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n+            \"sve_uunpklo $dst, D, $dst\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to D)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask\n+\n+instruct vstoremaskB(vReg dst, vReg src, immI_1 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n@@ -667,1 +819,1 @@\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector store mask (B)\" %}\n@@ -669,2 +821,2 @@\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($src$$reg));\n@@ -673,1 +825,1 @@\n-%}')dnl\n+%}\n@@ -675,7 +827,39 @@\n-\/\/ vector add reduction\n-REDUCE_ADD_EXT(reduce_addB, AddReductionVI, iRegINoSp, iRegIorL2I, B, T_BYTE,  sxtb)\n-REDUCE_ADD_EXT(reduce_addS, AddReductionVI, iRegINoSp, iRegIorL2I, H, T_SHORT, sxth)\n-REDUCE_ADD(reduce_addI, AddReductionVI, iRegINoSp, iRegIorL2I, S, T_INT, addw)\n-REDUCE_ADD(reduce_addL, AddReductionVL, iRegLNoSp, iRegL, D, T_LONG, add)\n-REDUCE_ADDF(reduce_addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF(reduce_addD, AddReductionVD, vRegD, D)\n+instruct vstoremaskS(vReg dst, vReg src, vReg tmp, immI_2 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_dup $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1 $dst, B, $src, $tmp\\n\\t\"\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (H to B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n+                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($dst$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremaskI(vReg dst, vReg src, vReg tmp, immI_4 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_dup $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1 $dst, H, $src, $tmp\\n\\t\"\n+            \"sve_uzp1 $dst, B, $dst, $tmp\\n\\t\"\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (S to B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n+                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n+                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -683,0 +867,23 @@\n+instruct vstoremaskL(vReg dst, vReg src, vReg tmp, immI_8 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_dup $tmp, D, 0\\n\\t\"\n+            \"sve_uzp1 $dst, S, $src, $tmp\\n\\t\"\n+            \"sve_uzp1 $dst, H, $dst, $tmp\\n\\t\"\n+            \"sve_uzp1 $dst, B, $dst, $tmp\\n\\t\"\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (D to B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ D, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S,\n+                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n+                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n+                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,\n+               as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -684,11 +891,11 @@\n-dnl REDUCE_FMINMAX($1,      $2,          $3,           $4,   $5         )\n-dnl REDUCE_FMINMAX(min_max, name_suffix, element_type, size, reg_src_dst)\n-define(`REDUCE_FMINMAX', `\n-instruct reduce_$1$2($5 dst, $5 src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n-  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_f$1v $dst, $src2 # vector (sve) (S)\\n\\t\"\n-            \"f$1s $dst, $dst, $src1\\t # $1 reduction $2\" %}\n+dnl\n+dnl VLOADMASK_LOADV($1,    $2  )\n+dnl VLOADMASK_LOADV(esize, cond)\n+define(`VLOADMASK_LOADV', `\n+instruct vloadmask_loadV_$1(vReg dst, ifelse($1, `byte', vmemA, indirect) mem) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() == MaxVectorSize &&\n+            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) $2);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_ld1b $dst, $mem\\n\\t\"\n+            \"sve_neg $dst, $dst\\t# load vector mask (sve)\" %}\n@@ -696,3 +903,7 @@\n-    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_vect_variant = __ elemType_to_regVariant(to_vect_bt);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                          T_BOOLEAN, to_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_neg(dst_reg, to_vect_variant, ptrue, dst_reg);\n@@ -702,3 +913,34 @@\n-\/\/ vector max reduction\n-REDUCE_FMINMAX(max, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n+dnl\n+define(`ARGLIST',\n+`ifelse($1, `byte', vmemA, indirect) mem, vReg src, vReg tmp, ifelse($1, `byte', immI_1, immI_gt_1) esize')\n+dnl\n+dnl STOREV_VSTOREMASK($1,  )\n+dnl STOREV_VSTOREMASK(esize)\n+define(`STOREV_VSTOREMASK', `\n+instruct storeV_vstoremask_$1(ARGLIST($1)) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() *\n+                          n->as_StoreVector()->in(MemNode::ValueIn)->in(2)->get_int() == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_neg $tmp, $src\\n\\t\"\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve)\" %}\n+  ins_encode %{\n+    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant from_vect_variant = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_neg(as_FloatRegister($tmp$$reg), from_vect_variant, ptrue,\n+               as_FloatRegister($src$$reg));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),\n+                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+undefine(ARGLIST)dnl\n+dnl\n+\/\/ load\/store mask vector\n+VLOADMASK_LOADV(byte, == 1)\n+VLOADMASK_LOADV(non_byte, > 1)\n+STOREV_VSTOREMASK(byte)\n+STOREV_VSTOREMASK(non_byte)\n@@ -706,3 +948,1 @@\n-\/\/ vector min reduction\n-REDUCE_FMINMAX(min, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n+\/\/ vector add reduction\n@@ -710,1 +950,22 @@\n-\/\/ vector Math.rint, floor, ceil\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addB\/S\/I reduction (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -712,5 +973,7 @@\n-instruct vroundD(vReg dst, vReg src, immI rmode) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n@@ -718,13 +981,14 @@\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -735,7 +999,5 @@\n-dnl\n-dnl REPLICATE($1,        $2,      $3,      $4,   $5         )\n-dnl REPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n-define(`REPLICATE', `\n-instruct $1(vReg dst, $3 src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n-  match(Set dst ($2 src));\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -743,1 +1005,1 @@\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction (sve)\" %}\n@@ -745,1 +1007,3 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, as_Register($src$$reg));\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -748,8 +1012,7 @@\n-%}')dnl\n-dnl\n-dnl REPLICATE_IMM8($1,        $2,      $3,       $4,   $5         )\n-dnl REPLICATE_IMM8(insn_name, op_name, imm_type, size, min_vec_len)\n-define(`REPLICATE_IMM8', `\n-instruct $1(vReg dst, $3 con) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n-  match(Set dst ($2 con));\n+%}\n+\n+instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n@@ -757,1 +1020,1 @@\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n@@ -759,1 +1022,6 @@\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, $con$$constant);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n@@ -762,1 +1030,2 @@\n-%}')dnl\n+%}\n+\n@@ -764,6 +1033,6 @@\n-dnl FREPLICATE($1,        $2,      $3,      $4,   $5         )\n-dnl FREPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n-define(`FREPLICATE', `\n-instruct $1(vReg dst, $3 src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n-  match(Set dst ($2 src));\n+dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n+dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n+define(`REDUCE_ADDF', `\n+instruct $1($3 src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set src1_dst (AddReductionV$2 src1_dst src2));\n@@ -771,1 +1040,1 @@\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n@@ -773,2 +1042,2 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n@@ -778,12 +1047,0 @@\n-\n-\/\/ vector replicate\n-REPLICATE(replicateB, ReplicateB, iRegIorL2I, B, 16)\n-REPLICATE(replicateS, ReplicateS, iRegIorL2I, H, 8)\n-REPLICATE(replicateI, ReplicateI, iRegIorL2I, S, 4)\n-REPLICATE(replicateL, ReplicateL, iRegL,      D, 2)\n-REPLICATE_IMM8(replicateB_imm8, ReplicateB, immI8,        B, 16)\n-REPLICATE_IMM8(replicateS_imm8, ReplicateS, immI8_shift8, H, 8)\n-REPLICATE_IMM8(replicateI_imm8, ReplicateI, immI8_shift8, S, 4)\n-REPLICATE_IMM8(replicateL_imm8, ReplicateL, immL8_shift8, D, 2)\n-FREPLICATE(replicateF, ReplicateF, vRegF, S, 4)\n-FREPLICATE(replicateD, ReplicateD, vRegD, D, 2)\n@@ -791,6 +1048,7 @@\n-dnl VSHIFT_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl VSHIFT_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`VSHIFT_TRUE_PREDICATE', `\n-instruct $1(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n-  match(Set dst ($2 dst shift));\n+dnl\n+dnl REDUCE_ADDF_PARTIAL($1,        $2,     $3,      $4  )\n+dnl REDUCE_ADDF_PARTIAL(insn_name, suffix, reg_dst, size)\n+define(`REDUCE_ADDF_PARTIAL', `\n+instruct $1($3 src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set src1_dst (AddReductionV$2 src1_dst src2));\n@@ -798,1 +1056,2 @@\n-  format %{ \"$5 $dst, $dst, $shift\\t# vector (sve) ($3)\" %}\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_add$2 $src1_dst, $src1_dst, $src2\\t# add$2 reduction partial (sve) ($4)\" %}\n@@ -800,2 +1059,4 @@\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n-         ptrue, as_FloatRegister($shift$$reg));\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ $4,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -806,6 +1067,12 @@\n-dnl VSHIFT_IMM_UNPREDICATED($1,        $2,      $3,       $4,   $5,          $6  )\n-dnl VSHIFT_IMM_UNPREDICATED(insn_name, op_name, op_name2, size, min_vec_len, insn)\n-define(`VSHIFT_IMM_UNPREDICATED', `\n-instruct $1(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n-  match(Set dst ($2 src ($3 shift)));\n+REDUCE_ADDF(reduce_addF, F, vRegF, S)\n+REDUCE_ADDF_PARTIAL(reduce_addF_partial, F, vRegF, S)\n+REDUCE_ADDF(reduce_addD, D, vRegD, D)\n+REDUCE_ADDF_PARTIAL(reduce_addD_partial, D, vRegD, D)\n+\n+\/\/ vector and reduction\n+\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -813,1 +1080,1 @@\n-  format %{ \"$6 $dst, $src, $shift\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andB\/S\/I reduction (sve) (may extend)\" %}\n@@ -815,1 +1082,514 @@\n-    int con = (int)$shift$$constant;dnl\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), variant,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or reduction\n+\n+instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orB\/S\/I reduction (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), variant,\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D,\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor reduction\n+\n+instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# xorB\/H\/I reduction (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_eorI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# xorI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# xorL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_eorL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# xorL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D,\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl REDUCE_MAXMIN_I($1,      $2,      $3 )\n+dnl REDUCE_MAXMIN_I(min_max, op_mame, cmp)\n+define(`REDUCE_MAXMIN_I', `\n+instruct reduce_$1I(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# reduce $1B\/S\/I (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_s$1v(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L($1,      $2,      $3 )\n+dnl REDUCE_MAXMIN_L(min_max, op_name, cmp)\n+define(`REDUCE_MAXMIN_L', `\n+instruct reduce_$1L(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# reduce $1L partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_s$1v(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_I_PARTIAL($1,      $2,      $3 )\n+dnl REDUCE_MAXMIN_I_PARTIAL(min_max, op_mame, cmp)\n+define(`REDUCE_MAXMIN_I_PARTIAL', `\n+instruct reduce_$1I_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# reduce $1I partial (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_s$1v(as_FloatRegister($vtmp$$reg), variant,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L_PARTIAL($1,      $2,      $3 )\n+dnl REDUCE_MAXMIN_L_PARTIAL(min_max, op_name, cmp)\n+define(`REDUCE_MAXMIN_L_PARTIAL', `\n+instruct reduce_$1L_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# reduce $1L partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_s$1v(as_FloatRegister($vtmp$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_FMINMAX($1,      $2,          $3,           $4,   $5         )\n+dnl REDUCE_FMINMAX(min_max, name_suffix, element_type, size, reg_src_dst)\n+define(`REDUCE_FMINMAX', `\n+instruct reduce_$1$2($5 dst, $5 src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_f$1v $dst, $src2 # vector (sve) ($4)\\n\\t\"\n+            \"f$1s $dst, $dst, $src1\\t# $1 reduction $2\" %}\n+  ins_encode %{\n+    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+dnl REDUCE_FMINMAX_PARTIAL($1,      $2,          $3,           $4,   $5         )\n+dnl REDUCE_FMINMAX_PARTIAL(min_max, name_suffix, element_type, size, reg_src_dst)\n+define(`REDUCE_FMINMAX_PARTIAL', `\n+instruct reduce_$1$2_partial($5 dst, $5 src1, vReg src2,\n+                             pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_$1$2 $dst, $src1, $src2\\t# reduce $1 $4 partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ $4,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4,\n+         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector max reduction\n+REDUCE_MAXMIN_I(max, MaxReductionV, GT)\n+REDUCE_MAXMIN_I_PARTIAL(max, MaxReductionV, GT)\n+REDUCE_MAXMIN_L(max, MaxReductionV, GT)\n+REDUCE_MAXMIN_L_PARTIAL(max, MaxReductionV, GT)\n+REDUCE_FMINMAX(max, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX_PARTIAL(max, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n+REDUCE_FMINMAX_PARTIAL(max, D, T_DOUBLE, D, vRegD)\n+\n+\/\/ vector min reduction\n+REDUCE_MAXMIN_I(min, MinReductionV, LT)\n+REDUCE_MAXMIN_I_PARTIAL(min, MinReductionV, LT)\n+REDUCE_MAXMIN_L(min, MinReductionV, LT)\n+REDUCE_MAXMIN_L_PARTIAL(min, MinReductionV, LT)\n+REDUCE_FMINMAX(min, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX_PARTIAL(min, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n+REDUCE_FMINMAX_PARTIAL(min, D, T_DOUBLE, D, vRegD)\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl REPLICATE($1,        $2,      $3,      $4,   $5         )\n+dnl REPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n+define(`REPLICATE', `\n+instruct $1(vReg dst, $3 src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_IMM8($1,        $2,      $3,       $4,   $5         )\n+dnl REPLICATE_IMM8(insn_name, op_name, imm_type, size, min_vec_len)\n+define(`REPLICATE_IMM8', `\n+instruct $1(vReg dst, $3 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst ($2 con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl FREPLICATE($1,        $2,      $3,        $4)\n+dnl FREPLICATE(insn_name, op_name, reg_src, size)\n+define(`FREPLICATE', `\n+instruct $1(vReg dst, $3 src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector replicate\n+REPLICATE(replicateB, ReplicateB, iRegIorL2I, B, 16)\n+REPLICATE(replicateS, ReplicateS, iRegIorL2I, H, 8)\n+REPLICATE(replicateI, ReplicateI, iRegIorL2I, S, 4)\n+REPLICATE(replicateL, ReplicateL, iRegL,      D, 2)\n+REPLICATE_IMM8(replicateB_imm8, ReplicateB, immI8,        B, 16)\n+REPLICATE_IMM8(replicateS_imm8, ReplicateS, immI8_shift8, H, 8)\n+REPLICATE_IMM8(replicateI_imm8, ReplicateI, immI8_shift8, S, 4)\n+REPLICATE_IMM8(replicateL_imm8, ReplicateL, immL8_shift8, D, 2)\n+FREPLICATE(replicateF, ReplicateF, vRegF, S, 4)\n+FREPLICATE(replicateD, ReplicateD, vRegD, D, 2)\n+dnl\n+dnl VSHIFT_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl VSHIFT_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`VSHIFT_TRUE_PREDICATE', `\n+instruct $1(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst ($2 dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $dst, $shift\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_IMM_UNPREDICATED($1,        $2,      $3,       $4,   $5,          $6  )\n+dnl VSHIFT_IMM_UNPREDICATED(insn_name, op_name, op_name2, size, min_vec_len, insn)\n+define(`VSHIFT_IMM_UNPREDICATED', `\n+instruct $1(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst ($2 src ($3 shift)));\n+  ins_cost(SVE_COST);\n+  format %{ \"$6 $dst, $src, $shift\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;dnl\n@@ -846,1 +1626,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3 &&\n+  predicate(UseSVE > 0 &&\n@@ -913,2 +1693,1 @@\n-\/\/ Intrisics for String.indexOf(char)\n-\n+\/\/ ------------------------------ Vector cast -------------------------------\n@@ -916,4 +1695,3 @@\n-define(`STRING_INDEXOF_CHAR', `\n-instruct string$1_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+dnl\n+define(`VECTOR_CAST_EXTEND1', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n@@ -921,3 +1699,803 @@\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::$1));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_EXTEND2', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n+            \"sve_$3  $dst, $5, $dst\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_EXTEND3', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n+            \"sve_$3  $dst, $5, $dst\\n\\t\"\n+            \"sve_$3  $dst, $6, $dst\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_NARROW1', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_$3  $tmp, $4, 0\\n\\t\"\n+            \"sve_$5  $dst, $4, $src, tmp\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($tmp$$reg), __ $4, 0);\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_NARROW2', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_$3  $tmp, $4, 0\\n\\t\"\n+            \"sve_$5  $dst, $4, $src, tmp\\n\\t\"\n+            \"sve_$5  $dst, $6, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($tmp$$reg), __ $4, 0);\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_NARROW3', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_$3  $tmp, $4, 0\\n\\t\"\n+            \"sve_$5  $dst, $4, $src, tmp\\n\\t\"\n+            \"sve_$5  $dst, $6, $dst, tmp\\n\\t\"\n+            \"sve_$5  $dst, $7, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($tmp$$reg), __ $4, 0);\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $7, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_I2F_EXTEND2', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n+            \"sve_$3  $dst, $5, $dst\\n\\t\"\n+            \"sve_$6  $dst, $5, $dst, $5\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n+    __ sve_$6(as_FloatRegister($dst$$reg), __ $5, ptrue, as_FloatRegister($dst$$reg), __ $5);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_I2F_EXTEND3', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n+            \"sve_$3  $dst, $5, $dst\\n\\t\"\n+            \"sve_$3  $dst, $6, $dst\\n\\t\"\n+            \"sve_$7  $dst, $6, $dst, $6\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg));\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, ptrue, as_FloatRegister($dst$$reg), __ $6);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_X2F_NARROW1', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src, $5\\n\\t\"\n+            \"sve_$6  $tmp, $7, 0\\n\\t\"\n+            \"sve_$8  $dst, $7, $dst, $tmp\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $5);\n+    __ sve_$6(as_FloatRegister($tmp$$reg), __ $7, 0);\n+    __ sve_$8(as_FloatRegister($dst$$reg), __ $7, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_X2X', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src, $4\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_X2F_EXTEND1', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n+            \"sve_$5  $dst, $4, $dst, $6\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($dst$$reg), __ $6);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_F2X_NARROW1', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n+            \"sve_$5  $tmp, $6, 0\\n\\t\"\n+            \"sve_$7  $dst, $6, $dst, tmp\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n+    __ sve_$5(as_FloatRegister($tmp$$reg), __ $6, 0);\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_F2X_NARROW2', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n+            \"sve_$5  $tmp, $6, 0\\n\\t\"\n+            \"sve_$7  $dst, $6, $dst, tmp\\n\\t\"\n+            \"sve_$7  $dst, $8, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n+    __ sve_$5(as_FloatRegister($tmp$$reg), __ $6, 0);\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $8, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_F2X_EXTEND1', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n+            \"sve_$5  $dst, $6, $dst\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n+    __ sve_$5(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`VECTOR_CAST_F2X_NARROW3', `\n+instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (VectorCast$1`'2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n+            \"sve_$5  $tmp, $6, 0\\n\\t\"\n+            \"sve_$7  $dst, $6, $dst, tmp\\n\\t\"\n+            \"sve_$7  $dst, $8, $dst, tmp\\n\\t\"\n+            \"sve_$7  $dst, $9, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+  ins_encode %{\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n+    __ sve_$5(as_FloatRegister($tmp$$reg), __ $6, 0);\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $8, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_$7(as_FloatRegister($dst$$reg), __ $9, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VECTOR_CAST_EXTEND1(B, S, sunpklo, H)\n+VECTOR_CAST_EXTEND2(B, I, sunpklo, H, S)\n+VECTOR_CAST_EXTEND3(B, L, sunpklo, H, S, D)\n+VECTOR_CAST_I2F_EXTEND2(B, F, sunpklo, H, S, scvtf)\n+VECTOR_CAST_I2F_EXTEND3(B, D, sunpklo, H, S, D, scvtf)\n+dnl\n+VECTOR_CAST_NARROW1(S, B, dup, B, uzp1)\n+VECTOR_CAST_EXTEND1(S, I, sunpklo, S)\n+VECTOR_CAST_EXTEND2(S, L, sunpklo, S, D)\n+VECTOR_CAST_X2F_EXTEND1(S, F, sunpklo, S, scvtf, S)\n+VECTOR_CAST_I2F_EXTEND2(S, D, sunpklo, S, D, scvtf)\n+dnl\n+VECTOR_CAST_NARROW2(I, B, dup, H, uzp1, B)\n+VECTOR_CAST_NARROW1(I, S, dup, H, uzp1)\n+VECTOR_CAST_EXTEND1(I, L, sunpklo, D)\n+VECTOR_CAST_X2X(I, F, scvtf, S)\n+VECTOR_CAST_X2F_EXTEND1(I, D, sunpklo, D, scvtf, D)\n+dnl\n+VECTOR_CAST_NARROW3(L, B, dup, S, uzp1, H, B)\n+VECTOR_CAST_NARROW2(L, S, dup, S, uzp1, H)\n+VECTOR_CAST_NARROW1(L, I, dup, S, uzp1)\n+VECTOR_CAST_X2F_NARROW1(L, F, scvtf, S, D, dup, S, uzp1)\n+VECTOR_CAST_X2X(L, D, scvtf, D)\n+dnl\n+VECTOR_CAST_F2X_NARROW2(F, B, fcvtzs, S, dup, H, uzp1, B)\n+VECTOR_CAST_F2X_NARROW1(F, S, fcvtzs, S, dup, H, uzp1)\n+VECTOR_CAST_X2X(F, I, fcvtzs, S)\n+VECTOR_CAST_F2X_EXTEND1(F, L, fcvtzs, S, sunpklo, D)\n+VECTOR_CAST_X2F_EXTEND1(F, D, sunpklo, D, fcvt, S)\n+dnl\n+VECTOR_CAST_F2X_NARROW3(D, B, fcvtzs, D, dup, S, uzp1, H, B)\n+VECTOR_CAST_F2X_NARROW2(D, S, fcvtzs, D, dup, S, uzp1, H)\n+VECTOR_CAST_F2X_NARROW1(D, I, fcvtzs, D, dup, S, uzp1)\n+VECTOR_CAST_X2X(D, L, fcvtzs, D)\n+VECTOR_CAST_X2F_NARROW1(D, F, fcvt, S, D, dup, S, uzp1)\n+dnl\n+dnl\n+\/\/ ------------------------------ Vector extract ---------------------------------\n+define(`VECTOR_EXTRACT_SXT', `\n+instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (Extract$1 src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, $3, $pTmp, $src, $idx\\n\\t\"\n+            \"sbfmw $dst, $dst, 0U, $5\\t# extract from vector($1)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sbfmw(as_$4($dst$$reg), as_$4($dst$$reg), 0U, $5);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl                $1 $2         $3 $4        $5\n+VECTOR_EXTRACT_SXT(B, iRegINoSp, B, Register, 7U)\n+VECTOR_EXTRACT_SXT(S, iRegINoSp, H, Register, 15U)\n+\n+dnl\n+define(`VECTOR_EXTRACT', `\n+instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (Extract$1 src idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract $dst, $3, $pTmp, $src, $idx\\t# extract from vector($1)\" %}\n+  ins_encode %{\n+    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pTmp$$reg),\n+                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl            $1 $2         $3 $4\n+VECTOR_EXTRACT(I, iRegINoSp, S, Register)\n+VECTOR_EXTRACT(L, iRegLNoSp, D, Register)\n+VECTOR_EXTRACT(F, vRegF,     S, FloatRegister)\n+VECTOR_EXTRACT(D, vRegD,     D, FloatRegister)\n+\n+\/\/ ------------------------------- VectorTest ----------------------------------\n+dnl\n+dnl VTEST($1,      $2,   $3,  $4  )\n+dnl VTEST(op_name, pred, imm, cond)\n+define(`VTEST', `\n+instruct vtest_$1`'(iRegINoSp dst, vReg src1, vReg src2, pReg pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::$2);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cmpeq $pTmp, $src1, $3\\n\\t\"\n+            \"csetw $dst, $4\\t# VectorTest (sve) - $1\" %}\n+  ins_encode %{\n+    \/\/ \"src2\" is not used for sve.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($src1$$reg), $3);\n+    __ csetw(as_Register($dst$$reg), Assembler::$4);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VTEST(alltrue, overflow, 0, EQ)\n+VTEST(anytrue, ne,      -1, NE)\n+dnl\n+dnl\n+dnl VTEST_PARTIAL($1,      $2,   $3,  $4  )\n+dnl VTEST_PARTIAL(op_name, pred, imm, cond)\n+define(`VTEST_PARTIAL', `\n+instruct vtest_$1_partial`'(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::$2);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"vtest_$1_partial $dst, $src1, $src2\\t# VectorTest partial (sve) - $1\" %}\n+  ins_encode %{\n+    \/\/ \"src2\" is not used for sve.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), size,\n+                          Matcher::vector_length(this, $src1));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),\n+                 as_FloatRegister($src1$$reg), $3);\n+    __ csetw(as_Register($dst$$reg), Assembler::$4);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VTEST_PARTIAL(alltrue, overflow, 0, EQ)\n+VTEST_PARTIAL(anytrue, ne,      -1, NE)\n+\n+\/\/ ------------------------------ Vector insert ---------------------------------\n+\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, -16, 1\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_dup $dst, $idx\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl\n+define(`VECTOR_INSERT_D', `\n+instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, $3, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector ($1)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($dst$$reg), __ $3, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl             $1 $2     $3 $4\n+VECTOR_INSERT_D(L, iRegL, D, Register)\n+VECTOR_INSERT_D(D, vRegD, D, FloatRegister)\n+\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n+            \"sve_dup $dst, S, $idx\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src$$reg),\n+               as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffleB(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst, $src, $src\\t# vector load shuffle (B)\" %}\n+  ins_encode %{\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+                 as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadshuffleS(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uunpklo $dst, $src\\t# vector load shuffle (B to H)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadshuffleI(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\t# vector load shuffle (B to S)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadshuffleL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (VectorLoadShuffle src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n+            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n+            \"sve_uunpklo $dst, D, $dst\\t# vector load shuffle (B to D)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector rearrange -------------------------------\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorRearrange src shuffle));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n+               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------------\n+\n+instruct gatherI(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (LoadVectorGather mem idx));\n+  ins_cost(SVE_COST);\n+  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (I\/F)\" %}\n+  ins_encode %{\n+    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue,\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gatherL(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (LoadVectorGather mem idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (L\/D)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue,\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather Partial-------------------------------\n+\n+instruct gatherI_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (I\/F)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ S,\n+                          Matcher::vector_length(this));\n+    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg),\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gatherL_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (L\/D)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ D,\n+                          Matcher::vector_length(this));\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg),\n+                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------------\n+\n+instruct scatterI(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  ins_cost(SVE_COST);\n+  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (I\/F)\" %}\n+  ins_encode %{\n+    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue,\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatterL(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (L\/D)\" %}\n+  ins_encode %{\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue,\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter Partial-------------------------------\n+\n+instruct scatterI_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (I\/F)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ S,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg),\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatterL_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (L\/D)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ D,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg),\n+                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ ------------------------------ Vector Load Const -------------------------------\n+\n+instruct loadconB(vReg dst, immI0 src) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorLoadConst src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_index $dst, 0, 1\\t# generate iota indices\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($dst$$reg), __ B, 0, 1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Intrisics for String.indexOf(char)\n+\n+dnl\n+define(`STRING_INDEXOF_CHAR', `\n+instruct string$1_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::$1));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n@@ -937,0 +2515,18 @@\n+\n+dnl\n+dnl VMASK_REDUCTION($1,     $2,      $3  )\n+dnl VMASK_REDUCTION(suffix, op_name, cost)\n+define(`VMASK_REDUCTION', `\n+instruct vmask_$1(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst ($2 src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost($3 * SVE_COST);\n+  format %{ \"vmask_$1 $dst, $src\\t# vector mask $1 (sve)\" %}\n+  ins_encode %{\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n+                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n@@ -938,0 +2534,27 @@\n+\/\/ ---------------------------- Vector mask reductions ---------------------------\n+VMASK_REDUCTION(truecount, VectorMaskTrueCount, 2)\n+VMASK_REDUCTION(firsttrue, VectorMaskFirstTrue, 3)\n+VMASK_REDUCTION(lasttrue,  VectorMaskLastTrue, 4)\n+dnl\n+dnl VMASK_REDUCTION_PARTIAL($1,     $2,      $3  )\n+dnl VMASK_REDUCTION_PARTIAL(suffix, op_name, cost)\n+define(`VMASK_REDUCTION_PARTIAL', `\n+instruct vmask_$1_partial(iRegINoSp dst, vReg src, pRegGov ifelse($1, `firsttrue', `pgtmp, pReg ptmp', `ptmp'), rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst ($2 src));\n+  effect(TEMP ifelse($1, `firsttrue', `pgtmp, TEMP ptmp', `ptmp'), KILL cr);\n+  ins_cost($3 * SVE_COST);\n+  format %{ \"vmask_$1 $dst, $src\\t# vector mask $1 partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_whilelo_zr_imm(as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg), __ B,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n+                           as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg), as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VMASK_REDUCTION_PARTIAL(truecount, VectorMaskTrueCount, 3)\n+VMASK_REDUCTION_PARTIAL(firsttrue, VectorMaskFirstTrue, 4)\n+VMASK_REDUCTION_PARTIAL(lasttrue,  VectorMaskLastTrue, 5)\n@@ -939,0 +2562,51 @@\n+dnl\n+dnl VSTOREMASK_REDUCTION($1,     $2,      $3  )\n+dnl VSTOREMASK_REDUCTION(suffix, op_name, cost)\n+define(`VSTOREMASK_REDUCTION', `\n+instruct vstoremask_$1(iRegINoSp dst, vReg src, immI esize, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst ($2 (VectorStoreMask src esize)));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost($3 * SVE_COST);\n+  format %{ \"vstoremask_$1 $dst, $src\\t# vector mask $1 (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           ptrue, as_PRegister($ptmp$$reg), Matcher::vector_length(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ----------------- Vector mask reductions combined with VectorMaskStore ---------------\n+VSTOREMASK_REDUCTION(truecount, VectorMaskTrueCount, 2)\n+VSTOREMASK_REDUCTION(firsttrue, VectorMaskFirstTrue, 3)\n+VSTOREMASK_REDUCTION(lasttrue,  VectorMaskLastTrue, 4)\n+dnl\n+dnl VSTOREMASK_REDUCTION_PARTIAL($1,     $2,      $3  )\n+dnl VSTOREMASK_REDUCTION_PARTIAL(suffix, op_name, cost)\n+define(`VSTOREMASK_REDUCTION_PARTIAL', `\n+instruct vstoremask_$1_partial(iRegINoSp dst, vReg src, immI esize, pRegGov ifelse($1, `firsttrue', `pgtmp, pReg ptmp', `ptmp'), rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst ($2 (VectorStoreMask src esize)));\n+  effect(TEMP ifelse($1, `firsttrue', `pgtmp, TEMP ptmp', `ptmp'), KILL cr);\n+  ins_cost($3 * SVE_COST);\n+  format %{ \"vstoremask_$1 $dst, $src\\t# vector mask $1 partial (sve)\" %}\n+  ins_encode %{\n+    int size = $esize$$constant;\n+    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n+    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n+    __ sve_whilelo_zr_imm(as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg), variant,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant, as_FloatRegister($src$$reg),\n+                           as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg), as_PRegister($ptmp$$reg), MaxVectorSize \/ size);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VSTOREMASK_REDUCTION_PARTIAL(truecount, VectorMaskTrueCount, 3)\n+VSTOREMASK_REDUCTION_PARTIAL(firsttrue, VectorMaskFirstTrue, 4)\n+VSTOREMASK_REDUCTION_PARTIAL(lasttrue,  VectorMaskLastTrue, 5)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":1948,"deletions":274,"binary":false,"changes":2222,"status":"modified"},{"patch":"@@ -63,0 +63,21 @@\n+Assembler::SIMD_RegVariant Assembler::elemBytes_to_regVariant(int esize) {\n+  switch(esize) {\n+    case 1:\n+      return B;\n+    case 2:\n+      return H;\n+    case 4:\n+      return S;\n+    case 8:\n+      return D;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+  return INVALID;\n+}\n+\n+Assembler::SIMD_RegVariant Assembler::elemType_to_regVariant(BasicType bt) {\n+  return elemBytes_to_regVariant(type2aelembytes(bt));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1511,2 +1511,0 @@\n-  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n-\n@@ -1517,0 +1515,4 @@\n+  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+  static SIMD_RegVariant elemType_to_regVariant(BasicType bt);\n+  static SIMD_RegVariant elemBytes_to_regVariant(int esize);\n+\n@@ -3141,0 +3143,14 @@\n+\/\/ SVE load gather, store scatter (scalar plus vector) - 32-bit scaled offset\n+#define INSN(NAME, op1, type, op2, op3)                                         \\\n+  void NAME(FloatRegister Zt, PRegister Pg, Register Xn, FloatRegister Zm) {    \\\n+    starti;                                                                     \\\n+    f(op1, 31, 25), f(type, 24, 23), f(op2, 22, 21), rf(Zm, 16);                \\\n+    f(op3, 15, 13), pgrf(Pg, 10), srf(Xn, 5), rf(Zt, 0);                        \\\n+  }\n+\n+  INSN(sve_ld1w_gather,  0b1000010, 0b10, 0b01, 0b010);\n+  INSN(sve_ld1d_gather,  0b1100010, 0b11, 0b01, 0b010);\n+  INSN(sve_st1w_scatter, 0b1110010, 0b10, 0b11, 0b100);\n+  INSN(sve_st1d_scatter, 0b1110010, 0b11, 0b01, 0b100);\n+#undef INSN\n+\n@@ -3178,8 +3194,0 @@\n-  \/\/ SVE predicate count\n-  void sve_cntp(Register Xd, SIMD_RegVariant T, PRegister Pg, PRegister Pn) {\n-    starti;\n-    assert(T != Q, \"invalid size\");\n-    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000010, 21, 14);\n-    prf(Pg, 10), f(0, 9), prf(Pn, 5), rf(Xd, 0);\n-  }\n-\n@@ -3217,2 +3225,37 @@\n-\/\/ Integer comparisons (SVE)\n-#define INSN(NAME, cond)                                                                          \\\n+  \/\/ SVE cpy general-purpose register\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, Register Rn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b101000101, 21, 13);\n+    pgrf(Pg, 10), srf(Rn, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE cpy immediate\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, int imm8, bool isMerge) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    int sh = 0;\n+    if (imm8 <= 127 && imm8 >= -128) {\n+      sh = 0;\n+    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n+      sh = 1;\n+      imm8 = (imm8 >> 8);\n+    } else {\n+      guarantee(false, \"invalid immediate\");\n+    }\n+    int m = isMerge ? 1 : 0;\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b01, 21, 20);\n+    prf(Pg, 16), f(0b0, 15), f(m, 14), f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE sel (vectors)\n+  void sve_sel(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg,\n+               FloatRegister Zn, FloatRegister Zm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b11, 15, 14), prf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+\/\/ SVE compare vectors\n+#define INSN(NAME, op, cond, fp)  \\\n@@ -3221,2 +3264,6 @@\n-    assert(T != Q, \"invalid size\");                                                               \\\n-    f(0b00100100, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);        \\\n+    if (fp == 0) {                                                                                \\\n+      assert(T != Q, \"invalid size\");                                                             \\\n+    } else {                                                                                      \\\n+      assert(T != B && T != Q, \"invalid size\");                                                   \\\n+    }                                                                                             \\\n+    f(op, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);                \\\n@@ -3226,4 +3273,54 @@\n-  INSN(sve_cmpeq, 0b1010);  \/\/ Compare signed equal to vector\n-  INSN(sve_cmpne, 0b1011);  \/\/ Compare not equal to vector\n-  INSN(sve_cmpge, 0b1000);  \/\/ Compare signed greater than or equal to vector\n-  INSN(sve_cmpgt, 0b1001);  \/\/ Compare signed greater than vector\n+  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);  \/\/ Compare signed equal to vector\n+  INSN(sve_cmpne, 0b00100100, 0b1011, 0);  \/\/ Compare not equal to vector\n+  INSN(sve_cmpge, 0b00100100, 0b1000, 0);  \/\/ Compare signed greater than or equal to vector\n+  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);  \/\/ Compare signed greater than vector\n+  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);  \/\/ Floating-point compare vectors: Equal\n+  INSN(sve_fcmne, 0b01100101, 0b0111, 1);  \/\/ Floating-point compare vectors: Not Equal\n+  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);  \/\/ Floating-point compare vectors: Greater than\n+  INSN(sve_fcmge, 0b01100101, 0b0100, 1);  \/\/ Floating-point compare vectors: Greater than or equal\n+#undef INSN\n+\n+\/\/ SVE compare vector with immediate\n+#define INSN(NAME, cond)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, int imm5) { \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    guarantee(-16 <= imm5 && imm5 <= 15, \"invalid immediate\");                           \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),                   \\\n+    f((cond >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0); \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b1000);\n+  INSN(sve_cmpne, 0b1001);\n+  INSN(sve_cmpgt, 0b0001);\n+  INSN(sve_cmpge, 0b0000);\n+  INSN(sve_cmplt, 0b0010);\n+  INSN(sve_cmple, 0b0011);\n+#undef INSN\n+\n+\/\/ SVE unpack and extend\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) { \\\n+    starti;                                                          \\\n+    assert(T != B && T != Q, \"invalid size\");                        \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1100, 21, 18);          \\\n+    f(op, 17, 16), f(0b001110, 15, 10), rf(Zn, 5), rf(Zd, 0);        \\\n+  }\n+\n+  INSN(sve_uunpkhi, 0b11);\n+  INSN(sve_uunpklo, 0b10);\n+  INSN(sve_sunpkhi, 0b01);\n+  INSN(sve_sunpklo, 0b00);\n+#undef INSN\n+\n+\/\/ SVE uzp1\/uzp2 (vectors)\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);                       \\\n+    f(0b01101, 15, 11), f(op, 10), rf(Zn, 5), rf(Zd, 0);                               \\\n+  }\n+\n+  INSN(sve_uzp1, 0b0);\n+  INSN(sve_uzp2, 0b1);\n@@ -3248,4 +3345,2 @@\n-  \/\/ Predicate scan (SVE)\n-\n-  \/\/ Break after the first true condition\n-  void sve_brka(PRegister pd, PRegister pg, PRegister pn, bool isMerge) {\n+  \/\/ SVE predicate reverse\n+  void sve_rev(PRegister Pd, SIMD_RegVariant T, PRegister Pn) {\n@@ -3253,2 +3348,11 @@\n-    f(0b00100101, 31, 24), f(0b00, 23, 22), f(0b01000001, 21, 14),\n-    prf(pg, 10), f(0b0, 9), prf(pn, 5), f(isMerge ? 1 : 0, 4), prf(pd, 0);\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1101000100000, 21, 9);\n+    prf(Pn, 5), f(0, 4), prf(Pd, 0);\n+  }\n+\n+\/\/ SVE predicate break after\/before first true condition\n+#define INSN(NAME, op) \\\n+  void NAME(PRegister Pd, PRegister Pg, PRegister Pn, bool isMerge) {      \\\n+    starti;                                                                \\\n+    f(0b00100101, 31, 24), f(op, 23, 22), f(0b01000001, 21, 14);           \\\n+    prf(Pg, 10), f(0b0, 9), prf(Pn, 5), f(isMerge ? 1 : 0, 4), prf(Pd, 0); \\\n@@ -3257,0 +3361,4 @@\n+  INSN(sve_brka, 0b00);\n+  INSN(sve_brkb, 0b10);\n+#undef INSN\n+\n@@ -3271,1 +3379,7 @@\n-  \/\/ Predicate count and increment scalar (SVE)\n+  \/\/ Set scalar to active predicate element count\n+  void sve_cntp(Register Xd, SIMD_RegVariant T, PRegister Pg, PRegister Pn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000010, 21, 14);\n+    prf(Pg, 10), f(0, 9), prf(Pn, 5), rf(Xd, 0);\n+  }\n@@ -3273,1 +3387,1 @@\n-  \/\/ Set scalar to the number of Active predicate elements that are TRUE\n+  \/\/ Increment scalar by active predicate element count\n@@ -3281,0 +3395,110 @@\n+  \/\/ SVE convert signed integer to floating-point (predicated)\n+  void sve_scvtf(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+                 FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    assert(T_src != B && T_dst != B && T_src != Q && T_dst != Q &&\n+           (T_src != H || T_dst == T_src), \"invalid register variant\");\n+    int opc = T_dst;\n+    int opc2 = T_src;\n+    \/\/ In most cases we can treat T_dst, T_src as opc, opc2,\n+    \/\/ except for the following two combinations.\n+    \/\/ +-----+------+---+------------------------------------+\n+    \/\/ | opc | opc2 | U |        Instruction Details         |\n+    \/\/ +-----+------+---+------------------------------------+\n+    \/\/ |  11 |   00 | 0 | SCVTF - 32-bit to double-precision |\n+    \/\/ |  11 |   10 | 0 | SCVTF - 64-bit to single-precision |\n+    \/\/ +-----+------+---+------------------------------------+\n+    if (T_src == S && T_dst == D) {\n+      opc = 0b11;\n+      opc2 = 0b00;\n+    } else if (T_src == D && T_dst == S) {\n+      opc = 0b11;\n+      opc2 = 0b10;\n+    }\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b010, 21, 19);\n+    f(opc2, 18, 17), f(0b0101, 16, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE floating-point convert to signed integer, rounding toward zero (predicated)\n+  void sve_fcvtzs(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+                  FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    assert(T_src != B && T_dst != B && T_src != Q && T_dst != Q &&\n+           (T_dst != H || T_src == H), \"invalid register variant\");\n+    int opc = T_src;\n+    int opc2 = T_dst;\n+    \/\/ In most cases we can treat T_src, T_dst as opc, opc2,\n+    \/\/ except for the following two combinations.\n+    \/\/ +-----+------+---+-------------------------------------+\n+    \/\/ | opc | opc2 | U |         Instruction Details         |\n+    \/\/ +-----+------+---+-------------------------------------+\n+    \/\/ |  11 |  10  | 0 | FCVTZS - single-precision to 64-bit |\n+    \/\/ |  11 |  00  | 0 | FCVTZS - double-precision to 32-bit |\n+    \/\/ +-----+------+---+-------------------------------------+\n+    if (T_src == S && T_dst == D) {\n+      opc = 0b11;\n+      opc2 = 0b10;\n+    } else if (T_src == D && T_dst == S) {\n+      opc = 0b11;\n+      opc2 = 0b00;\n+    }\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b011, 21, 19);\n+    f(opc2, 18, 17), f(0b0101, 16, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE floating-point convert precision (predicated)\n+  void sve_fcvt(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+                FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    assert(T_src != B && T_dst != B && T_src != Q && T_dst != Q &&\n+           T_src != T_dst, \"invalid register variant\");\n+    guarantee(T_src != H && T_dst != H, \"half-precision unsupported\");\n+    f(0b01100101, 31, 24), f(0b11, 23, 22), f(0b0010, 21, 18);\n+    f(T_dst, 17, 16), f(0b101, 15, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+\/\/ SVE extract element to general-purpose register\n+#define INSN(NAME, before)                                                      \\\n+  void NAME(Register Rd, SIMD_RegVariant T, PRegister Pg,  FloatRegister Zn) {  \\\n+    starti;                                                                     \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b10000, 21, 17);                    \\\n+    f(before, 16), f(0b101, 15, 13);                                            \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Rd, 0);                                         \\\n+  }\n+\n+  INSN(sve_lasta, 0b0);\n+  INSN(sve_lastb, 0b1);\n+#undef INSN\n+\n+\/\/ SVE extract element to SIMD&FP scalar register\n+#define INSN(NAME, before)                                                           \\\n+  void NAME(FloatRegister Vd, SIMD_RegVariant T, PRegister Pg,  FloatRegister Zn) {  \\\n+    starti;                                                                          \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b10001, 21, 17);                         \\\n+    f(before, 16), f(0b100, 15, 13);                                                 \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Vd, 0);                                              \\\n+  }\n+\n+  INSN(sve_lasta, 0b0);\n+  INSN(sve_lastb, 0b1);\n+#undef INSN\n+\n+  \/\/ SVE INDEX (immediates)\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T, int imm1, int imm2) {\n+    starti;\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(0b1, 21);\n+    sf(imm2, 20, 16), f(0b010000, 15, 10);\n+    sf(imm1, 9, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE programmable table lookup in single vector table\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":250,"deletions":26,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -947,0 +947,56 @@\n+\n+void C2_MacroAssembler::sve_compare(PRegister pd, BasicType bt, PRegister pg,\n+                                    FloatRegister zn, FloatRegister zm, int cond) {\n+  SIMD_RegVariant size = elemType_to_regVariant(bt);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: sve_fcmeq(pd, size, pg, zn, zm); break;\n+      case BoolTest::ne: sve_fcmne(pd, size, pg, zn, zm); break;\n+      case BoolTest::ge: sve_fcmge(pd, size, pg, zn, zm); break;\n+      case BoolTest::gt: sve_fcmgt(pd, size, pg, zn, zm); break;\n+      case BoolTest::le: sve_fcmge(pd, size, pg, zm, zn); break;\n+      case BoolTest::lt: sve_fcmgt(pd, size, pg, zm, zn); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: sve_cmpeq(pd, size, pg, zn, zm); break;\n+      case BoolTest::ne: sve_cmpne(pd, size, pg, zn, zm); break;\n+      case BoolTest::ge: sve_cmpge(pd, size, pg, zn, zm); break;\n+      case BoolTest::gt: sve_cmpgt(pd, size, pg, zn, zm); break;\n+      case BoolTest::le: sve_cmpge(pd, size, pg, zm, zn); break;\n+      case BoolTest::lt: sve_cmpgt(pd, size, pg, zm, zn); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::sve_vmask_reduction(int opc, Register dst, SIMD_RegVariant size, FloatRegister src,\n+                                            PRegister pg, PRegister pn, int length) {\n+  assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n+  \/\/ The conditional flags will be clobbered by this function\n+  sve_cmpne(pn, size, pg, src, 0);\n+  switch (opc) {\n+    case Op_VectorMaskTrueCount:\n+      sve_cntp(dst, size, ptrue, pn);\n+      break;\n+    case Op_VectorMaskFirstTrue:\n+      sve_brkb(pn, pg, pn, false);\n+      sve_cntp(dst, size, ptrue, pn);\n+      break;\n+    case Op_VectorMaskLastTrue:\n+      sve_rev(pn, size, pn);\n+      sve_brkb(pn, ptrue, pn, false);\n+      sve_cntp(dst, size, ptrue, pn);\n+      movw(rscratch1, length - 1);\n+      subw(dst, rscratch1, dst);\n+      break;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -61,0 +61,26 @@\n+  void sve_compare(PRegister pd, BasicType bt, PRegister pg,\n+                   FloatRegister zn, FloatRegister zm, int cond);\n+\n+  void sve_vmask_reduction(int opc, Register dst, SIMD_RegVariant size, FloatRegister src,\n+                           PRegister pg, PRegister pn, int length = MaxVectorSize);\n+\n+  \/\/ Generate predicate through whilelo, by comparing ZR with an unsigned\n+  \/\/ immediate. rscratch1 will be clobbered.\n+  inline void sve_whilelo_zr_imm(PRegister pd, SIMD_RegVariant size, uint imm) {\n+    assert(UseSVE > 0, \"not supported\");\n+    mov(rscratch1, imm);\n+    sve_whilelo(pd, size, zr, rscratch1);\n+  }\n+\n+  \/\/ Extract a scalar element from an sve vector at position 'idx'.\n+  \/\/ rscratch1 will be clobbered.\n+  \/\/ T could be FloatRegister or Register.\n+  template<class T>\n+  inline void sve_extract(T dst, SIMD_RegVariant size, PRegister pg, FloatRegister src, int idx) {\n+    assert(UseSVE > 0, \"not supported\");\n+    assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n+    mov(rscratch1, idx);\n+    sve_whilele(pg, size, zr, rscratch1);\n+    sve_lastb(dst, size, pg, src);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2540,1 +2540,3 @@\n-  if (restore_vectors) {\n+  \/\/ We may use predicate registers and rely on ptrue with SVE,\n+  \/\/ regardless of wide vector (> 8 bytes) used or not.\n+  if (use_sve) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7032,0 +7032,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2398,21 +2398,32 @@\n-  if (EnableVectorReboxing && can_reshape && progress == NULL) {\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-    bool all_inputs_are_equiv_vboxes = true;\n-    for (uint i = 1; i < req(); ++i) {\n-      Node* n = in(i);\n-      if (in(i)->Opcode() != Op_VectorBox) {\n-        all_inputs_are_equiv_vboxes = false;\n-        break;\n-      }\n-      \/\/ Check that vector type of vboxes is equivalent\n-      if (i != 1) {\n-        if (Type::cmp(in(i-0)->in(VectorBoxNode::Value)->bottom_type(),\n-                      in(i-1)->in(VectorBoxNode::Value)->bottom_type()) != 0) {\n-          all_inputs_are_equiv_vboxes = false;\n-          break;\n-        }\n-        if (Type::cmp(in(i-0)->in(VectorBoxNode::Box)->bottom_type(),\n-                      in(i-1)->in(VectorBoxNode::Box)->bottom_type()) != 0) {\n-          all_inputs_are_equiv_vboxes = false;\n-          break;\n+  if (EnableVectorReboxing && can_reshape && progress == NULL && type()->isa_oopptr()) {\n+    progress = merge_through_phi(this, phase->is_IterGVN());\n+  }\n+\n+  return progress;              \/\/ Return any progress\n+}\n+\n+Node* PhiNode::clone_through_phi(Node* root_phi, const Type* t, uint c, PhaseIterGVN* igvn) {\n+  Node_Stack stack(1);\n+  VectorSet  visited;\n+  Node_List  node_map;\n+\n+  stack.push(root_phi, 1); \/\/ ignore control\n+  visited.set(root_phi->_idx);\n+\n+  Node* new_phi = new PhiNode(root_phi->in(0), t);\n+  node_map.map(root_phi->_idx, new_phi);\n+\n+  while (stack.is_nonempty()) {\n+    Node* n   = stack.node();\n+    uint  idx = stack.index();\n+    assert(n->is_Phi(), \"not a phi\");\n+    if (idx < n->req()) {\n+      stack.set_index(idx + 1);\n+      Node* def = n->in(idx);\n+      if (def == NULL) {\n+        continue; \/\/ ignore dead path\n+      } else if (def->is_Phi()) { \/\/ inner node\n+        Node* new_phi = node_map[n->_idx];\n+        if (!visited.test_set(def->_idx)) { \/\/ not visited yet\n+          node_map.map(def->_idx, new PhiNode(def->in(0), t));\n+          stack.push(def, 1); \/\/ ignore control\n@@ -2420,0 +2431,9 @@\n+        Node* new_in = node_map[def->_idx];\n+        new_phi->set_req(idx, new_in);\n+      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+        assert(n->is_Phi(), \"not a phi\");\n+        Node* new_phi = node_map[n->_idx];\n+        new_phi->set_req(idx, def->in(c));\n+      } else {\n+        assert(false, \"not optimizeable\");\n+        return NULL;\n@@ -2421,0 +2441,4 @@\n+    } else {\n+      Node* new_phi = node_map[n->_idx];\n+      igvn->register_new_node_with_optimizer(new_phi, n);\n+      stack.pop();\n@@ -2422,0 +2446,3 @@\n+  }\n+  return new_phi;\n+}\n@@ -2423,8 +2450,34 @@\n-    if (all_inputs_are_equiv_vboxes) {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(in(1));\n-      PhiNode* new_vbox_phi = new PhiNode(r, vbox->box_type());\n-      PhiNode* new_vect_phi = new PhiNode(r, vbox->vec_type());\n-      for (uint i = 1; i < req(); ++i) {\n-        VectorBoxNode* old_vbox = static_cast<VectorBoxNode*>(in(i));\n-        new_vbox_phi->set_req(i, old_vbox->in(VectorBoxNode::Box));\n-        new_vect_phi->set_req(i, old_vbox->in(VectorBoxNode::Value));\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+  Node_Stack stack(1);\n+  VectorSet  visited;\n+\n+  stack.push(root_phi, 1); \/\/ ignore control\n+  visited.set(root_phi->_idx);\n+\n+  VectorBoxNode* cached_vbox = NULL;\n+  while (stack.is_nonempty()) {\n+    Node* n   = stack.node();\n+    uint  idx = stack.index();\n+    if (idx < n->req()) {\n+      stack.set_index(idx + 1);\n+      Node* in = n->in(idx);\n+      if (in == NULL) {\n+        continue; \/\/ ignore dead path\n+      } else if (in->isa_Phi()) {\n+        if (!visited.test_set(in->_idx)) {\n+          stack.push(in, 1); \/\/ ignore control\n+        }\n+      } else if (in->Opcode() == Op_VectorBox) {\n+        VectorBoxNode* vbox = static_cast<VectorBoxNode*>(in);\n+        if (cached_vbox == NULL) {\n+          cached_vbox = vbox;\n+        } else if (vbox->vec_type() != cached_vbox->vec_type()) {\n+          \/\/ TODO: vector type mismatch can be handled with additional reinterpret casts\n+          assert(Type::cmp(vbox->vec_type(), cached_vbox->vec_type()) != 0, \"inconsistent\");\n+          return NULL; \/\/ not optimizable: vector type mismatch\n+        } else if (vbox->box_type() != cached_vbox->box_type()) {\n+          assert(Type::cmp(vbox->box_type(), cached_vbox->box_type()) != 0, \"inconsistent\");\n+          return NULL; \/\/ not optimizable: box type mismatch\n+        }\n+      } else {\n+        return NULL; \/\/ not optimizable: neither Phi nor VectorBox\n@@ -2432,3 +2485,2 @@\n-      igvn->register_new_node_with_optimizer(new_vbox_phi, this);\n-      igvn->register_new_node_with_optimizer(new_vect_phi, this);\n-      progress = new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, vbox->box_type(), vbox->vec_type());\n+    } else {\n+      stack.pop();\n@@ -2437,2 +2489,6 @@\n-\n-  return progress;              \/\/ Return any progress\n+  assert(cached_vbox != NULL, \"sanity\");\n+  const TypeInstPtr* btype = cached_vbox->box_type();\n+  const TypeVect*    vtype = cached_vbox->vec_type();\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n+  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n+  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":90,"deletions":34,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+  static Node* clone_through_phi(Node* root_phi, const Type* t, uint c, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2138,1 +2138,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2148,1 +2149,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2111,1 +2111,4 @@\n-  if (C->max_vector_size() > 8)\n+  \/\/ And when the scalable vector register is used, we may spill\/unspill\n+  \/\/ the whole reg regardless of the max vector size.\n+  if (C->max_vector_size() > 8 ||\n+      (C->max_vector_size() > 0 && Matcher::supports_scalable_vector())) {\n@@ -2113,0 +2116,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -512,1 +512,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(1));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n@@ -817,2 +817,4 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n-  bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(gvn().type(base));\n+\n+  \/\/ The memory barrier checks are based on ones for unsafe access.\n+  \/\/ This is not 1-1 implementation.\n+  const Type *const base_type = gvn().type(base);\n@@ -823,0 +825,9 @@\n+  const bool in_native = TypePtr::NULL_PTR == base_type; \/\/ base always null\n+  const bool in_heap   = !TypePtr::NULL_PTR->higher_equal(base_type); \/\/ base never null\n+\n+  const bool is_mixed_access = !in_heap && !in_native;\n+\n+  const bool is_mismatched_access = in_heap && (addr_type->isa_aryptr() == NULL);\n+\n+  const bool needs_cpu_membar = is_mixed_access || is_mismatched_access;\n+\n@@ -880,1 +891,1 @@\n-  if (can_access_non_heap) {\n+  if (needs_cpu_membar) {\n@@ -927,1 +938,1 @@\n-  if (can_access_non_heap) {\n+  if (needs_cpu_membar) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1197,0 +1197,1 @@\n+    assert((BoolTest::mask)predicate_node->get_int() == predicate, \"Unmatched predicates\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/globalDefinitions_vecApi.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This file is used to provide some global declarations related to building\n+\/\/ VM with Vector API support. Also, the reason the file is separated is because\n+\/\/ the intent of this file to provide a header that can be included in .s files.\n+\n+#ifndef SHARE_VM_UTILITIES_GLOBALDEFINITIONS_VECAPI_HPP\n+#define SHARE_VM_UTILITIES_GLOBALDEFINITIONS_VECAPI_HPP\n+\n+\/\/ VS2017 required to build .s files for math intrinsics\n+#if defined(_WIN64) && (defined(_MSC_VER) && (_MSC_VER >= 1910))\n+#define __VECTOR_API_MATH_INTRINSICS_COMMON\n+#define __VECTOR_API_MATH_INTRINSICS_WINDOWS\n+#endif\n+\n+\/\/ GCC 4.9+ can build all .s files for Linux\n+#if defined(LINUX) && defined(_LP64) && (defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 9))))\n+#define __VECTOR_API_MATH_INTRINSICS_COMMON\n+#define __VECTOR_API_MATH_INTRINSICS_LINUX\n+#endif\n+\n+\n+#endif \/\/ SHARE_VM_UTILITIES_GLOBALDEFINITIONS_VECAPI_HPP\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_vecApi.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -323,0 +323,11 @@\n+  void truncate_to(int idx) {\n+    for (int i = 0, j = idx; j < length(); i++, j++) {\n+      at_put(i, at(j));\n+    }\n+    trunc_to(length() - idx);\n+  }\n+\n+  void truncate_from(int idx) {\n+    trunc_to(idx);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+        static final long BYTE_BUFFER_IS_READ_ONLY\n+                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+\n@@ -376,0 +379,5 @@\n+    @ForceInline\n+    public static boolean isReadOnly(ByteBuffer bb) {\n+        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n+    }\n+\n@@ -409,0 +417,2 @@\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n@@ -410,3 +420,3 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    bb, offset, s,\n-                    defaultImpl);\n+                      base, BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n@@ -451,0 +461,2 @@\n+            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+\n@@ -452,4 +464,4 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    v,\n-                    bb, offset,\n-                    defaultImpl);\n+                                base, BufferAccess.bufferAddress(bb, offset),\n+                                v,\n+                                bb, offset,\n+                                defaultImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3471,1 +3471,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3087,1 +3087,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3074,1 +3074,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3192,1 +3192,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3095,1 +3095,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3458,1 +3458,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4418,1 +4418,1 @@\n-        if (bb.isReadOnly()) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1539,46 +1539,113 @@\n-                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n-                        [\"inc\",    \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n-                        [\"dec\",    \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n-                        [\"lsl\",    \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n-                        [\"lsr\",    \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n-                        [\"asr\",    \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n-                        [\"lsr\",    \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n-                        [\"asr\",    \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n-                        [\"addvl\",  \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n-                        [\"addpl\",  \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n-                        [\"cntp\",   \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n-                        [\"dup\",    \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n-                        [\"dup\",    \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n-                        [\"dup\",    \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n-                        [\"dup\",    \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n-                        [\"dup\",    \"__ sve_dup(z4, __ B, r3);\",                          \"dup\\tz4.b, w3\"],\n-                        [\"dup\",    \"__ sve_dup(z14, __ H, r22);\",                        \"dup\\tz14.h, w22\"],\n-                        [\"ld1b\",   \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n-                        [\"ld1h\",   \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n-                        [\"ld1w\",   \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n-                        [\"ld1b\",   \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n-                        [\"ld1w\",   \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n-                        [\"ld1d\",   \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n-                        [\"st1w\",   \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n-                        [\"st1h\",   \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n-                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n-                        [\"ldr\",    \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n-                        [\"ldr\",    \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n-                        [\"str\",    \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n-                        [\"cntb\",   \"__ sve_cntb(r9);\",                                   \"cntb\\tx9\"],\n-                        [\"cnth\",   \"__ sve_cnth(r10);\",                                  \"cnth\\tx10\"],\n-                        [\"cntw\",   \"__ sve_cntw(r11);\",                                  \"cntw\\tx11\"],\n-                        [\"cntd\",   \"__ sve_cntd(r12);\",                                  \"cntd\\tx12\"],\n-                        [\"brka\",   \"__ sve_brka(p2, p0, p2, false);\",                    \"brka\\tp2.b, p0\/z, p2.b\"],\n-                        [\"brka\",   \"__ sve_brka(p1, p2, p3, true);\",                     \"brka\\tp1.b, p2\/m, p3.b\"],\n-                        [\"incp\",   \"__ sve_incp(r0, __ B, p2);\",                         \"incp\\tx0, p2.b\"],\n-                        [\"whilelt\",   \"__ sve_whilelt(p0, __ B, r1, r28);\",              \"whilelt\\tp0.b, x1, x28\"],\n-                        [\"whilele\",   \"__ sve_whilele(p2, __ H, r11, r8);\",              \"whilele\\tp2.h, x11, x8\"],\n-                        [\"whilelo\",   \"__ sve_whilelo(p3, __ S, r7, r2);\",               \"whilelo\\tp3.s, x7, x2\"],\n-                        [\"whilels\",   \"__ sve_whilels(p4, __ D, r17, r10);\",             \"whilels\\tp4.d, x17, x10\"],\n+                        [\"cpy\",     \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z0, __ B, p0, 127, true);\",               \"mov\\tz0.b, p0\/m, 127\"],\n+                        [\"cpy\",     \"__ sve_cpy(z1, __ H, p0, -128, true);\",              \"mov\\tz1.h, p0\/m, -128\"],\n+                        [\"cpy\",     \"__ sve_cpy(z2, __ S, p0, 32512, true);\",             \"mov\\tz2.s, p0\/m, 32512\"],\n+                        [\"cpy\",     \"__ sve_cpy(z5, __ D, p0, -32768, false);\",           \"mov\\tz5.d, p0\/z, -32768\"],\n+                        [\"cpy\",     \"__ sve_cpy(z10, __ B, p0, -1, false);\",              \"mov\\tz10.b, p0\/z, -1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z11, __ S, p0, -1, false);\",              \"mov\\tz11.s, p0\/z, -1\"],\n+                        [\"inc\",     \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n+                        [\"dec\",     \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n+                        [\"lsl\",     \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n+                        [\"lsr\",     \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n+                        [\"asr\",     \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n+                        [\"lsr\",     \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n+                        [\"asr\",     \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n+                        [\"addvl\",   \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n+                        [\"addpl\",   \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n+                        [\"cntp\",    \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n+                        [\"dup\",     \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n+                        [\"dup\",     \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n+                        [\"dup\",     \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n+                        [\"dup\",     \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n+                        [\"dup\",     \"__ sve_dup(z10, __ B, -1);\",                         \"dup\\tz10.b, -1\"],\n+                        [\"dup\",     \"__ sve_dup(z11, __ S, -1);\",                         \"dup\\tz11.s, -1\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ H, p1, Address(sp));\",            \"ld1b\\t{z0.h}, p1\/z, [sp]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ S, p2, Address(sp, r8));\",        \"ld1b\\t{z0.s}, p2\/z, [sp, x8]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ D, p3, Address(sp, 7));\",         \"ld1b\\t{z0.d}, p3\/z, [sp, #7, MUL VL]\"],\n+                        [\"ld1h\",    \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n+                        [\"ld1w\",    \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n+                        [\"ld1w\",    \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n+                        [\"ld1d\",    \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ H, p1, Address(sp));\",            \"st1b\\t{z0.h}, p1, [sp]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ S, p2, Address(sp, r8));\",        \"st1b\\t{z0.s}, p2, [sp, x8]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ D, p3, Address(sp));\",            \"st1b\\t{z0.d}, p3, [sp]\"],\n+                        [\"st1w\",    \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n+                        [\"st1h\",    \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n+                        [\"st1d\",    \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n+                        [\"ldr\",     \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n+                        [\"ldr\",     \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n+                        [\"str\",     \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+                        [\"cntb\",    \"__ sve_cntb(r9);\",                                   \"cntb\\tx9\"],\n+                        [\"cnth\",    \"__ sve_cnth(r10);\",                                  \"cnth\\tx10\"],\n+                        [\"cntw\",    \"__ sve_cntw(r11);\",                                  \"cntw\\tx11\"],\n+                        [\"cntd\",    \"__ sve_cntd(r12);\",                                  \"cntd\\tx12\"],\n+                        [\"brka\",    \"__ sve_brka(p2, p0, p2, false);\",                    \"brka\\tp2.b, p0\/z, p2.b\"],\n+                        [\"brka\",    \"__ sve_brka(p1, p2, p3, true);\",                     \"brka\\tp1.b, p2\/m, p3.b\"],\n+                        [\"brkb\",    \"__ sve_brkb(p1, p2, p3, false);\",                    \"brkb\\tp1.b, p2\/z, p3.b\"],\n+                        [\"brkb\",    \"__ sve_brkb(p2, p3, p4, true);\",                     \"brkb\\tp2.b, p3\/m, p4.b\"],\n+                        [\"rev\",     \"__ sve_rev(p0, __ B, p1);\",                          \"rev\\tp0.b, p1.b\"],\n+                        [\"rev\",     \"__ sve_rev(p1, __ H, p2);\",                          \"rev\\tp1.h, p2.h\"],\n+                        [\"rev\",     \"__ sve_rev(p2, __ S, p3);\",                          \"rev\\tp2.s, p3.s\"],\n+                        [\"rev\",     \"__ sve_rev(p3, __ D, p4);\",                          \"rev\\tp3.d, p4.d\"],\n+                        [\"incp\",    \"__ sve_incp(r0, __ B, p2);\",                         \"incp\\tx0, p2.b\"],\n+                        [\"whilelt\", \"__ sve_whilelt(p0, __ B, r1, r28);\",                 \"whilelt\\tp0.b, x1, x28\"],\n+                        [\"whilele\", \"__ sve_whilele(p2, __ H, r11, r8);\",                 \"whilele\\tp2.h, x11, x8\"],\n+                        [\"whilelo\", \"__ sve_whilelo(p3, __ S, r7, r2);\",                  \"whilelo\\tp3.s, x7, x2\"],\n+                        [\"whilels\", \"__ sve_whilels(p4, __ D, r17, r10);\",                \"whilels\\tp4.d, x17, x10\"],\n+                        [\"sel\",     \"__ sve_sel(z0, __ B, p0, z1, z2);\",                  \"sel\\tz0.b, p0, z1.b, z2.b\"],\n+                        [\"sel\",     \"__ sve_sel(z4, __ D, p0, z5, z6);\",                  \"sel\\tz4.d, p0, z5.d, z6.d\"],\n+                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p0, z0, z1);\",                \"cmpeq\\tp1.b, p0\/z, z0.b, z1.b\"],\n+                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, z3);\",                \"cmpne\\tp1.h, p0\/z, z2.h, z3.h\"],\n+                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p2, z4, z5);\",                \"cmpge\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ D, p3, z6, z7);\",                \"cmpgt\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"cmple\",   \"__ sve_cmpge(p2, __ B, p0, z10, z11);\",              \"cmple\\tp2.b, p0\/z, z11.b, z10.b\"],\n+                        [\"cmplt\",   \"__ sve_cmpgt(p3, __ S, p0, z16, z17);\",              \"cmplt\\tp3.s, p0\/z, z17.s, z16.s\"],\n+                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p4, z0, 15);\",                \"cmpeq\\tp1.b, p4\/z, z0.b, #15\"],\n+                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, -16);\",               \"cmpne\\tp1.h, p0\/z, z2.h, #-16\"],\n+                        [\"cmple\",   \"__ sve_cmple(p1, __ S, p1, z4, 0);\",                 \"cmple\\tp1.s, p1\/z, z4.s, #0\"],\n+                        [\"cmplt\",   \"__ sve_cmplt(p1, __ D, p2, z6, -1);\",                \"cmplt\\tp1.d, p2\/z, z6.d, #-1\"],\n+                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p3, z4, 5);\",                 \"cmpge\\tp1.s, p3\/z, z4.s, #5\"],\n+                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ B, p4, z6, -2);\",                \"cmpgt\\tp1.b, p4\/z, z6.b, #-2\"],\n+                        [\"fcmeq\",   \"__ sve_fcmeq(p1, __ S, p0, z0, z1);\",                \"fcmeq\\tp1.s, p0\/z, z0.s, z1.s\"],\n+                        [\"fcmne\",   \"__ sve_fcmne(p1, __ D, p0, z2, z3);\",                \"fcmne\\tp1.d, p0\/z, z2.d, z3.d\"],\n+                        [\"fcmgt\",   \"__ sve_fcmgt(p1, __ S, p2, z4, z5);\",                \"fcmgt\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"fcmge\",   \"__ sve_fcmge(p1, __ D, p3, z6, z7);\",                \"fcmge\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"fcmlt\",   \"__ sve_fcmgt(p2, __ S, p0, z10, z11);\",              \"fcmlt\\tp2.s, p0\/z, z11.s, z10.s\"],\n+                        [\"fcmle\",   \"__ sve_fcmge(p3, __ D, p0, z16, z17);\",              \"fcmle\\tp3.d, p0\/z, z17.d, z16.d\"],\n+                        [\"uunpkhi\", \"__ sve_uunpkhi(z0, __ H, z1);\",                      \"uunpkhi\\tz0.h, z1.b\"],\n+                        [\"uunpklo\", \"__ sve_uunpklo(z4, __ S, z5);\",                      \"uunpklo\\tz4.s, z5.h\"],\n+                        [\"sunpkhi\", \"__ sve_sunpkhi(z6, __ D, z7);\",                      \"sunpkhi\\tz6.d, z7.s\"],\n+                        [\"sunpklo\", \"__ sve_sunpklo(z10, __ H, z11);\",                    \"sunpklo\\tz10.h, z11.b\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z1, __ D, p0, z0, __ S);\",              \"scvtf\\tz1.d, p0\/m, z0.s\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z3, __ D, p1, z2, __ D);\",              \"scvtf\\tz3.d, p1\/m, z2.d\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z6, __ S, p2, z1, __ D);\",              \"scvtf\\tz6.s, p2\/m, z1.d\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z6, __ S, p3, z1, __ S);\",              \"scvtf\\tz6.s, p3\/m, z1.s\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z6, __ H, p3, z1, __ S);\",              \"scvtf\\tz6.h, p3\/m, z1.s\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z6, __ H, p3, z1, __ D);\",              \"scvtf\\tz6.h, p3\/m, z1.d\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z6, __ H, p3, z1, __ H);\",              \"scvtf\\tz6.h, p3\/m, z1.h\"],\n+                        [\"fcvt\",    \"__ sve_fcvt(z5, __ D, p3, z4, __ S);\",               \"fcvt\\tz5.d, p3\/m, z4.s\"],\n+                        [\"fcvt\",    \"__ sve_fcvt(z1, __ S, p3, z0, __ D);\",               \"fcvt\\tz1.s, p3\/m, z0.d\"],\n+                        [\"fcvtzs\",  \"__ sve_fcvtzs(z19, __ D, p2, z1, __ D);\",            \"fcvtzs\\tz19.d, p2\/m, z1.d\"],\n+                        [\"fcvtzs\",  \"__ sve_fcvtzs(z9, __ S, p1, z8, __ S);\",             \"fcvtzs\\tz9.s, p1\/m, z8.s\"],\n+                        [\"fcvtzs\",  \"__ sve_fcvtzs(z1, __ S, p2, z0, __ D);\",             \"fcvtzs\\tz1.s, p2\/m, z0.d\"],\n+                        [\"fcvtzs\",  \"__ sve_fcvtzs(z1, __ D, p3, z0, __ S);\",             \"fcvtzs\\tz1.d, p3\/m, z0.s\"],\n+                        [\"fcvtzs\",  \"__ sve_fcvtzs(z1, __ S, p4, z18, __ H);\",            \"fcvtzs\\tz1.s, p4\/m, z18.h\"],\n+                        [\"lasta\",   \"__ sve_lasta(r0, __ B, p0, z15);\",                   \"lasta\\tw0, p0, z15.b\"],\n+                        [\"lastb\",   \"__ sve_lastb(r1, __ B, p1, z16);\",                   \"lastb\\tw1, p1, z16.b\"],\n+                        [\"lasta\",   \"__ sve_lasta(v0, __ B, p0, z15);\",                   \"lasta\\tb0, p0, z15.b\"],\n+                        [\"lastb\",   \"__ sve_lastb(v1, __ B, p1, z16);\",                   \"lastb\\tb1, p1, z16.b\"],\n+                        [\"index\",   \"__ sve_index(z6, __ S, 1, 1);\",                      \"index\\tz6.s, #1, #1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z7, __ H, p3, r5);\",                      \"cpy\\tz7.h, p3\/m, w5\"],\n+                        [\"tbl\",     \"__ sve_tbl(z16, __ S, z17, z18);\",                   \"tbl\\tz16.s, {z17.s}, z18.s\"],\n+                        [\"ld1w\",    \"__ sve_ld1w_gather(z15, p0, r5, z16);\",              \"ld1w\\t{z15.s}, p0\/z, [x5, z16.s, uxtw #2]\"],\n+                        [\"ld1d\",    \"__ sve_ld1d_gather(z15, p0, r5, z16);\",              \"ld1d\\t{z15.d}, p0\/z, [x5, z16.d, uxtw #3]\"],\n+                        [\"st1w\",    \"__ sve_st1w_scatter(z15, p0, r5, z16);\",             \"st1w\\t{z15.s}, p0, [x5, z16.s, uxtw #2]\"],\n+                        [\"st1d\",    \"__ sve_st1d_scatter(z15, p0, r5, z16);\",             \"st1d\\t{z15.d}, p0, [x5, z16.d, uxtw #3]\"],\n@@ -1658,0 +1725,2 @@\n+                       [\"uzp1\", \"ZZZ\"],\n+                       [\"uzp2\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":115,"deletions":46,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -729,0 +729,6 @@\n+    __ sve_cpy(z0, __ B, p0, 127, true);               \/\/       mov     z0.b, p0\/m, 127\n+    __ sve_cpy(z1, __ H, p0, -128, true);              \/\/       mov     z1.h, p0\/m, -128\n+    __ sve_cpy(z2, __ S, p0, 32512, true);             \/\/       mov     z2.s, p0\/m, 32512\n+    __ sve_cpy(z5, __ D, p0, -32768, false);           \/\/       mov     z5.d, p0\/z, -32768\n+    __ sve_cpy(z10, __ B, p0, -1, false);              \/\/       mov     z10.b, p0\/z, -1\n+    __ sve_cpy(z11, __ S, p0, -1, false);              \/\/       mov     z11.s, p0\/z, -1\n@@ -746,2 +752,2 @@\n-    __ sve_dup(z4, __ B, r3);                          \/\/       dup     z4.b, w3\n-    __ sve_dup(z14, __ H, r22);                        \/\/       dup     z14.h, w22\n+    __ sve_dup(z10, __ B, -1);                         \/\/       dup     z10.b, -1\n+    __ sve_dup(z11, __ S, -1);                         \/\/       dup     z11.s, -1\n@@ -749,0 +755,3 @@\n+    __ sve_ld1b(z0, __ H, p1, Address(sp));            \/\/       ld1b    {z0.h}, p1\/z, [sp]\n+    __ sve_ld1b(z0, __ S, p2, Address(sp, r8));        \/\/       ld1b    {z0.s}, p2\/z, [sp, x8]\n+    __ sve_ld1b(z0, __ D, p3, Address(sp, 7));         \/\/       ld1b    {z0.d}, p3\/z, [sp, #7, MUL VL]\n@@ -756,0 +765,3 @@\n+    __ sve_st1b(z0, __ H, p1, Address(sp));            \/\/       st1b    {z0.h}, p1, [sp]\n+    __ sve_st1b(z0, __ S, p2, Address(sp, r8));        \/\/       st1b    {z0.s}, p2, [sp, x8]\n+    __ sve_st1b(z0, __ D, p3, Address(sp));            \/\/       st1b    {z0.d}, p3, [sp]\n@@ -769,0 +781,6 @@\n+    __ sve_brkb(p1, p2, p3, false);                    \/\/       brkb    p1.b, p2\/z, p3.b\n+    __ sve_brkb(p2, p3, p4, true);                     \/\/       brkb    p2.b, p3\/m, p4.b\n+    __ sve_rev(p0, __ B, p1);                          \/\/       rev     p0.b, p1.b\n+    __ sve_rev(p1, __ H, p2);                          \/\/       rev     p1.h, p2.h\n+    __ sve_rev(p2, __ S, p3);                          \/\/       rev     p2.s, p3.s\n+    __ sve_rev(p3, __ D, p4);                          \/\/       rev     p3.d, p4.d\n@@ -774,0 +792,49 @@\n+    __ sve_sel(z0, __ B, p0, z1, z2);                  \/\/       sel     z0.b, p0, z1.b, z2.b\n+    __ sve_sel(z4, __ D, p0, z5, z6);                  \/\/       sel     z4.d, p0, z5.d, z6.d\n+    __ sve_cmpeq(p1, __ B, p0, z0, z1);                \/\/       cmpeq   p1.b, p0\/z, z0.b, z1.b\n+    __ sve_cmpne(p1, __ H, p0, z2, z3);                \/\/       cmpne   p1.h, p0\/z, z2.h, z3.h\n+    __ sve_cmpge(p1, __ S, p2, z4, z5);                \/\/       cmpge   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_cmpgt(p1, __ D, p3, z6, z7);                \/\/       cmpgt   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_cmpge(p2, __ B, p0, z10, z11);              \/\/       cmple   p2.b, p0\/z, z11.b, z10.b\n+    __ sve_cmpgt(p3, __ S, p0, z16, z17);              \/\/       cmplt   p3.s, p0\/z, z17.s, z16.s\n+    __ sve_cmpeq(p1, __ B, p4, z0, 15);                \/\/       cmpeq   p1.b, p4\/z, z0.b, #15\n+    __ sve_cmpne(p1, __ H, p0, z2, -16);               \/\/       cmpne   p1.h, p0\/z, z2.h, #-16\n+    __ sve_cmple(p1, __ S, p1, z4, 0);                 \/\/       cmple   p1.s, p1\/z, z4.s, #0\n+    __ sve_cmplt(p1, __ D, p2, z6, -1);                \/\/       cmplt   p1.d, p2\/z, z6.d, #-1\n+    __ sve_cmpge(p1, __ S, p3, z4, 5);                 \/\/       cmpge   p1.s, p3\/z, z4.s, #5\n+    __ sve_cmpgt(p1, __ B, p4, z6, -2);                \/\/       cmpgt   p1.b, p4\/z, z6.b, #-2\n+    __ sve_fcmeq(p1, __ S, p0, z0, z1);                \/\/       fcmeq   p1.s, p0\/z, z0.s, z1.s\n+    __ sve_fcmne(p1, __ D, p0, z2, z3);                \/\/       fcmne   p1.d, p0\/z, z2.d, z3.d\n+    __ sve_fcmgt(p1, __ S, p2, z4, z5);                \/\/       fcmgt   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_fcmge(p1, __ D, p3, z6, z7);                \/\/       fcmge   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_fcmgt(p2, __ S, p0, z10, z11);              \/\/       fcmlt   p2.s, p0\/z, z11.s, z10.s\n+    __ sve_fcmge(p3, __ D, p0, z16, z17);              \/\/       fcmle   p3.d, p0\/z, z17.d, z16.d\n+    __ sve_uunpkhi(z0, __ H, z1);                      \/\/       uunpkhi z0.h, z1.b\n+    __ sve_uunpklo(z4, __ S, z5);                      \/\/       uunpklo z4.s, z5.h\n+    __ sve_sunpkhi(z6, __ D, z7);                      \/\/       sunpkhi z6.d, z7.s\n+    __ sve_sunpklo(z10, __ H, z11);                    \/\/       sunpklo z10.h, z11.b\n+    __ sve_scvtf(z1, __ D, p0, z0, __ S);              \/\/       scvtf   z1.d, p0\/m, z0.s\n+    __ sve_scvtf(z3, __ D, p1, z2, __ D);              \/\/       scvtf   z3.d, p1\/m, z2.d\n+    __ sve_scvtf(z6, __ S, p2, z1, __ D);              \/\/       scvtf   z6.s, p2\/m, z1.d\n+    __ sve_scvtf(z6, __ S, p3, z1, __ S);              \/\/       scvtf   z6.s, p3\/m, z1.s\n+    __ sve_scvtf(z6, __ H, p3, z1, __ S);              \/\/       scvtf   z6.h, p3\/m, z1.s\n+    __ sve_scvtf(z6, __ H, p3, z1, __ D);              \/\/       scvtf   z6.h, p3\/m, z1.d\n+    __ sve_scvtf(z6, __ H, p3, z1, __ H);              \/\/       scvtf   z6.h, p3\/m, z1.h\n+    __ sve_fcvt(z5, __ D, p3, z4, __ S);               \/\/       fcvt    z5.d, p3\/m, z4.s\n+    __ sve_fcvt(z1, __ S, p3, z0, __ D);               \/\/       fcvt    z1.s, p3\/m, z0.d\n+    __ sve_fcvtzs(z19, __ D, p2, z1, __ D);            \/\/       fcvtzs  z19.d, p2\/m, z1.d\n+    __ sve_fcvtzs(z9, __ S, p1, z8, __ S);             \/\/       fcvtzs  z9.s, p1\/m, z8.s\n+    __ sve_fcvtzs(z1, __ S, p2, z0, __ D);             \/\/       fcvtzs  z1.s, p2\/m, z0.d\n+    __ sve_fcvtzs(z1, __ D, p3, z0, __ S);             \/\/       fcvtzs  z1.d, p3\/m, z0.s\n+    __ sve_fcvtzs(z1, __ S, p4, z18, __ H);            \/\/       fcvtzs  z1.s, p4\/m, z18.h\n+    __ sve_lasta(r0, __ B, p0, z15);                   \/\/       lasta   w0, p0, z15.b\n+    __ sve_lastb(r1, __ B, p1, z16);                   \/\/       lastb   w1, p1, z16.b\n+    __ sve_lasta(v0, __ B, p0, z15);                   \/\/       lasta   b0, p0, z15.b\n+    __ sve_lastb(v1, __ B, p1, z16);                   \/\/       lastb   b1, p1, z16.b\n+    __ sve_index(z6, __ S, 1, 1);                      \/\/       index   z6.s, #1, #1\n+    __ sve_cpy(z7, __ H, p3, r5);                      \/\/       cpy     z7.h, p3\/m, w5\n+    __ sve_tbl(z16, __ S, z17, z18);                   \/\/       tbl     z16.s, {z17.s}, z18.s\n+    __ sve_ld1w_gather(z15, p0, r5, z16);              \/\/       ld1w    {z15.s}, p0\/z, [x5, z16.s, uxtw #2]\n+    __ sve_ld1d_gather(z15, p0, r5, z16);              \/\/       ld1d    {z15.d}, p0\/z, [x5, z16.d, uxtw #3]\n+    __ sve_st1w_scatter(z15, p0, r5, z16);             \/\/       st1w    {z15.s}, p0, [x5, z16.s, uxtw #2]\n+    __ sve_st1d_scatter(z15, p0, r5, z16);             \/\/       st1d    {z15.d}, p0, [x5, z16.d, uxtw #3]\n@@ -953,0 +1020,2 @@\n+    __ sve_uzp1(z19, __ H, z2, z8);                    \/\/       uzp1    z19.h, z2.h, z8.h\n+    __ sve_uzp2(z14, __ D, z24, z17);                  \/\/       uzp2    z14.d, z24.d, z17.d\n@@ -955,9 +1024,9 @@\n-    __ sve_andv(v19, __ H, p0, z8);                    \/\/       andv h19, p0, z8.h\n-    __ sve_orv(v14, __ D, p6, z17);                    \/\/       orv d14, p6, z17.d\n-    __ sve_eorv(v21, __ B, p1, z30);                   \/\/       eorv b21, p1, z30.b\n-    __ sve_smaxv(v10, __ B, p5, z12);                  \/\/       smaxv b10, p5, z12.b\n-    __ sve_sminv(v9, __ S, p1, z24);                   \/\/       sminv s9, p1, z24.s\n-    __ sve_fminv(v4, __ S, p6, z6);                    \/\/       fminv s4, p6, z6.s\n-    __ sve_fmaxv(v27, __ D, p6, z13);                  \/\/       fmaxv d27, p6, z13.d\n-    __ sve_fadda(v30, __ D, p5, z22);                  \/\/       fadda d30, p5, d30, z22.d\n-    __ sve_uaddv(v30, __ H, p7, z9);                   \/\/       uaddv d30, p7, z9.h\n+    __ sve_andv(v21, __ B, p1, z30);                   \/\/       andv b21, p1, z30.b\n+    __ sve_orv(v10, __ B, p5, z12);                    \/\/       orv b10, p5, z12.b\n+    __ sve_eorv(v9, __ S, p1, z24);                    \/\/       eorv s9, p1, z24.s\n+    __ sve_smaxv(v4, __ H, p6, z6);                    \/\/       smaxv h4, p6, z6.h\n+    __ sve_sminv(v27, __ S, p6, z13);                  \/\/       sminv s27, p6, z13.s\n+    __ sve_fminv(v30, __ D, p5, z22);                  \/\/       fminv d30, p5, z22.d\n+    __ sve_fmaxv(v30, __ S, p7, z9);                   \/\/       fmaxv s30, p7, z9.s\n+    __ sve_fadda(v19, __ D, p1, z20);                  \/\/       fadda d19, p1, d19, z20.d\n+    __ sve_uaddv(v9, __ H, p2, z13);                   \/\/       uaddv d9, p2, z13.h\n@@ -982,7 +1051,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400030d,     0x94000000,\n-    0x97ffffd4,     0x9400030a,     0x3400000a,     0x34fffa2a,\n-    0x340060ea,     0x35000008,     0x35fff9c8,     0x35006088,\n-    0xb400000b,     0xb4fff96b,     0xb400602b,     0xb500001d,\n-    0xb5fff91d,     0xb5005fdd,     0x10000013,     0x10fff8b3,\n-    0x10005f73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36305ef6,     0x3758000c,     0x375ff7cc,     0x37585e8c,\n+    0x14000000,     0x17ffffd7,     0x14000352,     0x94000000,\n+    0x97ffffd4,     0x9400034f,     0x3400000a,     0x34fffa2a,\n+    0x3400698a,     0x35000008,     0x35fff9c8,     0x35006928,\n+    0xb400000b,     0xb4fff96b,     0xb40068cb,     0xb500001d,\n+    0xb5fff91d,     0xb500687d,     0x10000013,     0x10fff8b3,\n+    0x10006813,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36306796,     0x3758000c,     0x375ff7cc,     0x3758672c,\n@@ -993,13 +1062,13 @@\n-    0x54005c60,     0x54000001,     0x54fff541,     0x54005c01,\n-    0x54000002,     0x54fff4e2,     0x54005ba2,     0x54000002,\n-    0x54fff482,     0x54005b42,     0x54000003,     0x54fff423,\n-    0x54005ae3,     0x54000003,     0x54fff3c3,     0x54005a83,\n-    0x54000004,     0x54fff364,     0x54005a24,     0x54000005,\n-    0x54fff305,     0x540059c5,     0x54000006,     0x54fff2a6,\n-    0x54005966,     0x54000007,     0x54fff247,     0x54005907,\n-    0x54000008,     0x54fff1e8,     0x540058a8,     0x54000009,\n-    0x54fff189,     0x54005849,     0x5400000a,     0x54fff12a,\n-    0x540057ea,     0x5400000b,     0x54fff0cb,     0x5400578b,\n-    0x5400000c,     0x54fff06c,     0x5400572c,     0x5400000d,\n-    0x54fff00d,     0x540056cd,     0x5400000e,     0x54ffefae,\n-    0x5400566e,     0x5400000f,     0x54ffef4f,     0x5400560f,\n+    0x54006500,     0x54000001,     0x54fff541,     0x540064a1,\n+    0x54000002,     0x54fff4e2,     0x54006442,     0x54000002,\n+    0x54fff482,     0x540063e2,     0x54000003,     0x54fff423,\n+    0x54006383,     0x54000003,     0x54fff3c3,     0x54006323,\n+    0x54000004,     0x54fff364,     0x540062c4,     0x54000005,\n+    0x54fff305,     0x54006265,     0x54000006,     0x54fff2a6,\n+    0x54006206,     0x54000007,     0x54fff247,     0x540061a7,\n+    0x54000008,     0x54fff1e8,     0x54006148,     0x54000009,\n+    0x54fff189,     0x540060e9,     0x5400000a,     0x54fff12a,\n+    0x5400608a,     0x5400000b,     0x54fff0cb,     0x5400602b,\n+    0x5400000c,     0x54fff06c,     0x54005fcc,     0x5400000d,\n+    0x54fff00d,     0x54005f6d,     0x5400000e,     0x54ffefae,\n+    0x54005f0e,     0x5400000f,     0x54ffef4f,     0x54005eaf,\n@@ -1037,1 +1106,1 @@\n-    0xbd1b1869,     0x5800465b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x58004efb,     0x1800000b,     0xf8945060,\n@@ -1125,8 +1194,11 @@\n-    0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,     0x0470e7e1,\n-    0x042f9c20,     0x043f9c35,     0x047f9c20,     0x04ff9c20,\n-    0x04299420,     0x04319160,     0x0461943e,     0x04a19020,\n-    0x042053ff,     0x047f5401,     0x25208028,     0x2538cfe0,\n-    0x2578d001,     0x25b8efe2,     0x25f8f007,     0x05203864,\n-    0x05603ace,     0xa400a3e0,     0xa4a8a7ea,     0xa547a814,\n-    0xa4084ffe,     0xa55c53e0,     0xa5e1540b,     0xe400fbf6,\n-    0xe408ffff,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0x4cc0ac3f,     0x05a08020,     0x05104fe0,     0x05505001,\n+    0x05906fe2,     0x05d03005,     0x05101fea,     0x05901feb,\n+    0x04b0e3e0,     0x0470e7e1,     0x042f9c20,     0x043f9c35,\n+    0x047f9c20,     0x04ff9c20,     0x04299420,     0x04319160,\n+    0x0461943e,     0x04a19020,     0x042053ff,     0x047f5401,\n+    0x25208028,     0x2538cfe0,     0x2578d001,     0x25b8efe2,\n+    0x25f8f007,     0x2538dfea,     0x25b8dfeb,     0xa400a3e0,\n+    0xa420a7e0,     0xa4484be0,     0xa467afe0,     0xa4a8a7ea,\n+    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n+    0xe400fbf6,     0xe408ffff,     0xe420e7e0,     0xe4484be0,\n+    0xe460efe0,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n@@ -1135,43 +1207,58 @@\n-    0x25104042,     0x25104871,     0x252c8840,     0x253c1420,\n-    0x25681572,     0x25a21ce3,     0x25ea1e34,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8208193,\n-    0xf83101b6,     0xf83c13fe,     0xf821239a,     0xf824309e,\n-    0xf826535e,     0xf8304109,     0xf82c7280,     0xf8216058,\n-    0xf8a08309,     0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,\n-    0xf8a2310b,     0xf8aa522f,     0xf8a2418a,     0xf8ac71af,\n-    0xf8a26287,     0xf8fa8090,     0xf8e20184,     0xf8f01215,\n-    0xf8f022ab,     0xf8f7334c,     0xf8f751dc,     0xf8eb4038,\n-    0xf8ec715f,     0xf8f06047,     0xf863826d,     0xf8710070,\n-    0xf86113cb,     0xf86521e8,     0xf87d301e,     0xf8745287,\n-    0xf87742bc,     0xf87b70b9,     0xf8616217,     0xb83f8185,\n-    0xb82901fc,     0xb83d13f6,     0xb83320bf,     0xb82e33f0,\n-    0xb830529b,     0xb830416c,     0xb82973c6,     0xb831639b,\n-    0xb8be8147,     0xb8b4008a,     0xb8b81231,     0xb8b623a3,\n-    0xb8af3276,     0xb8b35056,     0xb8af4186,     0xb8b071ab,\n-    0xb8b763c1,     0xb8f38225,     0xb8e202d0,     0xb8ed12aa,\n-    0xb8fd219b,     0xb8fb3023,     0xb8ff5278,     0xb8f14389,\n-    0xb8fb70ef,     0xb8f563f7,     0xb87983e2,     0xb87b0150,\n-    0xb8771073,     0xb8702320,     0xb87a3057,     0xb870508c,\n-    0xb87c43be,     0xb87070db,     0xb86961fd,     0xce273c87,\n-    0xce080ac9,     0xce7e8e9b,     0xce808b45,     0xce79806e,\n-    0xce758768,     0xcec0835a,     0xce608ad8,     0x043100c4,\n-    0x046105e3,     0x65c900a6,     0x65d60a87,     0x65c80545,\n-    0x0416a63e,     0x04001f8b,     0x0450979a,     0x04dabe0d,\n-    0x045381a5,     0x04918b4f,     0x049006cb,     0x0497a264,\n-    0x045eadd1,     0x04881062,     0x040a04d7,     0x04810f71,\n-    0x04dca450,     0x65c084c3,     0x65cd8d93,     0x65c69a68,\n-    0x65878ae0,     0x65c29db3,     0x049da0e6,     0x6582b911,\n-    0x65c0b6d6,     0x65c1a1e2,     0x65cda494,     0x65c18107,\n-    0x65af1493,     0x65e52b36,     0x65ab4ed0,     0x65f06a8d,\n-    0x0451448f,     0x049c7c86,     0x0429335d,     0x04bc3162,\n-    0x047a3027,     0x04e831d1,     0x2493b8a5,     0x249d9604,\n-    0x24d18095,     0x24d7b491,     0x045a2113,     0x04d83a2e,\n-    0x041927d5,     0x0408358a,     0x048a2709,     0x658738c4,\n-    0x65c639bb,     0x65d836de,     0x04413d3e,\n+    0x25104042,     0x25104871,     0x25904861,     0x25904c92,\n+    0x05344020,     0x05744041,     0x05b44062,     0x05f44083,\n+    0x252c8840,     0x253c1420,     0x25681572,     0x25a21ce3,\n+    0x25ea1e34,     0x0522c020,     0x05e6c0a4,     0x2401a001,\n+    0x2443a051,     0x24858881,     0x24c78cd1,     0x240b8142,\n+    0x24918213,     0x250f9001,     0x25508051,     0x25802491,\n+    0x25df28c1,     0x25850c81,     0x251e10d1,     0x65816001,\n+    0x65c36051,     0x65854891,     0x65c74cc1,     0x658b4152,\n+    0x65d14203,     0x05733820,     0x05b238a4,     0x05f138e6,\n+    0x0570396a,     0x65d0a001,     0x65d6a443,     0x65d4a826,\n+    0x6594ac26,     0x6554ac26,     0x6556ac26,     0x6552ac26,\n+    0x65cbac85,     0x65caac01,     0x65dea833,     0x659ca509,\n+    0x65d8a801,     0x65dcac01,     0x655cb241,     0x0520a1e0,\n+    0x0521a601,     0x052281e0,     0x05238601,     0x04a14026,\n+    0x0568aca7,     0x05b23230,     0x853040af,     0xc5b040af,\n+    0xe57080af,     0xe5b080af,     0x1e601000,     0x1e603000,\n+    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n+    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n+    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n+    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n+    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n+    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n+    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n+    0x1e7e1000,     0x1e7e3000,     0xf8208193,     0xf83101b6,\n+    0xf83c13fe,     0xf821239a,     0xf824309e,     0xf826535e,\n+    0xf8304109,     0xf82c7280,     0xf8216058,     0xf8a08309,\n+    0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,\n+    0xf8aa522f,     0xf8a2418a,     0xf8ac71af,     0xf8a26287,\n+    0xf8fa8090,     0xf8e20184,     0xf8f01215,     0xf8f022ab,\n+    0xf8f7334c,     0xf8f751dc,     0xf8eb4038,     0xf8ec715f,\n+    0xf8f06047,     0xf863826d,     0xf8710070,     0xf86113cb,\n+    0xf86521e8,     0xf87d301e,     0xf8745287,     0xf87742bc,\n+    0xf87b70b9,     0xf8616217,     0xb83f8185,     0xb82901fc,\n+    0xb83d13f6,     0xb83320bf,     0xb82e33f0,     0xb830529b,\n+    0xb830416c,     0xb82973c6,     0xb831639b,     0xb8be8147,\n+    0xb8b4008a,     0xb8b81231,     0xb8b623a3,     0xb8af3276,\n+    0xb8b35056,     0xb8af4186,     0xb8b071ab,     0xb8b763c1,\n+    0xb8f38225,     0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,\n+    0xb8fb3023,     0xb8ff5278,     0xb8f14389,     0xb8fb70ef,\n+    0xb8f563f7,     0xb87983e2,     0xb87b0150,     0xb8771073,\n+    0xb8702320,     0xb87a3057,     0xb870508c,     0xb87c43be,\n+    0xb87070db,     0xb86961fd,     0xce273c87,     0xce080ac9,\n+    0xce7e8e9b,     0xce808b45,     0xce79806e,     0xce758768,\n+    0xcec0835a,     0xce608ad8,     0x043100c4,     0x046105e3,\n+    0x65c900a6,     0x65d60a87,     0x65c80545,     0x0416a63e,\n+    0x04001f8b,     0x0450979a,     0x04dabe0d,     0x045381a5,\n+    0x04918b4f,     0x049006cb,     0x0497a264,     0x045eadd1,\n+    0x04881062,     0x040a04d7,     0x04810f71,     0x04dca450,\n+    0x65c084c3,     0x65cd8d93,     0x65c69a68,     0x65878ae0,\n+    0x65c29db3,     0x049da0e6,     0x6582b911,     0x65c0b6d6,\n+    0x65c1a1e2,     0x65cda494,     0x65c18107,     0x65af1493,\n+    0x65e52b36,     0x65ab4ed0,     0x65f06a8d,     0x0451448f,\n+    0x049c7c86,     0x0429335d,     0x04bc3162,     0x047a3027,\n+    0x04e831d1,     0x2493b8a5,     0x249d9604,     0x24d18095,\n+    0x24d7b491,     0x05686853,     0x05f16f0e,     0x041a27d5,\n+    0x0418358a,     0x04992709,     0x044838c4,     0x048a39bb,\n+    0x65c736de,     0x65863d3e,     0x65d82693,     0x044129a9,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":170,"deletions":83,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test if memory ordering is preserved\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileThreshold=100 -XX:CompileCommand=dontinline,compiler.vectorapi.VectorMemoryAlias::test\n+ *      compiler.vectorapi.VectorMemoryAlias\n+ * @modules jdk.incubator.vector\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+public class VectorMemoryAlias {\n+  public static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+  public static void main(String[] args) {\n+    for (int i=0; i < 30000; i++) {\n+      if (test() != 1) {\n+        throw new AssertionError();\n+      }\n+    }\n+  }\n+\n+  public static int test() {\n+    byte arr[] = new byte[256];\n+    final var bb = ByteBuffer.wrap(arr);\n+    final var ones = ByteVector.broadcast(SPECIES, 1);\n+    var res = ByteVector.zero(SPECIES);\n+\n+    int result = 0;\n+    result += arr[2];\n+    res.add(ones).intoByteBuffer(bb, 0, ByteOrder.nativeOrder());\n+    result += arr[2];\n+\n+    return result;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+% Benchmarking Vector API\n+\n+Benchmarks are generted from scripts in this directory to `test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation`\n+\n+## Test selection\n+Run benchmarks from the top level git dir using:\n+\n+``` shell\n+make test TEST=\"micro:<benchmark-name>\" CONF=linux-x86_64-server-release\n+\n+### One Test\n+make test TEST=\"micro:Int64Vector\" CONF=linux-x86_64-server-release\n+\n+### Run all tests -- WARNING requires ~4-5 hours\n+make test TEST=\"micro:org.openjdk.bench.jdk.incubator.vector\" CONF=linux-x86_64-server-release\n+```\n+\n+### JMH Configuration\n+See `https:\/\/github.com\/openjdk\/jdk\/blob\/master\/doc\/testing.md` or `doc\/testing.md` dir in this git repo for more detailed steps on running the benchmarks for Vector API at `test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation`.\n+\n+From doc\/testing.md:\n+To be able to run microbenchmarks, `configure` needs to know where to find the\n+JMH dependency. Use `--with-jmh=<path to JMH jars>` to point to a directory\n+containing the core JMH and transitive dependencies. The recommended\n+dependencies can be retrieved by running `sh make\/devkit\/createJMHBundle.sh`,\n+after which `--with-jmh=build\/jmh\/jars` should work.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BENCHMARKS.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -27,2 +27,2 @@\n-VECTORTESTS_HOME=\"$(pwd)\"\n-JDK_SRC_HOME=\".\/..\/..\/..\/..\/..\/\"\n+JDK_SRC_HOME=\"$(git rev-parse --show-toplevel)\"\n+VECTORTESTS_HOME=\"$JDK_SRC_HOME\/test\/jdk\/jdk\/incubator\/vector\/\"\n@@ -41,1 +41,0 @@\n-TEST_ITER_COUNT=100\n@@ -45,1 +44,2 @@\n-PERF_DEST=\"benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/\"\n+PERF_DEST=\"$JDK_SRC_HOME\/test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/config.sh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -264,1 +264,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+\n+    @Benchmark\n+    public Object [[TEST]][[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.[[TEST]], bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Compare.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.max(ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-Max-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.min(ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-Min-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.max(ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Max-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$)Math.min(ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Min-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]]);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)([[TEST_OP]]);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-Masked-op.template","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-op-math.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Blend-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < ms.length; i++) {\n+                r [[TEST_OP]]= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-BoolReduction-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+    void broadcastShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Broadcast.template","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= [[TEST_OP]](as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Compare.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        gather(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Gather-op.template","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+    void rearrangeShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    $type$ a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Rearrange.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = ($type$)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-Max-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = ($type$)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-Min-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r [[TEST_OP]]= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r = ($type$)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Max-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r = ($type$)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Min-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r [[TEST_OP]]= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        scatter(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Scatter-op.template","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Masked-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)([[TEST_OP]]);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Ternary-Masked-op.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Ternary-op.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= ([[TEST_OP]]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Test.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-Masked-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-math.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op-math.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = ($type$)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Zero.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-footer.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","status":"copied"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $Type$Scalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static $bitstype$ bits($type$ e) {\n+        return {#if[FP]?$Type$.$type$To$Bitstype$Bits(e):e};\n+    }\n+\n+    $type$[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> ($type$)(2*i));\n+        bs = fill(i -> ($type$)(i+1));\n+        cs = fill(i -> ($type$)(i+5));\n+        rs = fill(i -> ($type$)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> as;\n+    final IntFunction<$type$[]> fb = vl -> bs;\n+    final IntFunction<$type$[]> fc = vl -> cs;\n+    final IntFunction<$type$[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+\n+    @Benchmark\n+    public Object [[TEST]][[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.[[TEST]]));\n+            }\n+        }\n+\n+        return m;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Test.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-footer.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","status":"copied"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.$Type$Vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $vectorbenchtype$ extends AbstractVectorBenchmark {\n+#if[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_MAX;\n+#else[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_$bits$;\n+#end[MaxBit]\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+#if[BITWISE]\n+    static void replaceZero($type$[] a, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero($type$[] a, boolean[] mask, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+#end[BITWISE]\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    $type$[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> ($type$)(2*i));\n+        b = fill(i -> ($type$)(i+1));\n+        c = fill(i -> ($type$)(i+5));\n+        r = fill(i -> ($type$)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> a;\n+    final IntFunction<$type$[]> fb = vl -> b;\n+    final IntFunction<$type$[]> fc = vl -> c;\n+    final IntFunction<$type$[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-wrapper.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  ByteBuffer directInRo, directOutRo;\n+  ByteBuffer heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+\n+    directInRo = directIn.asReadOnlyBuffer();\n+    directOutRo = directOut.asReadOnlyBuffer();\n+\n+    heapInRo = heapIn.asReadOnlyBuffer();\n+    heapOutRo = heapOut.asReadOnlyBuffer();\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers2() {\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers3() {\n+    copyIntoNotInlined(directIn, directOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(directInRo, directOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers4() {\n+    copyIntoNotInlined(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, directOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedBuffers5() {\n+    copyIntoNotInlined(directIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, directIn);\n+    copyIntoNotInlined(heapIn, directOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyIntoNotInlined(heapIn, directOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = heapIn.array();\n+    byte[] out = heapOut.array();\n+\n+    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyIntoNotInlined(ByteBuffer in, ByteBuffer out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class BooleanArrayCheck {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_PREFERRED;\n+\n+  private boolean[] bitsArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"SPECIES's length: \" + SPECIES.length());\n+\n+    bitsArray = new boolean[ARRAY_LENGTH];\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      bitsArray[i] = true;\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll_vec() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos += SPECIES.length()) {\n+      VectorMask<Byte> mask = VectorMask.fromArray(SPECIES, bitsArray, filterPos);\n+      if (!mask.allTrue()) {\n+        return false;\n+      }\n+    }\n+\n+    for (filterPos -= SPECIES.length(); filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/BooleanArrayCheck.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ValueRangeCheckAndCastL2I {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  private long min = Integer.MIN_VALUE;\n+  private long max = Integer.MAX_VALUE;\n+\n+  private static final VectorSpecies<Long> LONG_SPECIES =\n+    LongVector.SPECIES_PREFERRED;\n+  private static final VectorSpecies<Integer> INT_SPECIES =\n+    VectorSpecies.of(int.class, VectorShape.forBitSize(LONG_SPECIES.vectorBitSize() \/ 2));\n+\n+  private int[] intResult;\n+  private long[] longArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"LONG_SPECIES's length: \" + LONG_SPECIES.length());\n+    System.out.println(\"INT_SPECIES's length: \" + INT_SPECIES.length());\n+    System.out.println(\"Min is: \" + min + \". Max is: \" + max);\n+\n+    longArray = new long[ARRAY_LENGTH];\n+    intResult = new int[ARRAY_LENGTH];\n+\n+    Random rand = new Random();\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      intResult[i] = 0;\n+      longArray[i] = rand.nextInt(Integer.MAX_VALUE);\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I() {\n+    for (int i = 0; i < longArray.length; i++) {\n+      if (longArray[i] >= min && longArray[i] <= max) {\n+        intResult[i] = (int)(longArray[i]);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I_vec() {\n+    for (int i = 0; i < longArray.length; i += LONG_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_SPECIES, longArray, i);\n+      if (av.compare(VectorOperators.GE, min).and(av.compare(VectorOperators.LE, max)).allTrue()) {\n+        ((IntVector) av.castShape(INT_SPECIES, 0)).intoArray(intResult, i);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/ValueRangeCheckAndCastL2I.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,583 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorDistance {\n+\n+    static final VectorSpecies<Float> SPECIES_FLOAT_128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_256 = FloatVector.SPECIES_256;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_MAX = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_256 = DoubleVector.SPECIES_256;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_MAX = DoubleVector.SPECIES_MAX;\n+\n+\n+    static long num = 0;\n+    private static String x1 = \"L5GSwXhHpEH05mNBHnmcQMTw3EBnagFCW1DGQHe\/nUFO1B1BlJOpwCBJ9j\" +\n+                \"+RkY1BzqKeQSglN0Gy7krB5CSfQFzxB8Djn5nB2KNFwKcSRMGYzRQ7qMGWQZ0FF0FTceDAIKjxv\/zhdkHFZMHB6hU4QZbo2cCAryRB+7OOQCxbfEHRtBlBxPG6P0BYSD+Pgz9BqzOLv\/nVO8C9x5\/BQOY\/wTTIx0GfW1BBGv2lQQwdDcGCqBfB12t\/QKUBoEEejIXBPN9kQWsFbEGsGcnBkqJkwKhLgr\/IQZxAelAWQfcYpcFQv0HBeiGCQWExhEDrKAnBpAwBQV4bVcFpGNjAyDsNQVOc+0CSc4nBgG\/ZQQGRccEXts9BKhYzQNK5+MAlU0DBzPGWwPGRCcEZC5\/ADxOcv7lUkEBomM5BuqKiwV2MU8HNGHDBSB84QZRSyMB8RZlBVFdZQXSVgcBTQQBCdWa\/QBQ0qkGILUW\/6NA9QQnkmsG+5PPBj0UowT6nYD9cwpjAS\/w5wTbX2UH8Gb5AR\/HUQMTNAMJ9MN9AgHoqPbbUyUFbe47BBHANQWZJBsGBuPlBy94EQADeXsG5eOtBnA+yQCRka8EMcGLBjuoRwb4k7sAasB5Bmk\/UwaI1akErp6xBq5G5wNo1E8KHa7tB3IiKQTCffcHphK1BTgJzwVY3JEEip\/VAlmgXQSeKCsLEABs\/n1\/xwL5u58CgQY49ahUWQoAJjj1hhqBASXrrQb6nM0H2fY+\/thtbQAQobMAohvXAxM3xv7xyqD+MvpDBrlDiQfBvPcGA8X5AQE4SwXhGx7+uLA1AxY8xu2mVjEE7KlFBArveQFNMtUD3N7DB12BbQcyH4cFhSw3Bu5VWQeTW0z9o03TBxtMlQctp\/8E\/lLVAGUtTwZsGJMKv\/R5A1HKVQV6RhsC1Ji5AcXLFQJd6f0HbB+e+ZDi8wV9tQ0FwCN\/B+A89v2DrU0Bcpc5BglTeQH5dT0HePS9Al4XPwdA6YEFlueXAbWKSQSBWzkBy2RnCt9Yawl9b77+xgxBC9eCqQd8f0kFoBG9BVxrkQZh2QkHNW\/zBEQiawLJEocDhutTA8zEYwbIvEUIO1T9BmlOTwIhbNEDhrtlAVk9BQARQaj89NQNC6usGwDfQrkBSJrlAON7FQQ8FqsEEc\/TAY3zeQYsqUEHV8QPBHJoYQQdn5kGyCiJBlDMYQBBNoUFrxbw\/NlmPP3B24j6ChIdBXk2bwdxdDMFQw1rA4hybQXTchr8d9wvBuCbLQSMKmMBH4RpBQIXePa5DT8IjgvtBgAetQZgGgMEprc1BAOeSPJ5XpEEMa0NBgX4uwX7XIsG2Ie0688iqQSpJPsCAy9LBAGHkPw==\";\n+    private static String x2 = \"5R3ZwGPrxEFMKyNBLFSeQdYav0BQtDFCur7WQAgRYEGHFYC\/MKZtvkiFUT+RNXfBVsGBP2KWSUCmAUTBIf+EQG57kMCtXo7BV1DuwLd98r+YzRQ7qKXNwBMSPUFNQffBPrxeQYw1t7\/7JjFAKNaXP+cMSEG6GI5BuEx0wUANDMEvDqdAT9YEworQTEEiVBZBiMejQP7t67+iRwzB3HadQB1be0Ei5g5BMt+cQXvYTUHwZsLAuoy3QfrR6EFrIiHB5X8Dwc8XbUH8Yr8\/AvGEwa5GkUH3F5tAP8YJQTiDyz+gKsRAFl\/rwDxJuUAPyyxBvg2gQU6bjMEPEa7Bz6wYQpQy7MDF5LvB8HP+QCJdicHQDjpC6RpWQcGeY8FMK6vBoeUjQcPYmUG2QmRBBI0nwScESsGMAcxBvRmawRL2A8IByKNAgTQBQuxdDEGq8JBBHJWmQSBDfz8sLe9BE3gFwTdCPkHEaMxBhX8Xwe7BCcE\/783Bt6EHwdpbpkHc5L\/BCPzRwUdIQUEd\/k3AoGNcQQwNmMEyuKRBtnWlwdCBAUI5Y5DBwOZYvdI+MsEu\/ixBnpMrwRtYt8FECytC6JjEQW3RHcBtfn3B+sgQQcyQKcEI5ytByvw2wPZdaUH+aqLAQFQ+QPi4REBF\/9lBCvJNQTdlEcIAMbzBtD+hwZWufsAEjus\/YRyjwR1YuMHj0ZhBa4w+QORAhMEq9qdB\/L8JQrjhyUAJBeBAKqoIQUnAq0GsLFdBkfrvQHc1zMHH6THBeggSwaJIOsAawwBBDDWqPwrAlkBYDqe\/maUcQabhwsFF2VBBxY8xu5aMQUFDkHVBKhRRwHhgWsEA5jXBlh9NQVMaT0CWlhTAroaFQRyciUHQlp7BF4trQa8unsE4TfI+9XLJQDNpLcIXLZdAuX2MwShiTsFcQh5BrHMqQVI1+UBWe4fBAzi0wfe11UFAIjq9Y1iAQDxrTsEY6plB\/JiXQfjFwkHkYGRBVNOhwCMxtEFbqZTA378WQeA\/Sb+FrSXCqlYywtb5SsDcqlZBk1EtQZ\/RREHZIxG\/kcv8QekDIkHPsDXCBL4VQHN8CMGtNvvAC3YwweUuAkKkJCnANEtVQG9z\/0DrwyTBQ9hnwWX3kMEdLB1CvIlKwQ0IO0HK1ErBvdRQQVpjMMCJDI\/Bb4X8QYVipEGpG2nBeLGUvmBlBT7ISgRB4iGAQUunkkFDFLm\/HNaqPzKTVkCITJG\/XzlYwbj0XcGD60PBbpLwQbvrs8Az8RXB4ubxQXh\/HEDtXLU\/kONrwVBs4MGc2X1BJaHkQd0ByEAKXLJBTq7JwPPkJUGJIIRBlh57wX3FjcC2Ie060Qc6Qal5xcCfqQrCl7edQQ==\";\n+    static float[] queryVectorFloat = parseBase64ToVector(x1);\n+    static float[] inputVectorFloat = parseBase64ToVector(x2);\n+    static double[] queryVectorDouble;\n+    static double[] inputVectorDouble;\n+\n+    static float normQueryVectorFloat;\n+    static double normQueryVectorDouble;\n+\n+    public static float[] parseArray(byte[] input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        float[] floatArr = new float[input.length \/ 4];\n+        for (int i = 0; i < floatArr.length; i++) {\n+            int l;\n+            l = input[i << 2];\n+            l &= 0xff;\n+            l |= ((long) input[(i << 2) + 1] << 8);\n+            l &= 0xffff;\n+            l |= ((long) input[(i << 2) + 2] << 16);\n+            l &= 0xffffff;\n+            l |= ((long) input[(i << 2) + 3] << 24);\n+            floatArr[i] = Float.intBitsToFloat(l);\n+        }\n+        return floatArr;\n+    }\n+\n+    public static float[] parseBase64ToVector(String vectorBase64) {\n+        return parseArray(Base64.getDecoder().decode(vectorBase64));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        queryVectorDouble = new double[queryVectorFloat.length];\n+        inputVectorDouble = new double[inputVectorFloat.length];\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            queryVectorDouble[i] = (double)(queryVectorFloat[i]);\n+        }\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            inputVectorDouble[i] = (double)(inputVectorFloat[i]);\n+        }\n+        float xSquare = 0;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            xSquare += (float)(queryVectorFloat[i] * queryVectorFloat[i]);\n+        }\n+        normQueryVectorFloat = xSquare;\n+        normQueryVectorDouble = (double)xSquare;\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normQueryVectorFloat = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedScalarDouble() {\n+        double dotProduct = 0.0;\n+        double normInputVector = 0.0;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return dotProduct \/ (Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilScalarDouble() {\n+        double dotProduct = 0.0f;\n+        double normQueryVectorDouble = 0.0f;\n+        double normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    \/\/ l2Squared is used to compute Euclidean distance\n+    @Benchmark\n+    public float l2SquaredVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredScalar() {\n+        float squaredDistance = 0;\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            squaredDistance += diff * diff;\n+        }\n+        return squaredDistance;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/VectorDistance.java","additions":583,"deletions":0,"binary":false,"changes":583,"status":"added"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+  \n+package org.openjdk.bench.jdk.incubator.vector.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class ChaChaBench {\n+\n+    @Param({\"16384\", \"65536\"})\n+    private int dataSize;\n+    \n+    private ChaChaVector cc20_S128 = makeCC20(VectorShape.S_128_BIT);\n+    private ChaChaVector cc20_S256 = makeCC20(VectorShape.S_256_BIT);\n+    private ChaChaVector cc20_S512 = makeCC20(VectorShape.S_512_BIT);\n+ \n+    private byte[] in;\n+    private byte[] out;\n+    \n+    private byte[] key = new byte[32];\n+    private byte[] nonce = new byte[12];\n+    private long counter = 0;\n+\n+    private static ChaChaVector makeCC20(VectorShape shape) {\n+        ChaChaVector cc20 = new ChaChaVector(shape);\n+        runKAT(cc20);\n+        return cc20;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        \n+        in = new byte[dataSize];\n+        out = new byte[dataSize];\n+    }\n+\n+    @Benchmark\n+    public void encrypt128() {\n+        cc20_S128.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    @Benchmark\n+    public void encrypt256() {\n+        cc20_S256.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    @Benchmark\n+    public void encrypt512() {\n+        cc20_S512.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    private static class ChaChaVector {\n+\n+        private static final int[] STATE_CONSTANTS =\n+            new int[]{0x61707865, 0x3320646e, 0x79622d32, 0x6b206574};\n+\n+        private final VectorSpecies<Integer> intSpecies;\n+        private final int numBlocks;\n+\n+        private final VectorShuffle<Integer> rot1;\n+        private final VectorShuffle<Integer> rot2;\n+        private final VectorShuffle<Integer> rot3;\n+\n+        private final IntVector counterAdd;\n+\n+        private final VectorShuffle<Integer> shuf0;\n+        private final VectorShuffle<Integer> shuf1;\n+        private final VectorShuffle<Integer> shuf2;\n+        private final VectorShuffle<Integer> shuf3;\n+\n+        private final VectorMask<Integer> mask0;\n+        private final VectorMask<Integer> mask1;\n+        private final VectorMask<Integer> mask2;\n+        private final VectorMask<Integer> mask3;\n+\n+        private final int[] state;\n+\n+        public ChaChaVector(VectorShape shape) {\n+            this.intSpecies = VectorSpecies.of(int.class, shape);\n+            this.numBlocks = intSpecies.length() \/ 4;\n+\n+            this.rot1 = makeRotate(1);\n+            this.rot2 = makeRotate(2);\n+            this.rot3 = makeRotate(3);\n+\n+            this.counterAdd = makeCounterAdd();\n+\n+            this.shuf0 = makeRearrangeShuffle(0);\n+            this.shuf1 = makeRearrangeShuffle(1);\n+            this.shuf2 = makeRearrangeShuffle(2);\n+            this.shuf3 = makeRearrangeShuffle(3);\n+\n+            this.mask0 = makeRearrangeMask(0);\n+            this.mask1 = makeRearrangeMask(1);\n+            this.mask2 = makeRearrangeMask(2);\n+            this.mask3 = makeRearrangeMask(3);\n+\n+            this.state = new int[numBlocks * 16];\n+        }\n+\n+        private VectorShuffle<Integer>  makeRotate(int amount) {\n+            int[] shuffleArr = new int[intSpecies.length()];\n+\n+            for (int i = 0; i < intSpecies.length(); i ++) {\n+                int offset = (i \/ 4) * 4;\n+                shuffleArr[i] = offset + ((i + amount) % 4);\n+            }\n+\n+            return VectorShuffle.fromValues(intSpecies, shuffleArr);\n+        }\n+\n+        private IntVector makeCounterAdd() {\n+            int[] addArr = new int[intSpecies.length()];\n+            for(int i = 0; i < numBlocks; i++) {\n+                addArr[4 * i] = numBlocks;\n+            }\n+            return IntVector.fromArray(intSpecies, addArr, 0);\n+        }\n+\n+        private VectorShuffle<Integer>  makeRearrangeShuffle(int order) {\n+            int[] shuffleArr = new int[intSpecies.length()];\n+            int start = order * 4;\n+            for (int i = 0; i < shuffleArr.length; i++) {\n+                shuffleArr[i] = (i % 4) + start;\n+            }\n+            return VectorShuffle.fromArray(intSpecies, shuffleArr, 0);\n+        }\n+\n+        private VectorMask<Integer> makeRearrangeMask(int order) {\n+            boolean[] maskArr = new boolean[intSpecies.length()];\n+            int start = order * 4;\n+            if (start < maskArr.length) {\n+                for (int i = 0; i < 4; i++) {\n+                    maskArr[i + start] = true;\n+                }\n+            }\n+\n+            return VectorMask.fromValues(intSpecies, maskArr);\n+        }\n+\n+        public void makeState(byte[] key, byte[] nonce, long counter,\n+            int[] out) {\n+\n+            \/\/ first field is constants\n+            for (int i = 0; i < 4; i++) {\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[4*j + i] = STATE_CONSTANTS[i];\n+                }\n+            }\n+\n+            \/\/ second field is first part of key\n+            int fieldStart = 4 * numBlocks;\n+            for (int i = 0; i < 4; i++) {\n+                int keyInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    keyInt += (0xFF & key[4 * i + j]) << 8 * j;\n+                }\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + i] = keyInt;\n+                }\n+            }\n+\n+            \/\/ third field is second part of key\n+            fieldStart = 8 * numBlocks;\n+            for (int i = 0; i < 4; i++) {\n+                int keyInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    keyInt += (0xFF & key[4 * (i + 4) + j]) << 8 * j;\n+                }\n+\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + i] = keyInt;\n+                }\n+            }\n+\n+            \/\/ fourth field is counter and nonce\n+            fieldStart = 12 * numBlocks;\n+            for (int j = 0; j < numBlocks; j++) {\n+                out[fieldStart + j*4] = (int) (counter + j);\n+            }\n+\n+            for (int i = 0; i < 3; i++) {\n+                int nonceInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    nonceInt += (0xFF & nonce[4 * i + j]) << 8 * j;\n+                }\n+\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + 1 + i] = nonceInt;\n+                }\n+            }\n+        }\n+\n+        public void chacha20(byte[] key, byte[] nonce, long counter,\n+            byte[] in, byte[] out) {\n+\n+            makeState(key, nonce, counter, state);\n+\n+            int len = intSpecies.length();\n+\n+            IntVector sa = IntVector.fromArray(intSpecies, state, 0);\n+            IntVector sb = IntVector.fromArray(intSpecies, state, len);\n+            IntVector sc = IntVector.fromArray(intSpecies, state, 2 * len);\n+            IntVector sd = IntVector.fromArray(intSpecies, state, 3 * len);\n+\n+            int stateLenBytes = state.length * 4;\n+            int numStates = (in.length + stateLenBytes - 1) \/ stateLenBytes;\n+            for (int j = 0; j < numStates; j++){\n+\n+                IntVector a = sa;\n+                IntVector b = sb;\n+                IntVector c = sc;\n+                IntVector d = sd;\n+\n+                for (int i = 0; i < 10; i++) {\n+                    \/\/ first round\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL, 16);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,12);\n+\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,8);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,7);\n+\n+                    \/\/ makeRotate\n+                    b = b.rearrange(rot1);\n+                    c = c.rearrange(rot2);\n+                    d = d.rearrange(rot3);\n+\n+                    \/\/ second round\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,16);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,12);\n+\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,8);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,7);\n+\n+                    \/\/ makeRotate\n+                    b = b.rearrange(rot3);\n+                    c = c.rearrange(rot2);\n+                    d = d.rearrange(rot1);\n+                }\n+\n+                a = a.add(sa);\n+                b = b.add(sb);\n+                c = c.add(sc);\n+                d = d.add(sd);\n+\n+                \/\/ rearrange the vectors\n+                if (intSpecies.length() == 4) {\n+                    \/\/ no rearrange needed\n+                } else if (intSpecies.length() == 8) {\n+                    IntVector a_r =\n+                            a.rearrange(shuf0).blend(b.rearrange(shuf0), mask1);\n+                    IntVector b_r =\n+                            c.rearrange(shuf0).blend(d.rearrange(shuf0), mask1);\n+                    IntVector c_r =\n+                            a.rearrange(shuf1).blend(b.rearrange(shuf1), mask1);\n+                    IntVector d_r =\n+                            c.rearrange(shuf1).blend(d.rearrange(shuf1), mask1);\n+\n+                    a = a_r;\n+                    b = b_r;\n+                    c = c_r;\n+                    d = d_r;\n+                } else if (intSpecies.length() == 16) {\n+                    IntVector a_r = a;\n+                    a_r = a_r.blend(b.rearrange(shuf0), mask1);\n+                    a_r = a_r.blend(c.rearrange(shuf0), mask2);\n+                    a_r = a_r.blend(d.rearrange(shuf0), mask3);\n+\n+                    IntVector b_r = b;\n+                    b_r = b_r.blend(a.rearrange(shuf1), mask0);\n+                    b_r = b_r.blend(c.rearrange(shuf1), mask2);\n+                    b_r = b_r.blend(d.rearrange(shuf1), mask3);\n+\n+                    IntVector c_r = c;\n+                    c_r = c_r.blend(a.rearrange(shuf2), mask0);\n+                    c_r = c_r.blend(b.rearrange(shuf2), mask1);\n+                    c_r = c_r.blend(d.rearrange(shuf2), mask3);\n+\n+                    IntVector d_r = d;\n+                    d_r = d_r.blend(a.rearrange(shuf3), mask0);\n+                    d_r = d_r.blend(b.rearrange(shuf3), mask1);\n+                    d_r = d_r.blend(c.rearrange(shuf3), mask2);\n+\n+                    a = a_r;\n+                    b = b_r;\n+                    c = c_r;\n+                    d = d_r;\n+                } else {\n+                    throw new RuntimeException(\"not supported\");\n+                }\n+\n+                \/\/ xor keystream with input\n+                int inOff = stateLenBytes * j;\n+                IntVector ina = IntVector.fromByteArray(intSpecies, in, inOff, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inb = IntVector.fromByteArray(intSpecies, in, inOff + 4 * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inc = IntVector.fromByteArray(intSpecies, in, inOff + 8 * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector ind = IntVector.fromByteArray(intSpecies, in, inOff + 12 * len, ByteOrder.LITTLE_ENDIAN);\n+\n+                ina.lanewise(VectorOperators.XOR, a).intoByteArray(out, inOff, ByteOrder.LITTLE_ENDIAN);\n+                inb.lanewise(VectorOperators.XOR, b).intoByteArray(out, inOff + 4 * len, ByteOrder.LITTLE_ENDIAN);\n+                inc.lanewise(VectorOperators.XOR, c).intoByteArray(out, inOff + 8 * len, ByteOrder.LITTLE_ENDIAN);\n+                ind.lanewise(VectorOperators.XOR, d).intoByteArray(out, inOff + 12 * len, ByteOrder.LITTLE_ENDIAN);\n+\n+                \/\/ increment counter\n+                sd = sd.add(counterAdd);\n+            }\n+        }\n+\n+        public int implBlockSize() {\n+            return numBlocks * 64;\n+        }\n+    }\n+\n+    private static byte[] hexStringToByteArray(String str) {\n+        byte[] result = new byte[str.length() \/ 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (byte) Character.digit(str.charAt(2 * i), 16);\n+            result[i] <<= 4;\n+            result[i] += Character.digit(str.charAt(2 * i + 1), 16);\n+        }\n+        return result;\n+    }\n+\n+    private static void runKAT(ChaChaVector cc20, String keyStr,\n+        String nonceStr, long counter, String inStr, String outStr) {\n+\n+        byte[] key = hexStringToByteArray(keyStr);\n+        byte[] nonce = hexStringToByteArray(nonceStr);\n+        byte[] in = hexStringToByteArray(inStr);\n+        byte[] expOut = hexStringToByteArray(outStr);\n+\n+        \/\/ implementation only works at multiples of some size\n+        int blockSize = cc20.implBlockSize();\n+\n+        int length = blockSize * ((in.length + blockSize - 1) \/ blockSize);\n+        in = Arrays.copyOf(in, length);\n+        byte[] out = new byte[length];\n+\n+        cc20.chacha20(key, nonce, counter, in, out);\n+\n+        byte[] actOut = new byte[expOut.length];\n+        System.arraycopy(out, 0, actOut, 0, expOut.length);\n+\n+        if (!Arrays.equals(out, 0, expOut.length, expOut, 0, expOut.length)) {\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    \/*\n+     * ChaCha20 Known Answer Tests to ensure that the implementation is correct.\n+     *\/\n+    private static void runKAT(ChaChaVector cc20) {\n+        runKAT(cc20,\n+        \"0000000000000000000000000000000000000000000000000000000000000001\",\n+        \"000000000000000000000002\",\n+        1,\n+        \"416e79207375626d697373696f6e20746f20746865204945544620696e74656e\" +\n+        \"6465642062792074686520436f6e7472696275746f7220666f72207075626c69\" +\n+        \"636174696f6e20617320616c6c206f722070617274206f6620616e2049455446\" +\n+        \"20496e7465726e65742d4472616674206f722052464320616e6420616e792073\" +\n+        \"746174656d656e74206d6164652077697468696e2074686520636f6e74657874\" +\n+        \"206f6620616e204945544620616374697669747920697320636f6e7369646572\" +\n+        \"656420616e20224945544620436f6e747269627574696f6e222e205375636820\" +\n+        \"73746174656d656e747320696e636c756465206f72616c2073746174656d656e\" +\n+        \"747320696e20494554462073657373696f6e732c2061732077656c6c20617320\" +\n+        \"7772697474656e20616e6420656c656374726f6e696320636f6d6d756e696361\" +\n+        \"74696f6e73206d61646520617420616e792074696d65206f7220706c6163652c\" +\n+        \"207768696368206172652061646472657373656420746f\",\n+        \"a3fbf07df3fa2fde4f376ca23e82737041605d9f4f4f57bd8cff2c1d4b7955ec\" +\n+        \"2a97948bd3722915c8f3d337f7d370050e9e96d647b7c39f56e031ca5eb6250d\" +\n+        \"4042e02785ececfa4b4bb5e8ead0440e20b6e8db09d881a7c6132f420e527950\" +\n+        \"42bdfa7773d8a9051447b3291ce1411c680465552aa6c405b7764d5e87bea85a\" +\n+        \"d00f8449ed8f72d0d662ab052691ca66424bc86d2df80ea41f43abf937d3259d\" +\n+        \"c4b2d0dfb48a6c9139ddd7f76966e928e635553ba76c5c879d7b35d49eb2e62b\" +\n+        \"0871cdac638939e25e8a1e0ef9d5280fa8ca328b351c3c765989cbcf3daa8b6c\" +\n+        \"cc3aaf9f3979c92b3720fc88dc95ed84a1be059c6499b9fda236e7e818b04b0b\" +\n+        \"c39c1e876b193bfe5569753f88128cc08aaa9b63d1a16f80ef2554d7189c411f\" +\n+        \"5869ca52c5b83fa36ff216b9c1d30062bebcfd2dc5bce0911934fda79a86f6e6\" +\n+        \"98ced759c3ff9b6477338f3da4f9cd8514ea9982ccafb341b2384dd902f3d1ab\" +\n+        \"7ac61dd29c6f21ba5b862f3730e37cfdc4fd806c22f221\"\n+        );\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/ChaChaBench.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -0,0 +1,663 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class Poly1305Bench {\n+\n+    @Param({\"16384\", \"65536\"})\n+    private int dataSize;\n+\n+    private Poly1305Vector poly1305_S128 = makePoly1305(VectorShape.S_128_BIT);\n+    private Poly1305Vector poly1305_S256 = makePoly1305(VectorShape.S_256_BIT);\n+    private Poly1305Vector poly1305_S512 = makePoly1305(VectorShape.S_512_BIT);\n+\n+    private byte[] in;\n+    private byte[] out = new byte[16];\n+    private byte[] key = new byte[32];\n+\n+    private static Poly1305Vector makePoly1305(VectorShape shape) {\n+        Poly1305Vector poly = new Poly1305Vector(shape);\n+        runKAT(poly);\n+        return poly;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        in = new byte[dataSize];\n+    }\n+\n+    @Benchmark\n+    public void auth128() {\n+        poly1305_S128.computeTag(key, in, out);\n+    }\n+\n+    @Benchmark\n+    public void auth256() {\n+        poly1305_S256.computeTag(key, in, out);\n+    }\n+\n+    @Benchmark\n+    public void auth512() {\n+        poly1305_S512.computeTag(key, in, out);\n+    }\n+\n+    private static class Poly1305Vector {\n+\n+        private static final int BITS_PER_LIMB = 26;\n+        private static final int LIMB_MASK = (1 << BITS_PER_LIMB) - 1;\n+        private static final int KEY_LENGTH = 32;\n+        private static final int RS_LENGTH = KEY_LENGTH \/ 2;\n+\n+        private final VectorSpecies<Long> longSpecies;\n+        private final VectorSpecies<Integer> intSpecies;\n+        private final int vectorWidth;\n+        private final int parBlockCount;\n+\n+        private final VectorShuffle<Long> inShuffle0;\n+        private final VectorShuffle<Long> inShuffle1;\n+        private final VectorMask<Long> inMask;\n+\n+        public Poly1305Vector(VectorShape shape) {\n+\n+            this.longSpecies = VectorSpecies.of(long.class, shape);\n+            int intSize = shape.vectorBitSize() \/ 2;\n+            VectorShape intShape = VectorShape.forBitSize(intSize);\n+            this.intSpecies = VectorSpecies.of(int.class, intShape);\n+            this.vectorWidth = longSpecies.length();\n+            this.parBlockCount = vectorWidth * 16;\n+\n+            this.inShuffle0 = makeInShuffle0();\n+            this.inShuffle1 = makeInShuffle1();\n+            this.inMask = makeInMask();\n+        }\n+\n+        private VectorShuffle<Long> makeInShuffle0() {\n+            int[] indexArr = new int[vectorWidth];\n+            for (int i = 0; i < indexArr.length; i++) {\n+                indexArr[i] = (2 * i) % vectorWidth;\n+            }\n+            return VectorShuffle.fromArray(longSpecies, indexArr, 0);\n+        }\n+        private VectorShuffle<Long> makeInShuffle1() {\n+            int[] indexArr = new int[vectorWidth];\n+            for (int i = 0; i < indexArr.length; i++) {\n+                indexArr[i] = ((2 * i) % vectorWidth) + 1;\n+            }\n+            return VectorShuffle.fromArray(longSpecies, indexArr, 0);\n+        }\n+        private VectorMask<Long> makeInMask() {\n+            boolean[] maskArr = new boolean[vectorWidth];\n+            for (int i = vectorWidth \/ 2; i < vectorWidth; i++) {\n+                maskArr[i] = true;\n+            }\n+            return VectorMask.fromArray(longSpecies, maskArr, 0);\n+        }\n+\n+        private static int[] fromByteArray(byte[] buf) {\n+            int[] result = new int[5];\n+\n+            result[0]\n+                    = (buf[0] & 0xFF)\n+                    + ((buf[1] & 0xFF) << 8)\n+                    + ((buf[2] & 0xFF) << 16)\n+                    + ((buf[3] & 0x03) << 24);\n+            result[1]\n+                    = ((buf[3] & 0xFF) >> 2)\n+                    + ((buf[4] & 0xFF) << 6)\n+                    + ((buf[5] & 0xFF) << 14)\n+                    + ((buf[6] & 0x0F) << 22);\n+            result[2]\n+                    = ((buf[6] & 0xFF) >> 4)\n+                    + ((buf[7] & 0xFF) << 4)\n+                    + ((buf[8] & 0xFF) << 12)\n+                    + ((buf[9] & 0x3F) << 20);\n+            result[3]\n+                    = ((buf[9] & 0xFF) >> 6)\n+                    + ((buf[10] & 0xFF) << 2)\n+                    + ((buf[11] & 0xFF) << 10)\n+                    + ((buf[12] & 0xFF) << 18);\n+            result[4]\n+                    = (buf[13] & 0xFF)\n+                    + ((buf[14] & 0xFF) << 8)\n+                    + ((buf[15] & 0xFF) << 16);\n+\n+            return result;\n+        }\n+\n+        private static void toByteArray(long v0, long v1, long v2, long v3,\n+            long v4, byte[] dst) {\n+\n+            dst[0] = (byte) v0;\n+            v0 >>= 8;\n+            dst[1] = (byte) v0;\n+            v0 >>= 8;\n+            dst[2] = (byte) v0;\n+            v0 >>= 8;\n+            dst[3] = (byte) v0;\n+\n+            dst[3] += (v1 & 0x3F) << 2;\n+            v1 >>= 6;\n+            dst[4] = (byte) v1;\n+            v1 >>= 8;\n+            dst[5] = (byte) v1;\n+            v1 >>= 8;\n+            dst[6] = (byte) v1;\n+\n+            dst[6] += (v2 & 0xF) << 4;\n+            v2 >>= 4;\n+            dst[7] = (byte) v2;\n+            v2 >>= 8;\n+            dst[8] = (byte) v2;\n+            v2 >>= 8;\n+            dst[9] = (byte) v2;\n+\n+            dst[9] += (v3 & 0x3) << 6;\n+            v3 >>= 2;\n+            dst[10] = (byte) v3;\n+            v3 >>= 8;\n+            dst[11] = (byte) v3;\n+            v3 >>= 8;\n+            dst[12] = (byte) v3;\n+\n+            dst[13] = (byte) v4;\n+            v4 >>= 8;\n+            dst[14] = (byte) v4;\n+            v4 >>= 8;\n+            dst[15] = (byte) v4;\n+        }\n+\n+        protected static long carryValue(long x) {\n+            return x >> BITS_PER_LIMB;\n+        }\n+\n+        public static void carryReduce(int[] r, long c0, long c1, long c2,\n+            long c3, long c4) {\n+\n+            long c;\n+\n+            c = carryValue(c3); c3 &= LIMB_MASK; c4 += c;\n+            c = carryValue(c4); c4 &= LIMB_MASK; c0 += c * 5;\n+            c = carryValue(c0); c0 &= LIMB_MASK; c1 += c;\n+            c = carryValue(c1); c1 &= LIMB_MASK; c2 += c;\n+            c = carryValue(c2); c2 &= LIMB_MASK; c3 += c;\n+            c = carryValue(c3); c3 &= LIMB_MASK; c4 += c;\n+\n+            r[0] = (int) c0;\n+            r[1] = (int) c1;\n+            r[2] = (int) c2;\n+            r[3] = (int) c3;\n+            r[4] = (int) c4;\n+        }\n+\n+        private int[] multiply(int[] a, int[] b) {\n+            int[] result = new int[5];\n+\n+            long a0 = a[0];\n+            long a1 = a[1];\n+            long a2 = a[2];\n+            long a3 = a[3];\n+            long a4 = a[4];\n+\n+            long c0 = (a0 * b[0]) + 5 * (a1 * b[4]) + 5 * (a2 * b[3]) +\n+                5 * (a3 * b[2]) + 5 * (a4 * b[1]);\n+            long c1 = (a0 * b[1]) + (a1 * b[0]) + 5 * (a2 * b[4]) +\n+                5 * (a3 * b[3]) + 5 * (a4 * b[2]);\n+            long c2 = (a0 * b[2]) + (a1 * b[1]) + (a2 * b[0]) +\n+                5 * (a3 * b[4]) + 5 * (a4 * b[3]);\n+            long c3 = (a0 * b[3]) + (a1 * b[2]) + (a2 * b[1]) + (a3 * b[0]) +\n+                5 * (a4 * b[4]);\n+            long c4 = (a0 * b[4]) + (a1 * b[3]) + (a2 * b[2]) + (a3 * b[1]) +\n+                (a4 * b[0]);\n+\n+            carryReduce(result, c0, c1, c2, c3, c4);\n+\n+            return result;\n+        }\n+\n+        private LongVector rPowerVec(int[][] r, long[] temp, int maxIndex,\n+            int secondIndex) {\n+\n+            for (int i = 0; i < temp.length; i++) {\n+                temp[i] = r[maxIndex - i][secondIndex];\n+            }\n+            return LongVector.fromArray(longSpecies, temp, 0);\n+        }\n+\n+        public void computeTag(byte[] key, byte[] msg, byte[] out) {\n+\n+            byte[] keyBytes = key.clone();\n+\n+            \/\/ setup key values\n+            \/\/ Clamp the bytes in the \"r\" half of the key.\n+            keyBytes[3] &= 15;\n+            keyBytes[7] &= 15;\n+            keyBytes[11] &= 15;\n+            keyBytes[15] &= 15;\n+            keyBytes[4] &= 252;\n+            keyBytes[8] &= 252;\n+            keyBytes[12] &= 252;\n+\n+            \/\/ Create IntegerModuloP elements from the r and s values\n+            int[][] r = new int[vectorWidth][];\n+            r[0] = fromByteArray(keyBytes);\n+            for (int i = 1; i < vectorWidth; i++) {\n+                r[i] = multiply(r[i - 1], r[0]);\n+            }\n+\n+            int rUpIndex = vectorWidth - 1;\n+            IntVector rUp0_int = IntVector.broadcast(intSpecies, r[rUpIndex][0]);\n+            IntVector rUp1_int = IntVector.broadcast(intSpecies, r[rUpIndex][1]);\n+            IntVector rUp2_int = IntVector.broadcast(intSpecies, r[rUpIndex][2]);\n+            IntVector rUp3_int = IntVector.broadcast(intSpecies, r[rUpIndex][3]);\n+            IntVector rUp4_int = IntVector.broadcast(intSpecies, r[rUpIndex][4]);\n+\n+            IntVector r5Up1_int = rUp1_int.mul(5);\n+            IntVector r5Up2_int = rUp2_int.mul(5);\n+            IntVector r5Up3_int = rUp3_int.mul(5);\n+            IntVector r5Up4_int = rUp4_int.mul(5);\n+\n+            LongVector longMsg0 = LongVector.fromByteArray(longSpecies, msg, 0, ByteOrder.LITTLE_ENDIAN);\n+            LongVector longMsg1 =\n+                LongVector.fromByteArray(longSpecies, msg, vectorWidth * 8, ByteOrder.LITTLE_ENDIAN);\n+\n+            LongVector inAlign0 =\n+            longMsg0.rearrange(inShuffle0).blend(longMsg1.rearrange(inShuffle0), inMask);\n+            LongVector inAlign1 =\n+            longMsg0.rearrange(inShuffle1).blend(longMsg1.rearrange(inShuffle1), inMask);\n+\n+            IntVector a0 = (IntVector)\n+                inAlign0.and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a1 = (IntVector)\n+                inAlign0.lanewise(VectorOperators.LSHR,26).and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a2 = (IntVector)\n+                inAlign0.lanewise(VectorOperators.LSHR,52).and(0xFFF).castShape(intSpecies, 0);\n+            a2 = a2.or(inAlign1.and(0x3FFF).lanewise(VectorOperators.LSHL,12).castShape(intSpecies, 0));\n+            IntVector a3 = (IntVector)\n+                inAlign1.lanewise(VectorOperators.LSHR,14).and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a4 = (IntVector)\n+                inAlign1.lanewise(VectorOperators.LSHR,40).and(0xFFFFFF).castShape(intSpecies, 0);\n+            a4 = a4.or(1 << 24);\n+\n+            int numParBlocks = msg.length \/ parBlockCount - 1;\n+            for (int i = 0; i < numParBlocks; i++) {\n+\n+                \/\/ multiply and reduce\n+                LongVector c0 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up2_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up1_int.castShape(longSpecies, 0)));\n+\n+                LongVector c1 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up2_int.castShape(longSpecies, 0)));\n+\n+                LongVector c2 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)));\n+\n+                LongVector c3 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp3_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)));\n+\n+                LongVector c4 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp4_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp3_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)));\n+\n+                \/\/ carry\/reduce\n+                \/\/ Note: this carry\/reduce sequence might not be correct\n+                c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c3 = c3.and(LIMB_MASK);\n+                c0 = c0.add(c4.lanewise(VectorOperators.LSHR, BITS_PER_LIMB).mul(5));\n+                c4 = c4.and(LIMB_MASK);\n+                c1 = c1.add(c0.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c0 = c0.and(LIMB_MASK);\n+                c2 = c2.add(c1.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c1 = c1.and(LIMB_MASK);\n+                c3 = c3.add(c2.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c2 = c2.and(LIMB_MASK);\n+                c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c3 = c3.and(LIMB_MASK);\n+\n+                a0 = (IntVector) c0.castShape(intSpecies, 0);\n+                a1 = (IntVector) c1.castShape(intSpecies, 0);\n+                a2 = (IntVector) c2.castShape(intSpecies, 0);\n+                a3 = (IntVector) c3.castShape(intSpecies, 0);\n+                a4 = (IntVector) c4.castShape(intSpecies, 0);\n+\n+                \/\/ fromByteArray and add next part of message\n+                int start = parBlockCount * (i + 1);\n+\n+                longMsg0 = LongVector.fromByteArray(longSpecies, msg, start, ByteOrder.LITTLE_ENDIAN);\n+                longMsg1 = LongVector.fromByteArray(longSpecies, msg,\n+                    start + vectorWidth * 8, ByteOrder.LITTLE_ENDIAN);\n+\n+                inAlign0 =\n+                        longMsg0.rearrange(inShuffle0).blend(longMsg1.rearrange(inShuffle0), inMask);\n+                inAlign1 =\n+                        longMsg0.rearrange(inShuffle1).blend(longMsg1.rearrange(inShuffle1), inMask);\n+\n+                IntVector in0 = (IntVector)\n+                    inAlign0.and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in1 = (IntVector)\n+                    inAlign0.lanewise(VectorOperators.LSHR, 26).and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in2 = (IntVector)\n+                    inAlign0.lanewise(VectorOperators.LSHR, 52).and(0xFFF).castShape(intSpecies, 0);\n+                in2 = in2.or(inAlign1.and(0x3FFF).lanewise(VectorOperators.LSHL, 12).castShape(intSpecies, 0));\n+                IntVector in3 = (IntVector)\n+                    inAlign1.lanewise(VectorOperators.LSHR, 14).and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in4 = (IntVector)\n+                    inAlign1.lanewise(VectorOperators.LSHR, 40).and(0xFFFFFF).castShape(intSpecies, 0);\n+                in4 = in4.or(1 << 24);\n+\n+                a0 = a0.add(in0);\n+                a1 = a1.add(in1);\n+                a2 = a2.add(in2);\n+                a3 = a3.add(in3);\n+                a4 = a4.add(in4);\n+            }\n+\n+            \/\/ multiply by powers of r\n+            long[] rTemp = new long[vectorWidth];\n+            LongVector rFin0 = rPowerVec(r, rTemp, rUpIndex, 0);\n+            LongVector rFin1 = rPowerVec(r, rTemp, rUpIndex, 1);\n+            LongVector rFin2 = rPowerVec(r, rTemp, rUpIndex, 2);\n+            LongVector rFin3 = rPowerVec(r, rTemp, rUpIndex, 3);\n+            LongVector rFin4 = rPowerVec(r, rTemp, rUpIndex, 4);\n+\n+            LongVector r5Fin_1 = rFin1.mul(5);\n+            LongVector r5Fin_2 = rFin2.mul(5);\n+            LongVector r5Fin_3 = rFin3.mul(5);\n+            LongVector r5Fin_4 = rFin4.mul(5);\n+\n+            LongVector c0 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin0)\n+                .add(a1.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a2.castShape(longSpecies, 0).mul(r5Fin_3))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_2))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_1));\n+            LongVector c1 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin1)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a2.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_3))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_2));\n+            LongVector c2 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin2)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_3));\n+            LongVector c3 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin3)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin2))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a3.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_4));\n+            LongVector c4 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin4)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin3))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin2))\n+                .add(a3.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a4.castShape(longSpecies, 0).mul(rFin0));\n+\n+            c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c3 = c3.and(LIMB_MASK);\n+            c0 = c0.add(c4.lanewise(VectorOperators.LSHR, BITS_PER_LIMB).mul(5));\n+            c4 = c4.and(LIMB_MASK);\n+            c1 = c1.add(c0.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c0 = c0.and(LIMB_MASK);\n+            c2 = c2.add(c1.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c1 = c1.and(LIMB_MASK);\n+            c3 = c3.add(c2.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c2 = c2.and(LIMB_MASK);\n+            c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c3 = c3.and(LIMB_MASK);\n+\n+            a0 = (IntVector) c0.castShape(intSpecies, 0);\n+            a1 = (IntVector) c1.castShape(intSpecies, 0);\n+            a2 = (IntVector) c2.castShape(intSpecies, 0);\n+            a3 = (IntVector) c3.castShape(intSpecies, 0);\n+            a4 = (IntVector) c4.castShape(intSpecies, 0);\n+\n+            \/\/ collect lanes and calculate tag\n+            long a0Fin = a0.reduceLanes(VectorOperators.ADD);\n+            long a1Fin = a1.reduceLanes(VectorOperators.ADD);\n+            long a2Fin = a2.reduceLanes(VectorOperators.ADD);\n+            long a3Fin = a3.reduceLanes(VectorOperators.ADD);\n+            long a4Fin = a4.reduceLanes(VectorOperators.ADD);\n+\n+            \/\/ carry\/reduce the result\n+            a4Fin = a4Fin + (a3Fin >>> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+            a0Fin = a0Fin + ((a4Fin >>> BITS_PER_LIMB) * 5);\n+            a4Fin = a4Fin & LIMB_MASK;\n+            a1Fin = a1Fin + (a0Fin >>> BITS_PER_LIMB);\n+            a0Fin = a0Fin & LIMB_MASK;\n+            a2Fin = a2Fin + (a1Fin >>> BITS_PER_LIMB);\n+            a1Fin = a1Fin & LIMB_MASK;\n+            a3Fin = a3Fin + (a2Fin >>> BITS_PER_LIMB);\n+            a2Fin = a2Fin & LIMB_MASK;\n+            a4Fin = a4Fin + (a3Fin >>> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+\n+            byte[] s_arr =\n+                Arrays.copyOfRange(keyBytes, RS_LENGTH, 2 * RS_LENGTH);\n+            int[] s = fromByteArray(s_arr);\n+\n+            \/\/ Add in the s-half of the key to the accumulator\n+            a0Fin += s[0];\n+            a1Fin += s[1];\n+            a2Fin += s[2];\n+            a3Fin += s[3];\n+            a4Fin += s[4];\n+\n+            \/\/ final carry mod 2^130\n+            a1Fin = a1Fin + (a0Fin >> BITS_PER_LIMB);\n+            a0Fin = a0Fin & LIMB_MASK;\n+            a2Fin = a2Fin + (a1Fin >> BITS_PER_LIMB);\n+            a1Fin = a1Fin & LIMB_MASK;\n+            a3Fin = a3Fin + (a2Fin >> BITS_PER_LIMB);\n+            a2Fin = a2Fin & LIMB_MASK;\n+            a4Fin = a4Fin + (a3Fin >> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+            a4Fin = a4Fin & LIMB_MASK;\n+\n+            \/\/ put result in buffer\n+            toByteArray(a0Fin, a1Fin, a2Fin, a3Fin, a4Fin, out);\n+        }\n+    }\n+\n+\n+    private static byte[] hexStringToByteArray(String str) {\n+        byte[] result = new byte[str.length() \/ 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (byte) Character.digit(str.charAt(2 * i), 16);\n+            result[i] <<= 4;\n+            result[i] += Character.digit(str.charAt(2 * i + 1), 16);\n+        }\n+        return result;\n+    }\n+\n+    public static String byteArrayToHexString(byte[] arr) {\n+        StringBuilder result = new StringBuilder();\n+        for (int i = 0; i < arr.length; ++i) {\n+            byte curVal = arr[i];\n+            result.append(Character.forDigit(curVal >> 4 & 0xF, 16));\n+            result.append(Character.forDigit(curVal & 0xF, 16));\n+        }\n+        return result.toString();\n+    }\n+\n+    private static void kat(Poly1305Vector poly1305, String key, String msg,\n+        String expectedTag) {\n+\n+        kat(poly1305, hexStringToByteArray(key), hexStringToByteArray(msg),\n+            hexStringToByteArray(expectedTag));\n+    }\n+\n+    private static void kat(Poly1305Vector poly1305, byte[] key, byte[] msg,\n+        byte[] expectedTag) {\n+\n+        byte[] tag = new byte[expectedTag.length];\n+        poly1305.computeTag(key, msg, tag);\n+        if (!Arrays.equals(tag, expectedTag)) {\n+            throw new RuntimeException(\n+                    \"bad tag: \" + byteArrayToHexString(tag) +\n+                    \" expected: \" + byteArrayToHexString(expectedTag));\n+        }\n+    }\n+\n+    \/*\n+     * Poly1305 Known Answer Tests to ensure that the implementation is correct.\n+     *\/\n+    private static void runKAT(Poly1305Vector poly1305) {\n+        kat(poly1305,\n+            \"d212b886dd4682a41f1759e6c5aef84760e5a63d4423ca7d1fb5c7ecfc5dac27\",\n+            \"5d2ad39e2a7b0bc5f375488643acf391188d01ad936971457427bc053c4262a1\" +\n+            \"598532850def8573213c5f79fa736703c57c03ec49b55617210998c8af408698\" +\n+            \"866632a7ecf7e9a688605cbca919e17e2badd090a7a6d83ad90be0617fa44642\" +\n+            \"cc9a1ca38514a026cbea51c287ec0b56719fc61183c88e9450ba85aa8ab7d390\",\n+            \"7ccdfa8e82df540276e8172f705adce2\");\n+\n+        kat(poly1305,\n+            \"2b0b684c86910104aee1d261ac4d5a0f5443b4b7746cf7f8ba03921d273f6a9b\",\n+            \"027b359f44a5d60f81073ceb74749207742529dcefa4a26a1817db2c8d50ba2b\" +\n+            \"d9e170cd1930946872d95e4eae41389f362087871a749897e0fbe42494e6f0b3\" +\n+            \"8db01e2059510b6fda4f422ce7d226433ba00940e1761baaff80d9b8f3a61d11\" +\n+            \"a109e6082d231cf85aa718199e6eaaaf07bad562469ef1b8e639c727967bf6da\" +\n+            \"bcd16fcb0fc102095325e2fac92e599e81c26900df1deb7b0a0b5c321a658024\" +\n+            \"26506740509ece646fecf33a517b66e57577372156aae85765c6b473521d1019\" +\n+            \"4f5fbe0e932cfee716e1d41c9154fb8e15b82ab7e807fb54f3d7d3e4c589cc9a\" +\n+            \"492d17ea4fd27894fa9d22a9db6d5df674cd1e97e7e8758a360291f22dfe1cc3\",\n+            \"84ca3a778faf0ab9f840fe5fb38ace27\");\n+\n+        kat(poly1305,\n+            \"870c6fa7da2eadb845ac8b0eeaed4cf856eca67bf96b64a29a2e6a881821fa8a\",\n+            \"ff1a3b67a4f575be5f05c4054e4c7365838c2cbe786ba78900c8b43f197c3c4d\" +\n+            \"120432a287e434669af579bcd56f3320e54d2f97a306f917f2f41b1c97cc69db\" +\n+            \"4ac2051adccd687fa89f92504d1ab5c3006681d846c8051aabccca0024ef5ec4\" +\n+            \"c43b8701ffc9d14fef8d55e229ed210a2b9bde996f5d7b545d15e1fc32764604\" +\n+            \"b2a0384dd173aa800b7526c8ff397c05130bb6a1f2194968adaef6979b023cd8\" +\n+            \"d9195d2739351c7e4ac6c43508634f813641f669e78cbcf732ccb1321a2cd2c4\" +\n+            \"14c7df5b9ea3408f2e12fbf3a3cbdb98699dd5402725ec25f9fff9bcd0f93cb3\" +\n+            \"cf0dac016fec41a5ef3ae8b8d258a09f530ad14ad2e52186041592eac0ea22ff\" +\n+            \"8c3751009b516c60f7764cccbb816394ef035bd8cb2a38d5c6b9229e528e56cd\" +\n+            \"62600b5219b64212642384e628f01d790eeef4963a7d1a63a9faff79d4acfa09\" +\n+            \"78b58b0b623ae89389661aa408b16814d3baaca20978dce6888c3365f4ffd2fa\" +\n+            \"8f031a44f2e870a06da21d7becf450d335e1386268bc189435e7955a477bc368\",\n+            \"ff4e0ee6feb1c6a57e638a79fafc7c60\");\n+\n+        kat(poly1305,\n+            \"c27987ae88a833ae2ea90371b2e257c15773da3bc34516b6b075446e1f844a81\",\n+            \"64e5a2e2940b173c7103ae931ced302a8f8c778f4e5c0b3677c51552655005d8\" +\n+            \"504b724107e7262448c94db83fc9c6a2a26fc973360dce15c0553b73bb733d3e\" +\n+            \"f61fcba8977e76c32523b80c3b45b1226b23ee17522f9b677880c69b356917ae\" +\n+            \"3c792a0c5b0c77b90dfa51483626323b7a73fffb1b128c595d553bf62a8f5bb9\" +\n+            \"fa48b4a850a932481bf607e8da84730c9052bba9316ec7eb84007a4eb5cbed5c\" +\n+            \"7c67ef32d4c5cb6cfbccd738d239857c240de6d3d4e5af14d480feb63541e5d8\" +\n+            \"036e088b2e32431e6fe0c4d3505aebe2e14bd02b6b15325f89aef048cd1236db\" +\n+            \"4461a59304b7c61ece2c52ef8ac4cf2326e6aaff013494b1b191be4ae4381f57\" +\n+            \"e72b947ee23d0a528087db9338bc28c68484929fc3436995b2083b06a765ceb7\" +\n+            \"09e9dd41ba896d99832d6851189766e844137d9a83d2890bc2be7afc82f9ebb8\" +\n+            \"bafe08ef5f7ff0cce9a1d08e6b797a17df04731f384a34b16e72e9f2ab070114\" +\n+            \"8008945509fe378658dc51eb752248f48364be327cd1b6bd148c518a976ae95d\" +\n+            \"d391f3b0d447251988c7e77400c9d44395b8f9f10cbc442a6804d0ad83e8c3e3\" +\n+            \"9fa09c2140fac143c90f09a7d907c57e29b528d54c8bd927f39aee2cec671213\" +\n+            \"c50fe657b29682d57a419e3e52dafb348cbe44b6c17e4be18f5c5e411734fcfc\" +\n+            \"99b9ca26f29a21cc93374ef1bfa86ca2bb3be76b94b4ef69ec790c968a51e4d0\",\n+            \"d4c09727f68fa3beb57ce9e74205b652\");\n+\n+        kat(poly1305,\n+            \"2593adf2efc0e49c7fde0d45de4f7a21ceb76df45c0e5a917ef1f6b7fbf4fb7e\",\n+            \"23665b9a6d4f04c9d58347d32d64d4cbf8d4ca993a8bb73758e6eb2db9f97096\" +\n+            \"d0f00aca8cb16460d2bc15c0136fa92482602f47b3ec78244c4dc619d9b28afa\" +\n+            \"19b063c196bcff848eff179102cce29dfcc58bf90a2f6311e6d021e2573ccbb4\" +\n+            \"4e06947167c9865127c0b7362196523f97c8157058f7aebff475f77e23393dc1\" +\n+            \"a3031bbaf31270db3eadc00cca6ae073aa53160d095afdce0a202de8a23d9a38\" +\n+            \"b0bed20cbe64e1ec77fc13ba0cfc9be52edb70475bf1aeaaff25e11f2e0ae47f\" +\n+            \"f23cbd4a6219d276fcc6c8f12a739f11434c86d4e24397f96ef6e36d9195fa8a\" +\n+            \"48eb55990d69feacfb754b5019a3ebafa98d5544077b46c136cc11de8ee7f8a6\" +\n+            \"76a6696600088696233f4e8f060ba8a64890fb638469639bfb727ed758c36250\" +\n+            \"a553b7ce1115509f2bb19c13cea87003a8eff45ce9e1cff0a21ba5ae19226d50\" +\n+            \"e108db212a588e5f4c502468859b9b607922c3311b5d912bd9400e696d7debbb\" +\n+            \"9ac5454cc7d0f95fc242c491f095a02f0d3bd7ead0f0b7358c9b1d85e4e9ab75\" +\n+            \"24bb43867c94a21a4e0db6470a210c9dd937e4801396bd687127fa7c83014c85\" +\n+            \"372553c56dfd6cd9b75fa10483aea825f8e3fa53c6bf17467e37c2e7439ed0ea\" +\n+            \"6fb24d13d428965c44f1ac943c7bc77fa84711c91b41f5ee6d9a7d9091648a96\" +\n+            \"cc7c261d7fc5d964446d1e3dcc41d32ecaa8d7791b8462563fcf7f96cd1d11d4\" +\n+            \"34923e0150321356866f5bdafebc96f2661bfd3c1f104e96b6492cafcbe25fc6\" +\n+            \"ec0c92a3bbec7328e1905d5951fae04625a2452f596027a5d9c64eed55165c8a\" +\n+            \"23bc3f944b4fa9c7ad83ebc1777c7153d5de13d04c0a12e774b17906a62f5134\" +\n+            \"685c2de31da08bd04840299fd62d56ffe95248365034e7ba95961cebf0542b24\",\n+            \"b9f68b0996caf5135136b10b37fe5f81\");\n+\n+        kat(poly1305,\n+            \"e9c8c78bc0ad5751f094fd4657fe5ef2a3c232f6930eef3431cde76659f04210\",\n+            \"914e57a2745fd475d7b8f982483fe11a05d7b55853239112d5ae99616c718b3c\" +\n+            \"4a0c2d05e3ca1df509614c0fe051b414d404149ec422e0998e192e51518518c4\" +\n+            \"b8acd9e3e3ff9f3b4ef931d3052755785d38e75821ceefa7da0bfe3f1fb2dc6d\" +\n+            \"738e2a2332e53ce77d44547621bb7aa724dd8805c7c795088db865d6b13d9b3e\" +\n+            \"8acec846efb072d105ab6e599f8292a7601087e0ba13af9f503dcfd426e26e4d\" +\n+            \"fb22bf5a1ff1a82d67d9bd8871e6adc17aa39d221f2865f81da9ed566192c269\" +\n+            \"3c85f0442924e603b9ae54b88dd0f21e92eedc40c08dd484c552e297894eeee8\" +\n+            \"b5acc91d5ae16f56257bb0836b48e1a8fa72e83a8b10b7026a7f466c8b08eac5\" +\n+            \"4359b70e639117cf688e263b891f004db94d77941380f3ab0559538c9398c859\" +\n+            \"b76d2bbcd6b635e753160583e7adc263097a80520d003514e134a21597c1ec57\" +\n+            \"55da3a70acc6951b4d4d81e98b9eb962d9e3bc37d5e8ebd61e2a3f61cc452a65\" +\n+            \"56571e12c190d4e3d0f8cc61ffcb60324b4a6987e7375a832ff807682e0b4595\" +\n+            \"66ef1f765638f3d2e837ed43ce2c1c7837f271c866908d865c3d9174fd4f8056\" +\n+            \"265abfb88fbc207db7a12c0a0ad035e5a728725e98cb682d41fd0bcf3aef2fd7\" +\n+            \"ab261727f310fc7cf3b34286c9e9ee235995315167191f3b4d77e5642fb57dbd\" +\n+            \"fdb5ccadefc5d03866918ab1a3eff54b405d8946e2b0c2fa444d1b2be4c3d41d\" +\n+            \"990515e7534190d66d10e38c36c5d3df0315db85ba10c924bef97d1faa07a5f8\" +\n+            \"f04998a7d38689237a1912bea3f821357d8383d7c5cfa66ba5965b5a94bb702c\" +\n+            \"e6583e59879021139355c5b90e0f9cd13b34f3357ffde404bbf34c97f9fd55b5\" +\n+            \"53e42d8a6b370eded02c8a5221e15db701da56918412520e12fd1ef9f4748647\" +\n+            \"858488d5e0abd5b9e01457768907e1d24581f9591771304192711292e4025fce\" +\n+            \"bd92adb2297e9496852f80bd78578bbdb292ca209f7584ff76e9eb66ec8a111e\" +\n+            \"add30dc7ef364c4f1339312f226fe0cfa7a5b1602417e469cf2c8e3874c51232\" +\n+            \"00f2d90dbe7f3c3ff5c6c6484052a80eb6229a6ed6176ad600da185da624bea6\",\n+            \"c1de44dd8ea245ca43e5587460feb514\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/Poly1305Bench.java","additions":663,"deletions":0,"binary":false,"changes":663,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import java.util.Random;\n+import java.util.function.IntFunction;\n+\n+public class AbstractVectorBenchmark {\n+    static final Random RANDOM = new Random(Integer.getInteger(\"jdk.incubator.vector.random-seed\", 1337));\n+\n+    static final VectorSpecies<Byte> B64  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> B128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Byte> B256 = ByteVector.SPECIES_256;\n+    static final VectorSpecies<Byte> B512 = ByteVector.SPECIES_512;\n+\n+    static final VectorSpecies<Short> S64  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+    static final VectorSpecies<Short> S512 = ShortVector.SPECIES_512;\n+\n+    static final VectorSpecies<Integer> I64  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> I128 = IntVector.SPECIES_128;\n+    static final VectorSpecies<Integer> I256 = IntVector.SPECIES_256;\n+    static final VectorSpecies<Integer> I512 = IntVector.SPECIES_512;\n+\n+    static final VectorSpecies<Long> L64  = LongVector.SPECIES_64;\n+    static final VectorSpecies<Long> L128 = LongVector.SPECIES_128;\n+    static final VectorSpecies<Long> L256 = LongVector.SPECIES_256;\n+    static final VectorSpecies<Long> L512 = LongVector.SPECIES_512;\n+\n+    static VectorShape widen(VectorShape s) {\n+        switch (s) {\n+            case S_64_BIT:  return VectorShape.S_128_BIT;\n+            case S_128_BIT: return VectorShape.S_256_BIT;\n+            case S_256_BIT: return VectorShape.S_512_BIT;\n+            default: throw new IllegalArgumentException(\"\" + s);\n+        }\n+    }\n+\n+    static VectorShape narrow(VectorShape s) {\n+        switch (s) {\n+            case S_512_BIT: return VectorShape.S_256_BIT;\n+            case S_256_BIT: return VectorShape.S_128_BIT;\n+            case S_128_BIT: return VectorShape.S_64_BIT;\n+            default: throw new IllegalArgumentException(\"\" + s);\n+        }\n+    }\n+\n+    static <E> VectorSpecies<E> widen(VectorSpecies<E> s) {\n+        return VectorSpecies.of(s.elementType(), widen(s.vectorShape()));\n+    }\n+\n+    static <E> VectorSpecies<E> narrow(VectorSpecies<E> s) {\n+        return VectorSpecies.of(s.elementType(), narrow(s.vectorShape()));\n+    }\n+\n+    static IntVector join(VectorSpecies<Integer> from, VectorSpecies<Integer> to, IntVector lo, IntVector hi) {\n+        assert 2 * from.length() == to.length();\n+\n+        int vlen = from.length();\n+        var lo_mask = mask(from, to, 0);\n+\n+        var v1 = lo.reinterpretShape(to, 0);\n+        var v2 = hi.reinterpretShape(to, 0).unslice(vlen);\n+        var r = v2.blend(v1, lo_mask);\n+        return (IntVector)r;\n+    }\n+\n+    static VectorMask<Integer> mask(VectorSpecies<Integer> from, VectorSpecies<Integer> to, int i) {\n+        int vlen = from.length();\n+        var v1 = IntVector.broadcast(from, 1);                   \/\/                         [1 1 ... 1]\n+        var v2 = v1.reinterpretShape(to, 0);                     \/\/ [0 0 ... 0 |   ...     | 1 1 ... 1]\n+        var v3 = v2.unslice(i * vlen);                           \/\/ [0 0 ... 0 | 1 1 ... 1 | 0 0 ... 0]\n+        return v3.compare(VectorOperators.NE, to.broadcast(0));  \/\/ [F F ... F | T T ... T | F F ... F]\n+    }\n+\n+    static <E> IntVector sum(ByteVector va) {\n+        VectorSpecies<Integer> species = VectorSpecies.of(Integer.class, va.shape());\n+        var acc = IntVector.zero(species);\n+        int limit = va.length() \/ species.length();\n+        for (int k = 0; k < limit; k++) {\n+            var vb = ((IntVector)(va.slice(k * B64.length()).reinterpretShape(B64, 0).castShape(species, 0))).and(0xFF);\n+            acc = acc.add(vb);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    boolean[] fillMask(int size, IntFunction<Boolean> f) {\n+        boolean[] array = new boolean[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] fillByte(int size, IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < size; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] fillInt(int size, IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] fillLong(int size, IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/AbstractVectorBenchmark.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (byte)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (byte)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (byte)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (byte)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ByteMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (byte)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1610 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ByteScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static byte bits(byte e) {\n+        return e;\n+    }\n+\n+    byte[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (byte)(2*i));\n+        bs = fill(i -> (byte)(i+1));\n+        cs = fill(i -> (byte)(i+5));\n+        rs = fill(i -> (byte)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> as;\n+    final IntFunction<byte[]> fb = vl -> bs;\n+    final IntFunction<byte[]> fc = vl -> cs;\n+    final IntFunction<byte[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a << (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a >> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(((a & 0xFF) >>> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a << (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(((a & 0xFF) >>> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a >> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = Byte.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (byte)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = Byte.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (byte)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = Byte.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (byte)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = Byte.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Byte.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (byte)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    byte a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (byte)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] cs = fc.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                byte c = cs[i];\n+                rs[i] = (byte)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] cs = fc.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                byte c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(-((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(-((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(Math.abs((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(Math.abs((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(~((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(~((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        scatter(window, bh);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":1610,"deletions":0,"binary":false,"changes":1610,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (double)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (double)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (double)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (double)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class DoubleMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (double)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1367 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class DoubleScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static long bits(double e) {\n+        return Double.doubleToLongBits(e);\n+    }\n+\n+    double[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (double)(2*i));\n+        bs = fill(i -> (double)(i+1));\n+        cs = fill(i -> (double)(i+5));\n+        rs = fill(i -> (double)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> as;\n+    final IntFunction<double[]> fb = vl -> bs;\n+    final IntFunction<double[]> fc = vl -> cs;\n+    final IntFunction<double[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Double.doubleToLongBits(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(Double.doubleToLongBits(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = Double.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (double)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = Double.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (double)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = Double.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (double)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = Double.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (double)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    double a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (double)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] cs = fc.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                double c = cs[i];\n+                rs[i] = (double)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] cs = fc.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                double c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(-((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(-((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.abs((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(Math.abs((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        scatter(window, bh);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":1367,"deletions":0,"binary":false,"changes":1367,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (float)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (float)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (float)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (float)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1585 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class FloatMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (float)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":1585,"deletions":0,"binary":false,"changes":1585,"status":"added"},{"patch":"@@ -0,0 +1,1367 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class FloatScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static int bits(float e) {\n+        return Float.floatToIntBits(e);\n+    }\n+\n+    float[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (float)(2*i));\n+        bs = fill(i -> (float)(i+1));\n+        cs = fill(i -> (float)(i+5));\n+        rs = fill(i -> (float)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> as;\n+    final IntFunction<float[]> fb = vl -> bs;\n+    final IntFunction<float[]> fc = vl -> cs;\n+    final IntFunction<float[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Double.doubleToLongBits(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(Double.doubleToLongBits(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = Float.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (float)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = Float.POSITIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (float)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = Float.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (float)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = Float.NEGATIVE_INFINITY;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (float)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    float a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (float)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] cs = fc.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                float c = cs[i];\n+                rs[i] = (float)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] cs = fc.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                float c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(-((float)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(-((float)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.abs((float)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(Math.abs((float)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        scatter(window, bh);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":1367,"deletions":0,"binary":false,"changes":1367,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (int)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (int)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (int)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (int)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IntMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (int)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1610 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IntScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static int bits(int e) {\n+        return e;\n+    }\n+\n+    int[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (int)(2*i));\n+        bs = fill(i -> (int)(i+1));\n+        cs = fill(i -> (int)(i+5));\n+        rs = fill(i -> (int)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> as;\n+    final IntFunction<int[]> fb = vl -> bs;\n+    final IntFunction<int[]> fc = vl -> cs;\n+    final IntFunction<int[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = Integer.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (int)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = Integer.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (int)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = Integer.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (int)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = Integer.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Integer.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (int)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (int)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] cs = fc.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                int c = cs[i];\n+                rs[i] = (int)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] cs = fc.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                int c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(-((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(-((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Math.abs((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Math.abs((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(~((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(~((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        scatter(window, bh);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":1610,"deletions":0,"binary":false,"changes":1610,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (long)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (long)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (long)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (long)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class LongMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (long)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1610 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class LongScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static long bits(long e) {\n+        return e;\n+    }\n+\n+    long[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (long)(2*i));\n+        bs = fill(i -> (long)(i+1));\n+        cs = fill(i -> (long)(i+5));\n+        rs = fill(i -> (long)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> as;\n+    final IntFunction<long[]> fb = vl -> bs;\n+    final IntFunction<long[]> fc = vl -> cs;\n+    final IntFunction<long[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = Long.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (long)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = Long.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (long)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = Long.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (long)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = Long.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Long.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (long)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    long a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (long)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] cs = fc.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                long c = cs[i];\n+                rs[i] = (long)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] cs = fc.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                long c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(-((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(-((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Math.abs((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Math.abs((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(~((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(~((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        scatter(window, bh);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":1610,"deletions":0,"binary":false,"changes":1610,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Merge extends AbstractVectorBenchmark {\n+\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    int[] in, out;\n+\n+    @Setup\n+    public void setup() {\n+        size = size + (size % 64); \/\/ FIXME: process tails\n+        in  = new int[size];\n+        out = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            in[i] = i;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void merge64_128() {\n+        merge(I64, I128);\n+    }\n+\n+    @Benchmark\n+    public void merge128_256() {\n+        merge(I128, I256);\n+    }\n+\n+    @Benchmark\n+    public void merge256_512() {\n+        merge(I256, I512);\n+    }\n+\n+    @Benchmark\n+    public void merge64_256() {\n+        merge(I64, I256);\n+    }\n+\n+    @Benchmark\n+    public void merge128_512() {\n+        merge(I128, I512);\n+    }\n+\n+    @Benchmark\n+    public void merge64_512() {\n+        merge(I64, I256);\n+    }\n+\n+    IntVector merge(VectorSpecies<Integer> from, VectorSpecies<Integer> to, int idx) {\n+        assert from.length() <= to.length();\n+\n+        int vlenFrom = from.length();\n+        int vlenTo   =   to.length();\n+\n+        if (vlenFrom == vlenTo) {\n+            return IntVector.fromArray(from, in, idx);\n+        } else {\n+            var stepDown = narrow(to);\n+            int mid = stepDown.length();\n+            var lo = merge(from, stepDown, idx);\n+            var hi = merge(from, stepDown, idx + mid);\n+            return join(stepDown, to, lo, hi);\n+        }\n+    }\n+\n+\n+    void merge(VectorSpecies<Integer> from, VectorSpecies<Integer> to) {\n+        int vlenTo = to.length();\n+        for (int i = 0; i < in.length; i += vlenTo) {\n+            var r = merge(from, to, i);\n+            r.intoArray(out, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        assert Arrays.deepEquals(new Object[] {in}, new Object[] {out});\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Merge.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,630 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Population count algorithms from \"Faster Population Counts Using AVX2 Instructions\", 2018 by Mula, Kurz, Lemire\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class PopulationCount extends AbstractVectorBenchmark {\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    private long[] data;\n+\n+    @Setup\n+    public void init() {\n+        data = fillLong(size, i -> RANDOM.nextLong());\n+\/\/        data = fillLong(size, i -> 0L);\n+\/\/        data = fillLong(size, i -> -1L);\n+\n+        checkConsistency();\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        checkConsistency();\n+    }\n+\n+    void checkConsistency() {\n+        long popCount = longBitCount();\n+        assert popCount == treeOfAdders();\n+        assert popCount == WilkesWheelerGill();\n+        assert popCount == Wegner();\n+        assert popCount == Lauradoux();\n+        assert popCount == HarleySeal();\n+        assert popCount == Mula128();\n+        assert popCount == Mula256();\n+        assert popCount == HarleySeal256();\n+    }\n+\n+    long tail(int upper) {\n+        long acc = 0;\n+        for (int i = upper; i < data.length; i++) {\n+            acc += Long.bitCount(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    @Benchmark\n+    public long longBitCount() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += Long.bitCount(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 4. The Wegner function in C\n+\n+    long popcntWegner(long x) {\n+        int v = 0;\n+        while (x != 0) {\n+            x &= x - 1;\n+            v++;\n+        }\n+        return v;\n+    }\n+\n+    @Benchmark\n+    public long Wegner() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntWegner(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 2. A naive tree-of-adders function in C\n+\n+    static long popcntTree(long x) {\n+        long c1  = 0x5555555555555555L;\n+        long c2  = 0x3333333333333333L;\n+        long c4  = 0x0F0F0F0F0F0F0F0FL;\n+        long c8  = 0x00FF00FF00FF00FFL;\n+        long c16 = 0x0000FFFF0000FFFFL;\n+        long c32 = 0x00000000FFFFFFFFL;\n+\n+        x = (x & c1)  + ((x >>> 1)  & c1);\n+        x = (x & c2)  + ((x >>> 2)  & c2);\n+        x = (x & c4)  + ((x >>> 4)  & c4);\n+        x = (x & c8)  + ((x >>> 8)  & c8);\n+        x = (x & c16) + ((x >>> 16) & c16);\n+        x = (x & c32) + ((x >>> 32) & c32);\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long treeOfAdders() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntTree(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 3. The Wilkes-Wheeler-Gill function in C\n+\n+    static long popcntWWG(long x) {\n+        long c1 = 0x5555555555555555L;\n+        long c2 = 0x3333333333333333L;\n+        long c4 = 0x0F0F0F0F0F0F0F0FL;\n+\n+        x -= (x >>> 1) & c1;\n+        x = (( x >>> 2) & c2) + (x & c2) ;\n+        x = ( x + (x >>> 4) ) & c4;\n+        x *= 0x0101010101010101L;\n+        x = x >>> 56;\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long WilkesWheelerGill() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntWWG(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 5. The Lauradoux population count in C for sets of 12 words.\n+\n+    static long parallelPopcnt(long count1, long count2, long count3) {\n+        long m1  = 0x5555555555555555L;\n+        long m2  = 0x3333333333333333L;\n+        long m4  = 0x0F0F0F0F0F0F0F0FL;\n+\n+        long half1 = (count3      ) & m1;\n+        long half2 = (count3 >>> 1) & m1;\n+\n+        count1 -= (count1 >>> 1) & m1;\n+        count2 -= (count2 >>> 1) & m1;\n+        count1 += half1;\n+        count2 += half2;\n+        count1  = (count1 & m2) + (( count1 >>> 2) & m2);\n+        count1 += (count2 & m2) + (( count2 >>> 2) & m2);\n+        return (count1 & m4) + (( count1 >>> 4) & m4);\n+    }\n+\n+    static long reduce(long acc) {\n+        long m8  = 0x00FF00FF00FF00FFL;\n+        long m16 = 0x0000FFFF0000FFFFL;\n+        long m32 = 0x00000000FFFFFFFFL;\n+\n+        acc = (acc & m8) + (( acc >>> 8) & m8);\n+        acc = (acc + (acc >>> 16) ) & m16;\n+        acc = (acc & m32) + (acc >>> 32);\n+        return acc;\n+    }\n+\n+    static long popcntLauradoux(long[] xs, int off) {\n+        long acc = 0;\n+        for (int j = off; j < off+12; j += 3) {\n+            acc += parallelPopcnt(xs[j+0], xs[j+1], xs[j+2]);\n+        }\n+        return reduce(acc);\n+    }\n+\n+    @Benchmark\n+    public long Lauradoux() {\n+        long acc = 0;\n+        int upper = data.length - (data.length % 12);\n+        for (int i = 0; i < upper; i += 12) {\n+            acc += popcntLauradoux(data, i);\n+        }\n+        return acc + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 6. A C function implementing a bitwise parallel carry-save adder (CSA). Given three input words a, b, c, it\n+    \/\/ generates two new words h, l in which each bit represents the high and low bits in the bitwise sum of the bits from a,\n+    \/\/ b, and c.\n+\n+    static long csaLow(long a, long b, long c) {\n+        long u = a ^ b;\n+        long lo = u ^ c;\n+        return lo;\n+    }\n+\n+    static long csaHigh(long a, long b, long c) {\n+        long u = a ^ b;\n+        long hi = (a & b) | (u & c) ;\n+        return hi;\n+    }\n+\n+    \/\/ FIGURE 8. A C function implementing the Harley-Seal\n+    \/\/ population count over an array of 64-bit words. The count\n+    \/\/ function could be the Wilkes-Wheeler-Gill function.\n+    @Benchmark\n+    public long HarleySeal() {\n+        long total = 0, ones = 0, twos = 0, fours = 0, eights = 0, sixteens = 0;\n+        long twosA   = 0, twosB   = 0;\n+        long foursA  = 0, foursB  = 0;\n+        long eightsA = 0, eightsB = 0;\n+\n+        int step = 16;\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            \/\/ CSA(&twosA, &ones, ones, d[i+0], d[i +1]);\n+            twosA = csaHigh(ones, data[i+0], data[i+1]);\n+            ones  = csaLow(ones, data[i+0], data[i+1]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+2], d[i+3]);\n+            twosB = csaHigh(ones, data[i+2], data[i+3]);\n+            ones  = csaLow(ones, data[i+2], data[i+3]);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+4], d[i+5]);\n+            twosA = csaHigh(ones, data[i+4], data[i+5]);\n+            ones  = csaLow(ones, data[i+4], data[i+5]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+6], d[i+7]);\n+            twosB = csaHigh(ones, data[i+6], data[i+7]);\n+            ones  = csaLow(ones, data[i+6], data[i+7]);\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&eightsA, &fours, fours, foursA, foursB);\n+            eightsA = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+8], d[i+9]);\n+            twosA = csaHigh(ones, data[i+8], data[i+9]);\n+            ones  = csaLow(ones, data[i+8], data[i+9]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+10],d[i+11]);\n+            twosB = csaHigh(ones, data[i+10], data[i+11]);\n+            ones  = csaLow(ones, data[i+10], data[i+11]);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+12], d[i +13]);\n+            twosA = csaHigh(ones, data[i+12], data[i+13]);\n+            ones  = csaLow(ones, data[i+12], data[i+13]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+14], d[i +15]);\n+            twosB = csaHigh(ones, data[i+14], data[i+15]);\n+            ones  = csaLow(ones, data[i+14], data[i+15]);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ CSA(&eightsB, &fours, fours, foursA, foursB);\n+            eightsB = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&sixteens, &eights, eights, eightsA, eightsB);\n+            sixteens = csaHigh(eights, eightsA, eightsB);\n+            eights   = csaLow(eights, eightsA, eightsB);\n+\n+            total += Long.bitCount(sixteens);\n+        }\n+        total = 16 * total\n+                + 8 * Long.bitCount(eights)\n+                + 4 * Long.bitCount(fours)\n+                + 2 * Long.bitCount(twos)\n+                + 1 * Long.bitCount(ones);\n+\n+        return total + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 9. A C function using SSE intrinsics implementing Mula's algorithm to compute sixteen population counts,\n+    \/\/ corresponding to sixteen input bytes.\n+\n+    static final ByteVector MULA128_LOOKUP = IntVector.fromArray(I128,\n+            new int[]{\n+                    0x02_01_01_00, \/\/ 0, 1, 1, 2,\n+                    0x03_02_02_01, \/\/ 1, 2, 2, 3,\n+                    0x03_02_02_01, \/\/ 1, 2, 2, 3,\n+                    0x04_03_03_02  \/\/ 2, 3, 3, 4\n+            },\n+            0\n+            ).reinterpretAsBytes();\n+\n+    ByteVector popcntB128(ByteVector v) {\n+        var low_mask = ByteVector.broadcast(B128, (byte)0x0f);\n+\n+        var lo = v          .and(low_mask);\n+        var hi = v.lanewise(VectorOperators.LSHR, 4).and(low_mask);\n+\n+        var cnt1 = MULA128_LOOKUP.rearrange(lo.toShuffle());\n+        var cnt2 = MULA128_LOOKUP.rearrange(hi.toShuffle());\n+\n+        return cnt1.add(cnt2);\n+    }\n+\n+    @Benchmark\n+    public long Mula128() {\n+        var acc = LongVector.zero(L128); \/\/ IntVector\n+        int step = 32; \/\/ % B128.length() == 0!\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            var bacc = ByteVector.zero(B128);\n+            for (int j = 0; j < step; j += L128.length()) {\n+                var v1 = LongVector.fromArray(L128, data, i + j);\n+                var v2 = v1.reinterpretAsBytes();\n+                var v3 = popcntB128(v2);\n+                bacc = bacc.add(v3);\n+            }\n+            acc = acc.add(sumUnsignedBytes(bacc));\n+        }\n+        var r = acc.reduceLanes(VectorOperators.ADD) + tail(upper);\n+        return r;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 10. A C function using AVX2 intrinsics implementing Mula's algorithm to compute the four population counts\n+    \/\/ of the four 64-bit words in a 256-bit vector. The 32 B output vector should be interpreted as four separate\n+    \/\/ 64-bit counts that need to be summed to obtain the final population count.\n+\n+    static final ByteVector MULA256_LOOKUP = \n+            join(I128, I256, MULA128_LOOKUP.reinterpretAsInts(), MULA128_LOOKUP.reinterpretAsInts()).reinterpretAsBytes();\n+\n+    ByteVector popcntB256(ByteVector v) {\n+        var low_mask = ByteVector.broadcast(B256, (byte)0x0F);\n+\n+        var lo = v          .and(low_mask);\n+        var hi = v.lanewise(VectorOperators.LSHR, 4).and(low_mask);\n+\n+        var cnt1 = MULA256_LOOKUP.rearrange(lo.toShuffle());\n+        var cnt2 = MULA256_LOOKUP.rearrange(hi.toShuffle());\n+        var cnt = cnt1.add(cnt2);\n+\n+        return cnt;\n+    }\n+\n+    \/\/ Horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers,\n+    \/\/ and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in dst:\n+    \/\/   _mm256_sad_epu8(total, _mm256_setzero_si256())\n+    LongVector sumUnsignedBytes(ByteVector vb) {\n+        return sumUnsignedBytesShapes(vb);\n+\/\/        return sumUnsignedBytesShifts(vb);\n+    }\n+\n+    LongVector sumUnsignedBytesShapes(ByteVector vb) {\n+        VectorSpecies<Short> shortSpecies = VectorSpecies.of(short.class, vb.shape());\n+        VectorSpecies<Integer> intSpecies = VectorSpecies.of(int.class, vb.shape());\n+        VectorSpecies<Long> longSpecies = VectorSpecies.of(long.class, vb.shape());\n+\n+        var low_short_mask = ShortVector.broadcast(shortSpecies, (short) 0xFF);\n+        var low_int_mask = IntVector.broadcast(intSpecies, 0xFFFF);\n+        var low_long_mask = LongVector.broadcast(longSpecies, 0xFFFFFFFFL);\n+\n+        var vs = vb.reinterpretAsShorts(); \/\/ 16-bit\n+        var vs0 = vs.and(low_short_mask);\n+        var vs1 = vs.lanewise(VectorOperators.LSHR, 8).and(low_short_mask);\n+        var vs01 = vs0.add(vs1);\n+\n+        var vi = vs01.reinterpretAsInts(); \/\/ 32-bit\n+        var vi0 = vi.and(low_int_mask);\n+        var vi1 = vi.lanewise(VectorOperators.LSHR, 16).and(low_int_mask);\n+        var vi01 = vi0.add(vi1);\n+\n+        var vl = vi01.reinterpretAsLongs(); \/\/ 64-bit\n+        var vl0 = vl.and(low_long_mask);\n+        var vl1 = vl.lanewise(VectorOperators.LSHR, 32).and(low_long_mask);\n+        var vl01 = vl0.add(vl1);\n+\n+        return vl01;\n+    }\n+\n+    LongVector sumUnsignedBytesShifts(ByteVector vb) {\n+        VectorSpecies<Long> to = VectorSpecies.of(long.class, vb.shape());\n+\n+        var low_mask = LongVector.broadcast(to, 0xFF);\n+\n+        var vl = vb.reinterpretAsLongs();\n+\n+        var v0 = vl           .and(low_mask); \/\/ 8-bit\n+        var v1 = vl.lanewise(VectorOperators.LSHR, 8).and(low_mask);  \/\/ 8-bit\n+        var v2 = vl.lanewise(VectorOperators.LSHR, 16).and(low_mask); \/\/ 8-bit\n+        var v3 = vl.lanewise(VectorOperators.LSHR, 24).and(low_mask); \/\/ 8-bit\n+        var v4 = vl.lanewise(VectorOperators.LSHR, 32).and(low_mask); \/\/ 8-bit\n+        var v5 = vl.lanewise(VectorOperators.LSHR, 40).and(low_mask); \/\/ 8-bit\n+        var v6 = vl.lanewise(VectorOperators.LSHR, 48).and(low_mask); \/\/ 8-bit\n+        var v7 = vl.lanewise(VectorOperators.LSHR, 56).and(low_mask); \/\/ 8-bit\n+\n+        var v01 = v0.add(v1);\n+        var v23 = v2.add(v3);\n+        var v45 = v4.add(v5);\n+        var v67 = v6.add(v7);\n+\n+        var v03 = v01.add(v23);\n+        var v47 = v45.add(v67);\n+\n+        var sum = v03.add(v47); \/\/ 64-bit\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long Mula256() {\n+        var acc = LongVector.zero(L256);\n+        int step = 32; \/\/ % B256.length() == 0!\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            var bacc = ByteVector.zero(B256);\n+            for (int j = 0; j < step; j += L256.length()) {\n+                var v1 = LongVector.fromArray(L256, data, i + j);\n+                var v2 = popcntB256(v1.reinterpretAsBytes());\n+                bacc = bacc.add(v2);\n+            }\n+            acc = acc.add(sumUnsignedBytes(bacc));\n+        }\n+        return acc.reduceLanes(VectorOperators.ADD) + tail(upper);\n+    }\n+\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 11. A C function using AVX2 intrinsics implementing a bitwise parallel carry-save adder (CSA).\n+\n+    LongVector csaLow(LongVector a, LongVector b, LongVector c) {\n+        var u = a.lanewise(VectorOperators.XOR, b);\n+        var r = u.lanewise(VectorOperators.XOR, c);\n+        return r;\n+    }\n+\n+    LongVector csaHigh(LongVector a, LongVector b, LongVector c) {\n+        var u  = a.lanewise(VectorOperators.XOR, b);\n+        var ab = a.and(b);\n+        var uc = u.and(c);\n+        var r  = ab.or(uc); \/\/ (a & b) | ((a ^ b) & c)\n+        return r;\n+    }\n+\n+    LongVector popcntL256(LongVector v) {\n+        var vb1 = v.reinterpretAsBytes();\n+        var vb2 = popcntB256(vb1);\n+        return sumUnsignedBytes(vb2);\n+    }\n+\n+    \/\/ FIGURE 12. A C function using AVX2 intrinsics implementing Harley-Seal's algorithm. It assumes, for\n+    \/\/ simplicity, that the input size in 256-bit vectors is divisible by 16. See Fig. 10 for the count function.\n+\n+    @Benchmark\n+    public long HarleySeal256() {\n+        LongVector ones, twos, fours, eights, sixteens, vtotal, twosA, twosB, foursA, foursB, eightsA, eightsB;\n+        ones = twos = fours = eights = sixteens = twosA = twosB = foursA = foursB = eightsA = eights = vtotal = LongVector.broadcast(L256, 0);\n+\n+        var vlen = L256.length();\n+        int step = 16 * vlen;\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            \/\/ CSA(&twosA, &ones, ones, d[i+0], d[i +1]);\n+            var d0 = LongVector.fromArray(L256, data, i + 0 * vlen);\n+            var d1 = LongVector.fromArray(L256, data, i + 1 * vlen);\n+\n+            twosA = csaHigh(ones, d0, d1);\n+            ones  = csaLow(ones, d0, d1);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+2], d[i+3]);\n+            var d2 = LongVector.fromArray(L256, data, i + 2 * vlen);\n+            var d3 = LongVector.fromArray(L256, data, i + 3 * vlen);\n+            twosB = csaHigh(ones, d2, d3);\n+            ones  = csaLow(ones, d2, d3);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+4], d[i+5]);\n+            var d4 = LongVector.fromArray(L256, data, i + 4 * vlen);\n+            var d5 = LongVector.fromArray(L256, data, i + 5 * vlen);\n+            twosA = csaHigh(ones, d4, d5);\n+            ones  = csaLow(ones, d4, d5);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+6], d[i+7]);\n+            var d6 = LongVector.fromArray(L256, data, i + 6 * vlen);\n+            var d7 = LongVector.fromArray(L256, data, i + 7 * vlen);\n+            twosB = csaHigh(ones, d6, d7);\n+            ones  = csaLow(ones, d6, d7);\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&eightsA, &fours, fours, foursA, foursB);\n+            eightsA = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+8], d[i+9]);\n+            var d8 = LongVector.fromArray(L256, data, i + 8 * vlen);\n+            var d9 = LongVector.fromArray(L256, data, i + 9 * vlen);\n+            twosA = csaHigh(ones, d8, d9);\n+            ones  = csaLow(ones, d8, d9);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+10],d[i+11]);\n+            var d10 = LongVector.fromArray(L256, data, i + 10 * vlen);\n+            var d11 = LongVector.fromArray(L256, data, i + 11 * vlen);\n+            twosB = csaHigh(ones, d10, d11);\n+            ones  = csaLow(ones, d10, d11);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+12], d[i +13]);\n+            var d12 = LongVector.fromArray(L256, data, i + 12 * vlen);\n+            var d13 = LongVector.fromArray(L256, data, i + 13 * vlen);\n+            twosA = csaHigh(ones, d12, d13);\n+            ones  = csaLow(ones, d12, d13);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+14], d[i +15]);\n+            var d14 = LongVector.fromArray(L256, data, i + 14 * vlen);\n+            var d15 = LongVector.fromArray(L256, data, i + 15 * vlen);\n+            twosB = csaHigh(ones, d14, d15);\n+            ones  = csaLow(ones, d14, d15);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ CSA(&eightsB, &fours, fours, foursA, foursB);\n+            eightsB = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&sixteens, &eights, eights, eightsA, eightsB);\n+            sixteens = csaHigh(eights, eightsA, eightsB);\n+            eights   = csaLow(eights, eightsA, eightsB);\n+\n+            vtotal = vtotal.add(popcntL256(sixteens));\n+        }\n+\n+        vtotal = vtotal.mul(16);                       \/\/ << 4\n+        vtotal = vtotal.add(popcntL256(eights).mul(8)); \/\/ << 3\n+        vtotal = vtotal.add(popcntL256(fours).mul(4));  \/\/ << 2\n+        vtotal = vtotal.add(popcntL256(twos).mul(2));   \/\/ << 1\n+        vtotal = vtotal.add(popcntL256(ones));          \/\/ << 0\n+\n+        var total = vtotal.reduceLanes(VectorOperators.ADD);\n+\n+        return total + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+\/\/    ByteVector csaLow512(ByteVector a, ByteVector b, ByteVector c) {\n+\/\/        return _mm512_ternarylogic_epi32(c, b, a, 0x96); \/\/ vpternlogd\n+\/\/    }\n+\/\/\n+\/\/    ByteVector csaLow512(ByteVector a, ByteVector b, ByteVector c) {\n+\/\/        return _mm512_ternarylogic_epi32(c, b, a, 0xe8); \/\/ vpternlogd\n+\/\/    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/PopulationCount.java","additions":630,"deletions":0,"binary":false,"changes":630,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (short)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (short)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (short)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (short)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1879 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ShortMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short)Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(0, (short)4).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void gather(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void gatherMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b    = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatter(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void scatterMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":1879,"deletions":0,"binary":false,"changes":1879,"status":"added"},{"patch":"@@ -0,0 +1,1610 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ShortScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    short[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (short)(2*i));\n+        bs = fill(i -> (short)(i+1));\n+        cs = fill(i -> (short)(i+5));\n+        rs = fill(i -> (short)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> as;\n+    final IntFunction<short[]> fb = vl -> bs;\n+    final IntFunction<short[]> fc = vl -> cs;\n+    final IntFunction<short[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a << (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a >> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(((a & 0xFFFF) >>> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a << (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(((a & 0xFFFF) >>> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a >> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = Short.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (short)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = Short.MAX_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MAX_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (short)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = Short.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                r = (short)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = Short.MIN_VALUE;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = Short.MIN_VALUE;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = (short)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    short a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (short)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                rs[i] = (short)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(-((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(-((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Math.abs((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Math.abs((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(~((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(~((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void gatherBase0(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[i] = as[ix];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+    void gather(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[i + j] = as[ix];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void gather064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void gather512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        gather(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatterBase0(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int ix = 0 + is[i];\n+                rs[ix] = as[i];\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void scatter(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] is    = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int ix = is[i + j];\n+                    rs[ix] = as[i + j];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void scatter064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        scatter(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void scatter512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        scatter(window, bh);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":1610,"deletions":0,"binary":false,"changes":1610,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Inspired by \"Sorting an AVX512 register\"\n+ *   http:\/\/0x80.pl\/articles\/avx512-sort-register.html\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SortVector extends AbstractVectorBenchmark {\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    int[] in, out;\n+\n+    @Setup\n+    public void setup() {\n+        size = size + (size % 16); \/\/ FIXME: process tails\n+        in  = fillInt(size, i -> RANDOM.nextInt());\n+        out = new int[size];\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI64() {\n+        sort(I64);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI128() {\n+        sort(I128);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI256() {\n+        sort(I256);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI512() {\n+        sort(I512);\n+    }\n+\n+\n+    void sort(VectorSpecies<Integer> spec) {\n+        var iota = (IntVector) VectorShuffle.iota(spec, 0, 1, false).toVector(); \/\/ [ 0 1 ... n ]\n+\n+        var result = IntVector.broadcast(spec, 0);\n+        var index = IntVector.broadcast(spec, 0);\n+        var incr = IntVector.broadcast(spec, 1);\n+\n+        for (int i = 0; i < in.length; i += spec.length()) {\n+            var input = IntVector.fromArray(spec, in, i);\n+\n+            for (int j = 0; j < input.length(); j++) {\n+                var shuf = index.toShuffle().wrapIndexes();\n+                var b = input.rearrange(shuf); \/\/ broadcast j-th element\n+                var lt = input.lt(b).trueCount();\n+                var eq = input.eq(b).trueCount();\n+\n+                \/\/ int\/long -> mask?\n+                \/\/ int m = (1 << (lt + eq)) - (1 << lt);\n+                \/\/ var mask = masks[lt + eq].lanewise(VectorOperators.XOR, masks[lt]);\n+                \/\/ var mask = masks[lt + eq].and(masks[lt].not());\n+                \/\/\n+                \/\/ masks[i] =  [ 0 0 ... 0 1 ... 1 ]\n+                \/\/                      i-th\n+                var m = iota.lt(spec.broadcast(lt + eq)).and(iota.lt(spec.broadcast(lt)).not());\n+\n+                result = result.blend(b, m);\n+                index = index.add(incr);\n+            }\n+            result.intoArray(out, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/SortVector.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\n+\/\/ Inspired by \"SIMDized sum of all bytes in the array\"\n+\/\/   http:\/\/0x80.pl\/notesen\/2018-10-24-sse-sumbytes.html\n+\/\/\n+\/\/ C\/C++ equivalent: https:\/\/github.com\/WojciechMula\/toys\/tree\/master\/sse-sumbytes\n+\/\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SumOfUnsignedBytes extends AbstractVectorBenchmark {\n+\n+    @Param({\"64\", \"1024\", \"4096\"})\n+    int size;\n+\n+    private byte[] data;\n+\n+    @Setup\n+    public void init() {\n+        size = size + size % 32; \/\/ FIXME: process tails\n+        data = fillByte(size, i -> (byte)(int)i);\n+\n+        int sum = scalar();\n+        assert vectorInt() == sum;\n+        assert vectorShort() == sum;\n+        \/\/assert vectorByte() == sum;\n+        \/\/assert vectorSAD() == sum;\n+    }\n+\n+    @Benchmark\n+    public int scalar() {\n+        int sum = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            sum += data[i] & 0xFF;\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ 1. 32-bit accumulators\n+    @Benchmark\n+    public int vectorInt() {\n+        final var lobyte_mask = IntVector.broadcast(I256, 0x000000FF);\n+\n+        var acc = IntVector.zero(I256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var vb = ByteVector.fromArray(B256, data, i);\n+            var vi = (IntVector)vb.reinterpretAsInts();\n+            for (int j = 0; j < 4; j++) {\n+                var tj = vi.lanewise(VectorOperators.LSHR, j * 8).and(lobyte_mask);\n+                acc = acc.add(tj);\n+            }\n+        }\n+        return (int)Integer.toUnsignedLong(acc.reduceLanes(VectorOperators.ADD));\n+    }\n+\n+    \/\/ 2. 16-bit accumulators\n+    @Benchmark\n+    public int vectorShort() {\n+        final var lobyte_mask = ShortVector.broadcast(S256, (short) 0x00FF);\n+\n+        \/\/ FIXME: overflow\n+        var acc = ShortVector.zero(S256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var vb = ByteVector.fromArray(B256, data, i);\n+            var vs = (ShortVector)vb.reinterpretAsShorts();\n+            for (int j = 0; j < 2; j++) {\n+                var tj = vs.lanewise(VectorOperators.LSHR, j * 8).and(lobyte_mask);\n+                acc = acc.add(tj);\n+            }\n+        }\n+\n+        int mid = S128.length();\n+        var accLo = ((IntVector)(acc.reinterpretShape(S128, 0).castShape(I256, 0))).and(0xFFFF); \/\/ low half as ints\n+        var accHi = ((IntVector)(acc.reinterpretShape(S128, 1).castShape(I256, 0))).and(0xFFFF); \/\/ high half as ints\n+        return accLo.reduceLanes(VectorOperators.ADD) + accHi.reduceLanes(VectorOperators.ADD);\n+    }\n+\n+    \/*\n+    \/\/ 3. 8-bit halves (MISSING: _mm_adds_epu8)\n+    @Benchmark\n+    public int vectorByte() {\n+        int window = 256;\n+        var acc_hi  = IntVector.zero(I256);\n+        var acc8_lo = ByteVector.zero(B256);\n+        for (int i = 0; i < data.length; i += window) {\n+            var acc8_hi = ByteVector.zero(B256);\n+            int limit = Math.min(window, data.length - i);\n+            for (int j = 0; j < limit; j += B256.length()) {\n+                var vb = ByteVector.fromArray(B256, data, i + j);\n+\n+                var t0 = acc8_lo.add(vb);\n+                var t1 = addSaturated(acc8_lo, vb); \/\/ MISSING\n+                var overflow = t0.notEqual(t1);\n+\n+                acc8_lo = t0;\n+                acc8_hi = acc8_hi.add((byte) 1, overflow);\n+            }\n+            acc_hi = acc_hi.add(sum(acc8_hi));\n+        }\n+        return sum(acc8_lo)\n+                .add(acc_hi.mul(256)) \/\/ overflow\n+                .addAll();\n+    }\n+\n+    \/\/ 4. Sum Of Absolute Differences (SAD) (MISSING: VPSADBW, _mm256_sad_epu8)\n+    public int vectorSAD() {\n+        var acc = IntVector.zero(I256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var v = ByteVector.fromArray(B256, data, i);\n+            var sad = sumOfAbsoluteDifferences(v, ByteVector.zero(B256)); \/\/ MISSING\n+            acc = acc.add(sad);\n+        }\n+        return acc.addAll();\n+    } *\/\n+\n+    \/\/ Helpers\n+    \/*\n+    static ByteVector addSaturated(ByteVector va, ByteVector vb) {\n+        var vc = ByteVector.zero(B256);\n+        for (int i = 0; i < B256.length(); i++) {\n+            if ((va.get(i) & 0xFF) + (vb.get(i) & 0xFF) < 0xFF) {\n+                vc = vc.withLane(i, (byte)(va.get(i) + vb.get(i)));\n+            } else {\n+                vc = vc.withLane(i, (byte)0xFF);\n+            }\n+        }\n+        return vc;\n+    }\n+    IntVector sumOfAbsoluteDifferences(ByteVector va, ByteVector vb) {\n+        var vc = ByteVector.zero(B256);\n+        for (int i = 0; i < B256.length(); i++) {\n+            if ((va.get(i) & 0xFF) > (vb.get(i) & 0xFF)) {\n+                vc = vc.withLane(i, (byte)(va.get(i) - vb.get(i)));\n+            } else {\n+                vc = vc.withLane(i, (byte)(vb.get(i) - va.get(i)));\n+            }\n+        }\n+        return sum(vc);\n+    } *\/\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/SumOfUnsignedBytes.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.utf8;\n+\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CoderResult;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import jdk.incubator.vector.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 5, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class DecodeBench {\n+\n+    @Param({\"32768\", \"8388608\"})\n+    private int dataSize;\n+\n+    @Param({\"1\", \"2\", \"3\", \"4\"})\n+    private int maxBytes;\n+\n+    private ByteBuffer src;\n+    private CharBuffer dst;\n+    private String in;\n+    private String out;\n+\n+    private static final VectorSpecies<Byte>  B128 = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+\n+    private static final HashMap<Long, DecoderLutEntry> lutTable = new HashMap<Long, DecoderLutEntry>();\n+\n+    private static class DecoderLutEntry {\n+        public final VectorShuffle<Byte> shufAB;   \/\/ shuffling mask to get lower two bytes of symbols\n+        public final VectorShuffle<Byte> shufC;    \/\/ shuffling mask to get third bytes of symbols\n+        public final byte srcStep;                 \/\/ number of bytes processed in input buffer\n+        public final byte dstStep;                 \/\/ number of symbols produced in output buffer (doubled)\n+        public final Vector<Byte> headerMask;      \/\/ mask of \"111..10\" bits required in each byte\n+        public final Vector<Short> zeroBits;\n+\n+        public DecoderLutEntry(VectorShuffle<Byte> _shufAB, VectorShuffle<Byte> _shufC,\n+                               byte _srcStep, byte _dstStep,\n+                               Vector<Byte> _headerMask, Vector<Short> _zeroBits) {\n+            shufAB = _shufAB;\n+            shufC = _shufC;\n+            srcStep = _srcStep;\n+            dstStep = _dstStep;\n+            headerMask = _headerMask;\n+            zeroBits = _zeroBits;\n+        }\n+\n+        \/\/ @Override\n+        \/\/ public String toString() {\n+        \/\/     return String.format(\"shufAB = %s, shufC = %s, srcStep = %d, dstStep = %d, headerMask = %s, zeroBits = %s\",\n+        \/\/         arrayToString(shufAB), arrayToString(shufC), srcStep, dstStep, arrayToString(headerMask), arrayToString(zeroBits));\n+        \/\/ }\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupLutTable() {\n+        int[] sizes = new int[32];\n+        computeLutRecursive(sizes, 0, 0); \/\/10609 entries total\n+\n+        \/\/ for (var entry : lutTable.entrySet()) {\n+        \/\/     System.out.println(\"\" + entry.getKey() + \" -> \" + entry.getValue());\n+        \/\/ }\n+    }\n+\n+    static void computeLutRecursive(int[] sizes, int num, int total) {\n+        if (total >= 16) {\n+            computeLutEntry(sizes, num);\n+            return;\n+        }\n+        for (int size = 1; size <= 3; size++) {\n+            sizes[num] = size;\n+            computeLutRecursive(sizes, num + 1, total + size);\n+        }\n+    }\n+\n+    static void computeLutEntry(int[] sizes, int num) {\n+        \/\/find maximal number of chars to decode\n+        int cnt = num - 1;\n+        int preSum = 0;\n+        for (int i = 0; i < cnt; i++)\n+            preSum += sizes[i];\n+        assert preSum < 16;\n+        \/\/ Note: generally, we can process a char only if the next byte is within XMM register\n+        \/\/ However, if the last char takes 3 bytes and fits the register tightly, we can take it too\n+        if (preSum == 13 && preSum + sizes[cnt] == 16)\n+            preSum += sizes[cnt++];\n+        \/\/still cannot process more that 8 chars per register\n+        while (cnt > 8)\n+            preSum -= sizes[--cnt];\n+\n+        \/\/generate bitmask\n+        long mask = 0;\n+        for (int i = 0, pos = 0; i < num; i++) {\n+            for (int j = 0; j < sizes[i]; j++, pos++) {\n+                \/\/ The first byte is not represented in the mask\n+                if (j > 0) {\n+                    mask |= 1 << pos;\n+                }\n+            }\n+        }\n+        assert mask <= 0xFFFF;\n+\n+        \/\/generate shuffle masks\n+        byte[] shufAB = new byte[16];\n+        byte[] shufC  = new byte[16];\n+        for (int i = 0; i < 16; i++)\n+            shufAB[i] = shufC[i] = (byte)0xFF;\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = sz-1; j >= 0; j--, pos++) {\n+                if (j < 2)\n+                    shufAB[2 * i + j] = (byte)pos;\n+                else\n+                    shufC[2 * i] = (byte)pos;\n+            }\n+        }\n+\n+        \/\/generate header masks for validation\n+        byte[] headerMask = new byte[16];\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = 0; j < sz; j++, pos++) {\n+                int bits;\n+                if      (j > 0)    bits = 2;\n+                else if (sz == 1)  bits = 1;\n+                else if (sz == 2)  bits = 3;\n+                else   \/*sz == 3*\/ bits = 4;\n+                headerMask[pos] = (byte)-(1 << (8 - bits));\n+            }\n+        }\n+\n+        \/\/generate min symbols values for validation\n+        short[] zeroBits = new short[8];\n+        for (int i = 0; i < 8; i++) {\n+            int sz = i < cnt ? sizes[i] : 1;\n+            if      (sz == 1)  zeroBits[i] = (short)(0xFF80);\n+            else if (sz == 2)  zeroBits[i] = (short)(0xF800);\n+            else   \/*sz == 3*\/ zeroBits[i] = (short)(0x0000);\n+        }\n+\n+        \/\/store info into the lookup table\n+        lutTable.put(mask, new DecoderLutEntry(ByteVector.fromArray(B128, shufAB, 0).toShuffle(),\n+                                               ByteVector.fromArray(B128, shufC, 0).toShuffle(),\n+                                               (byte)preSum, (byte)cnt,\n+                                               ByteVector.fromArray(B128, headerMask, 0),\n+                                               ShortVector.fromArray(S128, zeroBits, 0)));\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        in = randomString(dataSize, maxBytes);\n+        src = ByteBuffer.wrap(in.getBytes());\n+        dst = CharBuffer.allocate(in.length());\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setupInvocation() {\n+        src.clear();\n+        dst.clear();\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDownInvocation() {\n+        out = new String(dst.array());\n+        if (!in.equals(out)) {\n+            System.out.println(\"in  = (\" + in.length() + \") \\\"\" + arrayToString(in.getBytes()) + \"\\\"\");\n+            System.out.println(\"out = (\" + out.length() + \") \\\"\" + arrayToString(out.getBytes()) + \"\\\"\");\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    private static final Random RANDOM = new Random(0);\n+    private static int randomInt(int min \/* inclusive *\/, int max \/* inclusive *\/) {\n+        return RANDOM.nextInt(max - min + 1) + min;\n+    }\n+    private static String randomString(int dataSize, int maxBytes) {\n+        ByteBuffer buf = ByteBuffer.allocate(dataSize);\n+        for (int i = 0, size = randomInt(1, maxBytes); i + size - 1 < dataSize; i += size, size = randomInt(1, maxBytes)) {\n+            int b1, b2, b3, b4;\n+            switch (size) {\n+            case 1: {\n+                b1 = randomInt(0x00, 0x7F);\n+                buf.put(i + 0, (byte)((0b0     << (8 - 1)) | b1));\n+                break;\n+            }\n+            case 2: {\n+                b1 = randomInt(0xC2, 0xDF);\n+                b2 = randomInt(0x80, 0xBF);\n+                buf.put(i + 0, (byte)((0b110   << (8 - 3)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                break;\n+            }\n+            case 3: {\n+                b1 = randomInt(0xE0, 0xEF);\n+                switch (b1) {\n+                case 0xE0:\n+                    b2 = randomInt(0xA0, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b1110  << (8 - 4)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                break;\n+            }\n+            case 4: {\n+                b1 = randomInt(0xF0, 0xF4);\n+                switch (b1) {\n+                case 0xF0:\n+                    b2 = randomInt(0x90, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                case 0xF4:\n+                    b2 = randomInt(0x80, 0x8F);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b11110 << (8 - 5)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                buf.put(i + 3, (byte)((0b10    << (8 - 2)) | b4));\n+                break;\n+            }\n+            default:\n+                throw new RuntimeException(\"not supported\");\n+            }\n+        }\n+        return new String(buf.array(), Charset.forName(\"UTF-8\"));\n+    }\n+\n+    private static String arrayToString(byte[] array) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < array.length; ++i) {\n+            if (i != 0) sb.append(\",\");\n+            sb.append(String.format(\"%x\", (byte)array[i]));\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Benchmark\n+    public void decodeScalar() {\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVector() {\n+        decodeArrayVectorized(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVectorASCII() {\n+        decodeArrayVectorizedASCII(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    private static void decodeArrayVectorized(ByteBuffer src, CharBuffer dst) {\n+        \/\/ Algorithm is largely inspired from https:\/\/dirtyhandscoding.github.io\/posts\/utf8lut-vectorized-utf-8-converter-introduction.html\n+\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        while (sp + B128.length() < sl && dp + S128.length() < dl) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            \/* Decode *\/\n+\n+            var continuationByteMask = bytes.lanewise(VectorOperators.AND, (byte)0xC0).compare(VectorOperators.EQ, (byte)0x80);\n+            final DecoderLutEntry lookup = lutTable.get(continuationByteMask.toLong());\n+            if (lookup == null) {\n+                break;\n+            }\n+            \/\/ Shuffle the 1st and 2nd bytes\n+            var Rab = bytes.rearrange(lookup.shufAB, lookup.shufAB.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Shuffle the 3rd byte\n+            var Rc  = bytes.rearrange(lookup.shufC, lookup.shufC.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Extract the bits from each byte\n+            var sum = Rab.lanewise(VectorOperators.AND, (short)0x007F)\n+                 .add(Rab.lanewise(VectorOperators.AND, (short)0x3F00).lanewise(VectorOperators.LSHR, 2))\n+                 .add(Rc.lanewise(VectorOperators.LSHL, 12));\n+\n+            \/* Validate *\/\n+\n+            var zeroBits = lookup.zeroBits;\n+            if (sum.lanewise(VectorOperators.AND, zeroBits).compare(VectorOperators.NE, 0).anyTrue()) {\n+                break;\n+            }\n+            \/\/ Check for surrogate code point\n+            if (sum.lanewise(VectorOperators.SUB, (short)0x6000).compare(VectorOperators.GT, 0x77FF).anyTrue()) {\n+                break;\n+            }\n+            var headerMask = lookup.headerMask;\n+            if (bytes.lanewise(VectorOperators.AND, headerMask).compare(VectorOperators.NE, headerMask.lanewise(VectorOperators.LSHL, 1)).anyTrue()) {\n+                break;\n+            }\n+\n+            \/* Advance *\/\n+\n+            ((ShortVector)sum).intoCharArray(da, dp);\n+            sp += lookup.srcStep;\n+            dp += lookup.dstStep;\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static void decodeArrayVectorizedASCII(ByteBuffer src, CharBuffer dst) {\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        for (; sp <= sl - B128.length() && dp <= dl - S256.length(); sp += B128.length(), dp += S256.length()) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            if (bytes.compare(VectorOperators.LT, (byte) 0x00).anyTrue())\n+                break;\n+\n+            ((ShortVector) bytes.convertShape(VectorOperators.B2S, S256, 0)).intoCharArray(da, dp);\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {\n+        \/\/ This method is optimized for ASCII input.\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+        int dlASCII = dp + Math.min(sl - sp, dl - dp);\n+\n+        \/\/ ASCII only loop\n+        while (dp < dlASCII && sa[sp] >= 0)\n+            da[dp++] = (char) sa[sp++];\n+        while (sp < sl) {\n+            int b1 = sa[sp];\n+            if (b1 >= 0) {\n+                \/\/ 1 byte, 7 bits: 0xxxxxxx\n+                if (dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 1);\n+                da[dp++] = (char) b1;\n+                sp++;\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                \/\/ 2 bytes, 11 bits: 110xxxxx 10xxxxxx\n+                \/\/                   [C2..DF] [80..BF]\n+                if (sl - sp < 2 || dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 2);\n+                int b2 = sa[sp + 1];\n+                \/\/ Now we check the first byte of 2-byte sequence as\n+                \/\/     if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0)\n+                \/\/ no longer need to check b1 against c1 & c0 for\n+                \/\/ malformed as we did in previous version\n+                \/\/   (b1 & 0x1e) == 0x0 || (b2 & 0xc0) != 0x80;\n+                \/\/ only need to check the second byte b2.\n+                if (isNotContinuation(b2))\n+                    return malformedForLength(src, sp, dst, dp, 1);\n+                da[dp++] = (char) (((b1 << 6) ^ b2)\n+                                   ^\n+                                   (((byte) 0xC0 << 6) ^\n+                                    ((byte) 0x80 << 0)));\n+                sp += 2;\n+            } else if ((b1 >> 4) == -2) {\n+                \/\/ 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 3 || dp >= dl) {\n+                    if (srcRemaining > 1 && isMalformed3_2(b1, sa[sp + 1]))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    return xflow(src, sp, sl, dst, dp, 3);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                if (isMalformed3(b1, b2, b3))\n+                    return malformed(src, sp, dst, dp, 3);\n+                char c = (char)\n+                    ((b1 << 12) ^\n+                     (b2 <<  6) ^\n+                     (b3 ^\n+                      (((byte) 0xE0 << 12) ^\n+                       ((byte) 0x80 <<  6) ^\n+                       ((byte) 0x80 <<  0))));\n+                if (Character.isSurrogate(c))\n+                    return malformedForLength(src, sp, dst, dp, 3);\n+                da[dp++] = c;\n+                sp += 3;\n+            } else if ((b1 >> 3) == -2) {\n+                \/\/ 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 4 || dl - dp < 2) {\n+                    b1 &= 0xff;\n+                    if (b1 > 0xf4 ||\n+                        srcRemaining > 1 && isMalformed4_2(b1, sa[sp + 1] & 0xff))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    if (srcRemaining > 2 && isMalformed4_3(sa[sp + 2]))\n+                        return malformedForLength(src, sp, dst, dp, 2);\n+                    return xflow(src, sp, sl, dst, dp, 4);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                int b4 = sa[sp + 3];\n+                int uc = ((b1 << 18) ^\n+                          (b2 << 12) ^\n+                          (b3 <<  6) ^\n+                          (b4 ^\n+                           (((byte) 0xF0 << 18) ^\n+                            ((byte) 0x80 << 12) ^\n+                            ((byte) 0x80 <<  6) ^\n+                            ((byte) 0x80 <<  0))));\n+                if (isMalformed4(b2, b3, b4) ||\n+                    \/\/ shortest form check\n+                    !Character.isSupplementaryCodePoint(uc)) {\n+                    return malformed(src, sp, dst, dp, 4);\n+                }\n+                da[dp++] = Character.highSurrogate(uc);\n+                da[dp++] = Character.lowSurrogate(uc);\n+                sp += 4;\n+            } else\n+                return malformed(src, sp, dst, dp, 1);\n+        }\n+        return xflow(src, sp, sl, dst, dp, 0);\n+    }\n+\n+    private static CoderResult xflow(Buffer src, int sp, int sl,\n+                                     Buffer dst, int dp, int nb) {\n+        updatePositions(src, sp, dst, dp);\n+        return (nb == 0 || sl - sp < nb)\n+               ? CoderResult.UNDERFLOW : CoderResult.OVERFLOW;\n+    }\n+\n+    private static CoderResult malformedForLength(ByteBuffer src,\n+                                                  int sp,\n+                                                  CharBuffer dst,\n+                                                  int dp,\n+                                                  int malformedNB)\n+    {\n+        updatePositions(src, sp, dst, dp);\n+        return CoderResult.malformedForLength(malformedNB);\n+    }\n+\n+    private static CoderResult malformed(ByteBuffer src, int sp,\n+                                         CharBuffer dst, int dp,\n+                                         int nb)\n+    {\n+        src.position(sp - src.arrayOffset());\n+        CoderResult cr = malformedN(src, sp, nb);\n+        updatePositions(src, sp, dst, dp);\n+        return cr;\n+    }\n+\n+    private static CoderResult malformedN(ByteBuffer src, int sp,\n+                                          int nb) {\n+        switch (nb) {\n+        case 1:\n+        case 2:                    \/\/ always 1\n+            return CoderResult.malformedForLength(1);\n+        case 3:\n+            int b1 = src.get();\n+            int b2 = src.get();    \/\/ no need to lookup b3\n+            return CoderResult.malformedForLength(\n+                ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                 isNotContinuation(b2)) ? 1 : 2);\n+        case 4:  \/\/ we don't care the speed here\n+            b1 = src.get() & 0xff;\n+            b2 = src.get() & 0xff;\n+            if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+                return CoderResult.malformedForLength(1);\n+            if (isNotContinuation(src.get()))\n+                return CoderResult.malformedForLength(2);\n+            return CoderResult.malformedForLength(3);\n+        default:\n+            assert false;\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [E0]     [A0..BF] [80..BF]\n+    \/\/  [E1..EF] [80..BF] [80..BF]\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is only one byte left in src buffer\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [F0]     [90..BF] [80..BF] [80..BF]\n+    \/\/  [F1..F3] [80..BF] [80..BF] [80..BF]\n+    \/\/  [F4]     [80..8F] [80..BF] [80..BF]\n+    \/\/  only check 80-be range here, the [0xf0,0x80...] and [0xf4,0x90-...]\n+    \/\/  will be checked by Character.isSupplementaryCodePoint(uc)\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+               (b4 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is less than 4 bytes left in src buffer.\n+    \/\/ both b1 and b2 should be \"& 0xff\" before passed in.\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2  < 0x90 || b2 > 0xbf)) ||\n+               (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ tests if b1 and b2 are malformed as the first 2 bytes of a\n+    \/\/ legal`4-byte utf-8 byte sequence.\n+    \/\/ only used when there is less than 4 bytes left in src buffer,\n+    \/\/ after isMalformed4_2 has been invoked.\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static void updatePositions(Buffer src, int sp,\n+                                        Buffer dst, int dp) {\n+        src.position(sp - src.arrayOffset());\n+        dst.position(dp - dst.arrayOffset());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/utf8\/DecodeBench.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"}]}