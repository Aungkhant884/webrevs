{"files":[{"patch":"@@ -1905,1 +1905,1 @@\n-  if (C->max_vector_size() >= 16) {\n+  if (C->max_vector_size() > 0) {\n@@ -2391,1 +2391,1 @@\n-  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+  if (!match_rule_supported(opcode)) {\n@@ -2399,1 +2399,1 @@\n-    return op_sve_supported(opcode);\n+    return op_sve_supported(opcode, vlen, bt);\n@@ -2441,0 +2441,3 @@\n+    case Op_LoadVectorGather:\n+    case Op_StoreVectorScatter:\n+      return false;\n@@ -2445,1 +2448,1 @@\n-  return true; \/\/ Per default match rules are supported.\n+  return vector_size_supported(bt, vlen);\n@@ -2491,0 +2494,1 @@\n+\n@@ -2493,15 +2497,8 @@\n-  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n-    \/\/ Currently vector length less than SVE vector register size is not supported.\n-    return max_size;\n-  } else { \/\/ NEON\n-    \/\/ Limit the vector size to 8 bytes\n-    int size = 8 \/ type2aelembytes(bt);\n-    if (bt == T_BYTE) {\n-      \/\/ To support vector api shuffle\/rearrange.\n-      size = 4;\n-    } else if (bt == T_BOOLEAN) {\n-      \/\/ To support vector api load\/store mask.\n-      size = 2;\n-    }\n-    if (size < 2) size = 2;\n-    return MIN2(size,max_size);\n+  \/\/ Limit the min vector size to 8 bytes.\n+  int size = 8 \/ type2aelembytes(bt);\n+  if (bt == T_BYTE) {\n+    \/\/ To support vector api shuffle\/rearrange.\n+    size = 4;\n+  } else if (bt == T_BOOLEAN) {\n+    \/\/ To support vector api load\/store mask.\n+    size = 2;\n@@ -2509,0 +2506,2 @@\n+  if (size < 2) size = 2;\n+  return MIN2(size, max_size);\n@@ -2518,1 +2517,1 @@\n-  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+  if (UseSVE > 0 && 2 <= len && len <= 256) {\n@@ -3723,1 +3722,1 @@\n-    if (Compile::current()->max_vector_size() >= 16 && uncommon_trap_request() == 0) {\n+    if (Compile::current()->max_vector_size() > 0 && uncommon_trap_request() == 0) {\n@@ -3735,1 +3734,1 @@\n-    } else if (Compile::current()->max_vector_size() >= 16) {\n+    } else if (Compile::current()->max_vector_size() > 0) {\n@@ -3773,1 +3772,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -3786,1 +3785,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -4159,0 +4158,10 @@\n+operand immI_gt_1()\n+%{\n+  predicate(n->get_int() > 1);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":33,"deletions":24,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2540,1 +2540,3 @@\n-  if (restore_vectors) {\n+  \/\/ We may use predicate registers and rely on ptrue with SVE,\n+  \/\/ regardless of wide vector (> 8 bytes) used or not.\n+  if (use_sve) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2398,21 +2398,32 @@\n-  if (EnableVectorReboxing && can_reshape && progress == NULL) {\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-    bool all_inputs_are_equiv_vboxes = true;\n-    for (uint i = 1; i < req(); ++i) {\n-      Node* n = in(i);\n-      if (in(i)->Opcode() != Op_VectorBox) {\n-        all_inputs_are_equiv_vboxes = false;\n-        break;\n-      }\n-      \/\/ Check that vector type of vboxes is equivalent\n-      if (i != 1) {\n-        if (Type::cmp(in(i-0)->in(VectorBoxNode::Value)->bottom_type(),\n-                      in(i-1)->in(VectorBoxNode::Value)->bottom_type()) != 0) {\n-          all_inputs_are_equiv_vboxes = false;\n-          break;\n-        }\n-        if (Type::cmp(in(i-0)->in(VectorBoxNode::Box)->bottom_type(),\n-                      in(i-1)->in(VectorBoxNode::Box)->bottom_type()) != 0) {\n-          all_inputs_are_equiv_vboxes = false;\n-          break;\n+  if (EnableVectorReboxing && can_reshape && progress == NULL && type()->isa_oopptr()) {\n+    progress = merge_through_phi(this, phase->is_IterGVN());\n+  }\n+\n+  return progress;              \/\/ Return any progress\n+}\n+\n+Node* PhiNode::clone_through_phi(Node* root_phi, const Type* t, uint c, PhaseIterGVN* igvn) {\n+  Node_Stack stack(1);\n+  VectorSet  visited;\n+  Node_List  node_map;\n+\n+  stack.push(root_phi, 1); \/\/ ignore control\n+  visited.set(root_phi->_idx);\n+\n+  Node* new_phi = new PhiNode(root_phi->in(0), t);\n+  node_map.map(root_phi->_idx, new_phi);\n+\n+  while (stack.is_nonempty()) {\n+    Node* n   = stack.node();\n+    uint  idx = stack.index();\n+    assert(n->is_Phi(), \"not a phi\");\n+    if (idx < n->req()) {\n+      stack.set_index(idx + 1);\n+      Node* def = n->in(idx);\n+      if (def == NULL) {\n+        continue; \/\/ ignore dead path\n+      } else if (def->is_Phi()) { \/\/ inner node\n+        Node* new_phi = node_map[n->_idx];\n+        if (!visited.test_set(def->_idx)) { \/\/ not visited yet\n+          node_map.map(def->_idx, new PhiNode(def->in(0), t));\n+          stack.push(def, 1); \/\/ ignore control\n@@ -2420,0 +2431,9 @@\n+        Node* new_in = node_map[def->_idx];\n+        new_phi->set_req(idx, new_in);\n+      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+        assert(n->is_Phi(), \"not a phi\");\n+        Node* new_phi = node_map[n->_idx];\n+        new_phi->set_req(idx, def->in(c));\n+      } else {\n+        assert(false, \"not optimizeable\");\n+        return NULL;\n@@ -2421,0 +2441,4 @@\n+    } else {\n+      Node* new_phi = node_map[n->_idx];\n+      igvn->register_new_node_with_optimizer(new_phi, n);\n+      stack.pop();\n@@ -2422,0 +2446,3 @@\n+  }\n+  return new_phi;\n+}\n@@ -2423,8 +2450,34 @@\n-    if (all_inputs_are_equiv_vboxes) {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(in(1));\n-      PhiNode* new_vbox_phi = new PhiNode(r, vbox->box_type());\n-      PhiNode* new_vect_phi = new PhiNode(r, vbox->vec_type());\n-      for (uint i = 1; i < req(); ++i) {\n-        VectorBoxNode* old_vbox = static_cast<VectorBoxNode*>(in(i));\n-        new_vbox_phi->set_req(i, old_vbox->in(VectorBoxNode::Box));\n-        new_vect_phi->set_req(i, old_vbox->in(VectorBoxNode::Value));\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+  Node_Stack stack(1);\n+  VectorSet  visited;\n+\n+  stack.push(root_phi, 1); \/\/ ignore control\n+  visited.set(root_phi->_idx);\n+\n+  VectorBoxNode* cached_vbox = NULL;\n+  while (stack.is_nonempty()) {\n+    Node* n   = stack.node();\n+    uint  idx = stack.index();\n+    if (idx < n->req()) {\n+      stack.set_index(idx + 1);\n+      Node* in = n->in(idx);\n+      if (in == NULL) {\n+        continue; \/\/ ignore dead path\n+      } else if (in->isa_Phi()) {\n+        if (!visited.test_set(in->_idx)) {\n+          stack.push(in, 1); \/\/ ignore control\n+        }\n+      } else if (in->Opcode() == Op_VectorBox) {\n+        VectorBoxNode* vbox = static_cast<VectorBoxNode*>(in);\n+        if (cached_vbox == NULL) {\n+          cached_vbox = vbox;\n+        } else if (vbox->vec_type() != cached_vbox->vec_type()) {\n+          \/\/ TODO: vector type mismatch can be handled with additional reinterpret casts\n+          assert(Type::cmp(vbox->vec_type(), cached_vbox->vec_type()) != 0, \"inconsistent\");\n+          return NULL; \/\/ not optimizable: vector type mismatch\n+        } else if (vbox->box_type() != cached_vbox->box_type()) {\n+          assert(Type::cmp(vbox->box_type(), cached_vbox->box_type()) != 0, \"inconsistent\");\n+          return NULL; \/\/ not optimizable: box type mismatch\n+        }\n+      } else {\n+        return NULL; \/\/ not optimizable: neither Phi nor VectorBox\n@@ -2432,3 +2485,2 @@\n-      igvn->register_new_node_with_optimizer(new_vbox_phi, this);\n-      igvn->register_new_node_with_optimizer(new_vect_phi, this);\n-      progress = new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, vbox->box_type(), vbox->vec_type());\n+    } else {\n+      stack.pop();\n@@ -2437,2 +2489,6 @@\n-\n-  return progress;              \/\/ Return any progress\n+  assert(cached_vbox != NULL, \"sanity\");\n+  const TypeInstPtr* btype = cached_vbox->box_type();\n+  const TypeVect*    vtype = cached_vbox->vec_type();\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n+  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n+  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":90,"deletions":34,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2138,1 +2138,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2148,1 +2149,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -512,1 +512,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(1));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n@@ -817,2 +817,4 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n-  bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(gvn().type(base));\n+\n+  \/\/ The memory barrier checks are based on ones for unsafe access.\n+  \/\/ This is not 1-1 implementation.\n+  const Type *const base_type = gvn().type(base);\n@@ -823,0 +825,9 @@\n+  const bool in_native = TypePtr::NULL_PTR == base_type; \/\/ base always null\n+  const bool in_heap   = !TypePtr::NULL_PTR->higher_equal(base_type); \/\/ base never null\n+\n+  const bool is_mixed_access = !in_heap && !in_native;\n+\n+  const bool is_mismatched_access = in_heap && (addr_type->isa_aryptr() == NULL);\n+\n+  const bool needs_cpu_membar = is_mixed_access || is_mismatched_access;\n+\n@@ -880,1 +891,1 @@\n-  if (can_access_non_heap) {\n+  if (needs_cpu_membar) {\n@@ -927,1 +938,1 @@\n-  if (can_access_non_heap) {\n+  if (needs_cpu_membar) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"}]}