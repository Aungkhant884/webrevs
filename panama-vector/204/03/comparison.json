{"files":[{"patch":"@@ -2137,0 +2137,55 @@\n+void Assembler::evcvtph2pd(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16((unsigned char)0x5A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtph2pd(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtph2pd(dst, k0, src, vector_len);\n+}\n+\n+void Assembler::evcvtpd2ph(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16((unsigned char)0x5A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtpd2ph(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtpd2ph(dst, k0, src, vector_len);\n+}\n+\n+void Assembler::evcvtps2ph(XMMRegister dst, KRegister mask, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1D, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  evcvtps2ph(dst, k0, src, imm8, vector_len);\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x13, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtph2ps(dst, k0, src, vector_len);\n+}\n@@ -6136,0 +6191,9 @@\n+void Assembler::evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x58);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+}\n+\n@@ -6325,0 +6389,14 @@\n+void Assembler::evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evaddph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -6376,0 +6454,14 @@\n+void Assembler::evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evsubph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -6438,0 +6530,49 @@\n+void Assembler::evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evmulph(dst, k0, nds, src, vector_len);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, XMMRegister src2, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_fma(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16((unsigned char)0xB8, (0xC0 | encode));\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+  evfmadd231ph(dst, k0, src1, src2, vector_len);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, Address src2, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_fma(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int8((unsigned char)0xB8);\n+  emit_operand(dst, src2);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  evfmadd231ph(dst, k0, src1, src2, vector_len);\n+}\n+\n@@ -6523,0 +6664,14 @@\n+void Assembler::evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evdivph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -11000,2 +11155,2 @@\n-  \/\/ confine opc opcode extensions in mm bits to lower two bits\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ confine opc opcode extensions in mmm bits to lower three bits\n+  \/\/ of form {0F, 0F_38, 0F_3A, MAP5, MAP6}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":157,"deletions":2,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -544,0 +544,2 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n+    VEX_OPCODE_MAP6  = 0x6,\n@@ -1182,0 +1184,10 @@\n+  \/\/ convert vector HF and double\n+  void evcvtph2pd(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtph2pd(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void evcvtps2ph(XMMRegister dst, KRegister mask, XMMRegister src, int imm8, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evcvtpd2ph(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtpd2ph(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+\n@@ -2183,0 +2195,1 @@\n+  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n@@ -2221,0 +2234,2 @@\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2229,0 +2244,2 @@\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2238,0 +2255,2 @@\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2243,0 +2262,4 @@\n+  void evfmadd231ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, int vector_len);\n@@ -2251,0 +2274,2 @@\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1968,0 +1968,20 @@\n+void C2_MacroAssembler::reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2) {\n+  movdl(vtmp1, dst);\n+  evaddsh(vtmp1, vtmp1, src);\n+  pshuflw(vtmp, src, 0x01);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, src, 0x02);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, src, 0x03);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshufd(vtmp2, src, 0x0E);\n+  evaddsh(vtmp1, vtmp1, vtmp2);\n+  pshuflw(vtmp, vtmp2, 0x01);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, vtmp2, 0x02);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, vtmp2, 0x03);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  movdl(dst, vtmp1);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  void reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2184,0 +2184,16 @@\n+\/\/ dst = c = a * b + c\n+void MacroAssembler::evfmahf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {\n+  Assembler::evfmadd231ph(c, a, b, vector_len);\n+  if (dst != c) {\n+    vmovdqu(dst, c);\n+  }\n+}\n+\n+\/\/ dst = c = a * b + c\n+void MacroAssembler::evfmahf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {\n+  Assembler::evfmadd231ph(c, a, b, vector_len);\n+  if (dst != c) {\n+    vmovdqu(dst, c);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -480,0 +480,2 @@\n+  void evfmahf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);\n+  void evfmahf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4110,0 +4110,3 @@\n+    StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_fp_mask(\"vector_halffloat_sign_mask\", 0x7FFF7FFF);\n+    StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_fp_mask(\"vector_halffloat_sign_flip\", 0x80008000);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7763,0 +7763,3 @@\n+    StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_fp_mask(\"vector_halffloat_sign_mask\", 0x7FFF7FFF7FFF7FFF);\n+    StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_fp_mask(\"vector_halffloat_sign_flip\", 0x8000800080008000);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+address StubRoutines::x86::_vector_halffloat_sign_mask = NULL;\n+address StubRoutines::x86::_vector_halffloat_sign_flip = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,0 +186,2 @@\n+  static address _vector_halffloat_sign_flip;\n+  static address _vector_halffloat_sign_mask;\n@@ -268,0 +270,2 @@\n+  static address vector_halffloat_sign_mask() { return _vector_halffloat_sign_mask; }\n+  static address vector_halffloat_sign_flip() { return _vector_halffloat_sign_flip; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -926,0 +926,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -265,1 +265,3 @@\n-                           : 17;\n+                           : 8,\n+               avx512_fp16 : 1,\n+                           : 8;\n@@ -366,1 +368,2 @@\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     49) \/* Vector sub-word popcount and bit gather instructions *\/\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     49) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(AVX512_FP16,       \"avx512_fp16\",       50) \/* Vector FP16 instructions*\/\n@@ -606,0 +609,2 @@\n+        if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+          result |= CPU_AVX512_FP16;\n@@ -913,0 +918,1 @@\n+  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1397,0 +1397,2 @@\n+  static address vector_halffloat_signmask() { return StubRoutines::x86::vector_halffloat_sign_mask();}\n+  static address vector_halffloat_signflip() { return StubRoutines::x86::vector_halffloat_sign_flip();}\n@@ -1952,0 +1954,10 @@\n+    case Op_AddVHF:\n+    case Op_SubVHF:\n+    case Op_MulVHF:\n+    case Op_DivVHF:\n+    case Op_AbsVHF:\n+    case Op_NegVHF:\n+      if (bt != T_SHORT && !VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -2110,0 +2122,1 @@\n+\n@@ -4837,0 +4850,11 @@\n+\/\/ =======================Half Float Reduction==========================================\n+instruct reduction8HF(rRegI dst, vec src2, vec vtmp, vec vtmp1, vec vtmp2) %{\n+  match(Set dst (AddReductionVHF dst src2));\n+  effect(TEMP vtmp, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"reduction_halffloat  $dst, $src2\\t using $vtmp, $vtmp1, $vtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reduce8HF($dst$$Register, $src2$$XMMRegister, $vtmp$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5351,0 +5375,11 @@\n+\/\/ Halffloat vector add\n+instruct vaddHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"evaddph  $dst,$src1,$src2\\t! add packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evaddph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5559,0 +5594,11 @@\n+\/\/ Halffloat vector sub\n+instruct vsubHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"evsubph  $dst,$src1,$src2\\t! sub packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsubph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5888,0 +5934,11 @@\n+\/\/Halffloat vector mul\n+instruct vmulHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (MulVHF src1 src2));\n+  format %{ \"evmulph  $dst,$src1,$src2\\t! mul packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evmulph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5994,0 +6051,11 @@\n+\/\/ Halffloat vector div\n+instruct vdivHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"evdivph  $dst,$src1,$src2\\t! div packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evdivph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7316,0 +7384,47 @@\n+\/\/ Convert from Halffloat to other types\n+instruct vcvtHFtoD_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"evcvtph2pd   $dst,$src\\t! convert HF to D vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtph2pd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcvtHFtoF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"evcvtph2ps   $dst,$src\\t! convert HF to F vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Convert from other types to Halffloat\n+instruct vcvtFtoHF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"evcvtps2ph   $dst,$src\\t! convert F to HF vector\" %}\n+  ins_encode %{\n+    int midx = 0;\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, midx, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcvtDtoHF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"evcvtpd2ph   $dst,$src\\t! convert D to HF vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtpd2ph($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7835,0 +7950,22 @@\n+\/\/ Half float abs\n+instruct vabsHF_reg(vec dst, vec src) %{\n+  match(Set dst (AbsVHF  src));\n+  format %{ \"vandps $dst,$src\\t# $dst = |$src| abs packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vandps($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_halffloat_signmask()), vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Halffloat neg\n+instruct vnegHF_reg(vec dst, vec src) %{\n+  match(Set dst (NegVHF src));\n+  format %{\"vxorps $dst, $src\\t $dst = -$src neg packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vxorps($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_halffloat_signflip()), vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8667,0 +8804,27 @@\n+\/\/ a * b + c\n+instruct vfmaHF_reg(vecX a, vecX b, vecX c) %{\n+  match(Set c (FmaVHF  c (Binary a b)));\n+  format %{ \"evfmaph $a,$b,$c\\t# $c = $a * $b + $c fma packedHF\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    assert(UseFMA, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmahf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ a * b + c\n+instruct vfmaHF_mem(vecX a, memory b, vecX c) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n+  match(Set c (FmaVHF  c (Binary a (LoadVector b))));\n+  format %{ \"evfmaph $a,$b,$c\\t# $c = $a * $b + $c fma packedHF\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    assert(UseFMA, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmahf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":164,"deletions":0,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -4110,0 +4110,1 @@\n+        strcmp(opType,\"AddReductionVHF\")==0 ||\n@@ -4221,1 +4222,1 @@\n-    \"AddReductionVF\", \"AddReductionVD\",\n+    \"AddReductionVF\", \"AddReductionVD\",\"AddReductionVHF\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+macro(FmaVHF)\n@@ -379,0 +380,1 @@\n+macro(AddVHF)\n@@ -380,0 +382,1 @@\n+macro(AddReductionVHF)\n@@ -388,0 +391,1 @@\n+macro(SubVHF)\n@@ -399,0 +403,1 @@\n+macro(MulVHF)\n@@ -403,0 +408,1 @@\n+macro(DivVHF)\n@@ -409,0 +415,1 @@\n+macro(AbsVHF)\n@@ -413,0 +420,1 @@\n+macro(NegVHF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2263,0 +2263,1 @@\n+    case Op_FmaVHF:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -293,0 +293,41 @@\n+\/\/ Return the vector operator for the specified scalar operation\n+\/\/ and vector length for half float\n+int VectorNode::opcode(int sopc) {\n+  switch (sopc) {\n+    case Op_AddI:\n+      return Op_AddVHF;\n+    case Op_SubI:\n+      return Op_SubVHF;\n+    case Op_MulI:\n+      return Op_MulVHF;\n+    case Op_DivI:\n+      return Op_DivVHF;\n+    case Op_AbsI:\n+      return Op_AbsVHF;\n+    case Op_NegI:\n+      return Op_NegVHF;\n+    case Op_FmaF:\n+      return Op_FmaVHF;\n+    default:\n+      return 0; \/\/ Unimplemented\n+  }\n+}\n+\n+\/\/ Make a vectornode for half float binary operation\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, uint vlen) {\n+  const TypeVect* vt = TypeVect::make(T_SHORT, vlen);\n+  \/\/ This method should not be called for unimplemented vectors.\n+  switch (vopc) {\n+    case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n+    case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+    case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+    case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+    case Op_AbsVHF: return new AbsVHFNode(n1, vt);\n+    case Op_NegVHF: return new NegVHFNode(n1, vt);\n+\n+  default:\n+    fatal(\"Missed vector creation for '%s'\", NodeClassNames[vopc]);\n+    return NULL;\n+  }\n+}\n+\n@@ -677,0 +718,13 @@\n+\/\/ Make a vectornode for half float ternary operation\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, Node* n3, uint vlen) {\n+  const TypeVect* vt = TypeVect::make(T_SHORT, vlen);\n+  \/\/ This method should not be called for unimplemented vectors.\n+  guarantee(vopc > 0, \"Vector for '%s' is not implemented\", NodeClassNames[vopc]);\n+  switch (vopc) {\n+  case Op_FmaVHF: return new FmaVHFNode(n1, n2, n3, vt);\n+  default:\n+    fatal(\"Missed vector creation for '%s'\", NodeClassNames[vopc]);\n+    return NULL;\n+  }\n+}\n+\n@@ -1120,0 +1174,16 @@\n+\/\/Haffloat reduction nodes.\n+int ReductionNode::opcode(int opc) {\n+  int vopc = opc;\n+  switch (opc) {\n+    case Op_AddI:\n+      vopc = Op_AddReductionVHF;\n+      break;\n+    case Op_MulI:\n+      vopc = Op_MulReductionVF;\n+      break;\n+    default: ShouldNotReachHere(); return 0;\n+  }\n+  return vopc;\n+}\n+\n+\n@@ -1148,0 +1218,11 @@\n+\/\/ Return the appropriate reduction node for halffloat\n+ReductionNode* ReductionNode::make(int vopc, Node *ctrl, Node* n1, Node* n2) {\n+  switch (vopc) {\n+  case Op_AddReductionVHF: return new AddReductionVHFNode(ctrl, n1, n2);\n+  case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);\n+  default:\n+    assert(false,\"Missed vector creation for '%s'\", NodeClassNames[vopc]);\n+    return NULL;\n+  }\n+}\n+\n@@ -1239,0 +1320,1 @@\n+    case Op_AddReductionVHF:\/\/ fallthrough\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, uint vlen);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, Node* n3, uint vlen);\n@@ -89,0 +91,1 @@\n+  static int opcode(int opc);\n@@ -173,0 +176,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add halffloat\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -183,0 +194,1 @@\n+  static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2);\n@@ -184,0 +196,1 @@\n+  static int  opcode(int opc);\n@@ -223,0 +236,10 @@\n+\/\/------------------------------AddReductionVHFNode--------------------------------------\n+\/\/ Vector add halffloat as a reduction\n+class AddReductionVHFNode : public ReductionNode {\n+public:\n+  AddReductionVHFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -279,0 +302,8 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector sub halffloat\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -335,0 +366,9 @@\n+\/\/------------------------------MulVHFNode--------------------------------------\n+\/\/ Vector mul halffloat\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -351,0 +391,9 @@\n+\/\/------------------------------FmaVHFNode-------------------------------------\n+\/\/ Vector multiply halffloat\n+class FmaVHFNode : public VectorNode {\n+public:\n+  FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -415,0 +464,8 @@\n+\/\/------------------------------DivVHFNode--------------------------------------\n+\/\/ Vector div halffloat\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -431,0 +488,8 @@\n+\/\/------------------------------AbsVHFNode--------------------------------------\n+\/\/ Vector Abs Halffloat\n+class AbsVHFNode : public VectorNode {\n+public:\n+  AbsVHFNode(Node * in, const TypeVect * vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -523,0 +588,8 @@\n+\/\/------------------------------NegVHFNode--------------------------------------\n+\/\/ Vector Neg double\n+class NegVHFNode : public VectorNode {\n+public:\n+  NegVHFNode(Node * in, const TypeVect * vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1745,0 +1745,1 @@\n+  declare_c2_type(AbsVHFNode, VectorNode)                                 \\\n@@ -1748,0 +1749,1 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n@@ -1753,0 +1755,2 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n+  declare_c2_type(AddReductionVHFNode, ReductionNode)                     \\\n@@ -1761,0 +1765,1 @@\n+  declare_c2_type(SubVHFNode, VectorNode)                                 \\\n@@ -1764,0 +1769,1 @@\n+  declare_c2_type(MulVHFNode, VectorNode)                                 \\\n@@ -1775,0 +1781,1 @@\n+  declare_c2_type(NegVHFNode, VectorNode)                                 \\\n@@ -1784,0 +1791,1 @@\n+  declare_c2_type(DivVHFNode, VectorNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+        AVX512_FP16,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}