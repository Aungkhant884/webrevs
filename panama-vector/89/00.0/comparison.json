{"files":[{"patch":"@@ -1363,1 +1363,1 @@\n-    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL || UseAOT)) {\n+    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL)) {\n@@ -1785,14 +1785,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input\n-\n-\/\/ the shared code plants the oop data at the start of the generated\n-\/\/ code for the safepoint node and that needs ot be at the load\n-\/\/ instruction itself. so we cannot plant a mov of the safepoint poll\n-\/\/ address followed by a load. setting this to true means the mov is\n-\/\/ scheduled as a prior instruction. that's better for scheduling\n-\/\/ anyway.\n-\n-bool SafePointNode::needs_polling_address_input()\n-{\n-  return true;\n-}\n-\n@@ -1903,1 +1889,0 @@\n-  assert(framesize%(2*wordSize) == 0, \"must preserve 2*wordSize alignment\");\n@@ -1920,1 +1905,1 @@\n-  if (C->max_vector_size() >= 16) {\n+  if (C->max_vector_size() > 0) {\n@@ -2429,1 +2414,1 @@\n-  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+  if (!match_rule_supported(opcode)) {\n@@ -2437,1 +2422,1 @@\n-    return op_sve_supported(opcode);\n+    return op_sve_supported(opcode, vlen, bt);\n@@ -2454,0 +2439,3 @@\n+    case Op_LoadVectorGather:\n+    case Op_StoreVectorScatter:\n+      return false;\n@@ -2458,1 +2446,1 @@\n-  return true; \/\/ Per default match rules are supported.\n+  return vector_size_supported(bt, vlen);\n@@ -2465,4 +2453,0 @@\n-const bool Matcher::has_predicated_vectors(void) {\n-  return UseSVE > 0;\n-}\n-\n@@ -2477,22 +2461,0 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return true;\n-}\n-\n-\/\/ Vector calling convention not yet implemented.\n-const bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n-}\n-\n-void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n-  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n-}\n-\n-OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n-}\n-\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return false; \/\/ not supported\n-}\n-\n@@ -2513,11 +2475,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.\n-  \/\/ Probably always true, even if a temp register is required.\n-  return true;\n-}\n-\n-\/\/ true just means we have fast l2f conversion\n-const bool Matcher::convL2FSupported(void) {\n-  return true;\n-}\n-\n@@ -2539,0 +2490,1 @@\n+\n@@ -2541,19 +2493,8 @@\n-  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n-    \/\/ Currently vector length less than SVE vector register size is not supported.\n-    if (bt == T_BOOLEAN) {\n-      \/\/ To support vector api load\/store mask.\n-      return MaxVectorSize \/ 8;\n-    }\n-    return max_size;\n-  } else { \/\/ NEON\n-    \/\/ Limit the vector size to 8 bytes\n-    int size = 8 \/ type2aelembytes(bt);\n-    if (bt == T_BYTE) {\n-      \/\/ To support vector api shuffle\/rearrange.\n-      size = 4;\n-    } else if (bt == T_BOOLEAN) {\n-      \/\/ To support vector api load\/store mask.\n-      size = 2;\n-    }\n-    if (size < 2) size = 2;\n-    return MIN2(size,max_size);\n+  \/\/ Limit the min vector size to 8 bytes.\n+  int size = 8 \/ type2aelembytes(bt);\n+  if (bt == T_BYTE) {\n+    \/\/ To support vector api shuffle\/rearrange.\n+    size = 4;\n+  } else if (bt == T_BOOLEAN) {\n+    \/\/ To support vector api load\/store mask.\n+    size = 2;\n@@ -2561,4 +2502,2 @@\n-}\n-\n-const bool Matcher::supports_scalable_vector() {\n-  return UseSVE > 0;\n+  if (size < 2) size = 2;\n+  return MIN2(size, max_size);\n@@ -2588,29 +2527,0 @@\n-\/\/ aarch64 supports misaligned vectors store\/load.\n-const bool Matcher::misaligned_vectors_ok() {\n-  return true;\n-}\n-\n-\/\/ false => size gets scaled to BytesPerLong, ok.\n-const bool Matcher::init_array_count_is_in_bytes = false;\n-\n-\/\/ Use conditional move (CMOVL)\n-const int Matcher::long_cmove_cost() {\n-  \/\/ long cmoves are no more expensive than int cmoves\n-  return 0;\n-}\n-\n-const int Matcher::float_cmove_cost() {\n-  \/\/ float cmoves are no more expensive than int cmoves\n-  return 0;\n-}\n-\n-\/\/ Does the CPU require late expand (see block.cpp for description of late expand)?\n-const bool Matcher::require_postalloc_expand = false;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-const bool Matcher::need_masked_shift_count = false;\n-\n-\/\/ No support for generic vector operands.\n-const bool Matcher::supports_generic_vector_operands  = false;\n-\n@@ -2632,56 +2542,0 @@\n-\/\/ This affects two different things:\n-\/\/  - how Decode nodes are matched\n-\/\/  - how ImplicitNullCheck opportunities are recognized\n-\/\/ If true, the matcher will try to remove all Decodes and match them\n-\/\/ (as operands) into nodes. NullChecks are not prepared to deal with\n-\/\/ Decodes by final_graph_reshaping().\n-\/\/ If false, final_graph_reshaping() forces the decode behind the Cmp\n-\/\/ for a NullCheck. The matcher matches the Decode node into a register.\n-\/\/ Implicit_null_check optimization moves the Decode along with the\n-\/\/ memory operation back up before the NullCheck.\n-bool Matcher::narrow_oop_use_complex_address() {\n-  return CompressedOops::shift() == 0;\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-\/\/ TODO\n-\/\/ decide whether we need to set this to true\n-  return false;\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  \/\/ Prefer ConN+DecodeN over ConP in simple compressed oops mode.\n-  return CompressedOops::base() == NULL;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  \/\/ Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.\n-  return CompressedKlassPointers::base() == NULL;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from\n-\/\/ memory?  Intel can load a float constant from a direct address,\n-\/\/ requiring no extra registers.  Most RISCs will have to materialize\n-\/\/ an address into a register first, so they would do better to copy\n-\/\/ the constant from stack.\n-const bool Matcher::rematerialize_float_constants = false;\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no\n-\/\/ fixup is needed.  Else we split the double into 2 integer pieces\n-\/\/ and move it piece-by-piece.  Only happens when passing doubles into\n-\/\/ C code as the Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = true;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = false;\n-\n-\/\/ Are floats converted to double when stored to stack during\n-\/\/ deoptimization?\n-bool Matcher::float_in_double() { return false; }\n-\n-\/\/ Do ints take an entire long register or just half?\n-\/\/ The relevant question is how the int is callee-saved:\n-\/\/ the whole long is written but de-opt'ing will have to extract\n-\/\/ the relevant 32 bits.\n-const bool Matcher::int_in_long = true;\n-\n@@ -2764,2 +2618,0 @@\n-const bool Matcher::convi2l_type_required = false;\n-\n@@ -2816,4 +2668,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n-\n@@ -3175,26 +3023,0 @@\n-  \/\/ This encoding class is generated automatically from ad_encode.m4.\n-  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-  enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    address con = (address)$src$$constant;\n-    \/\/ need to do this the hard way until we can manage relocs\n-    \/\/ for 32 bit constants\n-    __ movoop(rscratch2, (jobject)con);\n-    if (con) __ encode_heap_oop_not_null(rscratch2);\n-    loadStore(_masm, &MacroAssembler::strw, rscratch2, $mem->opcode(),\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n-  %}\n-\n-  \/\/ This encoding class is generated automatically from ad_encode.m4.\n-  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-  enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    address con = (address)$src$$constant;\n-    \/\/ need to do this the hard way until we can manage relocs\n-    \/\/ for 32 bit constants\n-    __ movoop(rscratch2, (jobject)con);\n-    __ encode_klass_not_null(rscratch2);\n-    loadStore(_masm, &MacroAssembler::strw, rscratch2, $mem->opcode(),\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n-  %}\n-\n@@ -3856,1 +3678,1 @@\n-    if (Compile::current()->max_vector_size() >= 16 && uncommon_trap_request() == 0) {\n+    if (Compile::current()->max_vector_size() > 0 && uncommon_trap_request() == 0) {\n@@ -3868,1 +3690,1 @@\n-    } else if (Compile::current()->max_vector_size() >= 16) {\n+    } else if (Compile::current()->max_vector_size() > 0) {\n@@ -3906,1 +3728,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -3919,1 +3741,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -4300,0 +4122,10 @@\n+operand immI_gt_1()\n+%{\n+  predicate(n->get_int() > 1);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":33,"deletions":201,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -2395,0 +2395,1 @@\n+  INSN(uqsubv, 1, 0b001011, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2409,0 +2410,1 @@\n+  INSN(cmhi,   1, 0b001101, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2429,0 +2431,1 @@\n+  INSN(umaxv,  1, 0b110000101010, 1); \/\/ accepted arrangements: T8B, T16B, T4H, T8H,      T4S\n@@ -3063,0 +3066,1 @@\n+  INSN(sve_bic, 0b11);\n@@ -3157,0 +3161,14 @@\n+\/\/ SVE load gather, store scatter (scalar plus vector) - 32-bit scaled offset\n+#define INSN(NAME, op1, type, op2, op3)                                         \\\n+  void NAME(FloatRegister Zt, PRegister Pg, Register Xn, FloatRegister Zm) {    \\\n+    starti;                                                                     \\\n+    f(op1, 31, 25), f(type, 24, 23), f(op2, 22, 21), rf(Zm, 16);                \\\n+    f(op3, 15, 13), pgrf(Pg, 10), srf(Xn, 5), rf(Zt, 0);                        \\\n+  }\n+\n+  INSN(sve_ld1w_gather,  0b1000010, 0b10, 0b01, 0b010);\n+  INSN(sve_ld1d_gather,  0b1100010, 0b11, 0b01, 0b010);\n+  INSN(sve_st1w_scatter, 0b1110010, 0b10, 0b11, 0b100);\n+  INSN(sve_st1d_scatter, 0b1110010, 0b11, 0b01, 0b100);\n+#undef INSN\n+\n@@ -3211,1 +3229,1 @@\n-  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm16) {\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm8) {\n@@ -3215,2 +3233,1 @@\n-    unsigned imm = imm16;\n-    if (imm16 <= 127 && imm16 >= -128) {\n+    if (imm8 <= 127 && imm8 >= -128) {\n@@ -3218,1 +3235,1 @@\n-    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n+    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n@@ -3220,1 +3237,1 @@\n-      imm = (imm >> 8);\n+      imm8 = (imm8 >> 8);\n@@ -3224,3 +3241,1 @@\n-    unsigned mask = (1U << 8) - 1;\n-    imm &= mask;\n-    f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n+    f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n@@ -3257,0 +3272,8 @@\n+  \/\/ SVE cpy general-purpose register\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, Register Rn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b101000101, 21, 13);\n+    pgrf(Pg, 10), srf(Rn, 5), rf(Zd, 0);\n+  }\n+\n@@ -3258,1 +3281,1 @@\n-  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, int imm16, bool isMerge) {\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, int imm8, bool isMerge) {\n@@ -3262,2 +3285,1 @@\n-    unsigned imm = imm16;\n-    if (imm16 <= 127 && imm16 >= -128) {\n+    if (imm8 <= 127 && imm8 >= -128) {\n@@ -3265,1 +3287,1 @@\n-    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n+    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n@@ -3267,1 +3289,1 @@\n-      imm = (imm >> 8);\n+      imm8 = (imm8 >> 8);\n@@ -3271,2 +3293,0 @@\n-    unsigned mask = (1U << 8) - 1;\n-    imm &= mask;\n@@ -3275,1 +3295,1 @@\n-    prf(Pg, 16), f(0b0, 15), f(m, 14), f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n+    prf(Pg, 16), f(0b0, 15), f(m, 14), f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n@@ -3278,6 +3298,3 @@\n-  \/\/ SVE vector sel\n-  void sve_sel(FloatRegister Zd,\n-               SIMD_RegVariant T,\n-               PRegister Pg,\n-               FloatRegister Zn,\n-               FloatRegister Zm) {\n+  \/\/ SVE sel (vectors)\n+  void sve_sel(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg,\n+               FloatRegister Zn, FloatRegister Zm) {\n@@ -3290,1 +3307,1 @@\n-\/\/ SVE compare vector\n+\/\/ SVE compare vectors\n@@ -3318,3 +3335,1 @@\n-    if (imm5 > 15 || imm5 < -16) {                                                       \\\n-      guarantee(false, \"invalid immediate\");                                             \\\n-    }                                                                                    \\\n+    guarantee(-16 <= imm5 && imm5 <= 15, \"invalid immediate\");                           \\\n@@ -3348,1 +3363,1 @@\n-\/\/ SVE vector uzp1,uzp2\n+\/\/ SVE uzp1\/uzp2 (vectors)\n@@ -3381,14 +3396,10 @@\n-private:\n-\n-  void encode_cvtf_T(SIMD_RegVariant T_dst, SIMD_RegVariant T_src,\n-                     unsigned& opc, unsigned& opc2) {\n-    assert(T_src != B && T_dst != B &&\n-           T_src != Q && T_dst != Q, \"invalid register variant\");\n-    if (T_dst != D) {\n-      assert(T_dst <= T_src, \"invalid register variant\");\n-    } else {\n-      assert(T_src != H, \"invalid register variant\");\n-    }\n-    \/\/ In most cases we can treat T_dst,T_src as opc,opc2\n-    \/\/ except following four cases. These cases should be converted\n-    \/\/ according to Arm's architecture reference manual:\n+  \/\/ SVE convert signed integer to floating-point (predicated)\n+  void sve_scvtf(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+                 FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    assert(T_src != B && T_dst != B && T_src != Q && T_dst != Q &&\n+           (T_src != H || T_dst == T_src), \"invalid register variant\");\n+    int opc = T_dst;\n+    int opc2 = T_src;\n+    \/\/ In most cases we can treat T_dst, T_src as opc, opc2,\n+    \/\/ except for the following two combinations.\n@@ -3398,4 +3409,2 @@\n-    \/\/ |  11 |   00 | 0 | SCVTF — 32-bit to double-precision |\n-    \/\/ |  11 |   00 | 1 | UCVTF — 32-bit to double-precision |\n-    \/\/ |  11 |   10 | 0 | SCVTF — 64-bit to single-precision |\n-    \/\/ |  11 |   10 | 1 | UCVTF — 64-bit to single-precision |\n+    \/\/ |  11 |   00 | 0 | SCVTF - 32-bit to double-precision |\n+    \/\/ |  11 |   10 | 0 | SCVTF - 64-bit to single-precision |\n@@ -3403,59 +3412,6 @@\n-    if (T_dst == S && T_src == D) { \/\/ 64-bit to single-precision\n-      T_dst = D;\n-      T_src = S;\n-    } else if (T_dst == D && T_src == S) { \/\/ 32-bit to double-precision\n-      T_dst = D;\n-      T_src = B;\n-    }\n-    opc = T_dst;\n-    opc2 = T_src;\n-  }\n-public:\n-\n-\/\/ SVE convert integer to floating-point (predicated)\n-#define INSN(NAME, sign)                                                \\\n-  void NAME(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,      \\\n-            FloatRegister Zn, SIMD_RegVariant T_src) {                  \\\n-    starti;                                                             \\\n-    unsigned opc, opc2;                                                 \\\n-    encode_cvtf_T(T_dst, T_src, opc, opc2);                             \\\n-    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b010, 21, 19);            \\\n-    f(opc2, 18, 17), f(sign, 16), f(0b101, 15, 13);                     \\\n-    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                                 \\\n-  }\n-\n-  INSN(sve_scvtf, 0b0);\n-  INSN(sve_ucvtf, 0b1);\n-#undef INSN\n-\n-private:\n-\n-  void encode_fcvt_T(SIMD_RegVariant T_src,SIMD_RegVariant T_dst,\n-                     unsigned& opc, unsigned& opc2) {\n-    assert(T_src != B && T_dst != B &&\n-           T_src != Q && T_dst != Q, \"invalid register variant\");\n-    assert(T_src != T_dst, \"invalid register variant\");\n-    if (T_src == S) {\n-      if (T_dst == H) {\n-        opc = 0b10;\n-        opc2 = 0b00;\n-      } else if (T_dst == D) {\n-        opc = 0b11;\n-        opc2 = 0b11;\n-      }\n-    } else if (T_src == H) {\n-      if (T_dst == S) {\n-        opc = 0b10;\n-        opc2 = 0b01;\n-      } else if (T_dst == D) {\n-        opc = 0b11;\n-        opc2 = 0b01;\n-      }\n-    } else if (T_src == D) {\n-      if (T_dst == H) {\n-        opc = 0b11;\n-        opc2 = 0b00;\n-      } else if (T_dst == S) {\n-        opc = 0b11;\n-        opc2 = 0b10;\n-      }\n+    if (T_src == S && T_dst == D) {\n+      opc = 0b11;\n+      opc2 = 0b00;\n+    } else if (T_src == D && T_dst == S) {\n+      opc = 0b11;\n+      opc2 = 0b10;\n@@ -3463,11 +3419,2 @@\n-  }\n-public:\n-\n-\/\/ SVE floating-point convert precision (predicated)\n-  void sve_fcvt(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n-            FloatRegister Zn, SIMD_RegVariant T_src) {\n-    starti;\n-    unsigned opc, opc2;\n-    encode_fcvt_T(T_src, T_dst, opc, opc2);\n-    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b0010, 21, 18);\n-    f(opc2, 17, 16), f(0b101, 15, 13);\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b010, 21, 19);\n+    f(opc2, 18, 17), f(0b0101, 16, 13);\n@@ -3477,14 +3424,10 @@\n-private:\n-\n-  void encode_fcvtz_T (SIMD_RegVariant T_dst, SIMD_RegVariant T_src,\n-                       unsigned& opc, unsigned& opc2) {\n-    assert(T_src != B && T_dst != B &&\n-           T_src != Q && T_dst != Q, \"invalid register variant\");\n-    if (T_src != D) {\n-      assert(T_src <= T_dst, \"invalid register variant\");\n-    } else {\n-      assert(T_dst != H, \"invalid register variant\");\n-    }\n-    \/\/ In most cases we can treat T_dst,T_src as opc2,opc\n-    \/\/ except following four cases. These cases should be converted\n-    \/\/ according to Arm's architecture reference manual:\n+  \/\/ SVE floating-point convert to signed integer, rounding toward zero (predicated)\n+  void sve_fcvtzs(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+                  FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    assert(T_src != B && T_dst != B && T_src != Q && T_dst != Q &&\n+           (T_dst != H || T_src == H), \"invalid register variant\");\n+    int opc = T_src;\n+    int opc2 = T_dst;\n+    \/\/ In most cases we can treat T_src, T_dst as opc, opc2,\n+    \/\/ except for the following two combinations.\n@@ -3492,1 +3435,1 @@\n-    \/\/ | opc | opc2 | U |        Instruction Details          |\n+    \/\/ | opc | opc2 | U |         Instruction Details         |\n@@ -3494,4 +3437,2 @@\n-    \/\/ |  11 |   10 | 0 | FCVTZS — Single-precision to 64-bit |\n-    \/\/ |  11 |   10 | 1 | FCVTZU — Single-precision to 64-bit |\n-    \/\/ |  11 |   00 | 0 | FCVTZS — Double-precision to 32-bit |\n-    \/\/ |  11 |   00 | 1 | FCVTZU — Double-precision to 32-bit |\n+    \/\/ |  11 |  10  | 0 | FCVTZS - single-precision to 64-bit |\n+    \/\/ |  11 |  00  | 0 | FCVTZS - double-precision to 32-bit |\n@@ -3499,6 +3440,6 @@\n-    if (T_dst == D && T_src == S) { \/\/ Single-precision to 64-bit\n-      T_dst = S;\n-      T_src = D;\n-    } else if (T_dst == S && T_src == D) { \/\/ Double-precision to 32-bit\n-      T_dst = B;\n-      T_src = D;\n+    if (T_src == S && T_dst == D) {\n+      opc = 0b11;\n+      opc2 = 0b10;\n+    } else if (T_src == D && T_dst == S) {\n+      opc = 0b11;\n+      opc2 = 0b00;\n@@ -3506,2 +3447,3 @@\n-    opc = T_src;\n-    opc2 = T_dst;\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b011, 21, 19);\n+    f(opc2, 18, 17), f(0b0101, 16, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n@@ -3509,11 +3451,10 @@\n-public:\n-\/\/ SVE floating-point convert to integer (predicated)\n-#define INSN(NAME, sign)                                                \\\n-  void NAME(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,      \\\n-            FloatRegister Zn, SIMD_RegVariant T_src) {                  \\\n-    starti;                                                             \\\n-    unsigned opc, opc2;                                                 \\\n-    encode_fcvtz_T(T_dst, T_src, opc, opc2);                            \\\n-    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b011, 21, 19);            \\\n-    f(opc2, 18, 17), f(sign, 16), f(0b101, 15, 13);                     \\\n-    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                                 \\\n+  \/\/ SVE floating-point convert precision (predicated)\n+  void sve_fcvt(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+                FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    assert(T_src != B && T_dst != B && T_src != Q && T_dst != Q &&\n+           T_src != T_dst, \"invalid register variant\");\n+    guarantee(T_src != H && T_dst != H, \"half-precision unsupported\");\n+    f(0b01100101, 31, 24), f(0b11, 23, 22), f(0b0010, 21, 18);\n+    f(T_dst, 17, 16), f(0b101, 15, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n@@ -3523,4 +3464,0 @@\n-  INSN(sve_fcvtzs, 0b0);\n-  INSN(sve_fcvtzu, 0b1);\n-#undef INSN\n-\n@@ -3552,11 +3489,2 @@\n-\/\/ SVE cpy general-purpose register\n-  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, Register Rn) {\n-    starti;\n-    assert(T != Q, \"invalid size\");\n-    f(0b00000101, 31, 24), f(T, 23, 22), f(0b101000101, 21, 13);\n-    pgrf(Pg, 10), srf(Rn, 5), rf(Zd, 0);\n-  }\n-\n-\/\/ SVE INDEX (immediates)\n-  void sve_index(FloatRegister Zd, SIMD_RegVariant T,\n-                 int imm1, int imm2) {\n+  \/\/ SVE INDEX (immediates)\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T, int imm1, int imm2) {\n@@ -3569,0 +3497,8 @@\n+  \/\/ SVE programmable table lookup in single vector table\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":104,"deletions":168,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/bytecodeHistogram.hpp\"\n@@ -296,1 +297,1 @@\n-    lea(rscratch1, Address(rthread, Thread::polling_word_offset()));\n+    lea(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n@@ -299,1 +300,1 @@\n-    ldr(rscratch1, Address(rthread, Thread::polling_word_offset()));\n+    ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n@@ -2794,1 +2795,3 @@\n-  if (restore_vectors) {\n+  \/\/ We may use predicate registers and rely on ptrue with SVE,\n+  \/\/ regardless of wide vector (> 8 bytes) used or not.\n+  if (use_sve) {\n@@ -3847,2 +3850,1 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->obj_equals(this, obj1, obj2);\n+  cmp(obj1, obj2);\n@@ -4250,9 +4252,0 @@\n-void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {\n-  \/\/ Use stronger ACCESS_WRITE|ACCESS_READ by default.\n-  if ((decorators & (ACCESS_READ | ACCESS_WRITE)) == 0) {\n-    decorators |= ACCESS_READ | ACCESS_WRITE;\n-  }\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  return bs->resolve(this, decorators, obj);\n-}\n-\n@@ -4483,1 +4476,1 @@\n-  ldr(dest, Address(rthread, Thread::polling_page_offset()));\n+  ldr(dest, Address(rthread, JavaThread::polling_page_offset()));\n@@ -4538,1 +4531,2 @@\n-  assert(framesize > 0, \"framesize must be > 0\");\n+  assert(framesize >= 2 * wordSize, \"framesize must include space for FP\/LR\");\n+  assert(framesize % (2*wordSize) == 0, \"must preserve 2*wordSize alignment\");\n@@ -4557,1 +4551,2 @@\n-  assert(framesize > 0, \"framesize must be > 0\");\n+  assert(framesize >= 2 * wordSize, \"framesize must include space for FP\/LR\");\n+  assert(framesize % (2*wordSize) == 0, \"must preserve 2*wordSize alignment\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -843,4 +843,0 @@\n-  \/\/ Resolves obj for access. Result is placed in the same register.\n-  \/\/ All other registers are preserved.\n-  void resolve(DecoratorSet decorators, Register obj);\n-\n@@ -1093,1 +1089,1 @@\n-    return ReservedCodeCacheSize > branch_range || UseAOT;\n+    return ReservedCodeCacheSize > branch_range;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -631,1 +632,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -904,1 +905,0 @@\n-  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n@@ -1811,2 +1811,0 @@\n-    __ resolve(IS_NOT_NULL, obj_reg);\n-\n@@ -1963,2 +1961,0 @@\n-    __ resolve(IS_NOT_NULL, obj_reg);\n-\n@@ -2222,1 +2218,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2297,1 +2293,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2423,1 +2419,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2586,1 +2582,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -149,6 +149,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input.\n-\/\/ Since ARM does not have absolute addressing, it does.\n-bool SafePointNode::needs_polling_address_input() {\n-  return true;\n-}\n-\n@@ -996,4 +990,0 @@\n-const bool Matcher::has_predicated_vectors(void) {\n-  return false;\n-}\n-\n@@ -1008,22 +998,0 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return VM_Version::has_simd();\n-}\n-\n-\/\/ Vector calling convention not yet implemented.\n-const bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n-}\n-\n-void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n-  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n-}\n-\n-OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n-}\n-\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return false; \/\/ not supported\n-}\n-\n@@ -1039,4 +1007,0 @@\n-const bool Matcher::supports_scalable_vector() {\n-  return false;\n-}\n-\n@@ -1069,9 +1033,0 @@\n-\/\/ ARM doesn't support misaligned vectors store\/load.\n-const bool Matcher::misaligned_vectors_ok() {\n-  return false;\n-}\n-\n-const bool Matcher::convL2FSupported(void) {\n-  return false;\n-}\n-\n@@ -1092,27 +1047,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.\n-  return false;\n-}\n-\n-\/\/ No scaling for the parameter the ClearArray node.\n-const bool Matcher::init_array_count_is_in_bytes = true;\n-\n-\/\/ Needs 2 CMOV's for longs.\n-const int Matcher::long_cmove_cost() { return 2; }\n-\n-\/\/ CMOVF\/CMOVD are expensive on ARM.\n-const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }\n-\n-\/\/ Does the CPU require late expand (see block.cpp for description of late expand)?\n-const bool Matcher::require_postalloc_expand = false;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-\/\/ FIXME: does this handle vector shifts as well?\n-const bool Matcher::need_masked_shift_count = true;\n-\n-const bool Matcher::convi2l_type_required = true;\n-\n-\/\/ No support for generic vector operands.\n-const bool Matcher::supports_generic_vector_operands  = false;\n-\n@@ -1150,57 +1078,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n-bool Matcher::narrow_oop_use_complex_address() {\n-  NOT_LP64(ShouldNotCallThis());\n-  assert(UseCompressedOops, \"only for compressed oops code\");\n-  return false;\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-  NOT_LP64(ShouldNotCallThis());\n-  assert(UseCompressedClassPointers, \"only for compressed klass code\");\n-  return false;\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  NOT_LP64(ShouldNotCallThis());\n-  return true;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  NOT_LP64(ShouldNotCallThis());\n-  return true;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from memory?\n-\/\/ Intel can load a float constant from a direct address, requiring no\n-\/\/ extra registers.  Most RISCs will have to materialize an address into a\n-\/\/ register first, so they would do better to copy the constant from stack.\n-const bool Matcher::rematerialize_float_constants = false;\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no fixup is\n-\/\/ needed.  Else we split the double into 2 integer pieces and move it\n-\/\/ piece-by-piece.  Only happens when passing doubles into C code as the\n-\/\/ Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = false;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = false;\n-\n-\/\/ Are floats converted to double when stored to stack during deoptimization?\n-\/\/ ARM does not handle callee-save floats.\n-bool Matcher::float_in_double() {\n-  return false;\n-}\n-\n-\/\/ Do ints take an entire long register or just half?\n-\/\/ Note that we if-def off of _LP64.\n-\/\/ The relevant question is how the int is callee-saved.  In _LP64\n-\/\/ the whole long is written but de-opt'ing will have to extract\n-\/\/ the relevant 32 bits, in not-_LP64 only the low 32 bits is written.\n-#ifdef _LP64\n-const bool Matcher::int_in_long = true;\n-#else\n-const bool Matcher::int_in_long = false;\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":129,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -1008,3 +1008,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n@@ -1158,1 +1155,10 @@\n-\/\/ Currently not used on this platform.\n+\/\/ Add nop if a prefixed (two-word) instruction is going to cross a 64-byte boundary.\n+\/\/ (See Section 1.6 of Power ISA Version 3.1)\n+static int compute_prefix_padding(int current_offset) {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 bytes\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64)) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n@@ -1160,1 +1166,7 @@\n-\/\/=============================================================================\n+int loadConI32Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+int loadConL34Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n@@ -1162,4 +1174,2 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input.\n-bool SafePointNode::needs_polling_address_input() {\n-  \/\/ The address is loaded from thread by a seperate node.\n-  return true;\n+int addI_reg_imm32Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n@@ -1168,0 +1178,13 @@\n+int addL_reg_imm34Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+int addP_reg_imm34Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+int cmprb_Whitespace_reg_reg_prefixedNode::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+\n@@ -1904,1 +1927,1 @@\n-  st->print(\"NOP \\t\/\/ %d nops to pad for loops.\", _count);\n+  st->print(\"NOP \\t\/\/ %d nops to pad for loops or prefixed instructions.\", _count);\n@@ -2159,4 +2182,0 @@\n-const bool Matcher::has_predicated_vectors(void) {\n-  return false;\n-}\n-\n@@ -2171,22 +2190,0 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return false; \/\/ not supported\n-}\n-\n-\/\/ Vector calling convention not yet implemented.\n-const bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n-}\n-\n-void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n-  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n-}\n-\n-OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n-}\n-\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return false; \/\/ not supported\n-}\n-\n@@ -2197,6 +2194,0 @@\n-const bool Matcher::convL2FSupported(void) {\n-  \/\/ fcfids can do the conversion (>= Power7).\n-  \/\/ fcfid + frsp showed rounding problem when result should be 0x3f800001.\n-  return VM_Version::has_fcfids(); \/\/ False means that conversion is done by runtime call.\n-}\n-\n@@ -2235,4 +2226,0 @@\n-const bool Matcher::supports_scalable_vector() {\n-  return false;\n-}\n-\n@@ -2243,6 +2230,0 @@\n-\/\/ PPC implementation uses VSX load\/store instructions (if\n-\/\/ SuperwordUseVSX) which support 4 byte but not arbitrary alignment\n-const bool Matcher::misaligned_vectors_ok() {\n-  return false;\n-}\n-\n@@ -2271,4 +2252,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Probably always true, even if a temp register is required.\n-  return true;\n-}\n@@ -2287,21 +2264,0 @@\n-\/\/ false => size gets scaled to BytesPerLong, ok.\n-const bool Matcher::init_array_count_is_in_bytes = false;\n-\n-\/\/ Use conditional move (CMOVL) on Power7.\n-const int Matcher::long_cmove_cost() { return 0; } \/\/ this only makes long cmoves more expensive than int cmoves\n-\n-\/\/ Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.\n-\/\/ fsel doesn't accept a condition register as input, so this would be slightly different.\n-const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }\n-\n-\/\/ Power6 requires postalloc expand (see block.cpp for description of postalloc expand).\n-const bool Matcher::require_postalloc_expand = true;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-\/\/ PowerPC requires masked shift counts.\n-const bool Matcher::need_masked_shift_count = true;\n-\n-\/\/ No support for generic vector operands.\n-const bool Matcher::supports_generic_vector_operands  = false;\n-\n@@ -2323,59 +2279,0 @@\n-\/\/ This affects two different things:\n-\/\/  - how Decode nodes are matched\n-\/\/  - how ImplicitNullCheck opportunities are recognized\n-\/\/ If true, the matcher will try to remove all Decodes and match them\n-\/\/ (as operands) into nodes. NullChecks are not prepared to deal with\n-\/\/ Decodes by final_graph_reshaping().\n-\/\/ If false, final_graph_reshaping() forces the decode behind the Cmp\n-\/\/ for a NullCheck. The matcher matches the Decode node into a register.\n-\/\/ Implicit_null_check optimization moves the Decode along with the\n-\/\/ memory operation back up before the NullCheck.\n-bool Matcher::narrow_oop_use_complex_address() {\n-  \/\/ TODO: PPC port if (MatchDecodeNodes) return true;\n-  return false;\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-  NOT_LP64(ShouldNotCallThis());\n-  assert(UseCompressedClassPointers, \"only for compressed klass code\");\n-  \/\/ TODO: PPC port if (MatchDecodeNodes) return true;\n-  return false;\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  \/\/ Prefer ConN+DecodeN over ConP in simple compressed oops mode.\n-  return CompressedOops::base() == NULL;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  \/\/ Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.\n-  return CompressedKlassPointers::base() == NULL;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from memory?\n-\/\/ Intel can load a float constant from a direct address, requiring no\n-\/\/ extra registers. Most RISCs will have to materialize an address into a\n-\/\/ register first, so they would do better to copy the constant from stack.\n-const bool Matcher::rematerialize_float_constants = false;\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no fixup is\n-\/\/ needed. Else we split the double into 2 integer pieces and move it\n-\/\/ piece-by-piece. Only happens when passing doubles into C code as the\n-\/\/ Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = true;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = false;\n-\n-\/\/ Do floats take an entire double register or just half?\n-\/\/\n-\/\/ A float occupies a ppc64 double register. For the allocator, a\n-\/\/ ppc64 double register appears as a pair of float registers.\n-bool Matcher::float_in_double() { return true; }\n-\n-\/\/ Do ints take an entire long register or just half?\n-\/\/ The relevant question is how the int is callee-saved:\n-\/\/ the whole long is written but de-opt'ing will have to extract\n-\/\/ the relevant 32 bits.\n-const bool Matcher::int_in_long = true;\n-\n@@ -2495,2 +2392,0 @@\n-const bool Matcher::convi2l_type_required = true;\n-\n@@ -4045,0 +3940,9 @@\n+\/\/ Integer Immediate: 32-bit immediate for prefixed addi and load\/store.\n+operand immI32() %{\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  op_cost(0);\n+  match(ConI);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4286,0 +4190,9 @@\n+\/\/ Long Immediate: 34-bit, immediate field in prefixed addi and load\/store.\n+operand immL34() %{\n+  predicate(PowerArchitecturePPC64 >= 10 && Assembler::is_simm(n->get_long(), 34));\n+  match(ConL);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -5820,0 +5733,17 @@\n+instruct loadConI32(iRegIdst dst, immI32 src) %{\n+  match(Set dst src);\n+  \/\/ This macro is valid only in Power 10 and up, but adding the following predicate here\n+  \/\/ caused a build error, so we comment it out for now.\n+  \/\/ predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PLI     $dst, $src\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -5891,0 +5821,18 @@\n+\/\/ Load 34-bit long constant using prefixed addi. No constant pool entries required.\n+instruct loadConL34(iRegLdst dst, immL34 src) %{\n+  match(Set dst src);\n+  \/\/ This macro is valid only in Power 10 and up, but adding the following predicate here\n+  \/\/ caused a build error, so we comment it out for now.\n+  \/\/ predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PLI     $dst, $src \\t\/\/ long\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -8503,0 +8451,15 @@\n+\/\/ Immediate Addition using prefixed addi\n+instruct addI_reg_imm32(iRegIdst dst, iRegIsrc src1, immI32 src2) %{\n+  match(Set dst (AddI src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+  format %{ \"PADDI   $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -8577,0 +8540,17 @@\n+\/\/ Long Immediate Addition using prefixed addi\n+\/\/ No constant pool entries required.\n+instruct addL_reg_imm34(iRegLdst dst, iRegLsrc src1, immL34 src2) %{\n+  match(Set dst (AddL src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PADDI   $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -8614,0 +8594,17 @@\n+\/\/ Pointer Immediate Addition using prefixed addi\n+\/\/ No constant pool entries required.\n+instruct addP_reg_imm34(iRegPdst dst, iRegP_N2P src1, immL34 src2) %{\n+  match(Set dst (AddP src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PADDI    $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -11916,0 +11913,1 @@\n+  predicate(PowerArchitecturePPC64 <= 9);\n@@ -11935,0 +11933,23 @@\n+\/\/ Power 10 version, using prefixed addi to load 32-bit constant\n+instruct cmprb_Whitespace_reg_reg_prefixed(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{\n+  match(Set dst (Whitespace src1));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  effect(TEMP src2, TEMP crx);\n+  ins_cost(3 * DEFAULT_COST);\n+\n+  format %{ \"PLI     $src2, 0x201C0D09\\n\\t\"\n+            \"CMPRB   $crx, 1, $src1, $src2\\n\\t\"\n+            \"SETB    $dst, $crx\" %}\n+  size(16);\n+  ins_encode %{\n+    \/\/ 0x09 to 0x0D, 0x1C to 0x20\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($src2$$Register, 0x201C0D09);\n+    \/\/ compare src with ranges 0x09 to 0x0D and 0x1C to 0x20\n+    __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);\n+    __ setb($dst$$Register, $crx$$CondRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":159,"deletions":138,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -674,6 +674,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input.\n-\/\/ Since z\/Architecture does not have absolute addressing, it does.\n-bool SafePointNode::needs_polling_address_input() {\n-  return true;\n-}\n-\n@@ -966,1 +960,1 @@\n-    __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));\n+    __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::polling_page_offset()));\n@@ -1549,4 +1543,0 @@\n-const bool Matcher::has_predicated_vectors(void) {\n-  return false;\n-}\n-\n@@ -1561,22 +1551,0 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return false; \/\/ not supported\n-}\n-\n-\/\/ Vector calling convention not yet implemented.\n-const bool Matcher::supports_vector_calling_convention(void) {\n-  return false;\n-}\n-\n-void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n-  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n-}\n-\n-OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n-}\n-\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return false; \/\/ not supported\n-}\n-\n@@ -1587,4 +1555,0 @@\n-const bool Matcher::convL2FSupported(void) {\n-  return true; \/\/ False means that conversion is done by runtime call.\n-}\n-\n@@ -1615,4 +1579,0 @@\n-const bool Matcher::supports_scalable_vector() {\n-  return false;\n-}\n-\n@@ -1623,5 +1583,0 @@\n-\/\/ z\/Architecture does support misaligned store\/load at minimal extra cost.\n-const bool Matcher::misaligned_vectors_ok() {\n-  return true;\n-}\n-\n@@ -1646,26 +1601,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Probably always true, even if a temp register is required.\n-  return true;\n-}\n-\n-\/\/ Should correspond to setting above\n-const bool Matcher::init_array_count_is_in_bytes = false;\n-\n-\/\/ Suppress CMOVL. Conditional move available on z\/Architecture only from z196 onwards. Not exploited yet.\n-const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }\n-\n-\/\/ Suppress CMOVF. Conditional move available on z\/Architecture only from z196 onwards. Not exploited yet.\n-const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }\n-\n-\/\/ Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?\n-const bool Matcher::require_postalloc_expand = false;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-\/\/ 32bit shifts mask in emitter, 64bit shifts need no mask.\n-\/\/ Constant shift counts are handled in Ideal phase.\n-const bool Matcher::need_masked_shift_count = false;\n-\n-\/\/ No support for generic vector operands.\n-const bool Matcher::supports_generic_vector_operands  = false;\n-\n@@ -1687,50 +1616,0 @@\n-\/\/ Set this as clone_shift_expressions.\n-bool Matcher::narrow_oop_use_complex_address() {\n-  if (CompressedOops::base() == NULL && CompressedOops::shift() == 0) return true;\n-  return false;\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-  NOT_LP64(ShouldNotCallThis());\n-  assert(UseCompressedClassPointers, \"only for compressed klass code\");\n-  \/\/ TODO HS25: z port if (MatchDecodeNodes) return true;\n-  return false;\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  \/\/ Prefer ConN+DecodeN over ConP in simple compressed oops mode.\n-  return CompressedOops::base() == NULL;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  \/\/ Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.\n-  return CompressedKlassPointers::base() == NULL;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from memory?\n-\/\/ Most RISCs will have to materialize an address into a\n-\/\/ register first, so they would do better to copy the constant from stack.\n-const bool Matcher::rematerialize_float_constants = false;\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no fixup is\n-\/\/ needed. Else we split the double into 2 integer pieces and move it\n-\/\/ piece-by-piece. Only happens when passing doubles into C code as the\n-\/\/ Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = true;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = false;\n-\n-\/\/ Do floats take an entire double register or just half?\n-\/\/\n-\/\/ A float in resides in a zarch double register. When storing it by\n-\/\/ z_std, it cannot be restored in C-code by reloading it as a double\n-\/\/ and casting it into a float afterwards.\n-bool Matcher::float_in_double() { return false; }\n-\n-\/\/ Do ints take an entire long register or just half?\n-\/\/ The relevant question is how the int is callee-saved:\n-\/\/ the whole long is written but de-opt'ing will have to extract\n-\/\/ the relevant 32 bits.\n-const bool Matcher::int_in_long = true;\n-\n@@ -1812,2 +1691,0 @@\n-const bool Matcher::convi2l_type_required = true;\n-\n@@ -1826,3 +1703,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":127,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -1277,0 +1277,4 @@\n+static inline bool is_unsigned_booltest_pred(int bt) {\n+  return  ((bt & BoolTest::unsigned_compare) == BoolTest::unsigned_compare);\n+}\n+\n@@ -1602,0 +1606,10 @@\n+    case Op_SignumF:\n+      if (UseSSE < 1) {\n+        return false;\n+      }\n+      break;\n+    case Op_SignumD:\n+      if (UseSSE < 2) {\n+        return false;\n+      }\n+      break;\n@@ -1823,3 +1837,0 @@\n-\/\/ x86 supports generic vector operands: vec and legVec.\n-const bool Matcher::supports_generic_vector_operands = true;\n-\n@@ -1877,17 +1888,0 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return (UseAVX >= 2);\n-}\n-\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return true;\n-}\n-\n-const bool Matcher::has_predicated_vectors(void) {\n-  bool ret_value = false;\n-  if (UseAVX > 2) {\n-    ret_value = VM_Version::supports_avx512vl();\n-  }\n-\n-  return ret_value;\n-}\n-\n@@ -1972,4 +1966,0 @@\n-const bool Matcher::supports_scalable_vector() {\n-  return false;\n-}\n-\n@@ -1994,8 +1984,0 @@\n-\/\/ x86 supports misaligned vectors store\/load.\n-const bool Matcher::misaligned_vectors_ok() {\n-  return true;\n-}\n-\n-\n-const bool Matcher::convi2l_type_required = true;\n-\n@@ -2135,0 +2117,4 @@\n+  if (is_vshift_con_pattern(n, m)) { \/\/ ShiftV src (ShiftCntV con)\n+    mstack.push(m, Visit);           \/\/ m = ShiftCntV\n+    return true;\n+  }\n@@ -2179,3 +2165,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n@@ -2184,6 +2167,16 @@\n-    case BoolTest::eq: return Assembler::eq;\n-    case BoolTest::ne: return Assembler::neq;\n-    case BoolTest::le: return Assembler::le;\n-    case BoolTest::ge: return Assembler::nlt;\n-    case BoolTest::lt: return Assembler::lt;\n-    case BoolTest::gt: return Assembler::nle;\n+    case BoolTest::eq:\n+      return Assembler::eq;\n+    case BoolTest::ne:\n+      return Assembler::neq;\n+    case BoolTest::le:\n+    case BoolTest::ule:\n+      return Assembler::le;\n+    case BoolTest::ge:\n+    case BoolTest::uge:\n+      return Assembler::nlt;\n+    case BoolTest::lt:\n+    case BoolTest::ult:\n+      return Assembler::lt;\n+    case BoolTest::gt:\n+    case BoolTest::ugt:\n+      return Assembler::nle;\n@@ -5791,0 +5784,24 @@\n+\/\/ --------------------------------- Signum ---------------------------\n+\n+instruct signumF_reg(regF dst, regF zero, regF one, rRegP scratch, rFlagsReg cr) %{\n+  match(Set dst (SignumF dst (Binary zero one)));\n+  effect(TEMP scratch, KILL cr);\n+  format %{ \"signumF $dst, $dst\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ signum_fp(opcode, $dst$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct signumD_reg(regD dst, regD zero, regD one, rRegP scratch, rFlagsReg cr) %{\n+  match(Set dst (SignumD dst (Binary zero one)));\n+  effect(TEMP scratch, KILL cr);\n+  format %{ \"signumD $dst, $dst\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ signum_fp(opcode, $dst$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6873,1 +6890,3 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) && \n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n@@ -6888,2 +6907,23 @@\n-instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n+            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+              $vtmp2$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n@@ -6892,0 +6932,18 @@\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+  predicate(UseAVX > 2 && \n+            (VM_Version::supports_avx512vl() ||  \n+             vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n+             is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n@@ -6897,1 +6955,1 @@\n-    int vlen_enc = Assembler::AVX_512bit;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -6899,0 +6957,1 @@\n+    bool is_unsigned = is_unsigned_booltest_pred($cond$$constant);\n@@ -6905,1 +6964,1 @@\n-        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6910,1 +6969,1 @@\n-        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6915,1 +6974,1 @@\n-        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6917,0 +6976,1 @@\n+\n@@ -6920,1 +6980,1 @@\n-        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6924,1 +6984,0 @@\n-\n@@ -7532,0 +7591,12 @@\n+instruct vmaskcast(vec dst) %{\n+  predicate((vector_length(n) == vector_length(n->in(1))) &&\n+            (vector_length_in_bytes(n) == vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vector_mask_cast $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":121,"deletions":50,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -4206,1 +4206,2 @@\n-    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\"\n+    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\",\n+    \"VectorMaskCast\"\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -537,0 +537,3 @@\n+  \/* special marker for blackholed methods: *\/                                                                          \\\n+  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_S)                       \\\n+                                                                                                                        \\\n@@ -1151,0 +1154,2 @@\n+  static bool class_has_intrinsics(vmSymbolID holder);\n+\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  assert(!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci(), \"C2 compiler is launched, it's not c1\/interpreter only mode\");\n+  assert(!CompilerConfig::is_c1_or_interpreter_only_no_jvmci(), \"C2 compiler is launched, it's not c1\/interpreter only mode\");\n@@ -681,0 +681,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -818,1 +818,1 @@\n-          if (ireg == Op_VecA) {\n+          if (Matcher::implements_scalable_vector && ireg == Op_VecA) {\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-    return _is_scalable;\n+    return Matcher::implements_scalable_vector && _is_scalable;\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n+  if (callee->check_intrinsic_candidate() &&\n@@ -674,0 +674,3 @@\n+  case vmIntrinsics::_blackhole:\n+    return inline_blackhole();\n+\n@@ -1638,0 +1641,59 @@\n+\/\/------------------------------inline_math_pow-----------------------------\n+bool LibraryCallKit::inline_math_pow() {\n+  Node* exp = round_double_node(argument(2));\n+  const TypeD* d = _gvn.type(exp)->isa_double_constant();\n+  if (d != NULL) {\n+    if (d->getd() == 2.0) {\n+      \/\/ Special case: pow(x, 2.0) => x * x\n+      Node* base = round_double_node(argument(0));\n+      set_result(_gvn.transform(new MulDNode(base, base)));\n+      return true;\n+    } else if (d->getd() == 0.5 && Matcher::match_rule_supported(Op_SqrtD)) {\n+      \/\/ Special case: pow(x, 0.5) => sqrt(x)\n+      Node* base = round_double_node(argument(0));\n+      Node* zero = _gvn.zerocon(T_DOUBLE);\n+\n+      RegionNode* region = new RegionNode(3);\n+      Node* phi = new PhiNode(region, Type::DOUBLE);\n+\n+      Node* cmp  = _gvn.transform(new CmpDNode(base, zero));\n+      \/\/ According to the API specs, pow(-0.0, 0.5) = 0.0 and sqrt(-0.0) = -0.0.\n+      \/\/ So pow(-0.0, 0.5) shouldn't be replaced with sqrt(-0.0).\n+      \/\/ -0.0\/+0.0 are both excluded since floating-point comparison doesn't distinguish -0.0 from +0.0.\n+      Node* test = _gvn.transform(new BoolNode(cmp, BoolTest::le));\n+\n+      Node* if_pow = generate_slow_guard(test, NULL);\n+      Node* value_sqrt = _gvn.transform(new SqrtDNode(C, control(), base));\n+      phi->init_req(1, value_sqrt);\n+      region->init_req(1, control());\n+\n+      if (if_pow != NULL) {\n+        set_control(if_pow);\n+        address target = StubRoutines::dpow() != NULL ? StubRoutines::dpow() :\n+                                                        CAST_FROM_FN_PTR(address, SharedRuntime::dpow);\n+        const TypePtr* no_memory_effects = NULL;\n+        Node* trig = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(), target, \"POW\",\n+                                       no_memory_effects, base, top(), exp, top());\n+        Node* value_pow = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));\n+#ifdef ASSERT\n+        Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));\n+        assert(value_top == top(), \"second value must be top\");\n+#endif\n+        phi->init_req(2, value_pow);\n+        region->init_req(2, _gvn.transform(new ProjNode(trig, TypeFunc::Control)));\n+      }\n+\n+      C->set_has_split_ifs(true); \/\/ Has chance for split-if optimization\n+      set_control(_gvn.transform(region));\n+      record_for_igvn(region);\n+      set_result(_gvn.transform(phi));\n+\n+      return true;\n+    }\n+  }\n+\n+  return StubRoutines::dpow() != NULL ?\n+    runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  \"dpow\") :\n+    runtime_math(OptoRuntime::Math_DD_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dpow),  \"POW\");\n+}\n+\n@@ -1678,13 +1740,0 @@\n-  case vmIntrinsics::_dpow: {\n-    Node* exp = round_double_node(argument(2));\n-    const TypeD* d = _gvn.type(exp)->isa_double_constant();\n-    if (d != NULL && d->getd() == 2.0) {\n-      \/\/ Special case: pow(x, 2.0) => x * x\n-      Node* base = round_double_node(argument(0));\n-      set_result(_gvn.transform(new MulDNode(base, base)));\n-      return true;\n-    }\n-    return StubRoutines::dpow() != NULL ?\n-      runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  \"dpow\") :\n-      runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  \"POW\");\n-  }\n@@ -1693,0 +1742,1 @@\n+  case vmIntrinsics::_dpow:      return inline_math_pow();\n@@ -1695,2 +1745,2 @@\n-  case vmIntrinsics::_dsignum: return inline_double_math(id);\n-  case vmIntrinsics::_fsignum: return inline_math(id);\n+  case vmIntrinsics::_dsignum: return Matcher::match_rule_supported(Op_SignumD) ? inline_double_math(id) : false;\n+  case vmIntrinsics::_fsignum: return Matcher::match_rule_supported(Op_SignumF) ? inline_math(id) : false;\n@@ -2023,1 +2073,1 @@\n-Node* LibraryCallKit::make_unsafe_address(Node*& base, Node* offset, DecoratorSet decorators, BasicType type, bool can_cast) {\n+Node* LibraryCallKit::make_unsafe_address(Node*& base, Node* offset, BasicType type, bool can_cast) {\n@@ -2220,1 +2270,1 @@\n-  Node* adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);\n+  Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n@@ -2523,1 +2573,1 @@\n-  Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);\n+  Node* adr = make_unsafe_address(base, offset,type, false);\n@@ -3989,2 +4039,2 @@\n-  Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);\n-  Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);\n+  Node* src = make_unsafe_address(src_ptr, src_off);\n+  Node* dst = make_unsafe_address(dst_ptr, dst_off);\n@@ -5169,2 +5219,2 @@\n-  Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);\n-  Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);\n+  Node* obja_adr = make_unsafe_address(obja, aoffset);\n+  Node* objb_adr = make_unsafe_address(objb, boffset);\n@@ -6869,0 +6919,20 @@\n+\n+\/\/------------------------------- inline_blackhole --------------------------------------\n+\/\/\n+\/\/ Make sure all arguments to this node are alive.\n+\/\/ This matches methods that were requested to be blackholed through compile commands.\n+\/\/\n+bool LibraryCallKit::inline_blackhole() {\n+  assert(callee()->is_static(), \"Should have been checked before: only static methods here\");\n+  assert(callee()->is_empty(), \"Should have been checked before: only empty methods here\");\n+  assert(callee()->holder()->is_loaded(), \"Should have been checked before: only methods for loaded classes here\");\n+\n+  \/\/ Bind call arguments as blackhole arguments to keep them alive\n+  Node* bh = insert_mem_bar(Op_Blackhole);\n+  uint nargs = callee()->arg_size();\n+  for (uint i = 0; i < nargs; i++) {\n+    bh->add_req(argument(i));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":93,"deletions":23,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -204,0 +204,1 @@\n+  bool inline_math_pow();\n@@ -221,1 +222,1 @@\n-  Node* make_unsafe_address(Node*& base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);\n+  Node* make_unsafe_address(Node*& base, Node* offset, BasicType type = T_ILLEGAL, bool can_cast = false);\n@@ -348,0 +349,2 @@\n+\n+  bool inline_blackhole();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -77,1 +77,2 @@\n-#endif\n+  _reused(C->comp_arena()),\n+#endif \/\/ !PRODUCT\n@@ -758,1 +759,1 @@\n-bool Matcher::is_save_on_entry( int reg ) {\n+bool Matcher::is_save_on_entry(int reg) {\n@@ -761,3 +762,1 @@\n-    _register_save_policy[reg] == 'A' || \/\/ Save-on-entry register?\n-    \/\/ Also save argument registers in the trampolining stubs\n-    (C->save_argument_registers() && is_spillable_arg(reg));\n+    _register_save_policy[reg] == 'A'; \/\/ Save-on-entry register?\n@@ -779,6 +778,0 @@\n-  \/\/ Save argument registers in the trampolining stubs\n-  if( C->save_argument_registers() )\n-    for( i = 0; i < _last_Mach_Reg; i++ )\n-      if( is_spillable_arg(i) )\n-        soe_cnt++;\n-\n@@ -1133,3 +1126,1 @@\n-#ifdef ASSERT\n-              _new2old_map.map(m->_idx, n);\n-#endif\n+              NOT_PRODUCT(record_new2old(m, n);)\n@@ -1140,3 +1131,1 @@\n-#ifdef ASSERT\n-              _new2old_map.map(m->_idx, n);\n-#endif\n+              NOT_PRODUCT(record_new2old(m, n);)\n@@ -1200,3 +1189,1 @@\n-#ifdef ASSERT\n-          _new2old_map.map(m->_idx, n);\n-#endif\n+          NOT_PRODUCT(record_new2old(m, n));\n@@ -1545,4 +1532,2 @@\n-#ifdef ASSERT\n-  _old2new_map.map(n->_idx, m);\n-  _new2old_map.map(m->_idx, (Node*)n);\n-#endif\n+  \/\/ New-to-old mapping is done in ReduceInst, to cover complex instructions.\n+  NOT_PRODUCT(_old2new_map.map(n->_idx, m);)\n@@ -1805,0 +1790,1 @@\n+  NOT_PRODUCT(record_new2old(mach, leaf);)\n@@ -1873,3 +1859,1 @@\n-#ifdef ASSERT\n-    _new2old_map.map(ex->_idx, s->_leaf);\n-#endif\n+    NOT_PRODUCT(record_new2old(ex, s->_leaf);)\n@@ -2079,1 +2063,1 @@\n-bool Matcher::is_vshift_con_pattern(Node *n, Node *m) {\n+bool Matcher::is_vshift_con_pattern(Node* n, Node* m) {\n@@ -2473,1 +2457,11 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n+void Matcher::record_new2old(Node* newn, Node* old) {\n+  _new2old_map.map(newn->_idx, old);\n+  if (!_reused.test_set(old->_igv_idx)) {\n+    \/\/ Reuse the Ideal-level IGV identifier so that the node can be tracked\n+    \/\/ across matching. If there are multiple machine nodes expanded from the\n+    \/\/ same Ideal node, only one will reuse its IGV identifier.\n+    newn->_igv_idx = old->_igv_idx;\n+  }\n+}\n+\n@@ -2478,1 +2472,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/compressedOops.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -46,0 +48,3 @@\n+  \/\/ Machine-dependent definitions\n+#include CPU_HEADER(matcher)\n+\n@@ -124,1 +129,1 @@\n-  bool is_vshift_con_pattern(Node *n, Node *m);\n+  bool is_vshift_con_pattern(Node* n, Node* m);\n@@ -138,2 +143,5 @@\n-  debug_only(Node_Array _old2new_map;)   \/\/ Map roots of ideal-trees to machine-roots\n-  debug_only(Node_Array _new2old_map;)   \/\/ Maps machine nodes back to ideal\n+#ifndef PRODUCT\n+  Node_Array _old2new_map;    \/\/ Map roots of ideal-trees to machine-roots\n+  Node_Array _new2old_map;    \/\/ Maps machine nodes back to ideal\n+  VectorSet _reused;          \/\/ Ideal IGV identifiers reused by machine nodes\n+#endif \/\/ !PRODUCT\n@@ -322,2 +330,0 @@\n-  \/\/ Some microarchitectures have mask registers used on vectors\n-  static const bool has_predicated_vectors(void);\n@@ -330,4 +336,0 @@\n-  \/\/ Used to determine if we have fast l2f conversion\n-  \/\/ USII has it, USIII doesn't\n-  static const bool convL2FSupported(void);\n-\n@@ -345,1 +347,0 @@\n-  static const bool supports_scalable_vector();\n@@ -354,14 +355,0 @@\n-  \/\/ Does the CPU supports vector variable shift instructions?\n-  static bool supports_vector_variable_shifts(void);\n-\n-  \/\/ Does the CPU supports vector vairable rotate instructions?\n-  static bool supports_vector_variable_rotates(void);\n-\n-  \/\/ CPU supports misaligned vectors store\/load.\n-  static const bool misaligned_vectors_ok();\n-\n-  \/\/ Used to determine a \"low complexity\" 64-bit constant.  (Zero is simple.)\n-  \/\/ The standard of comparison is one (StoreL ConL) vs. two (StoreI ConI).\n-  \/\/ Depends on the details of 64-bit constant generation on the CPU.\n-  static const bool isSimpleConstant64(jlong con);\n-\n@@ -435,7 +422,0 @@\n-  \/\/ Java-Native vector calling convention\n-  static const bool supports_vector_calling_convention();\n-  static void vector_calling_convention(VMRegPair *regs,\n-                                        uint num_bits,\n-                                        uint total_args_passed);\n-  static OptoRegPair vector_return_value(uint ideal_reg);\n-\n@@ -445,9 +425,0 @@\n-  \/\/ Optional scaling for the parameter to the ClearArray\/CopyArray node.\n-  static const bool init_array_count_is_in_bytes;\n-\n-  \/\/ Some hardware needs 2 CMOV's for longs.\n-  static const int long_cmove_cost();\n-\n-  \/\/ Some hardware have expensive CMOV for float and double.\n-  static const int float_cmove_cost();\n-\n@@ -466,6 +437,0 @@\n-  static bool narrow_oop_use_complex_address();\n-  static bool narrow_klass_use_complex_address();\n-\n-  static bool const_oop_prefer_decode();\n-  static bool const_klass_prefer_decode();\n-\n@@ -498,21 +463,0 @@\n-  \/\/ Is it better to copy float constants, or load them directly from memory?\n-  \/\/ Intel can load a float constant from a direct address, requiring no\n-  \/\/ extra registers.  Most RISCs will have to materialize an address into a\n-  \/\/ register first, so they may as well materialize the constant immediately.\n-  static const bool rematerialize_float_constants;\n-\n-  \/\/ If CPU can load and store mis-aligned doubles directly then no fixup is\n-  \/\/ needed.  Else we split the double into 2 integer pieces and move it\n-  \/\/ piece-by-piece.  Only happens when passing doubles into C code or when\n-  \/\/ calling i2c adapters as the Java calling convention forces doubles to be\n-  \/\/ aligned.\n-  static const bool misaligned_doubles_ok;\n-\n-  \/\/ Does the CPU require postalloc expand (see block.cpp for description of\n-  \/\/ postalloc expand)?\n-  static const bool require_postalloc_expand;\n-\n-  \/\/ Does the platform support generic vector operands?\n-  \/\/ Requires cleanup after selection phase.\n-  static const bool supports_generic_vector_operands;\n-\n@@ -537,16 +481,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding;\n-\n-  \/\/ Are floats conerted to double when stored to stack during deoptimization?\n-  static bool float_in_double();\n-  \/\/ Do ints take an entire long register or just half?\n-  static const bool int_in_long;\n-\n-  \/\/ Do the processor's shift instructions only use the low 5\/6 bits\n-  \/\/ of the count for 32\/64 bit ints? If not we need to do the masking\n-  \/\/ ourselves.\n-  static const bool need_masked_shift_count;\n-\n-  \/\/ Whether code generation need accurate ConvI2L types.\n-  static const bool convi2l_type_required;\n-\n@@ -570,1 +498,4 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n+  \/\/ Record mach-to-Ideal mapping, reusing the Ideal IGV identifier if possible.\n+  void record_new2old(Node* newn, Node* old);\n+\n@@ -576,1 +507,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":16,"deletions":85,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -996,44 +996,0 @@\n-\/\/ Compute dual right now.\n-const Type::TYPES Type::dual_type[Type::lastype] = {\n-  Bad,          \/\/ Bad\n-  Control,      \/\/ Control\n-  Bottom,       \/\/ Top\n-  Bad,          \/\/ Int - handled in v-call\n-  Bad,          \/\/ Long - handled in v-call\n-  Half,         \/\/ Half\n-  Bad,          \/\/ NarrowOop - handled in v-call\n-  Bad,          \/\/ NarrowKlass - handled in v-call\n-\n-  Bad,          \/\/ Tuple - handled in v-call\n-  Bad,          \/\/ Array - handled in v-call\n-\n-  Bad,          \/\/ VectorMask - handled in v-call\n-  Bad,          \/\/ VectorA - handled in v-call\n-  Bad,          \/\/ VectorS - handled in v-call\n-  Bad,          \/\/ VectorD - handled in v-call\n-  Bad,          \/\/ VectorX - handled in v-call\n-  Bad,          \/\/ VectorY - handled in v-call\n-  Bad,          \/\/ VectorZ - handled in v-call\n-\n-  Bad,          \/\/ AnyPtr - handled in v-call\n-  Bad,          \/\/ RawPtr - handled in v-call\n-  Bad,          \/\/ OopPtr - handled in v-call\n-  Bad,          \/\/ InstPtr - handled in v-call\n-  Bad,          \/\/ AryPtr - handled in v-call\n-\n-  Bad,          \/\/  MetadataPtr - handled in v-call\n-  Bad,          \/\/ KlassPtr - handled in v-call\n-\n-  Bad,          \/\/ Function - handled in v-call\n-  Abio,         \/\/ Abio\n-  Return_Address,\/\/ Return_Address\n-  Memory,       \/\/ Memory\n-  FloatBot,     \/\/ FloatTop\n-  FloatCon,     \/\/ FloatCon\n-  FloatTop,     \/\/ FloatBot\n-  DoubleBot,    \/\/ DoubleTop\n-  DoubleCon,    \/\/ DoubleCon\n-  DoubleTop,    \/\/ DoubleBot\n-  Top           \/\/ Bottom\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -513,1 +513,2 @@\n-    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, cnt, vt));\n+    Node* shift_cnt = vector_shift_count(cnt, Op_LShiftI, elem_bt, num_elem);\n+    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, shift_cnt, vt));\n@@ -552,1 +553,0 @@\n-  \/\/ TODO shuffle is not supported on SVE\n@@ -692,0 +692,16 @@\n+static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_type) {\n+  assert(arr_type != NULL, \"unexpected\");\n+  BasicType arr_elem_bt = arr_type->elem()->array_element_basic_type();\n+  if (elem_bt == arr_elem_bt) {\n+    return true;\n+  } else if (elem_bt == T_SHORT && arr_elem_bt == T_CHAR) {\n+    \/\/ Load\/store of short vector from\/to char[] is supported\n+    return true;\n+  } else if (elem_bt == T_BYTE && arr_elem_bt == T_BOOLEAN) {\n+    \/\/ Load\/store of byte vector from\/to boolean[] is supported\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -753,1 +769,0 @@\n-  DecoratorSet decorators = C2_UNSAFE_ACCESS;\n@@ -759,1 +774,1 @@\n-  Node* addr = make_unsafe_address(base, offset, decorators, (is_mask ? T_BOOLEAN : elem_bt), true);\n+  Node* addr = make_unsafe_address(base, offset, (is_mask ? T_BOOLEAN : elem_bt), true);\n@@ -770,1 +785,6 @@\n-  if (arr_type != NULL && !using_byte_array && elem_bt != arr_type->elem()->array_element_basic_type() && !is_mask) {\n+  if (arr_type != NULL && !using_byte_array && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+                    is_store, is_store ? \"store\" : \"load\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -947,2 +967,6 @@\n-  DecoratorSet decorators = C2_UNSAFE_ACCESS;\n-  Node* addr = make_unsafe_address(base, offset, decorators, elem_bt, true);\n+\n+  \/\/ Save state and restore on bailout\n+  uint old_sp = sp();\n+  SafePointNode* old_map = clone_map();\n+\n+  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n@@ -952,0 +976,2 @@\n+    set_map(old_map);\n+    set_sp(old_sp);\n@@ -974,0 +1000,2 @@\n+      set_map(old_map);\n+      set_sp(old_sp);\n@@ -982,0 +1010,2 @@\n+      set_map(old_map);\n+      set_sp(old_sp);\n@@ -993,0 +1023,2 @@\n+  old_map->destruct(&_gvn);\n+\n@@ -1075,1 +1107,1 @@\n-  Node* addr = make_unsafe_address(base, offset, C2_UNSAFE_ACCESS, elem_bt, true);\n+  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n@@ -1081,1 +1113,6 @@\n-  if (arr_type == NULL || (arr_type != NULL && elem_bt != arr_type->elem()->array_element_basic_type())) {\n+  if (arr_type == NULL || (arr_type != NULL && !elem_consistent_with_arr(elem_bt, arr_type))) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+                    is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -1400,0 +1437,10 @@\n+  if ((cond->get_con() & BoolTest::unsigned_compare) != 0) {\n+    if (!Matcher::supports_unsigned_vector_comparison(num_elem, elem_bt)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+                      cond->get_con() & (BoolTest::unsigned_compare - 1), num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":56,"deletions":9,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1244,0 +1244,11 @@\n+class VectorMaskCastNode : public VectorNode {\n+ public:\n+  VectorMaskCastNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    const TypeVect* in_vt = in->bottom_type()->is_vect();\n+    assert(in_vt->length() == vt->length(), \"vector length must match\");\n+    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()), \"element size must match\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,4 +30,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n-import java.nio.Buffer;\n-import java.nio.ByteBuffer;\n-import java.util.Objects;\n@@ -92,9 +88,19 @@\n-    \/\/ enum BoolTest\n-    public static final int BT_eq = 0;\n-    public static final int BT_ne = 4;\n-    public static final int BT_le = 5;\n-    public static final int BT_ge = 7;\n-    public static final int BT_lt = 3;\n-    public static final int BT_gt = 1;\n-    public static final int BT_overflow = 2;\n-    public static final int BT_no_overflow = 6;\n+    \/\/ See src\/hotspot\/share\/opto\/subnode.hpp\n+    \/\/     struct BoolTest, and enclosed enum mask\n+    public static final int BT_eq = 0;  \/\/ 0000\n+    public static final int BT_ne = 4;  \/\/ 0100\n+    public static final int BT_le = 5;  \/\/ 0101\n+    public static final int BT_ge = 7;  \/\/ 0111\n+    public static final int BT_lt = 3;  \/\/ 0011\n+    public static final int BT_gt = 1;  \/\/ 0001\n+    public static final int BT_overflow = 2;     \/\/ 0010\n+    public static final int BT_no_overflow = 6;  \/\/ 0110\n+    \/\/ never = 8    1000\n+    \/\/ illegal = 9  1001\n+    \/\/ Unsigned comparisons apply to BT_le, BT_ge, BT_lt, BT_gt for integral types\n+    public static final int BT_unsigned_compare = 0b10000;\n+    public static final int BT_ule = BT_le | BT_unsigned_compare;\n+    public static final int BT_uge = BT_ge | BT_unsigned_compare;\n+    public static final int BT_ult = BT_lt | BT_unsigned_compare;\n+    public static final int BT_ugt = BT_gt | BT_unsigned_compare;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte128Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte128Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte128Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -829,0 +815,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte256Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte256Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte256Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -861,0 +847,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte512Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte512Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte512Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -925,0 +911,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte64Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte64Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte64Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Byte64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -813,0 +799,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ByteMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (ByteMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ByteMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (ByteMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -799,0 +785,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -390,14 +390,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1880,11 +1866,14 @@\n-    private static\n-    boolean compareWithOp(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, byte a, byte b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Byte.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Byte.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Byte.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Byte.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2094,8 +2083,5 @@\n-        byte[] a0 = this.vec();\n-        byte[] a1 = that.vec();\n-        byte[] res = new byte[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Byte> iota = iotaShuffle();\n+        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -2123,0 +2109,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    ByteVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Byte> iota = iotaShuffle();\n+        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2137,15 +2134,6 @@\n-        byte[] slice = this.vec();\n-        byte[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Byte> iota = iotaShuffle();\n+        VectorMask<Byte> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((byte)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2181,0 +2169,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    ByteVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Byte> iota = iotaShuffle();\n+        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((byte)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2937,0 +2938,158 @@\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ByteVector zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n@@ -3179,0 +3338,167 @@\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ByteSpecies vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<Byte> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ByteSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n@@ -3286,0 +3612,15 @@\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    ByteVector fromBooleanArray0Template(boolean[] a, int offset) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+\n@@ -3433,0 +3774,10 @@\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":399,"deletions":48,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double128Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double128Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double128Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -797,0 +783,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double256Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double256Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double256Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -801,0 +787,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double512Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double512Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double512Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -809,0 +795,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double64Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double64Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double64Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Double64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -795,0 +781,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         DoubleMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (DoubleMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         DoubleMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (DoubleMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -794,0 +780,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -390,14 +390,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1763,11 +1749,10 @@\n-    private static\n-    boolean compareWithOp(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, double a, double b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n@@ -1977,8 +1962,5 @@\n-        double[] a0 = this.vec();\n-        double[] a1 = that.vec();\n-        double[] res = new double[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Double> iota = iotaShuffle();\n+        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -2006,0 +1988,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    DoubleVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Double> iota = iotaShuffle();\n+        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2020,15 +2013,6 @@\n-        double[] slice = this.vec();\n-        double[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Double> iota = iotaShuffle();\n+        VectorMask<Double> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((double)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2064,0 +2048,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    DoubleVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Double> iota = iotaShuffle();\n+        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((double)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2814,0 +2811,1 @@\n+\n@@ -3103,0 +3101,1 @@\n+\n@@ -3210,0 +3209,1 @@\n+\n@@ -3362,0 +3362,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":49,"deletions":48,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float128Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float128Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float128Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -801,0 +787,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float256Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float256Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float256Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -809,0 +795,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float512Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float512Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float512Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -825,0 +811,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float64Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float64Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float64Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Float64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -797,0 +783,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -404,8 +404,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         FloatMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (FloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -432,8 +425,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         FloatMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (FloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -794,0 +780,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -390,14 +390,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1775,11 +1761,10 @@\n-    private static\n-    boolean compareWithOp(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, float a, float b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n@@ -1989,8 +1974,5 @@\n-        float[] a0 = this.vec();\n-        float[] a1 = that.vec();\n-        float[] res = new float[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float> iota = iotaShuffle();\n+        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -2018,0 +2000,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    FloatVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float> iota = iotaShuffle();\n+        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2032,15 +2025,6 @@\n-        float[] slice = this.vec();\n-        float[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float> iota = iotaShuffle();\n+        VectorMask<Float> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((float)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2076,0 +2060,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    FloatVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float> iota = iotaShuffle();\n+        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((float)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2820,0 +2817,1 @@\n+\n@@ -3090,0 +3088,1 @@\n+\n@@ -3197,0 +3196,1 @@\n+\n@@ -3349,0 +3349,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":49,"deletions":48,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int128Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int128Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int128Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -805,0 +791,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int256Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int256Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int256Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -813,0 +799,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int512Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int512Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int512Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -829,0 +815,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int64Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int64Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int64Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Int64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -801,0 +787,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         IntMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (IntMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         IntMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (IntMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -810,0 +796,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -390,14 +390,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1879,11 +1865,14 @@\n-    private static\n-    boolean compareWithOp(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, int a, int b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Integer.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Integer.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Integer.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Integer.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2093,8 +2082,5 @@\n-        int[] a0 = this.vec();\n-        int[] a1 = that.vec();\n-        int[] res = new int[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Integer> iota = iotaShuffle();\n+        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -2122,0 +2108,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    IntVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Integer> iota = iotaShuffle();\n+        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2136,15 +2133,6 @@\n-        int[] slice = this.vec();\n-        int[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Integer> iota = iotaShuffle();\n+        VectorMask<Integer> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((int)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2180,0 +2168,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    IntVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Integer> iota = iotaShuffle();\n+        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((int)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2953,0 +2954,1 @@\n+\n@@ -3223,0 +3225,1 @@\n+\n@@ -3330,0 +3333,1 @@\n+\n@@ -3482,0 +3486,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":53,"deletions":48,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -400,8 +400,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long128Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long128Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -428,8 +421,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long128Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -791,0 +777,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -400,8 +400,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long256Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long256Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -428,8 +421,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long256Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -795,0 +781,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -400,8 +400,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long512Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long512Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -428,8 +421,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long512Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -803,0 +789,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -400,8 +400,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long64Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long64Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -428,8 +421,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long64Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Long64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -789,0 +775,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -400,8 +400,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         LongMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (LongMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -428,8 +421,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         LongMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (LongMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -789,0 +775,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -390,14 +390,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1792,11 +1778,14 @@\n-    private static\n-    boolean compareWithOp(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, long a, long b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Long.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Long.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Long.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Long.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -1959,8 +1948,5 @@\n-        long[] a0 = this.vec();\n-        long[] a1 = that.vec();\n-        long[] res = new long[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Long> iota = iotaShuffle();\n+        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -1988,0 +1974,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    LongVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Long> iota = iotaShuffle();\n+        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2002,15 +1999,6 @@\n-        long[] slice = this.vec();\n-        long[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Long> iota = iotaShuffle();\n+        VectorMask<Long> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((long)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2046,0 +2034,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    LongVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Long> iota = iotaShuffle();\n+        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((long)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2832,0 +2833,1 @@\n+\n@@ -3121,0 +3123,1 @@\n+\n@@ -3228,0 +3231,1 @@\n+\n@@ -3380,0 +3384,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":53,"deletions":48,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short128Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short128Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short128Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -819,0 +805,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short256Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short256Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short256Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -835,0 +821,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short512Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short512Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short512Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -867,0 +853,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short64Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short64Vector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short64Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (Short64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -811,0 +797,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -410,8 +410,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ShortMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (ShortMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n@@ -438,8 +431,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ShortMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return (ShortMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -805,0 +791,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -390,14 +390,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1880,11 +1866,14 @@\n-    private static\n-    boolean compareWithOp(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Short.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Short.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Short.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Short.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2094,8 +2083,5 @@\n-        short[] a0 = this.vec();\n-        short[] a1 = that.vec();\n-        short[] res = new short[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Short> iota = iotaShuffle();\n+        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -2123,0 +2109,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    ShortVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Short> iota = iotaShuffle();\n+        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2137,15 +2134,6 @@\n-        short[] slice = this.vec();\n-        short[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Short> iota = iotaShuffle();\n+        VectorMask<Short> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((short)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2181,0 +2169,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    ShortVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Short> iota = iotaShuffle();\n+        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((short)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -3036,0 +3037,1 @@\n+        \/\/ FIXME: optimize\n@@ -3082,0 +3084,1 @@\n+        \/\/ FIXME: optimize\n@@ -3086,0 +3089,1 @@\n+\n@@ -3434,0 +3438,1 @@\n+        \/\/ FIXME: optimize\n@@ -3478,0 +3483,1 @@\n+        \/\/ FIXME: optimize\n@@ -3485,0 +3491,1 @@\n+\n@@ -3606,0 +3613,1 @@\n+\n@@ -3767,0 +3775,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":57,"deletions":48,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -394,14 +394,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -2161,11 +2147,16 @@\n-    private static\n-    boolean compareWithOp(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+#if[!FP]\n+            case BT_ult -> $Boxtype$.compareUnsigned(a, b) < 0;\n+            case BT_ule -> $Boxtype$.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> $Boxtype$.compareUnsigned(a, b) > 0;\n+            case BT_uge -> $Boxtype$.compareUnsigned(a, b) >= 0;\n+#end[!FP]\n+            default -> throw new AssertionError();\n+        };\n@@ -2379,8 +2370,5 @@\n-        $type$[] a0 = this.vec();\n-        $type$[] a1 = that.vec();\n-        $type$[] res = new $type$[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<$Boxtype$> iota = iotaShuffle();\n+        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n@@ -2408,0 +2396,11 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    $abstractvectortype$ sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<$Boxtype$> iota = iotaShuffle();\n+        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -2422,15 +2421,6 @@\n-        $type$[] slice = this.vec();\n-        $type$[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<$Boxtype$> iota = iotaShuffle();\n+        VectorMask<$Boxtype$> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast(($type$)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n@@ -2466,0 +2456,13 @@\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    $abstractvectortype$\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<$Boxtype$> iota = iotaShuffle();\n+        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast(($type$)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n@@ -3593,0 +3596,1 @@\n+        \/\/ FIXME: optimize\n@@ -3639,0 +3643,1 @@\n+        \/\/ FIXME: optimize\n@@ -3644,0 +3649,160 @@\n+#if[byte]\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+#end[byte]\n+\n@@ -4074,0 +4239,1 @@\n+        \/\/ FIXME: optimize\n@@ -4118,0 +4284,1 @@\n+        \/\/ FIXME: optimize\n@@ -4126,0 +4293,169 @@\n+#if[byte]\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+#end[byte]\n+\n@@ -4249,0 +4585,17 @@\n+#if[byte]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromBooleanArray0Template(boolean[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+#end[byte]\n+\n@@ -4414,0 +4767,12 @@\n+#if[byte]\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":413,"deletions":48,"binary":false,"changes":461,"status":"modified"},{"patch":"@@ -416,8 +416,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         $shuffletype$ Iota = iotaShuffle();\n-         VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return ($vectortype$) super.sliceTemplate(origin);  \/\/ specialize\n@@ -444,8 +437,1 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         $shuffletype$ Iota = iotaShuffle();\n-         VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast(($type$)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        return ($vectortype$) super.unsliceTemplate(origin);  \/\/ specialize\n@@ -1095,0 +1081,9 @@\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"}]}