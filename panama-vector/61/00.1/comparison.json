{"files":[{"patch":"@@ -3211,1 +3211,1 @@\n-  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm8) {\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm16) {\n@@ -3215,1 +3215,2 @@\n-    if (imm8 <= 127 && imm8 >= -128) {\n+    unsigned imm = imm16;\n+    if (imm16 <= 127 && imm16 >= -128) {\n@@ -3217,1 +3218,1 @@\n-    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n+    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n@@ -3219,1 +3220,1 @@\n-      imm8 = (imm8 >> 8);\n+      imm = (imm >> 8);\n@@ -3223,0 +3224,2 @@\n+    unsigned mask = (1U << 8) - 1;\n+    imm &= mask;\n@@ -3224,1 +3227,1 @@\n-    f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n+    f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n@@ -3233,0 +3236,312 @@\n+   \/\/ SVE cpy immediate\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, int imm16, bool isMerge) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    int sh = 0;\n+    unsigned imm = imm16;\n+    if (imm16 <= 127 && imm16 >= -128) {\n+      sh = 0;\n+    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n+      sh = 1;\n+      imm = (imm >> 8);\n+    } else {\n+      guarantee(false, \"invalid immediate\");\n+    }\n+    unsigned mask = (1U << 8) - 1;\n+    imm &= mask;\n+    int m = isMerge ? 1 : 0;\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b01, 21, 20);\n+    prf(Pg, 16), f(0b0, 15), f(m, 14), f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE vector sel\n+  void sve_sel(FloatRegister Zd,\n+               SIMD_RegVariant T,\n+               PRegister Pg,\n+               FloatRegister Zn,\n+               FloatRegister Zm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b11, 15, 14), prf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+\/\/ SVE compare vector\n+#define INSN(NAME, op, cond, fp)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm)  { \\\n+    starti;                                                                                       \\\n+    if (fp == 0) {                                                                                \\\n+      assert(T != Q, \"invalid size\");                                                             \\\n+    } else {                                                                                      \\\n+      assert(T != B && T != Q, \"invalid size\");                                                   \\\n+    }                                                                                             \\\n+    f(op, 31, 24), f(T, 23, 22), f(0b0, 21), rf(Zm, 16), f((cond >> 1) & 0x7, 15, 13);            \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0);                                        \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);\n+  INSN(sve_cmpne, 0b00100100, 0b1011, 0);\n+  INSN(sve_cmpge, 0b00100100, 0b1000, 0);\n+  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);\n+  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);\n+  INSN(sve_fcmne, 0b01100101, 0b0111, 1);\n+  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);\n+  INSN(sve_fcmge, 0b01100101, 0b0100, 1);\n+#undef INSN\n+\n+\/\/ SVE compare vector with immediate\n+#define INSN(NAME, cond)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, int imm5) { \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    if (imm5 > 15 || imm5 < -16) {                                                       \\\n+      guarantee(false, \"invalid immediate\");                                             \\\n+    }                                                                                    \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),                   \\\n+    f((cond >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0); \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b1000);\n+  INSN(sve_cmpne, 0b1001);\n+  INSN(sve_cmpgt, 0b0001);\n+  INSN(sve_cmpge, 0b0000);\n+  INSN(sve_cmplt, 0b0010);\n+  INSN(sve_cmple, 0b0011);\n+#undef INSN\n+\n+\/\/ SVE unpack and extend\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) { \\\n+    starti;                                                          \\\n+    assert(T != B && T != Q, \"invalid size\");                        \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1100, 21, 18);          \\\n+    f(op, 17, 16), f(0b001110, 15, 10), rf(Zn, 5), rf(Zd, 0);        \\\n+  }\n+\n+  INSN(sve_uunpkhi, 0b11);\n+  INSN(sve_uunpklo, 0b10);\n+  INSN(sve_sunpkhi, 0b01);\n+  INSN(sve_sunpklo, 0b00);\n+#undef INSN\n+\n+\/\/ SVE vector uzp1,uzp2\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);                       \\\n+    f(0b01101, 15, 11), f(op, 10), rf(Zn, 5), rf(Zd, 0);                               \\\n+  }\n+\n+  INSN(sve_uzp1, 0b0);\n+  INSN(sve_uzp2, 0b1);\n+#undef INSN\n+\n+\/\/ SVE while[cond]\n+#define INSN(NAME, decode, sf)                                            \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, Register Rn, Register Rm) {  \\\n+    starti;                                                               \\\n+    assert(T != Q, \"invalid register variant\");                           \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(1, 21),                        \\\n+    zrf(Rm, 16), f(0, 15, 13), f(sf, 12), f(decode >> 1, 11, 10),         \\\n+    zrf(Rn, 5), f(decode & 0b1, 4), prf(Pd, 0);                           \\\n+  }\n+\n+  INSN(sve_whilelt,  0b010, 1);\n+  INSN(sve_whileltw, 0b010, 0);\n+  INSN(sve_whilele,  0b011, 1);\n+  INSN(sve_whilelew, 0b011, 0);\n+  INSN(sve_whilelo,  0b110, 1);\n+  INSN(sve_whilelow, 0b110, 0);\n+  INSN(sve_whilels,  0b111, 1);\n+  INSN(sve_whilelsw, 0b111, 0);\n+#undef INSN\n+\n+private:\n+\n+  void encode_cvtf_T(SIMD_RegVariant T_dst, SIMD_RegVariant T_src,\n+                     unsigned& opc, unsigned& opc2) {\n+    assert(T_src != B && T_dst != B &&\n+           T_src != Q && T_dst != Q, \"invalid register variant\");\n+    if (T_dst != D) {\n+      assert(T_dst <= T_src, \"invalid register variant\");\n+    } else {\n+      assert(T_src != H, \"invalid register variant\");\n+    }\n+    \/\/ In most cases we can treat T_dst,T_src as opc,opc2\n+    \/\/ except following four cases. These cases should be converted\n+    \/\/ according to Arm's architecture reference manual:\n+    \/\/ +-----+------+---+------------------------------------+\n+    \/\/ | opc | opc2 | U |        Instruction Details         |\n+    \/\/ +-----+------+---+------------------------------------+\n+    \/\/ |  11 |   00 | 0 | SCVTF — 32-bit to double-precision |\n+    \/\/ |  11 |   00 | 1 | UCVTF — 32-bit to double-precision |\n+    \/\/ |  11 |   10 | 0 | SCVTF — 64-bit to single-precision |\n+    \/\/ |  11 |   10 | 1 | UCVTF — 64-bit to single-precision |\n+    \/\/ +-----+------+---+------------------------------------+\n+    if (T_dst == S && T_src == D) { \/\/ 64-bit to single-precision\n+      T_dst = D;\n+      T_src = S;\n+    } else if (T_dst == D && T_src == S) { \/\/ 32-bit to double-precision\n+      T_dst = D;\n+      T_src = B;\n+    }\n+    opc = T_dst;\n+    opc2 = T_src;\n+  }\n+public:\n+\n+\/\/ SVE convert integer to floating-point (predicated)\n+#define INSN(NAME, sign)                                                \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,      \\\n+            FloatRegister Zn, SIMD_RegVariant T_src) {                  \\\n+    starti;                                                             \\\n+    unsigned opc, opc2;                                                 \\\n+    encode_cvtf_T(T_dst, T_src, opc, opc2);                             \\\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b010, 21, 19);            \\\n+    f(opc2, 18, 17), f(sign, 16), f(0b101, 15, 13);                     \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                                 \\\n+  }\n+\n+  INSN(sve_scvtf, 0b0);\n+  INSN(sve_ucvtf, 0b1);\n+#undef INSN\n+\n+private:\n+\n+  void encode_fcvt_T(SIMD_RegVariant T_src,SIMD_RegVariant T_dst,\n+                     unsigned& opc, unsigned& opc2) {\n+    assert(T_src != B && T_dst != B &&\n+           T_src != Q && T_dst != Q, \"invalid register variant\");\n+    assert(T_src != T_dst, \"invalid register variant\");\n+    if (T_src == S) {\n+      if (T_dst == H) {\n+        opc = 0b10;\n+        opc2 = 0b00;\n+      } else if (T_dst == D) {\n+        opc = 0b11;\n+        opc2 = 0b11;\n+      }\n+    } else if (T_src == H) {\n+      if (T_dst == S) {\n+        opc = 0b10;\n+        opc2 = 0b01;\n+      } else if (T_dst == D) {\n+        opc = 0b11;\n+        opc2 = 0b01;\n+      }\n+    } else if (T_src == D) {\n+      if (T_dst == H) {\n+        opc = 0b11;\n+        opc2 = 0b00;\n+      } else if (T_dst == S) {\n+        opc = 0b11;\n+        opc2 = 0b10;\n+      }\n+    }\n+  }\n+public:\n+\n+\/\/ SVE floating-point convert precision (predicated)\n+  void sve_fcvt(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+            FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    unsigned opc, opc2;\n+    encode_fcvt_T(T_src, T_dst, opc, opc2);\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b0010, 21, 18);\n+    f(opc2, 17, 16), f(0b101, 15, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+private:\n+\n+  void encode_fcvtz_T (SIMD_RegVariant T_dst, SIMD_RegVariant T_src,\n+                       unsigned& opc, unsigned& opc2) {\n+    assert(T_src != B && T_dst != B &&\n+           T_src != Q && T_dst != Q, \"invalid register variant\");\n+    if (T_src != D) {\n+      assert(T_src <= T_dst, \"invalid register variant\");\n+    } else {\n+      assert(T_dst != H, \"invalid register variant\");\n+    }\n+    \/\/ In most cases we can treat T_dst,T_src as opc2,opc\n+    \/\/ except following four cases. These cases should be converted\n+    \/\/ according to Arm's architecture reference manual:\n+    \/\/ +-----+------+---+-------------------------------------+\n+    \/\/ | opc | opc2 | U |        Instruction Details          |\n+    \/\/ +-----+------+---+-------------------------------------+\n+    \/\/ |  11 |   10 | 0 | FCVTZS — Single-precision to 64-bit |\n+    \/\/ |  11 |   10 | 1 | FCVTZU — Single-precision to 64-bit |\n+    \/\/ |  11 |   00 | 0 | FCVTZS — Double-precision to 32-bit |\n+    \/\/ |  11 |   00 | 1 | FCVTZU — Double-precision to 32-bit |\n+    \/\/ +-----+------+---+-------------------------------------+\n+    if (T_dst == D && T_src == S) { \/\/ Single-precision to 64-bit\n+      T_dst = S;\n+      T_src = D;\n+    } else if (T_dst == S && T_src == D) { \/\/ Double-precision to 32-bit\n+      T_dst = B;\n+      T_src = D;\n+    }\n+    opc = T_src;\n+    opc2 = T_dst;\n+  }\n+public:\n+\n+\/\/ SVE floating-point convert to integer (predicated)\n+#define INSN(NAME, sign)                                                \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,      \\\n+            FloatRegister Zn, SIMD_RegVariant T_src) {                  \\\n+    starti;                                                             \\\n+    unsigned opc, opc2;                                                 \\\n+    encode_fcvtz_T(T_dst, T_src, opc, opc2);                            \\\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b011, 21, 19);            \\\n+    f(opc2, 18, 17), f(sign, 16), f(0b101, 15, 13);                     \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                                 \\\n+  }\n+\n+  INSN(sve_fcvtzs, 0b0);\n+  INSN(sve_fcvtzu, 0b1);\n+#undef INSN\n+\n+\/\/ SVE conditionally extract element to general-purpose register\n+#define INSN(NAME, before)                                                      \\\n+  void NAME(Register Rd, SIMD_RegVariant T, PRegister Pg,  FloatRegister Zn) {  \\\n+    starti;                                                                     \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b10000, 21, 17);                    \\\n+    f(before, 16), f(0b101, 15, 13);                                            \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Rd, 0);                                         \\\n+  }\n+\n+  INSN(sve_lasta, 0b0);\n+  INSN(sve_lastb, 0b1);\n+#undef INSN\n+\n+#define INSN(NAME, before)                                                           \\\n+  void NAME(FloatRegister Vd, SIMD_RegVariant T, PRegister Pg,  FloatRegister Zn) {  \\\n+    starti;                                                                          \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b10001, 21, 17);                         \\\n+    f(before, 16), f(0b100, 15, 13);                                                 \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Vd, 0);                                              \\\n+  }\n+\n+  INSN(sve_lasta, 0b0);\n+  INSN(sve_lastb, 0b1);\n+#undef INSN\n+\n+\/\/ SVE cpy general-purpose register\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, Register Rn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b101000101, 21, 13);\n+    pgrf(Pg, 10), srf(Rn, 5), rf(Zd, 0);\n+  }\n+\n+\/\/ SVE INDEX (immediates)\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T,\n+                 int imm1, int imm2) {\n+    starti;\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(0b1, 21);\n+    sf(imm2, 20, 16), f(0b010000, 15, 10);\n+    sf(imm1, 9, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":320,"deletions":5,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -1046,0 +1046,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -739,3 +739,5 @@\n-    OptoRegPair regs = is_CallRuntime()\n-      ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n-      : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n+    OptoRegPair regs = Opcode() == Op_CallLeafVector\n+      ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n+      : is_CallRuntime()\n+        ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n+        : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n@@ -743,0 +745,10 @@\n+\n+    \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n+    if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(OptoReg::is_valid(regs.second())) {\n+        for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n+          rm.Insert(r);\n+        }\n+      }\n+    }\n+\n@@ -1198,0 +1210,5 @@\n+uint CallLeafVectorNode::size_of() const { return sizeof(*this); }\n+bool CallLeafVectorNode::cmp( const Node &n ) const {\n+  CallLeafVectorNode &call = (CallLeafVectorNode&)n;\n+  return CallLeafNode::cmp(call) && _num_bits == call._num_bits;\n+}\n@@ -1269,0 +1286,15 @@\n+void CallLeafVectorNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+#ifdef ASSERT\n+  assert(tf()->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+         \"return vector size must match\");\n+  const TypeTuple* d = tf()->domain();\n+  for (uint i = TypeFunc::Parms; i < d->cnt(); i++) {\n+    Node* arg = in(i);\n+    assert(arg->bottom_type()->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+           \"vector argument size must match\");\n+  }\n+#endif\n+\n+  Matcher::vector_calling_convention(parm_regs, _num_bits, argcnt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+class         CallLeafVectorNode;\n@@ -784,0 +785,1 @@\n+protected:\n@@ -871,0 +873,18 @@\n+\/\/------------------------------CallLeafVectorNode-------------------------------\n+\/\/ CallLeafNode but calling with vector calling convention instead.\n+class CallLeafVectorNode : public CallLeafNode {\n+private:\n+  uint _num_bits;\n+protected:\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallLeafVectorNode(const TypeFunc* tf, address addr, const char* name,\n+                   const TypePtr* adr_type, uint num_bits)\n+    : CallLeafNode(tf, addr, name, adr_type), _num_bits(num_bits)\n+  {\n+  }\n+  virtual int   Opcode() const;\n+  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2194,1 +2194,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2204,1 +2205,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -3037,0 +3038,1 @@\n+  case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1531,0 +1531,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}