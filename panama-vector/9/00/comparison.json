{"files":[{"patch":"@@ -38,0 +38,2 @@\n+import org.testng.Assert;\n+\n@@ -155,0 +157,6 @@\n+    static final List<List<IntFunction<boolean[]>>>\n+        BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS =\n+            Stream.of(BOOLEAN_MASK_GENERATORS.get(0)).\n+                flatMap(fa -> BOOLEAN_MASK_GENERATORS.stream().skip(1).map(\n+                                      fb -> List.of(fa, fb))).collect(Collectors.toList());\n+\n@@ -241,0 +249,15 @@\n+\n+    interface FBooleanBinOp {\n+        boolean apply(boolean a, boolean b);\n+    }\n+\n+    static void assertArraysEquals(boolean[] a, boolean[] b, boolean[] r, FBooleanBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -935,0 +935,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5090,0 +5103,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -935,0 +935,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5090,0 +5103,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -935,0 +935,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5090,0 +5103,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -935,0 +935,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5090,0 +5103,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Byte64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongByte64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByte64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByte64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -940,0 +940,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5095,0 +5108,127 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, ByteMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeByteMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundByteMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1067,0 +1067,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4839,0 +4852,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1067,0 +1067,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4839,0 +4852,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1067,0 +1067,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4839,0 +4852,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1067,0 +1067,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4839,0 +4852,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Double64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongDouble64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDouble64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDouble64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1072,0 +1072,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4844,0 +4857,127 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, DoubleMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeDoubleMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundDoubleMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1077,0 +1077,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4817,0 +4830,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1077,0 +1077,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4817,0 +4830,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1077,0 +1077,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4817,0 +4830,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1077,0 +1077,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4817,0 +4830,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Float64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongFloat64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloat64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloat64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1082,0 +1082,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4822,0 +4835,127 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, FloatMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeFloatMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundFloatMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5045,0 +5058,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5045,0 +5058,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5045,0 +5058,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5045,0 +5058,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Int64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongInt64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeInt64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundInt64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -930,0 +930,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5050,0 +5063,127 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, IntMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeIntMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundIntMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -921,0 +921,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4928,0 +4941,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -921,0 +921,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4928,0 +4941,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -921,0 +921,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4928,0 +4941,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -921,0 +921,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4928,0 +4941,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Long64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongLong64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -926,0 +926,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4933,0 +4946,127 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, LongMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5069,0 +5082,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5069,0 +5082,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5069,0 +5082,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -925,0 +925,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5069,0 +5082,140 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, Short64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongShort64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShort64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShort64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -930,0 +930,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5074,0 +5087,127 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, ShortMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeShortMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundShortMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -367,0 +367,149 @@\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEquals$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEq$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(a, b, r, $vectorteststype$::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCode$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCount$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int tcount = vmask.trueCount();\n+#if[!MaxBit]\n+            int expectedTcount = Long.bitCount(vmask.toLong());\n+#else[!MaxBit]\n+            int expectedTcount = 0;\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expectedTcount += a[j] ? 1 : 0;\n+            }\n+#end[!MaxBit]\n+\n+            Assert.assertTrue(tcount == expectedTcount, \"at index \" + i + \", trueCount should be = \" + expectedTcount + \", but is = \" + tcount);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int ltrue = vmask.lastTrue();\n+            int j = i + SPECIES.length() - 1;\n+            for (; j >= i; j--) {\n+                if (a[j]) break;\n+            }\n+            int expectedLtrue = j - i;\n+\n+            Assert.assertTrue(ltrue == expectedLtrue, \"at index \" + i +\n+                \", lastTrue should be = \" + expectedLtrue + \", but is = \" + ltrue);\n+        }\n+    }\n+\n+#if[!MaxBit]\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFl},\n+                {0x0000000000000000l},\n+                {0x5555555555555555l},\n+                {0x0123456789abcdefl},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLong$vectorteststype$SmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, inputLong & (((1l << (SPECIES.length()-1)) << 1)-1));\n+    }\n+#end[!MaxBit]\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRange$vectorteststype$SmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i+offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i+offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i+j+offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBound$vectorteststype$SmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":149,"deletions":0,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -1138,0 +1138,13 @@\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}