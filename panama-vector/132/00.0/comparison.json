{"files":[{"patch":"@@ -2688,0 +2688,7 @@\n+    if (u->is_LoadStore()) {\n+      \/\/ On AArch64, LoadStoreNodes (i.e. compare and swap\n+      \/\/ instructions) only take register indirect as an operand, so\n+      \/\/ any attempt to use an AddPNode as an input to a LoadStoreNode\n+      \/\/ must fail.\n+      return false;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -479,1 +479,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -613,1 +613,1 @@\n-    __ sve_cmpeq(as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n@@ -1774,1 +1774,2 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ B, ptrue, as_FloatRegister($src$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n+               ptrue, as_FloatRegister($src$$reg), 0);\n@@ -1788,1 +1789,2 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ H, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ H,\n+               ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1804,1 +1806,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ S, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ S, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1821,1 +1823,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ D, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ D, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1908,2 +1910,2 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-                 ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n+               ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1932,1 +1934,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($vtmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($vtmp$$reg), 0);\n@@ -5113,2 +5115,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -5134,2 +5136,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -5161,2 +5163,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -5182,2 +5184,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ D, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -5203,2 +5205,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ D, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -5226,2 +5228,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -5767,1 +5769,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -5783,1 +5785,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -5801,1 +5803,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -5820,1 +5822,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -5839,1 +5841,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -5860,1 +5862,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -504,1 +504,1 @@\n-    __ sve_cmpeq(as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n@@ -1055,1 +1055,2 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ B, ptrue, as_FloatRegister($src$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n+               ptrue, as_FloatRegister($src$$reg), 0);\n@@ -1069,1 +1070,2 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ H, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ H,\n+               ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1085,1 +1087,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ S, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ S, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1102,1 +1104,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ D, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ D, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1189,2 +1191,2 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-                 ptrue, as_FloatRegister($tmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n+               ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1213,1 +1215,1 @@\n-    __ sve_cmpne(as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($vtmp$$reg), 0);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($vtmp$$reg), 0);\n@@ -2638,2 +2640,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -2659,2 +2661,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -2686,2 +2688,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -2709,2 +2711,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ $3, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -2735,2 +2737,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -3218,1 +3220,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -3247,1 +3249,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1505,0 +1505,4 @@\n+  enum SIMD_RegVariant {\n+      B, H, S, D, Q, INVALID\n+  };\n+\n@@ -1508,0 +1512,1 @@\n+  static SIMD_RegVariant _esize2regvariant[9];\n@@ -1511,5 +1516,1 @@\n-  enum SIMD_RegVariant {\n-    B, H, S, D, Q, INVALID\n-  };\n-\n-  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+  static SIMD_Arrangement esize2arrangement(unsigned esize, bool isQ);\n@@ -1517,1 +1518,1 @@\n-  static SIMD_RegVariant elemBytes_to_regVariant(int esize);\n+  static SIMD_RegVariant elemBytes_to_regVariant(unsigned esize);\n@@ -2932,1 +2933,1 @@\n-\/\/ SVE arithmetics - unpredicated\n+\/\/ SVE arithmetic - unpredicated\n@@ -2995,1 +2996,1 @@\n-\/\/ SVE integer arithmetics - predicate\n+\/\/ SVE integer arithmetic - predicate\n@@ -3026,1 +3027,1 @@\n-\/\/ SVE floating-point arithmetics - predicate\n+\/\/ SVE floating-point arithmetic - predicate\n@@ -3151,1 +3152,1 @@\n-\/\/ SVE load\/store - predicated\n+\/\/ SVE contiguous load\/store\n@@ -3168,1 +3169,1 @@\n-\/\/ SVE load gather, store scatter (scalar plus vector) - 32-bit scaled offset\n+\/\/ Gather\/scatter load\/store (SVE) - scalar plus vector\n@@ -3175,1 +3176,1 @@\n-\n+  \/\/ SVE 32-bit gather load words (scalar plus 32-bit scaled offsets)\n@@ -3177,0 +3178,1 @@\n+  \/\/ SVE 64-bit gather load (scalar plus 32-bit unpacked scaled offsets)\n@@ -3178,0 +3180,1 @@\n+  \/\/ SVE 32-bit scatter store (scalar plus 32-bit scaled offsets)\n@@ -3179,0 +3182,1 @@\n+  \/\/ SVE 64-bit scatter store (scalar plus unpacked 32-bit scaled offsets)\n@@ -3195,0 +3199,1 @@\n+\/\/ SVE stack frame adjustment\n@@ -3202,2 +3207,2 @@\n-  INSN(sve_addvl, 0b01);\n-  INSN(sve_addpl, 0b11);\n+  INSN(sve_addvl, 0b01); \/\/ Add multiple of vector register size to scalar register\n+  INSN(sve_addpl, 0b11); \/\/ Add multiple of predicate register size to scalar register\n@@ -3237,1 +3242,9 @@\n-  \/\/ SVE dup scalar\n+  \/\/ SVE increment register by predicate count\n+  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n+    prf(pg, 5), rf(rd, 0);\n+  }\n+\n+  \/\/ SVE broadcast general-purpose register to vector elements (unpredicated)\n@@ -3245,1 +3258,1 @@\n-  \/\/ SVE dup imm\n+  \/\/ SVE broadcast signed immediate to vector elements (unpredicated)\n@@ -3303,1 +3316,1 @@\n-  \/\/ SVE cpy general-purpose register\n+  \/\/ SVE copy general-purpose register to vector elements (predicated)\n@@ -3311,1 +3324,1 @@\n-  \/\/ SVE cpy immediate\n+  \/\/ SVE copy signed integer immediate to vector elements (predicated)\n@@ -3329,1 +3342,1 @@\n-  \/\/ SVE sel (vectors)\n+  \/\/ SVE conditionally select elements from two vectors\n@@ -3338,31 +3351,46 @@\n-\/\/ SVE compare vectors\n-#define INSN(NAME, op, cond, fp)  \\\n-  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm)  { \\\n-    starti;                                                                                       \\\n-    if (fp == 0) {                                                                                \\\n-      assert(T != Q, \"invalid size\");                                                             \\\n-    } else {                                                                                      \\\n-      assert(T != B && T != Q, \"invalid size\");                                                   \\\n-    }                                                                                             \\\n-    f(op, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);                \\\n-    pgrf(Pg, 10), rf(Zn, 5), f(cond & 1, 4), prf(Pd, 0);                                          \\\n-  }\n-\n-  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);  \/\/ Compare signed equal to vector\n-  INSN(sve_cmpne, 0b00100100, 0b1011, 0);  \/\/ Compare not equal to vector\n-  INSN(sve_cmpge, 0b00100100, 0b1000, 0);  \/\/ Compare signed greater than or equal to vector\n-  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);  \/\/ Compare signed greater than vector\n-  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);  \/\/ Floating-point compare vectors: Equal\n-  INSN(sve_fcmne, 0b01100101, 0b0111, 1);  \/\/ Floating-point compare vectors: Not Equal\n-  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);  \/\/ Floating-point compare vectors: Greater than\n-  INSN(sve_fcmge, 0b01100101, 0b0100, 1);  \/\/ Floating-point compare vectors: Greater than or equal\n-#undef INSN\n-\n-\/\/ SVE compare vector with immediate\n-#define INSN(NAME, cond)  \\\n-  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, int imm5) { \\\n-    starti;                                                                              \\\n-    assert(T != Q, \"invalid size\");                                                      \\\n-    guarantee(-16 <= imm5 && imm5 <= 15, \"invalid immediate\");                           \\\n-    f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),                   \\\n-    f((cond >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0); \\\n+\/\/ SVE Integer\/Floating-Point Compare - Vectors\n+#define INSN(NAME, op1, op2, fp)  \\\n+  void NAME(Condition cond, PRegister Pd, SIMD_RegVariant T, PRegister Pg,             \\\n+            FloatRegister Zn, FloatRegister Zm) {                                      \\\n+    starti;                                                                            \\\n+    if (fp == 0) {                                                                     \\\n+      assert(T != Q, \"invalid size\");                                                  \\\n+    } else {                                                                           \\\n+      assert(T != B && T != Q, \"invalid size\");                                        \\\n+      assert(cond != HI && cond != HS, \"invalid condition for fcm\");                   \\\n+    }                                                                                  \\\n+    int cond_op;                                                                       \\\n+    switch(cond) {                                                                     \\\n+      case EQ: cond_op = (op2 << 2) | 0b10; break;                                     \\\n+      case NE: cond_op = (op2 << 2) | 0b11; break;                                     \\\n+      case GE: cond_op = (op2 << 2) | 0b00; break;                                     \\\n+      case GT: cond_op = (op2 << 2) | 0b01; break;                                     \\\n+      case HI: cond_op = 0b0001; break;                                                \\\n+      case HS: cond_op = 0b0000; break;                                                \\\n+      default:                                                                         \\\n+        ShouldNotReachHere();                                                          \\\n+    }                                                                                  \\\n+    f(op1, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond_op >> 1) & 7, 15, 13); \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond_op & 1, 4), prf(Pd, 0);                            \\\n+  }\n+\n+  INSN(sve_cmp, 0b00100100, 0b10, 0);\n+  INSN(sve_fcm, 0b01100101, 0b01, 1);\n+#undef INSN\n+\n+\/\/ SVE Integer Compare - Signed Immediate\n+void sve_cmp(Condition cond, PRegister Pd, SIMD_RegVariant T,\n+             PRegister Pg, FloatRegister Zn, int imm5) {\n+  starti;\n+  assert(T != Q, \"invalid size\");\n+  guarantee(-16 <= imm5 && imm5 <= 15, \"invalid immediate\");\n+  int cond_op;\n+  switch(cond) {\n+    case EQ: cond_op = 0b1000; break;\n+    case NE: cond_op = 0b1001; break;\n+    case GE: cond_op = 0b0000; break;\n+    case GT: cond_op = 0b0001; break;\n+    case LE: cond_op = 0b0011; break;\n+    case LT: cond_op = 0b0010; break;\n+    default:\n+      ShouldNotReachHere();\n@@ -3370,0 +3398,4 @@\n+  f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),\n+  f((cond_op >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5);\n+  f(cond_op & 0x1, 4), prf(Pd, 0);\n+}\n@@ -3371,9 +3403,1 @@\n-  INSN(sve_cmpeq, 0b1000);\n-  INSN(sve_cmpne, 0b1001);\n-  INSN(sve_cmpgt, 0b0001);\n-  INSN(sve_cmpge, 0b0000);\n-  INSN(sve_cmplt, 0b0010);\n-  INSN(sve_cmple, 0b0011);\n-#undef INSN\n-\n-\/\/ SVE unpack and extend\n+\/\/ SVE unpack vector elements\n@@ -3388,4 +3412,4 @@\n-  INSN(sve_uunpkhi, 0b11);\n-  INSN(sve_uunpklo, 0b10);\n-  INSN(sve_sunpkhi, 0b01);\n-  INSN(sve_sunpklo, 0b00);\n+  INSN(sve_uunpkhi, 0b11); \/\/ Signed unpack and extend half of vector - high half\n+  INSN(sve_uunpklo, 0b10); \/\/ Signed unpack and extend half of vector - low half\n+  INSN(sve_sunpkhi, 0b01); \/\/ Unsigned unpack and extend half of vector - high half\n+  INSN(sve_sunpklo, 0b00); \/\/ Unsigned unpack and extend half of vector - low half\n@@ -3406,1 +3430,1 @@\n-\/\/ SVE uzp1\/uzp2 (vectors)\n+\/\/ SVE permute vector elements\n@@ -3415,2 +3439,2 @@\n-  INSN(sve_uzp1, 0b0);\n-  INSN(sve_uzp2, 0b1);\n+  INSN(sve_uzp1, 0b0); \/\/ Concatenate even elements from two vectors\n+  INSN(sve_uzp2, 0b1); \/\/ Concatenate odd elements from two vectors\n@@ -3456,1 +3480,1 @@\n-\/\/ SVE predicate break after\/before first true condition\n+\/\/ SVE partition break condition\n@@ -3464,2 +3488,2 @@\n-  INSN(sve_brka, 0b00);\n-  INSN(sve_brkb, 0b10);\n+  INSN(sve_brka, 0b00); \/\/ Break after first true condition\n+  INSN(sve_brkb, 0b10); \/\/ Break before first true condition\n@@ -3490,8 +3514,0 @@\n-  \/\/ Increment scalar by active predicate element count\n-  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n-    starti;\n-    assert(T != Q, \"invalid size\");\n-    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n-    prf(pg, 5), rf(rd, 0);\n-  }\n-\n@@ -3592,1 +3608,1 @@\n-  \/\/ SVE INDEX (immediates)\n+  \/\/ SVE create index starting from and incremented by immediate\n@@ -3600,1 +3616,1 @@\n-  \/\/ SVE programmable table lookup in single vector table\n+  \/\/ SVE programmable table lookup\/permute using vector of element indices\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":95,"deletions":79,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-    sve_cmpeq(tmp_pdn, T, tmp_pg, ztmp1, ztmp2);\n+    sve_cmp(Assembler::EQ, tmp_pdn, T, tmp_pg, ztmp1, ztmp2);\n@@ -908,1 +908,1 @@\n-  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt), isQ);\n@@ -950,0 +950,16 @@\n+  assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n+  FloatRegister z1 = zn, z2 = zm;\n+  \/\/ Convert the original BoolTest condition to Assembler::condition.\n+  Condition condition;\n+  switch (cond) {\n+    case BoolTest::eq: condition = Assembler::EQ; break;\n+    case BoolTest::ne: condition = Assembler::NE; break;\n+    case BoolTest::le: z1 = zm; z2 = zn; condition = Assembler::GE; break;\n+    case BoolTest::ge: condition = Assembler::GE; break;\n+    case BoolTest::lt: z1 = zm; z2 = zn; condition = Assembler::GT; break;\n+    case BoolTest::gt: condition = Assembler::GT; break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n+\n@@ -952,11 +968,1 @@\n-    switch (cond) {\n-      case BoolTest::eq: sve_fcmeq(pd, size, pg, zn, zm); break;\n-      case BoolTest::ne: sve_fcmne(pd, size, pg, zn, zm); break;\n-      case BoolTest::ge: sve_fcmge(pd, size, pg, zn, zm); break;\n-      case BoolTest::gt: sve_fcmgt(pd, size, pg, zn, zm); break;\n-      case BoolTest::le: sve_fcmge(pd, size, pg, zm, zn); break;\n-      case BoolTest::lt: sve_fcmgt(pd, size, pg, zm, zn); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+    sve_fcm(condition, pd, size, pg, z1, z2);\n@@ -964,11 +970,2 @@\n-    switch (cond) {\n-      case BoolTest::eq: sve_cmpeq(pd, size, pg, zn, zm); break;\n-      case BoolTest::ne: sve_cmpne(pd, size, pg, zn, zm); break;\n-      case BoolTest::ge: sve_cmpge(pd, size, pg, zn, zm); break;\n-      case BoolTest::gt: sve_cmpgt(pd, size, pg, zn, zm); break;\n-      case BoolTest::le: sve_cmpge(pd, size, pg, zm, zn); break;\n-      case BoolTest::lt: sve_cmpgt(pd, size, pg, zm, zn); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+    assert(is_integral_type(bt), \"unsupported element type\");\n+    sve_cmp(condition, pd, size, pg, z1, z2);\n@@ -982,1 +979,1 @@\n-  sve_cmpne(ptmp, size, pgtmp, src, 0);\n+  sve_cmp(Assembler::NE, ptmp, size, pgtmp, src, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -4866,1 +4866,8 @@\n-\/\/    scratch1 = cnt & 7;\n+\/\/    if (cnt == 0) {\n+\/\/      return;\n+\/\/    }\n+\/\/    if ((p & 8) != 0) {\n+\/\/      *p++ = v;\n+\/\/    }\n+\/\/\n+\/\/    scratch1 = cnt & 14;\n@@ -4869,1 +4876,1 @@\n-\/\/    switch (scratch1) {\n+\/\/    switch (scratch1 \/ 2) {\n@@ -4871,2 +4878,3 @@\n-\/\/        cnt -= 8;\n-\/\/          p[-8] = v;\n+\/\/        cnt -= 16;\n+\/\/          p[-16] = v;\n+\/\/          p[-15] = v;\n@@ -4874,1 +4882,2 @@\n-\/\/          p[-7] = v;\n+\/\/          p[-14] = v;\n+\/\/          p[-13] = v;\n@@ -4876,1 +4885,2 @@\n-\/\/          p[-6] = v;\n+\/\/          p[-12] = v;\n+\/\/          p[-11] = v;\n@@ -4879,0 +4889,1 @@\n+\/\/          p[-2] = v;\n@@ -4881,1 +4892,1 @@\n-\/\/          p += 8;\n+\/\/          p += 16;\n@@ -4883,0 +4894,3 @@\n+\/\/    }\n+\/\/    if ((cnt & 1) == 1) {\n+\/\/      *p++ = v;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -948,1 +948,6 @@\n-\n+  void gfmul_avx512(XMMRegister ghash, XMMRegister hkey);\n+  void generateHtbl_48_block_zmm(Register htbl);\n+  void ghash16_encrypt16_parallel(Register key, Register subkeyHtbl, XMMRegister ctr_blockx,\n+                                  XMMRegister aad_hashx, Register in, Register out, Register data, Register pos, bool reduction,\n+                                  XMMRegister addmask, bool no_ghash_input, Register rounds, Register ghash_pos,\n+                                  bool final_reduction, int index, XMMRegister counter_inc_mask);\n@@ -954,0 +959,2 @@\n+  void aesgcm_encrypt(Register in, Register len, Register ct, Register out, Register key,\n+                      Register state, Register subkeyHtbl, Register counter);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4371,0 +4371,89 @@\n+  address ghash_polynomial512_addr() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"_ghash_poly512_addr\");\n+    address start = __ pc();\n+    __ emit_data64(0x00000001C2000000, relocInfo::none); \/\/ POLY for reduction\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x00000001C2000000, relocInfo::none);\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x00000001C2000000, relocInfo::none);\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x00000001C2000000, relocInfo::none);\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none); \/\/ POLY\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none); \/\/ TWOONE\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    return start;\n+}\n+\n+  \/\/ Vector AES Galois Counter Mode implementation. Parameters:\n+  \/\/ Windows regs            |  Linux regs\n+  \/\/ in = c_rarg0 (rcx)      |  c_rarg0 (rsi)\n+  \/\/ len = c_rarg1 (rdx)     |  c_rarg1 (rdi)\n+  \/\/ ct = c_rarg2 (r8)       |  c_rarg2 (rdx)\n+  \/\/ out = c_rarg3 (r9)      |  c_rarg3 (rcx)\n+  \/\/ key = r10               |  c_rarg4 (r8)\n+  \/\/ state = r13             |  c_rarg5 (r9)\n+  \/\/ subkeyHtbl = r14        |  r11\n+  \/\/ counter = rsi           |  r12\n+  \/\/ return - number of processed bytes\n+  address generate_galoisCounterMode_AESCrypt() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+    address start = __ pc();\n+    const Register in = c_rarg0;\n+    const Register len = c_rarg1;\n+    const Register ct = c_rarg2;\n+    const Register out = c_rarg3;\n+    \/\/ and updated with the incremented counter in the end\n+#ifndef _WIN64\n+    const Register key = c_rarg4;\n+    const Register state = c_rarg5;\n+    const Address subkeyH_mem(rbp, 2 * wordSize);\n+    const Register subkeyHtbl = r11;\n+    const Address counter_mem(rbp, 3 * wordSize);\n+    const Register counter = r12;\n+#else\n+    const Address key_mem(rbp, 6 * wordSize);\n+    const Register key = r10;\n+    const Address state_mem(rbp, 7 * wordSize);\n+    const Register state = r13;\n+    const Address subkeyH_mem(rbp, 8 * wordSize);\n+    const Register subkeyHtbl = r14;\n+    const Address counter_mem(rbp, 9 * wordSize);\n+    const Register counter = rsi;\n+#endif\n+    __ enter();\n+   \/\/ Save state before entering routine\n+    __ push(r12);\n+    __ push(r13);\n+    __ push(r14);\n+    __ push(r15);\n+    __ push(rbx);\n+#ifdef _WIN64\n+    \/\/ on win64, fill len_reg from stack position\n+    __ push(rsi);\n+    __ movptr(key, key_mem);\n+    __ movptr(state, state_mem);\n+#endif\n+    __ movptr(subkeyHtbl, subkeyH_mem);\n+    __ movptr(counter, counter_mem);\n+\n+    __ aesgcm_encrypt(in, len, ct, out, key, state, subkeyHtbl, counter);\n+\n+    \/\/ Restore state before leaving routine\n+#ifdef _WIN64\n+    __ pop(rsi);\n+#endif\n+    __ pop(rbx);\n+    __ pop(r15);\n+    __ pop(r14);\n+    __ pop(r13);\n+    __ pop(r12);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+     return start;\n+  }\n+\n@@ -7622,0 +7711,4 @@\n+        StubRoutines::x86::_counter_mask_addr = counter_mask_addr();\n+        StubRoutines::x86::_ghash_poly512_addr = ghash_polynomial512_addr();\n+        StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n+        StubRoutines::_galoisCounterMode_AESCrypt = generate_galoisCounterMode_AESCrypt();\n@@ -7626,0 +7719,1 @@\n+\n@@ -7628,1 +7722,3 @@\n-        StubRoutines::x86::_counter_mask_addr = counter_mask_addr();\n+        if (StubRoutines::x86::_counter_mask_addr == NULL) {\n+          StubRoutines::x86::_counter_mask_addr = counter_mask_addr();\n+        }\n@@ -7668,1 +7764,3 @@\n-    StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n+      if (StubRoutines::x86::_ghash_long_swap_mask_addr == NULL) {\n+        StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":100,"deletions":2,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+address StubRoutines::x86::_ghash_poly512_addr = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  code_size2 = 35300 LP64_ONLY(+25000)          \/\/ simply increase if too small (assembler will crash if too small)\n+  code_size2 = 35300 LP64_ONLY(+32000)          \/\/ simply increase if too small (assembler will crash if too small)\n@@ -202,0 +202,1 @@\n+  static address _ghash_poly512_addr;\n@@ -258,0 +259,1 @@\n+  static address ghash_polynomial512_addr() { return _ghash_poly512_addr; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -418,0 +418,5 @@\n+  do_class(com_sun_crypto_provider_galoisCounterMode, \"com\/sun\/crypto\/provider\/GaloisCounterMode\")                      \\\n+   do_intrinsic(_galoisCounterMode_AESCrypt, com_sun_crypto_provider_galoisCounterMode, gcm_crypt_name, aes_gcm_signature, F_S)   \\\n+   do_name(gcm_crypt_name, \"implGCMCrypt\")                                                                                 \\\n+   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")                                                             \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -643,0 +643,1 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1358,1 +1358,1 @@\n-          offset < k->size_helper() * wordSize) {\n+          offset < k->layout_helper_size_in_bytes()) {\n@@ -1382,1 +1382,1 @@\n-    } else if (offset < 0 || offset >= k->size_helper() * wordSize) {\n+    } else if (offset < 0 || offset >= k->layout_helper_size_in_bytes()) {\n@@ -1392,0 +1392,1 @@\n+      assert(offset < canonical_holder->layout_helper_size_in_bytes(), \"\");\n@@ -1412,1 +1413,1 @@\n-                                   TypeKlassPtr::OBJECT->klass(),\n+                                   TypeInstKlassPtr::OBJECT->klass(),\n@@ -1459,1 +1460,3 @@\n-    case Type::KlassPtr: tj = TypeKlassPtr::OBJECT; break;\n+    case Type::KlassPtr:\n+    case Type::AryKlassPtr:\n+    case Type::InstKlassPtr: tj = TypeInstKlassPtr::OBJECT; break;\n@@ -1664,1 +1667,1 @@\n-          tinst->offset() >= (tinst->klass()->as_instance_klass()->size_helper() * wordSize)) {\n+          tinst->offset() >= (tinst->klass()->as_instance_klass()->layout_helper_size_in_bytes())) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-  bool block_size_threshold_ok = (block->number_of_nodes() > 10) ? true : false;\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n@@ -952,1 +952,1 @@\n-  bool block_size_threshold_ok = (block->number_of_nodes() > 10) ? true : false;\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -550,0 +550,3 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n+    return inline_galoisCounterMode_AESCrypt();\n+\n@@ -720,0 +723,2 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n+    return inline_galoisCounterMode_AESCrypt_predicate();\n@@ -2174,1 +2179,1 @@\n-      const TypeOopPtr *elem_type = adr_type->is_aryptr()->elem()->isa_oopptr();\n+      const TypeOopPtr* elem_type = adr_type->is_aryptr()->elem()->make_oopptr();\n@@ -2840,1 +2845,1 @@\n-                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+                                                 TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -2870,1 +2875,1 @@\n-                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+                                                   TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -2963,1 +2968,1 @@\n-  const TypeKlassPtr*  kls_type = TypeKlassPtr::OBJECT_OR_NULL;\n+  const TypeKlassPtr*  kls_type = TypeInstKlassPtr::OBJECT_OR_NULL;\n@@ -3152,1 +3157,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -3294,1 +3299,1 @@\n-  const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;\n+  const TypeKlassPtr* kls_type = TypeInstKlassPtr::OBJECT_OR_NULL;\n@@ -4079,0 +4084,23 @@\n+\n+static bool has_wide_mem(PhaseGVN& gvn, Node* addr, Node* base) {\n+  const TypeAryPtr* addr_t = gvn.type(addr)->isa_aryptr();\n+  const Type*       base_t = gvn.type(base);\n+\n+  bool in_native = (base_t == TypePtr::NULL_PTR);\n+  bool in_heap   = !TypePtr::NULL_PTR->higher_equal(base_t);\n+  bool is_mixed  = !in_heap && !in_native;\n+\n+  if (is_mixed) {\n+    return true; \/\/ mixed accesses can touch both on-heap and off-heap memory\n+  }\n+  if (in_heap) {\n+    bool is_prim_array = (addr_t != NULL) && (addr_t->elem() != Type::BOTTOM);\n+    if (!is_prim_array) {\n+      \/\/ Though Unsafe.copyMemory() ensures at runtime for on-heap accesses that base is a primitive array,\n+      \/\/ there's not enough type information available to determine proper memory slice for it.\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -4086,5 +4114,5 @@\n-  Node* src_ptr =         argument(1);   \/\/ type: oop\n-  Node* src_off = ConvL2X(argument(2));  \/\/ type: long\n-  Node* dst_ptr =         argument(4);   \/\/ type: oop\n-  Node* dst_off = ConvL2X(argument(5));  \/\/ type: long\n-  Node* size    = ConvL2X(argument(7));  \/\/ type: long\n+  Node* src_base =         argument(1);  \/\/ type: oop\n+  Node* src_off  = ConvL2X(argument(2)); \/\/ type: long\n+  Node* dst_base =         argument(4);  \/\/ type: oop\n+  Node* dst_off  = ConvL2X(argument(5)); \/\/ type: long\n+  Node* size     = ConvL2X(argument(7)); \/\/ type: long\n@@ -4095,6 +4123,2 @@\n-  Node* src = make_unsafe_address(src_ptr, src_off);\n-  Node* dst = make_unsafe_address(dst_ptr, dst_off);\n-\n-  \/\/ Conservatively insert a memory barrier on all memory slices.\n-  \/\/ Do not let writes of the copy source or destination float below the copy.\n-  insert_mem_bar(Op_MemBarCPUOrder);\n+  Node* src_addr = make_unsafe_address(src_base, src_off);\n+  Node* dst_addr = make_unsafe_address(dst_base, dst_off);\n@@ -4110,0 +4134,15 @@\n+  int flags = RC_LEAF | RC_NO_FP;\n+\n+  const TypePtr* dst_type = TypePtr::BOTTOM;\n+\n+  \/\/ Adjust memory effects of the runtime call based on input values.\n+  if (!has_wide_mem(_gvn, src_addr, src_base) &&\n+      !has_wide_mem(_gvn, dst_addr, dst_base)) {\n+    dst_type = _gvn.type(dst_addr)->is_ptr(); \/\/ narrow out memory\n+\n+    const TypePtr* src_type = _gvn.type(src_addr)->is_ptr();\n+    if (C->get_alias_index(src_type) == C->get_alias_index(dst_type)) {\n+      flags |= RC_NARROW_MEM; \/\/ narrow in memory\n+    }\n+  }\n+\n@@ -4111,1 +4150,1 @@\n-  make_runtime_call(RC_LEAF|RC_NO_FP,\n+  make_runtime_call(flags,\n@@ -4115,2 +4154,2 @@\n-                    TypeRawPtr::BOTTOM,\n-                    src, dst, size XTOP);\n+                    dst_type,\n+                    src_addr, dst_addr, size XTOP);\n@@ -4120,3 +4159,0 @@\n-  \/\/ Do not let reads of the copy destination float above the copy.\n-  insert_mem_bar(Op_MemBarCPUOrder);\n-\n@@ -5975,1 +6011,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n@@ -6063,1 +6099,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n@@ -6134,1 +6170,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n@@ -6652,1 +6688,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n@@ -6686,0 +6722,128 @@\n+\/\/------------------------------inline_galoisCounterMode_AESCrypt-----------------------\n+bool LibraryCallKit::inline_galoisCounterMode_AESCrypt() {\n+  assert(UseAES, \"need AES instruction support\");\n+  address stubAddr = NULL;\n+  const char *stubName = NULL;\n+  stubAddr = StubRoutines::galoisCounterMode_AESCrypt();\n+  stubName = \"galoisCounterMode_AESCrypt\";\n+\n+  if (stubAddr == NULL) return false;\n+\n+  Node* in      = argument(0);\n+  Node* inOfs   = argument(1);\n+  Node* len     = argument(2);\n+  Node* ct      = argument(3);\n+  Node* ctOfs   = argument(4);\n+  Node* out     = argument(5);\n+  Node* outOfs  = argument(6);\n+  Node* gctr_object = argument(7);\n+  Node* ghash_object = argument(8);\n+\n+  \/\/ (1) in, ct and out are arrays.\n+  const Type* in_type = in->Value(&_gvn);\n+  const Type* ct_type = ct->Value(&_gvn);\n+  const Type* out_type = out->Value(&_gvn);\n+  const TypeAryPtr* top_in = in_type->isa_aryptr();\n+  const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n+  const TypeAryPtr* top_out = out_type->isa_aryptr();\n+  assert(top_in != NULL && top_in->klass() != NULL &&\n+         top_ct != NULL && top_ct->klass() != NULL &&\n+         top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+\n+  \/\/ checks are the responsibility of the caller\n+  Node* in_start = in;\n+  Node* ct_start = ct;\n+  Node* out_start = out;\n+  if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n+    assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n+    in_start = array_element_address(in, inOfs, T_BYTE);\n+    ct_start = array_element_address(ct, ctOfs, T_BYTE);\n+    out_start = array_element_address(out, outOfs, T_BYTE);\n+  }\n+\n+  \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n+  \/\/ (because of the predicated logic executed earlier).\n+  \/\/ so we cast it here safely.\n+  \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n+  Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n+  Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n+  Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n+\n+  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+      return false;\n+  }\n+  \/\/ cast it to what we know it will be at runtime\n+  const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n+  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n+  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n+  aescrypt_object = _gvn.transform(aescrypt_object);\n+  \/\/ we need to get the start of the aescrypt_object's expanded key array\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  if (k_start == NULL) return false;\n+\n+  \/\/ similarly, get the start address of the r vector\n+  Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n+  Node* state_start = array_element_address(state, intcon(0), T_LONG);\n+  Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n+\n+  \/\/ Call the stub, passing params\n+  Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                               OptoRuntime::galoisCounterMode_aescrypt_Type(),\n+                               stubAddr, stubName, TypePtr::BOTTOM,\n+                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n+\n+  \/\/ return cipher length (int)\n+  Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/----------------------------inline_galoisCounterMode_AESCrypt_predicate----------------------------\n+\/\/ Return node representing slow path of predicate check.\n+\/\/ the pseudo code we want to emulate with this predicate is:\n+\/\/ for encryption:\n+\/\/    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath\n+\/\/ for decryption:\n+\/\/    if ((embeddedCipherObj instanceof AESCrypt) && (cipher!=plain)) do_intrinsic, else do_javapath\n+\/\/    note cipher==plain is more conservative than the original java code but that's OK\n+\/\/\n+\n+Node* LibraryCallKit::inline_galoisCounterMode_AESCrypt_predicate() {\n+  \/\/ The receiver was checked for NULL already.\n+  Node* objGCTR = argument(7);\n+  \/\/ Load embeddedCipher field of GCTR object.\n+  Node* embeddedCipherObj = load_field_from_object(objGCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  assert(embeddedCipherObj != NULL, \"embeddedCipherObj is null\");\n+\n+  \/\/ get AESCrypt klass for instanceOf check\n+  \/\/ AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point\n+  \/\/ will have same classloader as CipherBlockChaining object\n+  const TypeInstPtr* tinst = _gvn.type(objGCTR)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+\n+  \/\/ we want to do an instanceof comparison against the AESCrypt class\n+  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  if (!klass_AESCrypt->is_loaded()) {\n+    \/\/ if AESCrypt is not even loaded, we never take the intrinsic fast path\n+    Node* ctrl = control();\n+    set_control(top()); \/\/ no regular fast path\n+    return ctrl;\n+  }\n+\n+  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+  Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));\n+  Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));\n+  Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));\n+  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+\n+  return instof_false; \/\/ even if it is NULL\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":191,"deletions":27,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -308,0 +308,2 @@\n+  bool inline_galoisCounterMode_AESCrypt();\n+  Node* inline_galoisCounterMode_AESCrypt_predicate();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-                                                 mem->in(0)->Opcode() == Op_MemBarCPUOrder)) {\n+                                               mem->in(0)->Opcode() == Op_MemBarCPUOrder)) {\n@@ -1064,1 +1064,0 @@\n-    bool final = !atp->is_rewritable();\n@@ -1072,1 +1071,4 @@\n-    \/\/ a synchronized region.\n+    \/\/ a synchronized region. It is not safe to step over MemBarCPUOrder,\n+    \/\/ because alias info above them may be inaccurate (e.g., due to\n+    \/\/ mixed\/mismatched unsafe accesses).\n+    bool is_final_mem = !atp->is_rewritable();\n@@ -1075,3 +1077,3 @@\n-      if ((final && (opc == Op_MemBarAcquire ||\n-                     opc == Op_MemBarAcquireLock ||\n-                     opc == Op_LoadFence)) ||\n+      if ((is_final_mem && (opc == Op_MemBarAcquire ||\n+                            opc == Op_MemBarAcquireLock ||\n+                            opc == Op_LoadFence)) ||\n@@ -1081,2 +1083,1 @@\n-          opc == Op_MemBarStoreStore ||\n-          opc == Op_MemBarCPUOrder) {\n+          opc == Op_MemBarStoreStore) {\n@@ -1628,1 +1629,8 @@\n-        x->set_req(0, in);\n+        if (mem->is_Phi() && (mem->in(0) == region) && mem->in(i)->in(0) != NULL &&\n+            MemNode::all_controls_dominate(address, region)) {\n+          \/\/ Enable other optimizations such as loop predication which does not work\n+          \/\/ if we directly pin the node to node `in`\n+          x->set_req(0, mem->in(i)->in(0)); \/\/ Use same control as memory\n+        } else {\n+          x->set_req(0, in);\n+        }\n@@ -1974,1 +1982,1 @@\n-  } else if (tp->base() == Type::KlassPtr) {\n+  } else if (tp->base() == Type::KlassPtr || tp->base() == Type::InstKlassPtr || tp->base() == Type::AryKlassPtr) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -97,0 +97,2 @@\n+  { Bad,             T_METADATA,   \"instklass:\",    false, Op_RegP,              relocInfo::metadata_type },  \/\/ InstKlassPtr\n+  { Bad,             T_METADATA,   \"aryklass:\",     false, Op_RegP,              relocInfo::metadata_type },  \/\/ AryKlassPtr\n@@ -602,2 +604,2 @@\n-  TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current->env()->Object_klass(), 0 );\n-  TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current->env()->Object_klass(), 0 );\n+  TypeInstKlassPtr::OBJECT = TypeInstKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), 0);\n+  TypeInstKlassPtr::OBJECT_OR_NULL = TypeInstKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), 0);\n@@ -936,0 +938,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1106,0 +1110,2 @@\n+    case Type::InstKlassPtr:\n+    case Type::AryKlassPtr:\n@@ -1192,0 +1198,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1303,0 +1311,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1474,0 +1484,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1735,0 +1747,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -2587,0 +2601,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -2974,1 +2990,1 @@\n-const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeRawPtr* TypeRawPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -3018,0 +3034,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3184,1 +3202,1 @@\n-const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeOopPtr* TypeOopPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -3208,7 +3226,3 @@\n-const TypeKlassPtr* TypeOopPtr::as_klass_type() const {\n-  ciKlass* k = klass();\n-  bool    xk = klass_is_exact();\n-  if (k == NULL)\n-    return TypeKlassPtr::OBJECT;\n-  else\n-    return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);\n+const TypeKlassPtr* TypeOopPtr::as_klass_type(bool try_for_exact) const {\n+  ShouldNotReachHere();\n+  return NULL;\n@@ -3247,0 +3261,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3675,1 +3691,1 @@\n-const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeInstPtr *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -3777,0 +3793,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3852,2 +3870,2 @@\n-    int off = meet_offset( tinst->offset() );\n-    PTR ptr = meet_ptr( tinst->ptr() );\n+    int off = meet_offset(tinst->offset());\n+    PTR ptr = meet_ptr(tinst->ptr());\n@@ -3857,11 +3875,1 @@\n-\n-    \/\/ Check for easy case; klasses are equal (and perhaps not loaded!)\n-    \/\/ If we have constants, then we created oops so classes are loaded\n-    \/\/ and we can handle the constants further down.  This case handles\n-    \/\/ both-not-loaded or both-loaded classes\n-    if (ptr != Constant && klass()->equals(tinst->klass()) && klass_is_exact() == tinst->klass_is_exact()) {\n-      return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);\n-    }\n-\n-    \/\/ Classes require inspection in the Java klass hierarchy.  Must be loaded.\n-    ciKlass* this_klass  = this->klass();\n+    ciKlass* this_klass  = klass();\n@@ -3870,2 +3878,7 @@\n-    bool this_xk  = this->klass_is_exact();\n-    if (!tinst_klass->is_loaded() || !this_klass->is_loaded() ) {\n+    bool this_xk  = klass_is_exact();\n+\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    const Type* res;\n+    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    if (kind == UNLOADED) {\n@@ -3873,1 +3886,1 @@\n-      const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n@@ -3875,4 +3888,10 @@\n-      if( PrintOpto && Verbose ) {\n-        tty->print(\"meet of unloaded classes resulted in: \"); unloaded_meet->dump(); tty->cr();\n-        tty->print(\"  this == \"); this->dump(); tty->cr();\n-        tty->print(\" tinst == \"); tinst->dump(); tty->cr();\n+      if (PrintOpto && Verbose) {\n+        tty->print(\"meet of unloaded classes resulted in: \");\n+        unloaded_meet->dump();\n+        tty->cr();\n+        tty->print(\"  this == \");\n+        dump();\n+        tty->cr();\n+        tty->print(\" tinst == \");\n+        tinst->dump();\n+        tty->cr();\n@@ -3881,105 +3900,6 @@\n-      return unloaded_meet;\n-    }\n-\n-    \/\/ Handle mixing oops and interfaces first.\n-    if( this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                        tinst_klass == ciEnv::current()->Object_klass())) {\n-      ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-      tinst_klass = this_klass;\n-      this_klass = tmp;\n-      bool tmp2 = tinst_xk;\n-      tinst_xk = this_xk;\n-      this_xk = tmp2;\n-    }\n-    if (tinst_klass->is_interface() &&\n-        !(this_klass->is_interface() ||\n-          \/\/ Treat java\/lang\/Object as an honorary interface,\n-          \/\/ because we need a bottom for the interface hierarchy.\n-          this_klass == ciEnv::current()->Object_klass())) {\n-      \/\/ Oop meets interface!\n-\n-      \/\/ See if the oop subtypes (implements) interface.\n-      ciKlass *k;\n-      bool xk;\n-      if( this_klass->is_subtype_of( tinst_klass ) ) {\n-        \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-        \/\/ on whether we are both above the centerline or either is\n-        \/\/ below the centerline.  If we are on the centerline\n-        \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-        k  = below_centerline(ptr) ? tinst_klass : this_klass;\n-        \/\/ If we are keeping this_klass, keep its exactness too.\n-        xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      } else {                  \/\/ Does not implement, fall to Object\n-        \/\/ Oop does not implement interface, so mixing falls to Object\n-        \/\/ just like the verifier does (if both are above the\n-        \/\/ centerline fall to interface)\n-        k = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-        xk = above_centerline(ptr) ? tinst_xk : false;\n-        \/\/ Watch out for Constant vs. AnyNull interface.\n-        if (ptr == Constant) {\n-          ptr = NotNull;  \/\/ forget it was a constant\n-        }\n-        if (instance_id > 0) {\n-          instance_id = InstanceBot;\n-        }\n-      }\n-      ciObject* o = NULL;  \/\/ the Constant value, if any\n-      if (ptr == Constant) {\n-        \/\/ Find out which constant.\n-        o = (this_klass == klass()) ? const_oop() : tinst->const_oop();\n-      }\n-      return make(ptr, k, xk, o, off, instance_id, speculative, depth);\n-    }\n-\n-    \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n-    \/\/ !!! Here's how the symmetry requirement breaks down into invariants:\n-    \/\/ If we split one up & one down AND they subtype, take the down man.\n-    \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n-    \/\/ If both are up and they subtype, take the subtype class.\n-    \/\/ If both are up and they do NOT subtype, \"fall hard\".\n-    \/\/ If both are down and they subtype, take the supertype class.\n-    \/\/ If both are down and they do NOT subtype, \"fall hard\".\n-    \/\/ Constants treated as down.\n-\n-    \/\/ Now, reorder the above list; observe that both-down+subtype is also\n-    \/\/ \"fall hard\"; \"fall hard\" becomes the default case:\n-    \/\/ If we split one up & one down AND they subtype, take the down man.\n-    \/\/ If both are up and they subtype, take the subtype class.\n-\n-    \/\/ If both are down and they subtype, \"fall hard\".\n-    \/\/ If both are down and they do NOT subtype, \"fall hard\".\n-    \/\/ If both are up and they do NOT subtype, \"fall hard\".\n-    \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n-\n-    \/\/ If a proper subtype is exact, and we return it, we return it exactly.\n-    \/\/ If a proper supertype is exact, there can be no subtyping relationship!\n-    \/\/ If both types are equal to the subtype, exactness is and-ed below the\n-    \/\/ centerline and or-ed above it.  (N.B. Constants are always exact.)\n-\n-    \/\/ Check for subtyping:\n-    ciKlass *subtype = NULL;\n-    bool subtype_exact = false;\n-    if( tinst_klass->equals(this_klass) ) {\n-      subtype = this_klass;\n-      subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-    } else if( !tinst_xk && this_klass->is_subtype_of( tinst_klass ) ) {\n-      subtype = this_klass;     \/\/ Pick subtyping class\n-      subtype_exact = this_xk;\n-    } else if( !this_xk && tinst_klass->is_subtype_of( this_klass ) ) {\n-      subtype = tinst_klass;    \/\/ Pick subtyping class\n-      subtype_exact = tinst_xk;\n-    }\n-\n-    if( subtype ) {\n-      if( above_centerline(ptr) ) { \/\/ both are up?\n-        this_klass = tinst_klass = subtype;\n-        this_xk = tinst_xk = subtype_exact;\n-      } else if( above_centerline(this ->_ptr) && !above_centerline(tinst->_ptr) ) {\n-        this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-        this_xk = tinst_xk;\n-      } else if( above_centerline(tinst->_ptr) && !above_centerline(this ->_ptr) ) {\n-        tinst_klass = this_klass; \/\/ this is down; keep down man\n-        tinst_xk = this_xk;\n-      } else {\n-        this_xk = subtype_exact;  \/\/ either they are equal, or we'll do an LCA\n+      res = unloaded_meet;\n+    } else {\n+      if (kind == NOT_SUBTYPE && instance_id > 0) {\n+        instance_id = InstanceBot;\n+      } else if (kind == LCA) {\n+        instance_id = InstanceBot;\n@@ -3987,8 +3907,1 @@\n-    }\n-\n-    \/\/ Check for classes now being equal\n-    if (tinst_klass->equals(this_klass)) {\n-      \/\/ If the klasses are equal, the constants may still differ.  Fall to\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n-      \/\/ handled elsewhere).\n-      ciObject* this_oop  = const_oop();\n+      ciObject* this_oop = const_oop();\n@@ -3997,1 +3910,1 @@\n-      if( ptr == Constant ) {\n+      if (ptr == Constant) {\n@@ -3999,1 +3912,1 @@\n-            this_oop->equals(tinst_oop) )\n+            this_oop->equals(tinst_oop))\n@@ -4001,1 +3914,2 @@\n-        else if (above_centerline(this ->_ptr))\n+        else if (above_centerline(_ptr)) {\n+          assert(!tinst_klass->is_interface(), \"\");\n@@ -4003,1 +3917,2 @@\n-        else if (above_centerline(tinst ->_ptr))\n+        } else if (above_centerline(tinst->_ptr)) {\n+          assert(!this_klass->is_interface(), \"\");\n@@ -4005,1 +3920,1 @@\n-        else\n+        } else\n@@ -4008,7 +3923,1 @@\n-      return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);\n-    } \/\/ Else classes are not equal\n-\n-    \/\/ Since klasses are different, we require a LCA in the Java\n-    \/\/ class hierarchy - which means we have to fall to at least NotNull.\n-    if (ptr == TopPTR || ptr == AnyNull || ptr == Constant) {\n-      ptr = NotNull;\n+      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n@@ -4016,4 +3925,2 @@\n-    instance_id = InstanceBot;\n-    \/\/ Now we find the LCA of Java classes\n-    ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n-    return make(ptr, k, false, NULL, off, instance_id, speculative, depth);\n+    return res;\n+\n@@ -4027,0 +3934,138 @@\n+TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n+                                          PTR this_ptr,\n+                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n+\n+  \/\/ Check for easy case; klasses are equal (and perhaps not loaded!)\n+  \/\/ If we have constants, then we created oops so classes are loaded\n+  \/\/ and we can handle the constants further down.  This case handles\n+  \/\/ both-not-loaded or both-loaded classes\n+  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+    res_klass = this_klass;\n+    res_xk = this_xk;\n+    return QUICK;\n+  }\n+\n+  \/\/ Classes require inspection in the Java klass hierarchy.  Must be loaded.\n+  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+    return UNLOADED;\n+  }\n+\n+  \/\/ Handle mixing oops and interfaces first.\n+  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n+                                      tinst_klass == ciEnv::current()->Object_klass())) {\n+    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n+    tinst_klass = this_klass;\n+    this_klass = tmp;\n+    bool tmp2 = tinst_xk;\n+    tinst_xk = this_xk;\n+    this_xk = tmp2;\n+  }\n+  if (tinst_klass->is_interface() &&\n+      !(this_klass->is_interface() ||\n+        \/\/ Treat java\/lang\/Object as an honorary interface,\n+        \/\/ because we need a bottom for the interface hierarchy.\n+        this_klass == ciEnv::current()->Object_klass())) {\n+    \/\/ Oop meets interface!\n+\n+    \/\/ See if the oop subtypes (implements) interface.\n+    if (this_klass->is_subtype_of(tinst_klass)) {\n+      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n+      \/\/ on whether we are both above the centerline or either is\n+      \/\/ below the centerline.  If we are on the centerline\n+      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n+      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n+      \/\/ If we are keeping this_klass, keep its exactness too.\n+      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n+      return SUBTYPE;\n+    } else {                  \/\/ Does not implement, fall to Object\n+      \/\/ Oop does not implement interface, so mixing falls to Object\n+      \/\/ just like the verifier does (if both are above the\n+      \/\/ centerline fall to interface)\n+      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n+      res_xk = above_centerline(ptr) ? tinst_xk : false;\n+      \/\/ Watch out for Constant vs. AnyNull interface.\n+      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n+      return NOT_SUBTYPE;\n+    }\n+  }\n+\n+  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n+\n+  \/\/ !!! Here's how the symmetry requirement breaks down into invariants:\n+  \/\/ If we split one up & one down AND they subtype, take the down man.\n+  \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n+  \/\/ If both are up and they subtype, take the subtype class.\n+  \/\/ If both are up and they do NOT subtype, \"fall hard\".\n+  \/\/ If both are down and they subtype, take the supertype class.\n+  \/\/ If both are down and they do NOT subtype, \"fall hard\".\n+  \/\/ Constants treated as down.\n+\n+  \/\/ Now, reorder the above list; observe that both-down+subtype is also\n+  \/\/ \"fall hard\"; \"fall hard\" becomes the default case:\n+  \/\/ If we split one up & one down AND they subtype, take the down man.\n+  \/\/ If both are up and they subtype, take the subtype class.\n+\n+  \/\/ If both are down and they subtype, \"fall hard\".\n+  \/\/ If both are down and they do NOT subtype, \"fall hard\".\n+  \/\/ If both are up and they do NOT subtype, \"fall hard\".\n+  \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n+\n+  \/\/ If a proper subtype is exact, and we return it, we return it exactly.\n+  \/\/ If a proper supertype is exact, there can be no subtyping relationship!\n+  \/\/ If both types are equal to the subtype, exactness is and-ed below the\n+  \/\/ centerline and or-ed above it.  (N.B. Constants are always exact.)\n+\n+  \/\/ Check for subtyping:\n+  ciKlass *subtype = NULL;\n+  bool subtype_exact = false;\n+  if (tinst_klass->equals(this_klass)) {\n+    subtype = this_klass;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n+  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n+    subtype = this_klass;     \/\/ Pick subtyping class\n+    subtype_exact = this_xk;\n+  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n+    subtype = tinst_klass;    \/\/ Pick subtyping class\n+    subtype_exact = tinst_xk;\n+  }\n+\n+  if (subtype) {\n+    if (above_centerline(ptr)) { \/\/ both are up?\n+      this_klass = tinst_klass = subtype;\n+      this_xk = tinst_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n+      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n+      this_xk = tinst_xk;\n+    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n+      tinst_klass = this_klass; \/\/ this is down; keep down man\n+      tinst_xk = this_xk;\n+    } else {\n+      this_xk = subtype_exact;  \/\/ either they are equal, or we'll do an LCA\n+    }\n+  }\n+\n+  \/\/ Check for classes now being equal\n+  if (tinst_klass->equals(this_klass)) {\n+    \/\/ If the klasses are equal, the constants may still differ.  Fall to\n+    \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+    \/\/ handled elsewhere).\n+    res_klass = this_klass;\n+    res_xk = this_xk;\n+    return SUBTYPE;\n+  } \/\/ Else classes are not equal\n+\n+  \/\/ Since klasses are different, we require a LCA in the Java\n+  \/\/ class hierarchy - which means we have to fall to at least NotNull.\n+  if (ptr == TopPTR || ptr == AnyNull || ptr == Constant) {\n+    ptr = NotNull;\n+  }\n+\n+  \/\/ Now we find the LCA of Java classes\n+  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+\n+  res_klass = k;\n+  res_xk = false;\n+\n+  return LCA;\n+}\n+\n@@ -4143,0 +4188,12 @@\n+const TypeKlassPtr* TypeInstPtr::as_klass_type(bool try_for_exact) const {\n+  bool xk = klass_is_exact();\n+  ciInstanceKlass* ik = klass()->as_instance_klass();\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n+    Compile* C = Compile::current();\n+    Dependencies* deps = C->dependencies();\n+    deps->assert_leaf_type(ik);\n+    xk = true;\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+}\n+\n@@ -4179,1 +4236,1 @@\n-const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeAryPtr* TypeAryPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -4386,0 +4443,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -4396,61 +4455,5 @@\n-    ciKlass* lazy_klass = NULL;\n-    if (tary->_elem->isa_int()) {\n-      \/\/ Integral array element types have irrelevant lattice relations.\n-      \/\/ It is the klass that determines array layout, not the element type.\n-      if (_klass == NULL)\n-        lazy_klass = tap->_klass;\n-      else if (tap->_klass == NULL || tap->_klass == _klass) {\n-        lazy_klass = _klass;\n-      } else {\n-        \/\/ Something like byte[int+] meets char[int+].\n-        \/\/ This must fall to bottom, not (int[-128..65535])[int+].\n-        instance_id = InstanceBot;\n-        tary = TypeAry::make(Type::BOTTOM, tary->_size, tary->_stable);\n-      }\n-    } else \/\/ Non integral arrays.\n-      \/\/ Must fall to bottom if exact klasses in upper lattice\n-      \/\/ are not equal or super klass is exact.\n-      if ((above_centerline(ptr) || ptr == Constant) && klass() != tap->klass() &&\n-          \/\/ meet with top[] and bottom[] are processed further down:\n-          tap->_klass != NULL  && this->_klass != NULL   &&\n-          \/\/ both are exact and not equal:\n-          ((tap->_klass_is_exact && this->_klass_is_exact) ||\n-           \/\/ 'tap'  is exact and super or unrelated:\n-           (tap->_klass_is_exact && !tap->klass()->is_subtype_of(klass())) ||\n-           \/\/ 'this' is exact and super or unrelated:\n-           (this->_klass_is_exact && !klass()->is_subtype_of(tap->klass())))) {\n-      if (above_centerline(ptr) || (tary->_elem->make_ptr() && above_centerline(tary->_elem->make_ptr()->_ptr))) {\n-        tary = TypeAry::make(Type::BOTTOM, tary->_size, tary->_stable);\n-      }\n-      return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);\n-    }\n-    bool xk = false;\n-    switch (tap->ptr()) {\n-    case AnyNull:\n-    case TopPTR:\n-      \/\/ Compute new klass on demand, do not use tap->_klass\n-      if (below_centerline(this->_ptr)) {\n-        xk = this->_klass_is_exact;\n-      } else {\n-        xk = (tap->_klass_is_exact || this->_klass_is_exact);\n-      }\n-      return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);\n-    case Constant: {\n-      ciObject* o = const_oop();\n-      if( _ptr == Constant ) {\n-        if( tap->const_oop() != NULL && !o->equals(tap->const_oop()) ) {\n-          xk = (klass() == tap->klass());\n-          ptr = NotNull;\n-          o = NULL;\n-          instance_id = InstanceBot;\n-        } else {\n-          xk = true;\n-        }\n-      } else if(above_centerline(_ptr)) {\n-        o = tap->const_oop();\n-        xk = true;\n-      } else {\n-        \/\/ Only precise for identical arrays\n-        xk = this->_klass_is_exact && (klass() == tap->klass());\n-      }\n-      return make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    const Type* elem = tary->_elem;\n+    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+      instance_id = InstanceBot;\n@@ -4459,5 +4462,12 @@\n-    case NotNull:\n-    case BotPTR:\n-      \/\/ Compute new klass on demand, do not use tap->_klass\n-      if (above_centerline(this->_ptr)) {\n-        xk = tap->_klass_is_exact;\n+\n+    ciObject* o = NULL;             \/\/ Assume not constant when done\n+    ciObject* this_oop = const_oop();\n+    ciObject* tap_oop = tap->const_oop();\n+    if (ptr == Constant) {\n+      if (this_oop != NULL && tap_oop != NULL &&\n+          this_oop->equals(tap_oop)) {\n+        o = tap_oop;\n+      } else if (above_centerline(_ptr)) {\n+        o = tap_oop;\n+      } else if (above_centerline(tap->_ptr)) {\n+        o = this_oop;\n@@ -4465,2 +4475,1 @@\n-        xk = (tap->_klass_is_exact & this->_klass_is_exact) &&\n-             (klass() == tap->klass()); \/\/ Only precise for identical arrays\n+        ptr = NotNull;\n@@ -4468,2 +4477,1 @@\n-      return make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n-    default: ShouldNotReachHere();\n+    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable), res_klass, res_xk, off, instance_id, speculative, depth);\n@@ -4527,0 +4535,79 @@\n+\n+TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+  res_klass = NULL;\n+  MeetResult result = SUBTYPE;\n+  if (elem->isa_int()) {\n+    \/\/ Integral array element types have irrelevant lattice relations.\n+    \/\/ It is the klass that determines array layout, not the element type.\n+    if (this_klass == NULL)\n+      res_klass = tap_klass;\n+    else if (tap_klass == NULL || tap_klass == this_klass) {\n+      res_klass = this_klass;\n+    } else {\n+      \/\/ Something like byte[int+] meets char[int+].\n+      \/\/ This must fall to bottom, not (int[-128..65535])[int+].\n+      \/\/ instance_id = InstanceBot;\n+      elem = Type::BOTTOM;\n+      result = NOT_SUBTYPE;\n+    }\n+  } else \/\/ Non integral arrays.\n+    \/\/ Must fall to bottom if exact klasses in upper lattice\n+    \/\/ are not equal or super klass is exact.\n+    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+        \/\/ meet with top[] and bottom[] are processed further down:\n+        tap_klass != NULL  && this_klass != NULL   &&\n+        \/\/ both are exact and not equal:\n+        ((tap_xk && this_xk) ||\n+         \/\/ 'tap'  is exact and super or unrelated:\n+         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         \/\/ 'this' is exact and super or unrelated:\n+         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n+      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr))) {\n+        elem = Type::BOTTOM;\n+      }\n+      ptr = NotNull;\n+      res_xk = false;\n+      return NOT_SUBTYPE;\n+    }\n+\n+  res_xk = false;\n+  switch (tap_ptr) {\n+    case AnyNull:\n+    case TopPTR:\n+      \/\/ Compute new klass on demand, do not use tap->_klass\n+      if (below_centerline(this_ptr)) {\n+        res_xk = this_xk;\n+      } else {\n+        res_xk = (tap_xk || this_xk);\n+      }\n+      return result;\n+    case Constant: {\n+      if (this_ptr == Constant) {\n+          res_xk = true;\n+      } else if(above_centerline(this_ptr)) {\n+        res_xk = true;\n+      } else {\n+        \/\/ Only precise for identical arrays\n+        res_xk = this_xk && (this_klass == tap_klass);\n+      }\n+      return result;\n+    }\n+    case NotNull:\n+    case BotPTR:\n+      \/\/ Compute new klass on demand, do not use tap->_klass\n+      if (above_centerline(this_ptr)) {\n+        res_xk = tap_xk;\n+      } else {\n+        res_xk = (tap_xk && this_xk) &&\n+          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+      }\n+      return result;\n+    default:  {\n+      ShouldNotReachHere();\n+      return result;\n+    }\n+  }\n+  return result;\n+}\n+\n+\n@@ -4708,0 +4795,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -4832,1 +4921,1 @@\n-const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeMetadataPtr* TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -4886,0 +4975,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -4959,2 +5050,11 @@\n-\/\/=============================================================================\n-\/\/ Convenience common pre-built types.\n+const TypeKlassPtr* TypeAryPtr::as_klass_type(bool try_for_exact) const {\n+  const Type* elem = _ary->_elem;\n+  bool xk = klass_is_exact();\n+  if (elem->make_oopptr() != NULL) {\n+    elem = elem->make_oopptr()->as_klass_type(try_for_exact);\n+    if (elem->is_klassptr()->klass_is_exact()) {\n+      xk = true;\n+    }\n+  }\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), 0);\n+}\n@@ -4962,3 +5062,6 @@\n-\/\/ Not-null object klass or below\n-const TypeKlassPtr *TypeKlassPtr::OBJECT;\n-const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+  if (klass->is_instance_klass()) {\n+    return TypeInstKlassPtr::make(klass);\n+  }\n+  return TypeAryKlassPtr::make(klass);\n+}\n@@ -4966,3 +5069,5 @@\n-\/\/------------------------------TypeKlassPtr-----------------------------------\n-TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )\n-  : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+  if (klass->is_instance_klass()) {\n+    return TypeInstKlassPtr::make(ptr, klass, offset);\n+  }\n+  return TypeAryKlassPtr::make(ptr, klass, offset);\n@@ -4971,8 +5076,3 @@\n-\/\/------------------------------make-------------------------------------------\n-\/\/ ptr to klass 'k', if Constant, or possibly to a sub-klass if not a Constant\n-const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {\n-  assert( k != NULL, \"Expect a non-NULL klass\");\n-  assert(k->is_instance_klass() || k->is_array_klass(), \"Incorrect type of klass oop\");\n-  TypeKlassPtr *r =\n-    (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))->hashcons();\n-  return r;\n+\/\/------------------------------TypeKlassPtr-----------------------------------\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass) {\n@@ -4984,1 +5084,1 @@\n-bool TypeKlassPtr::eq( const Type *t ) const {\n+bool TypeKlassPtr::eq(const Type *t) const {\n@@ -4987,1 +5087,0 @@\n-    klass()->equals(p->klass()) &&\n@@ -4994,1 +5093,1 @@\n-  return java_add((jint)klass()->hash(), (jint)TypePtr::hash());\n+  return TypePtr::hash();\n@@ -5011,2 +5110,2 @@\n-  const TypeKlassPtr* ftkp = ft->isa_klassptr();\n-  const TypeKlassPtr* ktkp = kills->isa_klassptr();\n+  const TypeKlassPtr* ftkp = ft->isa_instklassptr();\n+  const TypeKlassPtr* ktkp = kills->isa_instklassptr();\n@@ -5033,0 +5132,312 @@\n+\/\/------------------------------get_con----------------------------------------\n+intptr_t TypeKlassPtr::get_con() const {\n+  assert( _ptr == Null || _ptr == Constant, \"\" );\n+  assert( _offset >= 0, \"\" );\n+\n+  if (_offset != 0) {\n+    \/\/ After being ported to the compiler interface, the compiler no longer\n+    \/\/ directly manipulates the addresses of oops.  Rather, it only has a pointer\n+    \/\/ to a handle at compile time.  This handle is embedded in the generated\n+    \/\/ code and dereferenced at the time the nmethod is made.  Until that time,\n+    \/\/ it is not reasonable to do arithmetic with the addresses of oops (we don't\n+    \/\/ have access to the addresses!).  This does not seem to currently happen,\n+    \/\/ but this assertion here is to help prevent its occurence.\n+    tty->print_cr(\"Found oop constant with non-zero offset\");\n+    ShouldNotReachHere();\n+  }\n+\n+  return (intptr_t)klass()->constant_encoding();\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+\/\/ Dump Klass Type\n+#ifndef PRODUCT\n+void TypeKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n+  switch(_ptr) {\n+  case Constant:\n+    st->print(\"precise \");\n+  case NotNull:\n+    {\n+      const char *name = klass()->name()->as_utf8();\n+      if (name) {\n+        st->print(\"%s: \" INTPTR_FORMAT, name, p2i(klass()));\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  case BotPTR:\n+    if (!WizardMode && !Verbose && _ptr != Constant) break;\n+  case TopPTR:\n+  case AnyNull:\n+    st->print(\":%s\", ptr_msg[_ptr]);\n+    if (_ptr == Constant) st->print(\":exact\");\n+    break;\n+  default:\n+    break;\n+  }\n+\n+  if (_offset) {               \/\/ Dump offset, if any\n+    if (_offset == OffsetBot)      { st->print(\"+any\"); }\n+    else if (_offset == OffsetTop) { st->print(\"+unknown\"); }\n+    else                            { st->print(\"+%d\", _offset); }\n+  }\n+\n+  st->print(\" *\");\n+}\n+#endif\n+\n+\/\/=============================================================================\n+\/\/ Convenience common pre-built types.\n+\n+\/\/ Not-null object klass or below\n+const TypeInstKlassPtr *TypeInstKlassPtr::OBJECT;\n+const TypeInstKlassPtr *TypeInstKlassPtr::OBJECT_OR_NULL;\n+\n+bool TypeInstKlassPtr::eq(const Type *t) const {\n+  const TypeKlassPtr *p = t->is_klassptr();\n+  return\n+    klass()->equals(p->klass()) &&\n+    TypeKlassPtr::eq(p);\n+}\n+\n+int TypeInstKlassPtr::hash(void) const {\n+  return java_add((jint)klass()->hash(), TypeKlassPtr::hash());\n+}\n+\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+  TypeInstKlassPtr *r =\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+\n+  return r;\n+}\n+\n+\/\/------------------------------add_offset-------------------------------------\n+\/\/ Access internals of klass object\n+const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), xadd_offset(offset) );\n+}\n+\n+const TypeKlassPtr *TypeInstKlassPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, klass(), offset);\n+}\n+\n+\/\/------------------------------cast_to_ptr_type-------------------------------\n+const TypePtr* TypeInstKlassPtr::cast_to_ptr_type(PTR ptr) const {\n+  assert(_base == InstKlassPtr, \"subclass must override cast_to_ptr_type\");\n+  if( ptr == _ptr ) return this;\n+  return make(ptr, _klass, _offset);\n+}\n+\n+\n+bool TypeInstKlassPtr::must_be_exact() const {\n+  if (!_klass->is_loaded())  return false;\n+  ciInstanceKlass* ik = _klass->as_instance_klass();\n+  if (ik->is_final())  return true;  \/\/ cannot clear xk\n+  return false;\n+}\n+\n+\/\/-----------------------------cast_to_exactness-------------------------------\n+const TypeKlassPtr* TypeInstKlassPtr::cast_to_exactness(bool klass_is_exact) const {\n+  if (klass_is_exact == (_ptr == Constant)) return this;\n+  if (must_be_exact()) return this;\n+  ciKlass* k = klass();\n+  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+}\n+\n+\n+\/\/-----------------------------as_instance_type--------------------------------\n+\/\/ Corresponding type for an instance of the given class.\n+\/\/ It will be NotNull, and exact if and only if the klass type is exact.\n+const TypeOopPtr* TypeInstKlassPtr::as_instance_type() const {\n+  ciKlass* k = klass();\n+  bool    xk = klass_is_exact();\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+}\n+\n+\/\/------------------------------xmeet------------------------------------------\n+\/\/ Compute the MEET of two types, return a new Type object.\n+const Type    *TypeInstKlassPtr::xmeet( const Type *t ) const {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+\n+  \/\/ Current \"this->_base\" is Pointer\n+  switch (t->base()) {          \/\/ switch on original type\n+\n+  case Int:                     \/\/ Mixing ints & oops happens when javac\n+  case Long:                    \/\/ reuses local variables\n+  case FloatTop:\n+  case FloatCon:\n+  case FloatBot:\n+  case DoubleTop:\n+  case DoubleCon:\n+  case DoubleBot:\n+  case NarrowOop:\n+  case NarrowKlass:\n+  case Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  case Top:\n+    return this;\n+\n+  default:                      \/\/ All else is a mistake\n+    typerr(t);\n+\n+  case AnyPtr: {                \/\/ Meeting to AnyPtrs\n+    \/\/ Found an AnyPtr type vs self-KlassPtr type\n+    const TypePtr *tp = t->is_ptr();\n+    int offset = meet_offset(tp->offset());\n+    PTR ptr = meet_ptr(tp->ptr());\n+    switch (tp->ptr()) {\n+    case TopPTR:\n+      return this;\n+    case Null:\n+      if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+    case AnyNull:\n+      return make( ptr, klass(), offset );\n+    case BotPTR:\n+    case NotNull:\n+      return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+    default: typerr(t);\n+    }\n+  }\n+\n+  case RawPtr:\n+  case MetadataPtr:\n+  case OopPtr:\n+  case AryPtr:                  \/\/ Meet with AryPtr\n+  case InstPtr:                 \/\/ Meet with InstPtr\n+    return TypePtr::BOTTOM;\n+\n+  \/\/\n+  \/\/             A-top         }\n+  \/\/           \/   |   \\       }  Tops\n+  \/\/       B-top A-any C-top   }\n+  \/\/          | \/  |  \\ |      }  Any-nulls\n+  \/\/       B-any   |   C-any   }\n+  \/\/          |    |    |\n+  \/\/       B-con A-con C-con   } constants; not comparable across classes\n+  \/\/          |    |    |\n+  \/\/       B-not   |   C-not   }\n+  \/\/          | \\  |  \/ |      }  not-nulls\n+  \/\/       B-bot A-not C-bot   }\n+  \/\/           \\   |   \/       }  Bottoms\n+  \/\/             A-bot         }\n+  \/\/\n+\n+  case InstKlassPtr: {  \/\/ Meet two KlassPtr types\n+    const TypeInstKlassPtr *tkls = t->is_instklassptr();\n+    int  off     = meet_offset(tkls->offset());\n+    PTR  ptr     = meet_ptr(tkls->ptr());\n+    ciKlass* tkls_klass = tkls->klass();\n+    ciKlass* this_klass  = klass();\n+    bool tkls_xk = tkls->klass_is_exact();\n+    bool this_xk  = klass_is_exact();\n+\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+      case UNLOADED:\n+        ShouldNotReachHere();\n+      case SUBTYPE:\n+      case NOT_SUBTYPE:\n+      case LCA:\n+      case QUICK: {\n+        assert(res_xk == (ptr == Constant), \"\");\n+        const Type* res1 = make(ptr, res_klass, off);\n+        return res1;\n+      }\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  } \/\/ End of case KlassPtr\n+  case AryKlassPtr: {                \/\/ All arrays inherit from Object class\n+    const TypeAryKlassPtr *tp = t->is_aryklassptr();\n+    int offset = meet_offset(tp->offset());\n+    PTR ptr = meet_ptr(tp->ptr());\n+\n+    switch (ptr) {\n+    case TopPTR:\n+    case AnyNull:                \/\/ Fall 'down' to dual of object klass\n+      \/\/ For instances when a subclass meets a superclass we fall\n+      \/\/ below the centerline when the superclass is exact. We need to\n+      \/\/ do the same here.\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset);\n+      } else {\n+        \/\/ cannot subclass, so the meet has to fall badly below the centerline\n+        ptr = NotNull;\n+        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      }\n+    case Constant:\n+    case NotNull:\n+    case BotPTR:                \/\/ Fall down to object klass\n+      \/\/ LCA is object_klass, but if we subclass from the top we can do better\n+      if( above_centerline(_ptr) ) { \/\/ if( _ptr == TopPTR || _ptr == AnyNull )\n+        \/\/ If 'this' (InstPtr) is above the centerline and it is Object class\n+        \/\/ then we can subclass in the Java class hierarchy.\n+        \/\/ For instances when a subclass meets a superclass we fall\n+        \/\/ below the centerline when the superclass is exact. We need\n+        \/\/ to do the same here.\n+        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+          \/\/ that is, tp's array type is a subtype of my klass\n+          return TypeAryKlassPtr::make(ptr,\n+                                       tp->elem(), tp->klass(), offset);\n+        }\n+      }\n+      \/\/ The other case cannot happen, since I cannot be a subtype of an array.\n+      \/\/ The meet falls down to Object class below centerline.\n+      if( ptr == Constant )\n+         ptr = NotNull;\n+      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+    default: typerr(t);\n+    }\n+  }\n+\n+  } \/\/ End of switch\n+  return this;                  \/\/ Return the double constant\n+}\n+\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type    *TypeInstKlassPtr::xdual() const {\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+}\n+\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n+  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset))->hashcons();\n+}\n+\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+  if (klass->is_obj_array_klass()) {\n+    \/\/ Element is an object array. Recursively call ourself.\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+    return TypeAryKlassPtr::make(ptr, etype, NULL, offset);\n+  } else if (klass->is_type_array_klass()) {\n+    \/\/ Element is an typeArray\n+    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+  } else {\n+    ShouldNotReachHere();\n+    return NULL;\n+  }\n+}\n+\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0);\n+}\n+\n+\/\/------------------------------eq---------------------------------------------\n+\/\/ Structural equality check for Type representations\n+bool TypeAryKlassPtr::eq(const Type *t) const {\n+  const TypeAryKlassPtr *p = t->is_aryklassptr();\n+  return\n+    _elem == p->_elem &&  \/\/ Check array\n+    TypeKlassPtr::eq(p);  \/\/ Check sub-parts\n+}\n+\n+\/\/------------------------------hash-------------------------------------------\n+\/\/ Type-specific hashing function.\n+int TypeAryKlassPtr::hash(void) const {\n+  return (intptr_t)_elem + TypeKlassPtr::hash();\n+}\n+\n@@ -5123,2 +5534,6 @@\n-const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+  return make(_ptr, elem(), klass(), xadd_offset(offset));\n+}\n+\n+const TypeKlassPtr *TypeAryKlassPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, elem(), klass(), offset);\n@@ -5128,4 +5543,12 @@\n-const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {\n-  assert(_base == KlassPtr, \"subclass must override cast_to_ptr_type\");\n-  if( ptr == _ptr ) return this;\n-  return make(ptr, _klass, _offset);\n+const TypePtr* TypeAryKlassPtr::cast_to_ptr_type(PTR ptr) const {\n+  assert(_base == AryKlassPtr, \"subclass must override cast_to_ptr_type\");\n+  if (ptr == _ptr) return this;\n+  return make(ptr, elem(), _klass, _offset);\n+}\n+\n+bool TypeAryKlassPtr::must_be_exact() const {\n+  if (_elem == Type::BOTTOM) return false;\n+  if (_elem == Type::TOP   ) return false;\n+  const TypeKlassPtr*  tk = _elem->isa_klassptr();\n+  if (!tk)             return true;   \/\/ a primitive type, like int\n+  return tk->must_be_exact();\n@@ -5136,3 +5559,8 @@\n-const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {\n-  if( klass_is_exact == _klass_is_exact ) return this;\n-  return make(klass_is_exact ? Constant : NotNull, _klass, _offset);\n+const TypeKlassPtr *TypeAryKlassPtr::cast_to_exactness(bool klass_is_exact) const {\n+  if (must_be_exact()) return this;  \/\/ cannot clear xk\n+  ciKlass* k = _klass;\n+  const Type* elem = this->elem();\n+  if (elem->isa_klassptr() && !klass_is_exact) {\n+    elem = elem->is_klassptr()->cast_to_exactness(klass_is_exact);\n+  }\n+  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset);\n@@ -5144,2 +5572,2 @@\n-\/\/ It will be NotNull, and exact if and only if the klass type is exact.\n-const TypeOopPtr* TypeKlassPtr::as_instance_type() const {\n+\/\/ It will be exact if and only if the klass type is exact.\n+const TypeOopPtr* TypeAryKlassPtr::as_instance_type() const {\n@@ -5148,5 +5576,2 @@\n-  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);\n-  const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);\n-  guarantee(toop != NULL, \"need type for given klass\");\n-  toop = toop->cast_to_ptr_type(TypePtr::NotNull)->is_oopptr();\n-  return toop->cast_to_exactness(xk)->is_oopptr();\n+  const Type* el = elem()->isa_klassptr() ? elem()->is_klassptr()->as_instance_type()->is_oopptr()->cast_to_exactness(false) : elem();\n+  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS), k, xk, 0);\n@@ -5158,1 +5583,1 @@\n-const Type    *TypeKlassPtr::xmeet( const Type *t ) const {\n+const Type    *TypeAryKlassPtr::xmeet( const Type *t ) const {\n@@ -5194,1 +5619,1 @@\n-      return make( ptr, klass(), offset );\n+      return make( ptr, _elem, klass(), offset );\n@@ -5225,12 +5650,4 @@\n-  case KlassPtr: {  \/\/ Meet two KlassPtr types\n-    const TypeKlassPtr *tkls = t->is_klassptr();\n-    int  off     = meet_offset(tkls->offset());\n-    PTR  ptr     = meet_ptr(tkls->ptr());\n-\n-    \/\/ Check for easy case; klasses are equal (and perhaps not loaded!)\n-    \/\/ If we have constants, then we created oops so classes are loaded\n-    \/\/ and we can handle the constants further down.  This case handles\n-    \/\/ not-loaded classes\n-    if( ptr != Constant && tkls->klass()->equals(klass()) ) {\n-      return make( ptr, klass(), off );\n-    }\n+  case AryKlassPtr: {  \/\/ Meet two KlassPtr types\n+    const TypeAryKlassPtr *tap = t->is_aryklassptr();\n+    int off = meet_offset(tap->offset());\n+    const Type* elem = _elem->meet(tap->_elem);\n@@ -5238,18 +5655,11 @@\n-    \/\/ Classes require inspection in the Java klass hierarchy.  Must be loaded.\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass = this->klass();\n-    assert( tkls_klass->is_loaded(), \"This class should have been loaded.\");\n-    assert( this_klass->is_loaded(), \"This class should have been loaded.\");\n-\n-    \/\/ If 'this' type is above the centerline and is a superclass of the\n-    \/\/ other, we can treat 'this' as having the same type as the other.\n-    if ((above_centerline(this->ptr())) &&\n-        tkls_klass->is_subtype_of(this_klass)) {\n-      this_klass = tkls_klass;\n-    }\n-    \/\/ If 'tinst' type is above the centerline and is a superclass of the\n-    \/\/ other, we can treat 'tinst' as having the same type as the other.\n-    if ((above_centerline(tkls->ptr())) &&\n-        this_klass->is_subtype_of(tkls_klass)) {\n-      tkls_klass = this_klass;\n-    }\n+    PTR ptr = meet_ptr(tap->ptr());\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    assert(res_xk == (ptr == Constant), \"\");\n+    return make(ptr, elem, res_klass, off);\n+  } \/\/ End of case KlassPtr\n+  case InstKlassPtr: {\n+    const TypeInstKlassPtr *tp = t->is_instklassptr();\n+    int offset = meet_offset(tp->offset());\n+    PTR ptr = meet_ptr(tp->ptr());\n@@ -5257,12 +5667,12 @@\n-    \/\/ Check for classes now being equal\n-    if (tkls_klass->equals(this_klass)) {\n-      \/\/ If the klasses are equal, the constants may still differ.  Fall to\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n-      \/\/ handled elsewhere).\n-      if( ptr == Constant ) {\n-        if (this->_ptr == Constant && tkls->_ptr == Constant &&\n-            this->klass()->equals(tkls->klass()));\n-        else if (above_centerline(this->ptr()));\n-        else if (above_centerline(tkls->ptr()));\n-        else\n-          ptr = NotNull;\n+    switch (ptr) {\n+    case TopPTR:\n+    case AnyNull:                \/\/ Fall 'down' to dual of object klass\n+      \/\/ For instances when a subclass meets a superclass we fall\n+      \/\/ below the centerline when the superclass is exact. We need to\n+      \/\/ do the same here.\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset);\n+      } else {\n+        \/\/ cannot subclass, so the meet has to fall badly below the centerline\n+        ptr = NotNull;\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -5270,11 +5680,23 @@\n-      return make( ptr, this_klass, off );\n-    } \/\/ Else classes are not equal\n-\n-    \/\/ Since klasses are different, we require the LCA in the Java\n-    \/\/ class hierarchy - which means we have to fall to at least NotNull.\n-    if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )\n-      ptr = NotNull;\n-    \/\/ Now we find the LCA of Java classes\n-    ciKlass* k = this_klass->least_common_ancestor(tkls_klass);\n-    return   make( ptr, k, off );\n-  } \/\/ End of case KlassPtr\n+    case Constant:\n+    case NotNull:\n+    case BotPTR:                \/\/ Fall down to object klass\n+      \/\/ LCA is object_klass, but if we subclass from the top we can do better\n+      if (above_centerline(tp->ptr())) {\n+        \/\/ If 'tp'  is above the centerline and it is Object class\n+        \/\/ then we can subclass in the Java class hierarchy.\n+        \/\/ For instances when a subclass meets a superclass we fall\n+        \/\/ below the centerline when the superclass is exact. We need\n+        \/\/ to do the same here.\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+          \/\/ that is, my array type is a subtype of 'tp' klass\n+          return make(ptr, _elem, _klass, offset);\n+        }\n+      }\n+      \/\/ The other case cannot happen, since t cannot be a subtype of an array.\n+      \/\/ The meet falls down to Object class below centerline.\n+      if (ptr == Constant)\n+         ptr = NotNull;\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+    default: typerr(t);\n+    }\n+  }\n@@ -5288,2 +5710,2 @@\n-const Type    *TypeKlassPtr::xdual() const {\n-  return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );\n+const Type    *TypeAryKlassPtr::xdual() const {\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset());\n@@ -5293,14 +5715,15 @@\n-intptr_t TypeKlassPtr::get_con() const {\n-  assert( _ptr == Null || _ptr == Constant, \"\" );\n-  assert( _offset >= 0, \"\" );\n-\n-  if (_offset != 0) {\n-    \/\/ After being ported to the compiler interface, the compiler no longer\n-    \/\/ directly manipulates the addresses of oops.  Rather, it only has a pointer\n-    \/\/ to a handle at compile time.  This handle is embedded in the generated\n-    \/\/ code and dereferenced at the time the nmethod is made.  Until that time,\n-    \/\/ it is not reasonable to do arithmetic with the addresses of oops (we don't\n-    \/\/ have access to the addresses!).  This does not seem to currently happen,\n-    \/\/ but this assertion here is to help prevent its occurence.\n-    tty->print_cr(\"Found oop constant with non-zero offset\");\n-    ShouldNotReachHere();\n+ciKlass* TypeAryKlassPtr::klass() const {\n+  if (_klass != NULL) {\n+    return _klass;\n+  }\n+  ciKlass* k = NULL;\n+  if (elem()->isa_klassptr()) {\n+    k = elem()->is_klassptr()->klass();\n+    if (k != NULL) {\n+      k = ciObjArrayKlass::make(k);\n+      ((TypeAryKlassPtr*)this)->_klass = k;\n+    }\n+  } else if ((elem()->base() == Type::Top) ||\n+             (elem()->base() == Type::Bottom)) {\n+  } else {\n+    k = ciTypeArrayKlass::make(elem()->basic_type());\n@@ -5308,2 +5731,1 @@\n-\n-  return (intptr_t)klass()->constant_encoding();\n+  return k;\n@@ -5311,0 +5733,1 @@\n+\n@@ -5314,1 +5737,1 @@\n-void TypeKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+void TypeAryKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n@@ -5320,6 +5743,3 @@\n-      const char *name = klass()->name()->as_utf8();\n-      if( name ) {\n-        st->print(\"klass %s: \" INTPTR_FORMAT, name, p2i(klass()));\n-      } else {\n-        ShouldNotReachHere();\n-      }\n+      st->print(\"[\");\n+      _elem->dump2(d, depth, st);\n+      st->print(\": \");\n@@ -5328,1 +5748,1 @@\n-    if( !WizardMode && !Verbose && !_klass_is_exact ) break;\n+    if( !WizardMode && !Verbose && _ptr != Constant ) break;\n@@ -5332,1 +5752,1 @@\n-    if( _klass_is_exact ) st->print(\":exact\");\n+    if( _ptr == Constant ) st->print(\":exact\");\n@@ -5348,1 +5768,9 @@\n-\n+const Type* TypeAryKlassPtr::base_element_type(int& dims) const {\n+  const Type* elem = this->elem();\n+  dims = 1;\n+  while (elem->isa_aryklassptr()) {\n+    elem = elem->is_aryklassptr()->elem();\n+    dims++;\n+  }\n+  return elem;\n+}\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":781,"deletions":353,"binary":false,"changes":1134,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+class       TypeInstKlassPtr;\n+class       TypeAryKlassPtr;\n@@ -111,0 +113,2 @@\n+    InstKlassPtr,\n+    AryKlassPtr,\n@@ -324,0 +328,4 @@\n+  const TypeInstKlassPtr  *isa_instklassptr() const;  \/\/ Returns NULL if not IntKlassPtr\n+  const TypeInstKlassPtr  *is_instklassptr() const;   \/\/ assert if not IntKlassPtr\n+  const TypeAryKlassPtr   *isa_aryklassptr() const;   \/\/ Returns NULL if not AryKlassPtr\n+  const TypeAryKlassPtr   *is_aryklassptr() const;    \/\/ assert if not AryKlassPtr\n@@ -919,0 +927,18 @@\n+  \/\/ TypeInstPtr (TypeAryPtr resp.) and TypeInstKlassPtr (TypeAryKlassPtr resp.) implement very similar meet logic.\n+  \/\/ The logic for meeting 2 instances (2 arrays resp.) is shared in the 2 utility methods below. However the logic for\n+  \/\/ the oop and klass versions can be slightly different and extra logic may have to be executed depending on what\n+  \/\/ exact case the meet falls into. The MeetResult struct is used by the utility methods to communicate what case was\n+  \/\/ encountered so the right logic specific to klasses or oops can be executed.,\n+  enum MeetResult {\n+    QUICK,\n+    UNLOADED,\n+    SUBTYPE,\n+    NOT_SUBTYPE,\n+    LCA\n+  };\n+  static MeetResult\n+  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n+               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n+  static MeetResult\n+  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n+\n@@ -1001,1 +1027,1 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeRawPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1100,1 +1126,1 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeOopPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1107,1 +1133,1 @@\n-  const TypeKlassPtr* as_klass_type() const;\n+  virtual const TypeKlassPtr* as_klass_type(bool try_for_exact = false) const;\n@@ -1184,1 +1210,1 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeInstPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1202,0 +1228,2 @@\n+  const TypeKlassPtr* as_klass_type(bool try_for_exact = false) const;\n+\n@@ -1268,1 +1296,1 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeAryPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1295,0 +1323,1 @@\n+  virtual const TypeKlassPtr* as_klass_type(bool try_for_exact = false) const;\n@@ -1346,1 +1375,1 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeMetadataPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1366,2 +1395,2 @@\n-  TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );\n-\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n+\n@@ -1370,1 +1399,2 @@\n- public:\n+\n+public:\n@@ -1372,1 +1402,1 @@\n-  virtual int hash() const;             \/\/ Type specific hashing\n+  virtual int hash() const;\n@@ -1374,1 +1404,1 @@\n- private:\n+  virtual bool must_be_exact() const { ShouldNotReachHere(); return false; }\n@@ -1376,1 +1406,1 @@\n-  static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n+protected:\n@@ -1380,7 +1410,2 @@\n-  \/\/ Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)\n-  bool          _klass_is_exact;\n-\n-  ciSymbol* name()  const { return klass()->name(); }\n-\n-  ciKlass* klass() const { return  _klass; }\n-  bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual ciKlass* klass() const { return  _klass; }\n+  bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1391,5 +1416,29 @@\n-  \/\/ Creates a type given a klass. Correctly handles multi-dimensional arrays\n-  \/\/ Respects UseUniqueSubclasses.\n-  \/\/ If the klass is final, the resulting type will be exact.\n-  static const TypeKlassPtr* make_from_klass(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, false);\n+  static const TypeKlassPtr* make(ciKlass* klass);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n+\n+\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const { ShouldNotReachHere(); return NULL; }\n+\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const { ShouldNotReachHere(); return NULL; }\n+\n+  \/\/ corresponding pointer to instance, for a given class\n+  virtual const TypeOopPtr* as_instance_type() const { ShouldNotReachHere(); return NULL; }\n+\n+  virtual const TypePtr *add_offset( intptr_t offset ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type    *xmeet( const Type *t ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type    *xdual() const { ShouldNotReachHere(); return NULL; }\n+\n+  virtual intptr_t get_con() const;\n+\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return NULL; }\n+\n+#ifndef PRODUCT\n+  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n+#endif\n+};\n+\n+\/\/ Instance klass pointer, mirrors TypeInstPtr\n+class TypeInstKlassPtr : public TypeKlassPtr {\n+\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n@@ -1397,4 +1446,9 @@\n-  \/\/ Same as before, but will produce an exact type, even if\n-  \/\/ the klass is not final, as long as it has exactly one implementation.\n-  static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, true);\n+\n+  virtual bool must_be_exact() const;\n+\n+public:\n+  \/\/ Instance klass ignoring any interface\n+  ciInstanceKlass* instance_klass() const { return klass()->as_instance_klass();     }\n+\n+  static const TypeInstKlassPtr *make(ciKlass* k) {\n+    return make(TypePtr::Constant, k, 0);\n@@ -1402,4 +1456,27 @@\n-  \/\/ Same as before, but does not respects UseUniqueSubclasses.\n-  \/\/ Use this only for creating array element types.\n-  static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {\n-    return make_from_klass_common(klass, false, false);\n+  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n+\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const;\n+\n+  \/\/ corresponding pointer to instance, for a given class\n+  virtual const TypeOopPtr* as_instance_type() const;\n+  virtual int hash() const;\n+  virtual bool eq(const Type *t) const;\n+\n+  virtual const TypePtr *add_offset( intptr_t offset ) const;\n+  virtual const Type    *xmeet( const Type *t ) const;\n+  virtual const Type    *xdual() const;\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const;\n+\n+  \/\/ Convenience common pre-built types.\n+  static const TypeInstKlassPtr* OBJECT; \/\/ Not-null object klass or below\n+  static const TypeInstKlassPtr* OBJECT_OR_NULL; \/\/ Maybe-null version of same\n+};\n+\n+\/\/ Array klass pointer, mirrors TypeAryPtr\n+class TypeAryKlassPtr : public TypeKlassPtr {\n+  const Type *_elem;\n+\n+  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, int offset)\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n@@ -1408,2 +1485,1 @@\n-  \/\/ Make a generic (unclassed) pointer to metadata.\n-  static const TypeKlassPtr* make(PTR ptr, int offset);\n+  virtual bool must_be_exact() const;\n@@ -1411,6 +1487,2 @@\n-  \/\/ ptr to klass 'k'\n-  static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }\n-  \/\/ ptr to klass 'k' with offset\n-  static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }\n-  \/\/ ptr to klass 'k' or sub-klass\n-  static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);\n+public:\n+  virtual ciKlass* klass() const;\n@@ -1418,1 +1490,2 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  \/\/ returns base element type, an instance klass (and not interface) for object arrays\n+  const Type* base_element_type(int& dims) const;\n@@ -1420,1 +1493,12 @@\n-  virtual const Type *cast_to_exactness(bool klass_is_exact) const;\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr* make(ciKlass* klass);\n+\n+  const Type *elem() const { return _elem; }\n+\n+  virtual bool eq(const Type *t) const;\n+  virtual int hash() const;             \/\/ Type specific hashing\n+\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n+\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const;\n@@ -1423,1 +1507,1 @@\n-  const TypeOopPtr* as_instance_type() const;\n+  virtual const TypeOopPtr* as_instance_type() const;\n@@ -1429,1 +1513,5 @@\n-  virtual intptr_t get_con() const;\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const;\n+\n+  virtual bool empty(void) const {\n+    return TypeKlassPtr::empty() || _elem->empty();\n+  }\n@@ -1431,3 +1519,0 @@\n-  \/\/ Convenience common pre-built types.\n-  static const TypeKlassPtr* OBJECT; \/\/ Not-null object klass or below\n-  static const TypeKlassPtr* OBJECT_OR_NULL; \/\/ Maybe-null version of same\n@@ -1724,1 +1809,1 @@\n-  assert(_base >= AnyPtr && _base <= KlassPtr, \"Not a pointer\");\n+  assert(_base >= AnyPtr && _base <= AryKlassPtr, \"Not a pointer\");\n@@ -1730,1 +1815,1 @@\n-  return (_base >= AnyPtr && _base <= KlassPtr) ? (TypePtr*)this : NULL;\n+  return (_base >= AnyPtr && _base <= AryKlassPtr) ? (TypePtr*)this : NULL;\n@@ -1802,1 +1887,1 @@\n-  return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;\n+  return (_base >= KlassPtr && _base <= AryKlassPtr ) ? (TypeKlassPtr*)this : NULL;\n@@ -1806,1 +1891,1 @@\n-  assert( _base == KlassPtr, \"Not a klass pointer\" );\n+  assert(_base >= KlassPtr && _base <= AryKlassPtr, \"Not a klass pointer\");\n@@ -1810,0 +1895,18 @@\n+inline const TypeInstKlassPtr *Type::isa_instklassptr() const {\n+  return (_base == InstKlassPtr) ? (TypeInstKlassPtr*)this : NULL;\n+}\n+\n+inline const TypeInstKlassPtr *Type::is_instklassptr() const {\n+  assert(_base == InstKlassPtr, \"Not a klass pointer\");\n+  return (TypeInstKlassPtr*)this;\n+}\n+\n+inline const TypeAryKlassPtr *Type::isa_aryklassptr() const {\n+  return (_base == AryKlassPtr) ? (TypeAryKlassPtr*)this : NULL;\n+}\n+\n+inline const TypeAryKlassPtr *Type::is_aryklassptr() const {\n+  assert(_base == AryKlassPtr, \"Not a klass pointer\");\n+  return (TypeAryKlassPtr*)this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":154,"deletions":51,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -2432,2 +2432,1 @@\n-      \/\/ In case the size exceeds the arch size, we do the minimum.\n-      int num_elem_for_cast = MIN2(num_elem_from, Matcher::max_vector_size(elem_bt_to));\n+      int num_elem_for_cast = num_elem_from;\n@@ -2452,1 +2451,1 @@\n-      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_from));\n+      int num_elem_for_resize = num_elem_to;\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -543,0 +543,1 @@\n+     static_field(StubRoutines,                _galoisCounterMode_AESCrypt,                   address)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1622,18 +1622,16 @@\n-                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p0, z0, z1);\",                \"cmpeq\\tp1.b, p0\/z, z0.b, z1.b\"],\n-                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, z3);\",                \"cmpne\\tp1.h, p0\/z, z2.h, z3.h\"],\n-                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p2, z4, z5);\",                \"cmpge\\tp1.s, p2\/z, z4.s, z5.s\"],\n-                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ D, p3, z6, z7);\",                \"cmpgt\\tp1.d, p3\/z, z6.d, z7.d\"],\n-                        [\"cmple\",   \"__ sve_cmpge(p2, __ B, p0, z10, z11);\",              \"cmple\\tp2.b, p0\/z, z11.b, z10.b\"],\n-                        [\"cmplt\",   \"__ sve_cmpgt(p3, __ S, p0, z16, z17);\",              \"cmplt\\tp3.s, p0\/z, z17.s, z16.s\"],\n-                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p4, z0, 15);\",                \"cmpeq\\tp1.b, p4\/z, z0.b, #15\"],\n-                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, -16);\",               \"cmpne\\tp1.h, p0\/z, z2.h, #-16\"],\n-                        [\"cmple\",   \"__ sve_cmple(p1, __ S, p1, z4, 0);\",                 \"cmple\\tp1.s, p1\/z, z4.s, #0\"],\n-                        [\"cmplt\",   \"__ sve_cmplt(p1, __ D, p2, z6, -1);\",                \"cmplt\\tp1.d, p2\/z, z6.d, #-1\"],\n-                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p3, z4, 5);\",                 \"cmpge\\tp1.s, p3\/z, z4.s, #5\"],\n-                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ B, p4, z6, -2);\",                \"cmpgt\\tp1.b, p4\/z, z6.b, #-2\"],\n-                        [\"fcmeq\",   \"__ sve_fcmeq(p1, __ S, p0, z0, z1);\",                \"fcmeq\\tp1.s, p0\/z, z0.s, z1.s\"],\n-                        [\"fcmne\",   \"__ sve_fcmne(p1, __ D, p0, z2, z3);\",                \"fcmne\\tp1.d, p0\/z, z2.d, z3.d\"],\n-                        [\"fcmgt\",   \"__ sve_fcmgt(p1, __ S, p2, z4, z5);\",                \"fcmgt\\tp1.s, p2\/z, z4.s, z5.s\"],\n-                        [\"fcmge\",   \"__ sve_fcmge(p1, __ D, p3, z6, z7);\",                \"fcmge\\tp1.d, p3\/z, z6.d, z7.d\"],\n-                        [\"fcmlt\",   \"__ sve_fcmgt(p2, __ S, p0, z10, z11);\",              \"fcmlt\\tp2.s, p0\/z, z11.s, z10.s\"],\n-                        [\"fcmle\",   \"__ sve_fcmge(p3, __ D, p0, z16, z17);\",              \"fcmle\\tp3.d, p0\/z, z17.d, z16.d\"],\n+                        [\"cmpeq\",   \"__ sve_cmp(Assembler::EQ, p1, __ B, p0, z0, z1);\",   \"cmpeq\\tp1.b, p0\/z, z0.b, z1.b\"],\n+                        [\"cmpne\",   \"__ sve_cmp(Assembler::NE, p1, __ H, p0, z2, z3);\",   \"cmpne\\tp1.h, p0\/z, z2.h, z3.h\"],\n+                        [\"cmpge\",   \"__ sve_cmp(Assembler::GE, p1, __ S, p2, z4, z5);\",   \"cmpge\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"cmpgt\",   \"__ sve_cmp(Assembler::GT, p1, __ D, p3, z6, z7);\",   \"cmpgt\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"cmphi\",   \"__ sve_cmp(Assembler::HI, p1, __ S, p2, z4, z5);\",   \"cmphi\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"cmphs\",   \"__ sve_cmp(Assembler::HS, p1, __ D, p3, z6, z7);\",   \"cmphs\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"cmpeq\",   \"__ sve_cmp(Assembler::EQ, p1, __ B, p4, z0, 15);\",   \"cmpeq\\tp1.b, p4\/z, z0.b, #15\"],\n+                        [\"cmpne\",   \"__ sve_cmp(Assembler::NE, p1, __ H, p0, z2, -16);\",  \"cmpne\\tp1.h, p0\/z, z2.h, #-16\"],\n+                        [\"cmple\",   \"__ sve_cmp(Assembler::LE, p1, __ S, p1, z4, 0);\",    \"cmple\\tp1.s, p1\/z, z4.s, #0\"],\n+                        [\"cmplt\",   \"__ sve_cmp(Assembler::LT, p1, __ D, p2, z6, -1);\",   \"cmplt\\tp1.d, p2\/z, z6.d, #-1\"],\n+                        [\"cmpge\",   \"__ sve_cmp(Assembler::GE, p1, __ S, p3, z4, 5);\",    \"cmpge\\tp1.s, p3\/z, z4.s, #5\"],\n+                        [\"cmpgt\",   \"__ sve_cmp(Assembler::GT, p1, __ B, p4, z6, -2);\",   \"cmpgt\\tp1.b, p4\/z, z6.b, #-2\"],\n+                        [\"fcmeq\",   \"__ sve_fcm(Assembler::EQ, p1, __ S, p0, z0, z1);\",   \"fcmeq\\tp1.s, p0\/z, z0.s, z1.s\"],\n+                        [\"fcmne\",   \"__ sve_fcm(Assembler::NE, p1, __ D, p0, z2, z3);\",   \"fcmne\\tp1.d, p0\/z, z2.d, z3.d\"],\n+                        [\"fcmgt\",   \"__ sve_fcm(Assembler::GT, p1, __ S, p2, z4, z5);\",   \"fcmgt\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"fcmge\",   \"__ sve_fcm(Assembler::GE, p1, __ D, p3, z6, z7);\",   \"fcmge\\tp1.d, p3\/z, z6.d, z7.d\"],\n@@ -1765,4 +1763,0 @@\n-                       [\"cmpeq\", \"PPZZ\", \"z\"],\n-                       [\"cmpge\", \"PPZZ\", \"z\"],\n-                       [\"cmpgt\", \"PPZZ\", \"z\"],\n-                       [\"cmpne\", \"PPZZ\", \"z\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -811,18 +811,16 @@\n-    __ sve_cmpeq(p1, __ B, p0, z0, z1);                \/\/       cmpeq   p1.b, p0\/z, z0.b, z1.b\n-    __ sve_cmpne(p1, __ H, p0, z2, z3);                \/\/       cmpne   p1.h, p0\/z, z2.h, z3.h\n-    __ sve_cmpge(p1, __ S, p2, z4, z5);                \/\/       cmpge   p1.s, p2\/z, z4.s, z5.s\n-    __ sve_cmpgt(p1, __ D, p3, z6, z7);                \/\/       cmpgt   p1.d, p3\/z, z6.d, z7.d\n-    __ sve_cmpge(p2, __ B, p0, z10, z11);              \/\/       cmple   p2.b, p0\/z, z11.b, z10.b\n-    __ sve_cmpgt(p3, __ S, p0, z16, z17);              \/\/       cmplt   p3.s, p0\/z, z17.s, z16.s\n-    __ sve_cmpeq(p1, __ B, p4, z0, 15);                \/\/       cmpeq   p1.b, p4\/z, z0.b, #15\n-    __ sve_cmpne(p1, __ H, p0, z2, -16);               \/\/       cmpne   p1.h, p0\/z, z2.h, #-16\n-    __ sve_cmple(p1, __ S, p1, z4, 0);                 \/\/       cmple   p1.s, p1\/z, z4.s, #0\n-    __ sve_cmplt(p1, __ D, p2, z6, -1);                \/\/       cmplt   p1.d, p2\/z, z6.d, #-1\n-    __ sve_cmpge(p1, __ S, p3, z4, 5);                 \/\/       cmpge   p1.s, p3\/z, z4.s, #5\n-    __ sve_cmpgt(p1, __ B, p4, z6, -2);                \/\/       cmpgt   p1.b, p4\/z, z6.b, #-2\n-    __ sve_fcmeq(p1, __ S, p0, z0, z1);                \/\/       fcmeq   p1.s, p0\/z, z0.s, z1.s\n-    __ sve_fcmne(p1, __ D, p0, z2, z3);                \/\/       fcmne   p1.d, p0\/z, z2.d, z3.d\n-    __ sve_fcmgt(p1, __ S, p2, z4, z5);                \/\/       fcmgt   p1.s, p2\/z, z4.s, z5.s\n-    __ sve_fcmge(p1, __ D, p3, z6, z7);                \/\/       fcmge   p1.d, p3\/z, z6.d, z7.d\n-    __ sve_fcmgt(p2, __ S, p0, z10, z11);              \/\/       fcmlt   p2.s, p0\/z, z11.s, z10.s\n-    __ sve_fcmge(p3, __ D, p0, z16, z17);              \/\/       fcmle   p3.d, p0\/z, z17.d, z16.d\n+    __ sve_cmp(Assembler::EQ, p1, __ B, p0, z0, z1);   \/\/       cmpeq   p1.b, p0\/z, z0.b, z1.b\n+    __ sve_cmp(Assembler::NE, p1, __ H, p0, z2, z3);   \/\/       cmpne   p1.h, p0\/z, z2.h, z3.h\n+    __ sve_cmp(Assembler::GE, p1, __ S, p2, z4, z5);   \/\/       cmpge   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_cmp(Assembler::GT, p1, __ D, p3, z6, z7);   \/\/       cmpgt   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_cmp(Assembler::HI, p1, __ S, p2, z4, z5);   \/\/       cmphi   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_cmp(Assembler::HS, p1, __ D, p3, z6, z7);   \/\/       cmphs   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_cmp(Assembler::EQ, p1, __ B, p4, z0, 15);   \/\/       cmpeq   p1.b, p4\/z, z0.b, #15\n+    __ sve_cmp(Assembler::NE, p1, __ H, p0, z2, -16);  \/\/       cmpne   p1.h, p0\/z, z2.h, #-16\n+    __ sve_cmp(Assembler::LE, p1, __ S, p1, z4, 0);    \/\/       cmple   p1.s, p1\/z, z4.s, #0\n+    __ sve_cmp(Assembler::LT, p1, __ D, p2, z6, -1);   \/\/       cmplt   p1.d, p2\/z, z6.d, #-1\n+    __ sve_cmp(Assembler::GE, p1, __ S, p3, z4, 5);    \/\/       cmpge   p1.s, p3\/z, z4.s, #5\n+    __ sve_cmp(Assembler::GT, p1, __ B, p4, z6, -2);   \/\/       cmpgt   p1.b, p4\/z, z6.b, #-2\n+    __ sve_fcm(Assembler::EQ, p1, __ S, p0, z0, z1);   \/\/       fcmeq   p1.s, p0\/z, z0.s, z1.s\n+    __ sve_fcm(Assembler::NE, p1, __ D, p0, z2, z3);   \/\/       fcmne   p1.d, p0\/z, z2.d, z3.d\n+    __ sve_fcm(Assembler::GT, p1, __ S, p2, z4, z5);   \/\/       fcmgt   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_fcm(Assembler::GE, p1, __ D, p3, z6, z7);   \/\/       fcmge   p1.d, p3\/z, z6.d, z7.d\n@@ -1060,6 +1058,2 @@\n-    __ sve_cmpeq(p1, __ B, p6, z25, z19);              \/\/       cmpeq   p1.b, p6\/z, z25.b, z19.b\n-    __ sve_cmpge(p2, __ S, p2, z14, z24);              \/\/       cmpge   p2.s, p2\/z, z14.s, z24.s\n-    __ sve_cmpgt(p7, __ B, p5, z4, z30);               \/\/       cmpgt   p7.b, p5\/z, z4.b, z30.b\n-    __ sve_cmpne(p2, __ H, p5, z12, z0);               \/\/       cmpne   p2.h, p5\/z, z12.h, z0.h\n-    __ sve_uzp1(z7, __ B, z24, z17);                   \/\/       uzp1    z7.b, z24.b, z17.b\n-    __ sve_uzp2(z27, __ D, z6, z9);                    \/\/       uzp2    z27.d, z6.d, z9.d\n+    __ sve_uzp1(z4, __ S, z23, z25);                   \/\/       uzp1    z4.s, z23.s, z25.s\n+    __ sve_uzp2(z2, __ H, z8, z8);                     \/\/       uzp2    z2.h, z8.h, z8.h\n@@ -1068,9 +1062,9 @@\n-    __ sve_andv(v23, __ D, p3, z16);                   \/\/       andv d23, p3, z16.d\n-    __ sve_orv(v22, __ D, p5, z20);                    \/\/       orv d22, p5, z20.d\n-    __ sve_eorv(v28, __ S, p2, z13);                   \/\/       eorv s28, p2, z13.s\n-    __ sve_smaxv(v7, __ H, p5, z28);                   \/\/       smaxv h7, p5, z28.h\n-    __ sve_sminv(v11, __ S, p3, z11);                  \/\/       sminv s11, p3, z11.s\n-    __ sve_fminv(v1, __ D, p6, z8);                    \/\/       fminv d1, p6, z8.d\n-    __ sve_fmaxv(v13, __ D, p4, z17);                  \/\/       fmaxv d13, p4, z17.d\n-    __ sve_fadda(v4, __ S, p0, z3);                    \/\/       fadda s4, p0, s4, z3.s\n-    __ sve_uaddv(v7, __ S, p3, z14);                   \/\/       uaddv d7, p3, z14.s\n+    __ sve_andv(v24, __ S, p4, z30);                   \/\/       andv s24, p4, z30.s\n+    __ sve_orv(v4, __ H, p7, z1);                      \/\/       orv h4, p7, z1.h\n+    __ sve_eorv(v19, __ H, p3, z0);                    \/\/       eorv h19, p3, z0.h\n+    __ sve_smaxv(v7, __ B, p6, z17);                   \/\/       smaxv b7, p6, z17.b\n+    __ sve_sminv(v27, __ D, p1, z9);                   \/\/       sminv d27, p1, z9.d\n+    __ sve_fminv(v23, __ D, p3, z16);                  \/\/       fminv d23, p3, z16.d\n+    __ sve_fmaxv(v22, __ D, p5, z20);                  \/\/       fmaxv d22, p5, z20.d\n+    __ sve_fadda(v28, __ D, p2, z13);                  \/\/       fadda d28, p2, d28, z13.d\n+    __ sve_uaddv(v7, __ H, p5, z28);                   \/\/       uaddv d7, p5, z28.h\n@@ -1095,7 +1089,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400037e,     0x94000000,\n-    0x97ffffd4,     0x9400037b,     0x3400000a,     0x34fffa2a,\n-    0x34006f0a,     0x35000008,     0x35fff9c8,     0x35006ea8,\n-    0xb400000b,     0xb4fff96b,     0xb4006e4b,     0xb500001d,\n-    0xb5fff91d,     0xb5006dfd,     0x10000013,     0x10fff8b3,\n-    0x10006d93,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36306d16,     0x3758000c,     0x375ff7cc,     0x37586cac,\n+    0x14000000,     0x17ffffd7,     0x14000378,     0x94000000,\n+    0x97ffffd4,     0x94000375,     0x3400000a,     0x34fffa2a,\n+    0x34006e4a,     0x35000008,     0x35fff9c8,     0x35006de8,\n+    0xb400000b,     0xb4fff96b,     0xb4006d8b,     0xb500001d,\n+    0xb5fff91d,     0xb5006d3d,     0x10000013,     0x10fff8b3,\n+    0x10006cd3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36306c56,     0x3758000c,     0x375ff7cc,     0x37586bec,\n@@ -1106,13 +1100,13 @@\n-    0x54006a80,     0x54000001,     0x54fff541,     0x54006a21,\n-    0x54000002,     0x54fff4e2,     0x540069c2,     0x54000002,\n-    0x54fff482,     0x54006962,     0x54000003,     0x54fff423,\n-    0x54006903,     0x54000003,     0x54fff3c3,     0x540068a3,\n-    0x54000004,     0x54fff364,     0x54006844,     0x54000005,\n-    0x54fff305,     0x540067e5,     0x54000006,     0x54fff2a6,\n-    0x54006786,     0x54000007,     0x54fff247,     0x54006727,\n-    0x54000008,     0x54fff1e8,     0x540066c8,     0x54000009,\n-    0x54fff189,     0x54006669,     0x5400000a,     0x54fff12a,\n-    0x5400660a,     0x5400000b,     0x54fff0cb,     0x540065ab,\n-    0x5400000c,     0x54fff06c,     0x5400654c,     0x5400000d,\n-    0x54fff00d,     0x540064ed,     0x5400000e,     0x54ffefae,\n-    0x5400648e,     0x5400000f,     0x54ffef4f,     0x5400642f,\n+    0x540069c0,     0x54000001,     0x54fff541,     0x54006961,\n+    0x54000002,     0x54fff4e2,     0x54006902,     0x54000002,\n+    0x54fff482,     0x540068a2,     0x54000003,     0x54fff423,\n+    0x54006843,     0x54000003,     0x54fff3c3,     0x540067e3,\n+    0x54000004,     0x54fff364,     0x54006784,     0x54000005,\n+    0x54fff305,     0x54006725,     0x54000006,     0x54fff2a6,\n+    0x540066c6,     0x54000007,     0x54fff247,     0x54006667,\n+    0x54000008,     0x54fff1e8,     0x54006608,     0x54000009,\n+    0x54fff189,     0x540065a9,     0x5400000a,     0x54fff12a,\n+    0x5400654a,     0x5400000b,     0x54fff0cb,     0x540064eb,\n+    0x5400000c,     0x54fff06c,     0x5400648c,     0x5400000d,\n+    0x54fff00d,     0x5400642d,     0x5400000e,     0x54ffefae,\n+    0x540063ce,     0x5400000f,     0x54ffef4f,     0x5400636f,\n@@ -1150,1 +1144,1 @@\n-    0xbd1b1869,     0x5800547b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x580053bb,     0x1800000b,     0xf8945060,\n@@ -1260,1 +1254,1 @@\n-    0x240b8142,     0x24918213,     0x250f9001,     0x25508051,\n+    0x24850891,     0x24c70cc1,     0x250f9001,     0x25508051,\n@@ -1263,57 +1257,55 @@\n-    0x658b4152,     0x65d14203,     0x05733820,     0x05b238a4,\n-    0x05f138e6,     0x0570396a,     0x65d0a001,     0x65d6a443,\n-    0x65d4a826,     0x6594ac26,     0x6554ac26,     0x6556ac26,\n-    0x6552ac26,     0x65cbac85,     0x65caac01,     0x65dea833,\n-    0x659ca509,     0x65d8a801,     0x65dcac01,     0x655cb241,\n-    0x0520a1e0,     0x0521a601,     0x052281e0,     0x05238601,\n-    0x04a14026,     0x0568aca7,     0x05b23230,     0x853040af,\n-    0xc5b040af,     0xe57080af,     0xe5b080af,     0x25034440,\n-    0x254054c4,     0x25034640,     0x25415a05,     0x25834440,\n-    0x25c54489,     0x250b5d3a,     0x2550dc20,     0x2518e3e1,\n-    0x2558e3e2,     0x2598e3e3,     0x25d8e3e4,     0x2518e407,\n-    0x05214800,     0x05614800,     0x05a14800,     0x05e14800,\n-    0x05214c00,     0x05614c00,     0x05a14c00,     0x05e14c00,\n-    0x05304001,     0x05314001,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf8208193,     0xf83101b6,\n-    0xf83c13fe,     0xf821239a,     0xf824309e,     0xf826535e,\n-    0xf8304109,     0xf82c7280,     0xf8216058,     0xf8a08309,\n-    0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,\n-    0xf8aa522f,     0xf8a2418a,     0xf8ac71af,     0xf8a26287,\n-    0xf8fa8090,     0xf8e20184,     0xf8f01215,     0xf8f022ab,\n-    0xf8f7334c,     0xf8f751dc,     0xf8eb4038,     0xf8ec715f,\n-    0xf8f06047,     0xf863826d,     0xf8710070,     0xf86113cb,\n-    0xf86521e8,     0xf87d301e,     0xf8745287,     0xf87742bc,\n-    0xf87b70b9,     0xf8616217,     0xb83f8185,     0xb82901fc,\n-    0xb83d13f6,     0xb83320bf,     0xb82e33f0,     0xb830529b,\n-    0xb830416c,     0xb82973c6,     0xb831639b,     0xb8be8147,\n-    0xb8b4008a,     0xb8b81231,     0xb8b623a3,     0xb8af3276,\n-    0xb8b35056,     0xb8af4186,     0xb8b071ab,     0xb8b763c1,\n-    0xb8f38225,     0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,\n-    0xb8fb3023,     0xb8ff5278,     0xb8f14389,     0xb8fb70ef,\n-    0xb8f563f7,     0xb87983e2,     0xb87b0150,     0xb8771073,\n-    0xb8702320,     0xb87a3057,     0xb870508c,     0xb87c43be,\n-    0xb87070db,     0xb86961fd,     0xce273c87,     0xce080ac9,\n-    0xce7e8e9b,     0xce808b45,     0xce79806e,     0xce758768,\n-    0xcec0835a,     0xce608ad8,     0x043100c4,     0x046105e3,\n-    0x65c900a6,     0x65d60a87,     0x65c80545,     0x0416a63e,\n-    0x04001f8b,     0x045a179a,     0x04d09e0d,     0x045aa1a5,\n-    0x04990b4f,     0x049386cb,     0x04918264,     0x04500dd1,\n-    0x0497b062,     0x041ea4d7,     0x04980f71,     0x04c80450,\n-    0x048a04c3,     0x04810d93,     0x04dcba68,     0x65808ae0,\n-    0x65cd9db3,     0x658680e6,     0x65879911,     0x65c296d6,\n-    0x04dda1e2,     0x65c2a494,     0x65c0a107,     0x65c1b493,\n-    0x65cdb569,     0x65819e05,     0x65ad8c36,     0x65af1334,\n-    0x65e63104,     0x65fd5e04,     0x65eb6c49,     0x049a4423,\n-    0x04916d11,     0x043330b8,     0x04b032d1,     0x04603274,\n-    0x04e432f1,     0x2413bb21,     0x249889c2,     0x241e9497,\n-    0x2440b592,     0x05316b07,     0x05e96cdb,     0x04da2e17,\n-    0x04d83696,     0x049929bc,     0x04483787,     0x048a2d6b,\n-    0x65c73901,     0x65c6322d,     0x65982064,     0x04812dc7,\n-\n+    0x05733820,     0x05b238a4,     0x05f138e6,     0x0570396a,\n+    0x65d0a001,     0x65d6a443,     0x65d4a826,     0x6594ac26,\n+    0x6554ac26,     0x6556ac26,     0x6552ac26,     0x65cbac85,\n+    0x65caac01,     0x65dea833,     0x659ca509,     0x65d8a801,\n+    0x65dcac01,     0x655cb241,     0x0520a1e0,     0x0521a601,\n+    0x052281e0,     0x05238601,     0x04a14026,     0x0568aca7,\n+    0x05b23230,     0x853040af,     0xc5b040af,     0xe57080af,\n+    0xe5b080af,     0x25034440,     0x254054c4,     0x25034640,\n+    0x25415a05,     0x25834440,     0x25c54489,     0x250b5d3a,\n+    0x2550dc20,     0x2518e3e1,     0x2558e3e2,     0x2598e3e3,\n+    0x25d8e3e4,     0x2518e407,     0x05214800,     0x05614800,\n+    0x05a14800,     0x05e14800,     0x05214c00,     0x05614c00,\n+    0x05a14c00,     0x05e14c00,     0x05304001,     0x05314001,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf8208193,     0xf83101b6,     0xf83c13fe,     0xf821239a,\n+    0xf824309e,     0xf826535e,     0xf8304109,     0xf82c7280,\n+    0xf8216058,     0xf8a08309,     0xf8ba03d0,     0xf8a312ea,\n+    0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,     0xf8a2418a,\n+    0xf8ac71af,     0xf8a26287,     0xf8fa8090,     0xf8e20184,\n+    0xf8f01215,     0xf8f022ab,     0xf8f7334c,     0xf8f751dc,\n+    0xf8eb4038,     0xf8ec715f,     0xf8f06047,     0xf863826d,\n+    0xf8710070,     0xf86113cb,     0xf86521e8,     0xf87d301e,\n+    0xf8745287,     0xf87742bc,     0xf87b70b9,     0xf8616217,\n+    0xb83f8185,     0xb82901fc,     0xb83d13f6,     0xb83320bf,\n+    0xb82e33f0,     0xb830529b,     0xb830416c,     0xb82973c6,\n+    0xb831639b,     0xb8be8147,     0xb8b4008a,     0xb8b81231,\n+    0xb8b623a3,     0xb8af3276,     0xb8b35056,     0xb8af4186,\n+    0xb8b071ab,     0xb8b763c1,     0xb8f38225,     0xb8e202d0,\n+    0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,     0xb8ff5278,\n+    0xb8f14389,     0xb8fb70ef,     0xb8f563f7,     0xb87983e2,\n+    0xb87b0150,     0xb8771073,     0xb8702320,     0xb87a3057,\n+    0xb870508c,     0xb87c43be,     0xb87070db,     0xb86961fd,\n+    0xce273c87,     0xce080ac9,     0xce7e8e9b,     0xce808b45,\n+    0xce79806e,     0xce758768,     0xcec0835a,     0xce608ad8,\n+    0x043100c4,     0x046105e3,     0x65c900a6,     0x65d60a87,\n+    0x65c80545,     0x0416a63e,     0x04001f8b,     0x045a179a,\n+    0x04d09e0d,     0x045aa1a5,     0x04990b4f,     0x049386cb,\n+    0x04918264,     0x04500dd1,     0x0497b062,     0x041ea4d7,\n+    0x04980f71,     0x04c80450,     0x048a04c3,     0x04810d93,\n+    0x04dcba68,     0x65808ae0,     0x65cd9db3,     0x658680e6,\n+    0x65879911,     0x65c296d6,     0x04dda1e2,     0x65c2a494,\n+    0x65c0a107,     0x65c1b493,     0x65cdb569,     0x65819e05,\n+    0x65ad8c36,     0x65af1334,     0x65e63104,     0x65fd5e04,\n+    0x65eb6c49,     0x049a4423,     0x04916d11,     0x043330b8,\n+    0x04b032d1,     0x04603274,     0x04e432f1,     0x05b96ae4,\n+    0x05686d02,     0x049a33d8,     0x04583c24,     0x04592c13,\n+    0x04083a27,     0x04ca253b,     0x65c72e17,     0x65c63696,\n+    0x65d829bc,     0x04413787,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":104,"deletions":112,"binary":false,"changes":216,"status":"modified"}]}