{"files":[{"patch":"@@ -1905,1 +1905,1 @@\n-  if (C->max_vector_size() >= 16) {\n+  if (C->max_vector_size() > 0) {\n@@ -2391,1 +2391,1 @@\n-  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+  if (!match_rule_supported(opcode)) {\n@@ -2399,1 +2399,1 @@\n-    return op_sve_supported(opcode);\n+    return op_sve_supported(opcode, vlen, bt);\n@@ -2416,0 +2416,3 @@\n+    case Op_LoadVectorGather:\n+    case Op_StoreVectorScatter:\n+      return false;\n@@ -2420,1 +2423,1 @@\n-  return true; \/\/ Per default match rules are supported.\n+  return vector_size_supported(bt, vlen);\n@@ -2460,0 +2463,1 @@\n+\n@@ -2462,15 +2466,8 @@\n-  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n-    \/\/ Currently vector length less than SVE vector register size is not supported.\n-    return max_size;\n-  } else { \/\/ NEON\n-    \/\/ Limit the vector size to 8 bytes\n-    int size = 8 \/ type2aelembytes(bt);\n-    if (bt == T_BYTE) {\n-      \/\/ To support vector api shuffle\/rearrange.\n-      size = 4;\n-    } else if (bt == T_BOOLEAN) {\n-      \/\/ To support vector api load\/store mask.\n-      size = 2;\n-    }\n-    if (size < 2) size = 2;\n-    return MIN2(size,max_size);\n+  \/\/ Limit the min vector size to 8 bytes.\n+  int size = 8 \/ type2aelembytes(bt);\n+  if (bt == T_BYTE) {\n+    \/\/ To support vector api shuffle\/rearrange.\n+    size = 4;\n+  } else if (bt == T_BOOLEAN) {\n+    \/\/ To support vector api load\/store mask.\n+    size = 2;\n@@ -2478,0 +2475,2 @@\n+  if (size < 2) size = 2;\n+  return MIN2(size, max_size);\n@@ -2487,1 +2486,1 @@\n-  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+  if (UseSVE > 0 && 2 <= len && len <= 256) {\n@@ -3652,1 +3651,1 @@\n-    if (Compile::current()->max_vector_size() >= 16 && uncommon_trap_request() == 0) {\n+    if (Compile::current()->max_vector_size() > 0 && uncommon_trap_request() == 0) {\n@@ -3664,1 +3663,1 @@\n-    } else if (Compile::current()->max_vector_size() >= 16) {\n+    } else if (Compile::current()->max_vector_size() > 0) {\n@@ -3702,1 +3701,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -3715,1 +3714,1 @@\n-    if (Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() > 0) {\n@@ -4096,0 +4095,10 @@\n+operand immI_gt_1()\n+%{\n+  predicate(n->get_int() > 1);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":33,"deletions":24,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2707,1 +2707,3 @@\n-  if (restore_vectors) {\n+  \/\/ We may use predicate registers and rely on ptrue with SVE,\n+  \/\/ regardless of wide vector (> 8 bytes) used or not.\n+  if (use_sve) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,0 +141,18 @@\n+  static bool supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n+  \/\/ Vector calling convention not yet implemented.\n+  static const bool supports_vector_calling_convention(void) {\n+    return false;\n+  }\n+\n+  static void vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+    (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+  }\n+\n+  static OptoRegPair vector_return_value(uint ideal_reg) {\n+    Unimplemented();\n+    return OptoRegPair(0, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -867,0 +867,7 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -134,0 +134,18 @@\n+  static bool supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n+  \/\/ Vector calling convention not yet implemented.\n+  static const bool supports_vector_calling_convention(void) {\n+    return false;\n+  }\n+\n+  static void vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+    (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+  }\n+\n+  static OptoRegPair vector_return_value(uint ideal_reg) {\n+    Unimplemented();\n+    return OptoRegPair(0, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -358,0 +358,7 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -141,0 +141,18 @@\n+  static bool supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n+  \/\/ Vector calling convention not yet implemented.\n+  static const bool supports_vector_calling_convention(void) {\n+    return false;\n+  }\n+\n+  static void vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+    (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+  }\n+\n+  static OptoRegPair vector_return_value(uint ideal_reg) {\n+    Unimplemented();\n+    return OptoRegPair(0, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -131,0 +131,18 @@\n+  static bool supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+    return false;\n+  }\n+\n+  \/\/ Vector calling convention not yet implemented.\n+  static const bool supports_vector_calling_convention(void) {\n+    return false;\n+  }\n+\n+  static void vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+    (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+  }\n+\n+  static OptoRegPair vector_return_value(uint ideal_reg) {\n+    Unimplemented();\n+    return OptoRegPair(0, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3919,10 +3919,0 @@\n-void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n-  attributes.reset_is_clear_context();\n-  attributes.set_embedded_opmask_register_specifier(mask);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n-  emit_int24(0x3E, (0xC0 | encode), vcc);\n-}\n-\n@@ -9153,1 +9143,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9162,1 +9152,2 @@\n-  emit_int24(0x1F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9166,1 +9157,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9178,1 +9169,2 @@\n-  emit_int8((unsigned char)0x1F);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int8((unsigned char)opcode);\n@@ -9184,1 +9176,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9193,1 +9185,2 @@\n-  emit_int24(0x1F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9197,1 +9190,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9209,1 +9202,2 @@\n-  emit_int8((unsigned char)0x1F);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int8((unsigned char)opcode);\n@@ -9215,1 +9209,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9225,1 +9219,2 @@\n-  emit_int24(0x3F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9229,1 +9224,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9242,1 +9237,2 @@\n-  emit_int8((unsigned char)0x3F);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int8((unsigned char)opcode);\n@@ -9248,1 +9244,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9258,1 +9254,2 @@\n-  emit_int24(0x3F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9262,1 +9259,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9275,1 +9272,2 @@\n-  emit_int8((unsigned char)0x3F);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int8((unsigned char)opcode);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1724,1 +1724,0 @@\n-  void evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate of, int vector_len);\n@@ -2497,1 +2496,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2499,1 +2498,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2503,1 +2502,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2505,1 +2504,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2509,1 +2508,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2511,1 +2510,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2515,1 +2514,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2517,1 +2516,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2146,1 +2146,1 @@\n-      evpcmpb(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpb(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2149,1 +2149,1 @@\n-      evpcmpw(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpw(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2153,1 +2153,1 @@\n-      evpcmpd(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpd(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2157,1 +2157,1 @@\n-      evpcmpq(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpq(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2165,0 +2165,78 @@\n+void C2_MacroAssembler::vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison,\n+                            int vlen_in_bytes, XMMRegister vtmp1, XMMRegister vtmp2, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes*2);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpacksswb(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vpackssdw(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpermilps(dst, dst, 8, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+  if (vlen_in_bytes == 16) {\n+    vpermpd(dst, dst, 0x8, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                              XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxbw(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxbw(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpacksswb(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxwd(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxwd(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::D,  vlen_enc, scratch);\n+    vpackssdw(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpshufd(dst, dst, 8, vlen_enc);\n+    vpermq(dst, dst, 8, vlen_enc);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxdq(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxdq(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::Q,  vlen_enc, scratch);\n+    vpshufd(vtmp3, vtmp3, 8, vlen_enc);\n+    vpermq(vtmp3, vtmp3, 0x80, vlen_enc);\n+    vpblendd(dst, dst, vtmp3, 0xf0, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -147,0 +147,6 @@\n+  \/\/ vector compare\n+  void vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+              XMMRegister vtmp1, XMMRegister vtmp2, Register scratch);\n+  void vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3133,1 +3133,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3135,1 +3135,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3138,1 +3138,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3143,1 +3143,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3145,1 +3145,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3148,1 +3148,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3153,1 +3153,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3155,1 +3155,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3158,1 +3158,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3163,1 +3163,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3165,1 +3165,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3168,1 +3168,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -7839,1 +7839,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n@@ -7889,1 +7889,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1282,1 +1282,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1284,1 +1284,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1286,1 +1286,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1288,1 +1288,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1290,1 +1290,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1292,1 +1292,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1294,1 +1294,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1296,1 +1296,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -161,0 +161,42 @@\n+  static bool supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+    if ((UseAVX > 2) && (VM_Version::supports_avx512vl() || vlen == 64))\n+      return true;\n+    else {\n+      \/\/ instruction set supports only signed comparison\n+      \/\/ so need to zero extend to higher integral type and perform comparison\n+      \/\/ cannot cast long to higher integral type\n+      \/\/ and on avx1 cannot cast 128 bit integral vectors to higher size\n+\n+      if ((bt != T_LONG)  &&\n+          ((UseAVX >= 2) || (vlen <= 8)))\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  static const bool supports_vector_calling_convention() {\n+#ifdef _LP64\n+    return true;\n+#else\n+    return false;\n+#endif\n+  }\n+\n+  static void vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+    (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+  }\n+\n+  static OptoRegPair vector_return_value(uint ideal_reg) {\n+#ifdef _LP64\n+    int lo = XMM0_num;\n+    int hi = XMM0b_num;\n+    if (ideal_reg == Op_VecX) hi = XMM0d_num;\n+    else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n+    else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n+    return OptoRegPair(hi, lo);\n+#else\n+    Unimplemented();\n+    return OptoRegPair(0, 0);\n+#endif\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1166,0 +1166,25 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n+\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n+\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n+  }\n+\n+  return stk_args;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1277,0 +1277,4 @@\n+static inline bool is_unsigned_booltest_pred(int bt) {\n+  return  ((bt & BoolTest::unsigned_compare) == BoolTest::unsigned_compare);\n+}\n+\n@@ -1699,0 +1703,5 @@\n+    case Op_CallLeafVector:\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512vlbwdq()) {\n+        return false;\n+      }\n+      break;\n@@ -1946,0 +1955,4 @@\n+  \/\/ Support for calling svml double64 vectors\n+  if (bt == T_DOUBLE) {\n+    size = 1;\n+  }\n@@ -2150,6 +2163,16 @@\n-    case BoolTest::eq: return Assembler::eq;\n-    case BoolTest::ne: return Assembler::neq;\n-    case BoolTest::le: return Assembler::le;\n-    case BoolTest::ge: return Assembler::nlt;\n-    case BoolTest::lt: return Assembler::lt;\n-    case BoolTest::gt: return Assembler::nle;\n+    case BoolTest::eq:\n+      return Assembler::eq;\n+    case BoolTest::ne:\n+      return Assembler::neq;\n+    case BoolTest::le:\n+    case BoolTest::ule:\n+      return Assembler::le;\n+    case BoolTest::ge:\n+    case BoolTest::uge:\n+      return Assembler::nlt;\n+    case BoolTest::lt:\n+    case BoolTest::ult:\n+      return Assembler::lt;\n+    case BoolTest::gt:\n+    case BoolTest::ugt:\n+      return Assembler::nle;\n@@ -6863,1 +6886,3 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) && \n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n@@ -6878,2 +6903,5 @@\n-instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n@@ -6882,0 +6910,36 @@\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+              $vtmp2$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n+            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+  predicate(UseAVX > 2 && \n+            (VM_Version::supports_avx512vl() ||  \n+             vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n+             is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n@@ -6887,1 +6951,1 @@\n-    int vlen_enc = Assembler::AVX_512bit;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -6889,0 +6953,1 @@\n+    bool is_unsigned = is_unsigned_booltest_pred($cond$$constant);\n@@ -6895,1 +6960,1 @@\n-        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6900,1 +6965,1 @@\n-        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6905,1 +6970,1 @@\n-        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6907,0 +6972,1 @@\n+\n@@ -6910,1 +6976,1 @@\n-        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6914,1 +6980,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":80,"deletions":15,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -466,1 +466,3 @@\n-  offset += clear_avx_size();\n+  if (this->ideal_Opcode() != Op_CallLeafVector) {\n+    offset += clear_avx_size();\n+  }\n@@ -12978,0 +12980,12 @@\n+\/\/ Call runtime without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf,vector \" %}\n+  ins_encode(Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -728,0 +728,3 @@\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -739,3 +739,5 @@\n-    OptoRegPair regs = is_CallRuntime()\n-      ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n-      : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n+    OptoRegPair regs = Opcode() == Op_CallLeafVector\n+      ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n+      : is_CallRuntime()\n+        ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n+        : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n@@ -743,0 +745,10 @@\n+\n+    \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n+    if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(OptoReg::is_valid(regs.second())) {\n+        for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n+          rm.Insert(r);\n+        }\n+      }\n+    }\n+\n@@ -1198,0 +1210,5 @@\n+uint CallLeafVectorNode::size_of() const { return sizeof(*this); }\n+bool CallLeafVectorNode::cmp( const Node &n ) const {\n+  CallLeafVectorNode &call = (CallLeafVectorNode&)n;\n+  return CallLeafNode::cmp(call) && _num_bits == call._num_bits;\n+}\n@@ -1269,0 +1286,15 @@\n+void CallLeafVectorNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+#ifdef ASSERT\n+  assert(tf()->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+         \"return vector size must match\");\n+  const TypeTuple* d = tf()->domain();\n+  for (uint i = TypeFunc::Parms; i < d->cnt(); i++) {\n+    Node* arg = in(i);\n+    assert(arg->bottom_type()->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+           \"vector argument size must match\");\n+  }\n+#endif\n+\n+  Matcher::vector_calling_convention(parm_regs, _num_bits, argcnt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+class         CallLeafVectorNode;\n@@ -788,0 +789,1 @@\n+protected:\n@@ -875,0 +877,18 @@\n+\/\/------------------------------CallLeafVectorNode-------------------------------\n+\/\/ CallLeafNode but calling with vector calling convention instead.\n+class CallLeafVectorNode : public CallLeafNode {\n+private:\n+  uint _num_bits;\n+protected:\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallLeafVectorNode(const TypeFunc* tf, address addr, const char* name,\n+                   const TypePtr* adr_type, uint num_bits)\n+    : CallLeafNode(tf, addr, name, adr_type), _num_bits(num_bits)\n+  {\n+  }\n+  virtual int   Opcode() const;\n+  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+macro(CallLeafVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2127,1 +2127,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2137,1 +2138,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2970,0 +2971,1 @@\n+  case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -872,0 +872,1 @@\n+    case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -328,0 +328,1 @@\n+  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1368,2 +1368,4 @@\n-      if( !parm_regs[i].first()->is_valid() &&\n-          !parm_regs[i].second()->is_valid() ) {\n+      VMReg first = parm_regs[i].first();\n+      VMReg second = parm_regs[i].second();\n+      if( !first->is_valid() &&\n+          !second->is_valid() ) {\n@@ -1372,0 +1374,9 @@\n+      \/\/ Handle case where arguments are in vector registers.\n+      if(call->in(TypeFunc::Parms + i)->bottom_type()->isa_vect()) {\n+        OptoReg::Name reg_fst = OptoReg::as_OptoReg(first);\n+        OptoReg::Name reg_snd = OptoReg::as_OptoReg(second);\n+        assert (reg_fst <= reg_snd, \"fst=%d snd=%d\", reg_fst, reg_snd);\n+        for (OptoReg::Name r = reg_fst; r <= reg_snd; r++) {\n+          rm->Insert(r);\n+        }\n+      }\n@@ -1373,1 +1384,1 @@\n-      OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg1 = warp_outgoing_stk_arg(first, begin_out_arg_area, out_arg_limit_per_call );\n@@ -1377,1 +1388,1 @@\n-      OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg2 = warp_outgoing_stk_arg(second, begin_out_arg_area, out_arg_limit_per_call );\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -662,0 +662,19 @@\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+const TypeFunc *OptoRuntime::Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type) {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(num_arg);\n+  \/\/ Symbol* name of class to be loaded\n+  assert(num_arg > 0, \"must have at least 1 input\");\n+  for (uint i = 0; i < num_arg; i++) {\n+    fields[TypeFunc::Parms+i] = in_type;\n+  }\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+num_arg, fields);\n+\n+  \/\/ create result type (range)\n+  const uint num_ret = 1;\n+  fields = TypeTuple::fields(num_ret);\n+  fields[TypeFunc::Parms+0] = out_type;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+num_ret, fields);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  static const TypeFunc* Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,24 @@\n+  if (num_elem == 1) {\n+    if (mask_use_type != VecMaskNotUsed) {\n+#ifndef PRODUCT\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected vector mask op (%s,%s,%d) because architecture does not support it\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n+#endif\n+      return false;\n+    }\n+\n+    if (sopc != 0) {\n+      if (sopc != Op_LoadVector && sopc != Op_StoreVector) {\n+#ifndef PRODUCT\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** Not a svml call or load\/store vector op (%s,%s,%d)\",\n+                        NodeClassNames[sopc], type2name(type), num_elem);\n+        }\n+#endif\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -234,1 +258,1 @@\n-  if (sopc == 0) {\n+  if ((opc != Op_CallLeafVector) && (sopc == 0)) {\n@@ -240,0 +264,9 @@\n+  if (num_elem == 1) {\n+    if (opc != Op_CallLeafVector || elem_bt != T_DOUBLE) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n+                      n, opc, num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n@@ -243,0 +276,22 @@\n+  if (opc == Op_CallLeafVector) {\n+    if (!UseVectorStubs) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector stubs support is disabled\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::supports_vector_calling_convention()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** no vector calling conventions supported\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::vector_size_supported(elem_bt, num_elem)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n+                      num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n+\n@@ -244,1 +299,2 @@\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, is_vector_mask(vbox_klass) ? VecMaskUseAll : VecMaskNotUsed)) {\n+  if ((sopc != 0) &&\n+      !arch_supports_vector(sopc, num_elem, elem_bt, is_vector_mask(vbox_klass) ? VecMaskUseAll : VecMaskNotUsed)) {\n@@ -292,10 +348,22 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  switch (n) {\n-    case 1:\n-    case 2: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n-      break;\n-    }\n-    case 3: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n-      break;\n+  if (opc == Op_CallLeafVector) {\n+    assert(UseVectorStubs, \"sanity\");\n+    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    if (operation == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** svml call failed\");\n+      }\n+      return false;\n+     }\n+  } else {\n+    const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+    switch (n) {\n+      case 1:\n+      case 2: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n+        break;\n+      }\n+      case 3: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n+        break;\n+      }\n+      default: fatal(\"unsupported arity: %d\", n);\n@@ -303,1 +371,0 @@\n-    default: fatal(\"unsupported arity: %d\", n);\n@@ -355,0 +422,3 @@\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n@@ -387,1 +457,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(1));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n@@ -551,0 +621,16 @@\n+static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_type) {\n+  assert(arr_type != NULL, \"unexpected\");\n+  BasicType arr_elem_bt = arr_type->elem()->array_element_basic_type();\n+  if (elem_bt == arr_elem_bt) {\n+    return true;\n+  } else if (elem_bt == T_SHORT && arr_elem_bt == T_CHAR) {\n+    \/\/ Load\/store of short vector from\/to char[] is supported\n+    return true;\n+  } else if (elem_bt == T_BYTE && arr_elem_bt == T_BOOLEAN) {\n+    \/\/ Load\/store of byte vector from\/to boolean[] is supported\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -628,1 +714,6 @@\n-  if (arr_type != NULL && !using_byte_array && elem_bt != arr_type->elem()->array_element_basic_type() && !is_mask) {\n+  if (arr_type != NULL && !using_byte_array && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+                    is_store, is_store ? \"store\" : \"load\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -811,1 +902,6 @@\n-  if (arr_type == NULL || (arr_type != NULL && elem_bt != arr_type->elem()->array_element_basic_type())) {\n+  if (arr_type == NULL || (arr_type != NULL && !elem_consistent_with_arr(elem_bt, arr_type))) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+                    is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -1130,0 +1226,10 @@\n+  if ((cond->get_con() & BoolTest::unsigned_compare) != 0) {\n+    if (!Matcher::supports_unsigned_vector_comparison(num_elem, elem_bt)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+                      cond->get_con() & (BoolTest::unsigned_compare - 1), num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n+\n@@ -1240,0 +1346,417 @@\n+static void get_svml_address(int op, int bits, BasicType bt, const char** name_ptr, address* addr_ptr) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(name_ptr != NULL, \"unexpected\");\n+  assert(addr_ptr != NULL, \"unexpected\");\n+\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Since the addresses are resolved at runtime, using switch instead of table - otherwise might get NULL addresses.\n+  if (bt == T_FLOAT) {\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_float64\";  *addr_ptr = StubRoutines::vector_exp_float64();  break;\n+            case 128: *name_ptr = \"vector_exp_float128\"; *addr_ptr = StubRoutines::vector_exp_float128(); break;\n+            case 256: *name_ptr = \"vector_exp_float256\"; *addr_ptr = StubRoutines::vector_exp_float256(); break;\n+            case 512: *name_ptr = \"vector_exp_float512\"; *addr_ptr = StubRoutines::vector_exp_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_float64\";  *addr_ptr = StubRoutines::vector_log1p_float64();  break;\n+            case 128: *name_ptr = \"vector_log1p_float128\"; *addr_ptr = StubRoutines::vector_log1p_float128(); break;\n+            case 256: *name_ptr = \"vector_log1p_float256\"; *addr_ptr = StubRoutines::vector_log1p_float256(); break;\n+            case 512: *name_ptr = \"vector_log1p_float512\"; *addr_ptr = StubRoutines::vector_log1p_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_float64\";  *addr_ptr = StubRoutines::vector_log_float64();  break;\n+            case 128: *name_ptr = \"vector_log_float128\"; *addr_ptr = StubRoutines::vector_log_float128(); break;\n+            case 256: *name_ptr = \"vector_log_float256\"; *addr_ptr = StubRoutines::vector_log_float256(); break;\n+            case 512: *name_ptr = \"vector_log_float512\"; *addr_ptr = StubRoutines::vector_log_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_float64\";  *addr_ptr = StubRoutines::vector_log10_float64();  break;\n+            case 128: *name_ptr = \"vector_log10_float128\"; *addr_ptr = StubRoutines::vector_log10_float128(); break;\n+            case 256: *name_ptr = \"vector_log10_float256\"; *addr_ptr = StubRoutines::vector_log10_float256(); break;\n+            case 512: *name_ptr = \"vector_log10_float512\"; *addr_ptr = StubRoutines::vector_log10_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_float64\";  *addr_ptr = StubRoutines::vector_expm1_float64();  break;\n+            case 128: *name_ptr = \"vector_expm1_float128\"; *addr_ptr = StubRoutines::vector_expm1_float128(); break;\n+            case 256: *name_ptr = \"vector_expm1_float256\"; *addr_ptr = StubRoutines::vector_expm1_float256(); break;\n+            case 512: *name_ptr = \"vector_expm1_float512\"; *addr_ptr = StubRoutines::vector_expm1_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_float64\";  *addr_ptr = StubRoutines::vector_sin_float64();  break;\n+            case 128: *name_ptr = \"vector_sin_float128\"; *addr_ptr = StubRoutines::vector_sin_float128(); break;\n+            case 256: *name_ptr = \"vector_sin_float256\"; *addr_ptr = StubRoutines::vector_sin_float256(); break;\n+            case 512: *name_ptr = \"vector_sin_float512\"; *addr_ptr = StubRoutines::vector_sin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_float64\";  *addr_ptr = StubRoutines::vector_cos_float64();  break;\n+            case 128: *name_ptr = \"vector_cos_float128\"; *addr_ptr = StubRoutines::vector_cos_float128(); break;\n+            case 256: *name_ptr = \"vector_cos_float256\"; *addr_ptr = StubRoutines::vector_cos_float256(); break;\n+            case 512: *name_ptr = \"vector_cos_float512\"; *addr_ptr = StubRoutines::vector_cos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_float64\";  *addr_ptr = StubRoutines::vector_tan_float64();  break;\n+            case 128: *name_ptr = \"vector_tan_float128\"; *addr_ptr = StubRoutines::vector_tan_float128(); break;\n+            case 256: *name_ptr = \"vector_tan_float256\"; *addr_ptr = StubRoutines::vector_tan_float256(); break;\n+            case 512: *name_ptr = \"vector_tan_float512\"; *addr_ptr = StubRoutines::vector_tan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_float64\";  *addr_ptr = StubRoutines::vector_sinh_float64();  break;\n+            case 128: *name_ptr = \"vector_sinh_float128\"; *addr_ptr = StubRoutines::vector_sinh_float128(); break;\n+            case 256: *name_ptr = \"vector_sinh_float256\"; *addr_ptr = StubRoutines::vector_sinh_float256(); break;\n+            case 512: *name_ptr = \"vector_sinh_float512\"; *addr_ptr = StubRoutines::vector_sinh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_float64\";  *addr_ptr = StubRoutines::vector_cosh_float64();  break;\n+            case 128: *name_ptr = \"vector_cosh_float128\"; *addr_ptr = StubRoutines::vector_cosh_float128(); break;\n+            case 256: *name_ptr = \"vector_cosh_float256\"; *addr_ptr = StubRoutines::vector_cosh_float256(); break;\n+            case 512: *name_ptr = \"vector_cosh_float512\"; *addr_ptr = StubRoutines::vector_cosh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_float64\";  *addr_ptr = StubRoutines::vector_tanh_float64();  break;\n+            case 128: *name_ptr = \"vector_tanh_float128\"; *addr_ptr = StubRoutines::vector_tanh_float128(); break;\n+            case 256: *name_ptr = \"vector_tanh_float256\"; *addr_ptr = StubRoutines::vector_tanh_float256(); break;\n+            case 512: *name_ptr = \"vector_tanh_float512\"; *addr_ptr = StubRoutines::vector_tanh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_float64\";  *addr_ptr = StubRoutines::vector_asin_float64();  break;\n+            case 128: *name_ptr = \"vector_asin_float128\"; *addr_ptr = StubRoutines::vector_asin_float128(); break;\n+            case 256: *name_ptr = \"vector_asin_float256\"; *addr_ptr = StubRoutines::vector_asin_float256(); break;\n+            case 512: *name_ptr = \"vector_asin_float512\"; *addr_ptr = StubRoutines::vector_asin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_float64\";  *addr_ptr = StubRoutines::vector_acos_float64();  break;\n+            case 128: *name_ptr = \"vector_acos_float128\"; *addr_ptr = StubRoutines::vector_acos_float128(); break;\n+            case 256: *name_ptr = \"vector_acos_float256\"; *addr_ptr = StubRoutines::vector_acos_float256(); break;\n+            case 512: *name_ptr = \"vector_acos_float512\"; *addr_ptr = StubRoutines::vector_acos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_float64\";  *addr_ptr = StubRoutines::vector_atan_float64();  break;\n+            case 128: *name_ptr = \"vector_atan_float128\"; *addr_ptr = StubRoutines::vector_atan_float128(); break;\n+            case 256: *name_ptr = \"vector_atan_float256\"; *addr_ptr = StubRoutines::vector_atan_float256(); break;\n+            case 512: *name_ptr = \"vector_atan_float512\"; *addr_ptr = StubRoutines::vector_atan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_float64\";  *addr_ptr = StubRoutines::vector_cbrt_float64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_float128\"; *addr_ptr = StubRoutines::vector_cbrt_float128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_float256\"; *addr_ptr = StubRoutines::vector_cbrt_float256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_float512\"; *addr_ptr = StubRoutines::vector_cbrt_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+       case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_float64\";  *addr_ptr = StubRoutines::vector_hypot_float64();  break;\n+            case 128: *name_ptr = \"vector_hypot_float128\"; *addr_ptr = StubRoutines::vector_hypot_float128(); break;\n+            case 256: *name_ptr = \"vector_hypot_float256\"; *addr_ptr = StubRoutines::vector_hypot_float256(); break;\n+            case 512: *name_ptr = \"vector_hypot_float512\"; *addr_ptr = StubRoutines::vector_hypot_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_float64\";  *addr_ptr = StubRoutines::vector_pow_float64();  break;\n+            case 128: *name_ptr = \"vector_pow_float128\"; *addr_ptr = StubRoutines::vector_pow_float128(); break;\n+            case 256: *name_ptr = \"vector_pow_float256\"; *addr_ptr = StubRoutines::vector_pow_float256(); break;\n+            case 512: *name_ptr = \"vector_pow_float512\"; *addr_ptr = StubRoutines::vector_pow_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_float64\";  *addr_ptr = StubRoutines::vector_atan2_float64();  break;\n+            case 128: *name_ptr = \"vector_atan2_float128\"; *addr_ptr = StubRoutines::vector_atan2_float128(); break;\n+            case 256: *name_ptr = \"vector_atan2_float256\"; *addr_ptr = StubRoutines::vector_atan2_float256(); break;\n+            case 512: *name_ptr = \"vector_atan2_float512\"; *addr_ptr = StubRoutines::vector_atan2_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  } else {\n+    assert(bt == T_DOUBLE, \"must be FP type only\");\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_double64\";  *addr_ptr = StubRoutines::vector_exp_double64();  break;\n+            case 128: *name_ptr = \"vector_exp_double128\"; *addr_ptr = StubRoutines::vector_exp_double128(); break;\n+            case 256: *name_ptr = \"vector_exp_double256\"; *addr_ptr = StubRoutines::vector_exp_double256(); break;\n+            case 512: *name_ptr = \"vector_exp_double512\"; *addr_ptr = StubRoutines::vector_exp_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_double64\";  *addr_ptr = StubRoutines::vector_log1p_double64();  break;\n+            case 128: *name_ptr = \"vector_log1p_double128\"; *addr_ptr = StubRoutines::vector_log1p_double128(); break;\n+            case 256: *name_ptr = \"vector_log1p_double256\"; *addr_ptr = StubRoutines::vector_log1p_double256(); break;\n+            case 512: *name_ptr = \"vector_log1p_double512\"; *addr_ptr = StubRoutines::vector_log1p_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_double64\";  *addr_ptr = StubRoutines::vector_log_double64();  break;\n+            case 128: *name_ptr = \"vector_log_double128\"; *addr_ptr = StubRoutines::vector_log_double128(); break;\n+            case 256: *name_ptr = \"vector_log_double256\"; *addr_ptr = StubRoutines::vector_log_double256(); break;\n+            case 512: *name_ptr = \"vector_log_double512\"; *addr_ptr = StubRoutines::vector_log_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_double64\";  *addr_ptr = StubRoutines::vector_log10_double64();  break;\n+            case 128: *name_ptr = \"vector_log10_double128\"; *addr_ptr = StubRoutines::vector_log10_double128(); break;\n+            case 256: *name_ptr = \"vector_log10_double256\"; *addr_ptr = StubRoutines::vector_log10_double256(); break;\n+            case 512: *name_ptr = \"vector_log10_double512\"; *addr_ptr = StubRoutines::vector_log10_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_double64\";  *addr_ptr = StubRoutines::vector_expm1_double64();  break;\n+            case 128: *name_ptr = \"vector_expm1_double128\"; *addr_ptr = StubRoutines::vector_expm1_double128(); break;\n+            case 256: *name_ptr = \"vector_expm1_double256\"; *addr_ptr = StubRoutines::vector_expm1_double256(); break;\n+            case 512: *name_ptr = \"vector_expm1_double512\"; *addr_ptr = StubRoutines::vector_expm1_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_double64\";  *addr_ptr = StubRoutines::vector_sin_double64();  break;\n+            case 128: *name_ptr = \"vector_sin_double128\"; *addr_ptr = StubRoutines::vector_sin_double128(); break;\n+            case 256: *name_ptr = \"vector_sin_double256\"; *addr_ptr = StubRoutines::vector_sin_double256(); break;\n+            case 512: *name_ptr = \"vector_sin_double512\"; *addr_ptr = StubRoutines::vector_sin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_double64\";  *addr_ptr = StubRoutines::vector_cos_double64();  break;\n+            case 128: *name_ptr = \"vector_cos_double128\"; *addr_ptr = StubRoutines::vector_cos_double128(); break;\n+            case 256: *name_ptr = \"vector_cos_double256\"; *addr_ptr = StubRoutines::vector_cos_double256(); break;\n+            case 512: *name_ptr = \"vector_cos_double512\"; *addr_ptr = StubRoutines::vector_cos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_double64\";  *addr_ptr = StubRoutines::vector_tan_double64();  break;\n+            case 128: *name_ptr = \"vector_tan_double128\"; *addr_ptr = StubRoutines::vector_tan_double128(); break;\n+            case 256: *name_ptr = \"vector_tan_double256\"; *addr_ptr = StubRoutines::vector_tan_double256(); break;\n+            case 512: *name_ptr = \"vector_tan_double512\"; *addr_ptr = StubRoutines::vector_tan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_double64\";  *addr_ptr = StubRoutines::vector_sinh_double64();  break;\n+            case 128: *name_ptr = \"vector_sinh_double128\"; *addr_ptr = StubRoutines::vector_sinh_double128(); break;\n+            case 256: *name_ptr = \"vector_sinh_double256\"; *addr_ptr = StubRoutines::vector_sinh_double256(); break;\n+            case 512: *name_ptr = \"vector_sinh_double512\"; *addr_ptr = StubRoutines::vector_sinh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_double64\";  *addr_ptr = StubRoutines::vector_cosh_double64();  break;\n+            case 128: *name_ptr = \"vector_cosh_double128\"; *addr_ptr = StubRoutines::vector_cosh_double128(); break;\n+            case 256: *name_ptr = \"vector_cosh_double256\"; *addr_ptr = StubRoutines::vector_cosh_double256(); break;\n+            case 512: *name_ptr = \"vector_cosh_double512\"; *addr_ptr = StubRoutines::vector_cosh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_double64\";  *addr_ptr = StubRoutines::vector_tanh_double64();  break;\n+            case 128: *name_ptr = \"vector_tanh_double128\"; *addr_ptr = StubRoutines::vector_tanh_double128(); break;\n+            case 256: *name_ptr = \"vector_tanh_double256\"; *addr_ptr = StubRoutines::vector_tanh_double256(); break;\n+            case 512: *name_ptr = \"vector_tanh_double512\"; *addr_ptr = StubRoutines::vector_tanh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_double64\";  *addr_ptr = StubRoutines::vector_asin_double64();  break;\n+            case 128: *name_ptr = \"vector_asin_double128\"; *addr_ptr = StubRoutines::vector_asin_double128(); break;\n+            case 256: *name_ptr = \"vector_asin_double256\"; *addr_ptr = StubRoutines::vector_asin_double256(); break;\n+            case 512: *name_ptr = \"vector_asin_double512\"; *addr_ptr = StubRoutines::vector_asin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_double64\";  *addr_ptr = StubRoutines::vector_acos_double64();  break;\n+            case 128: *name_ptr = \"vector_acos_double128\"; *addr_ptr = StubRoutines::vector_acos_double128(); break;\n+            case 256: *name_ptr = \"vector_acos_double256\"; *addr_ptr = StubRoutines::vector_acos_double256(); break;\n+            case 512: *name_ptr = \"vector_acos_double512\"; *addr_ptr = StubRoutines::vector_acos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_double64\";  *addr_ptr = StubRoutines::vector_atan_double64();  break;\n+            case 128: *name_ptr = \"vector_atan_double128\"; *addr_ptr = StubRoutines::vector_atan_double128(); break;\n+            case 256: *name_ptr = \"vector_atan_double256\"; *addr_ptr = StubRoutines::vector_atan_double256(); break;\n+            case 512: *name_ptr = \"vector_atan_double512\"; *addr_ptr = StubRoutines::vector_atan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_double64\";  *addr_ptr = StubRoutines::vector_cbrt_double64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_double128\"; *addr_ptr = StubRoutines::vector_cbrt_double128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_double256\"; *addr_ptr = StubRoutines::vector_cbrt_double256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_double512\"; *addr_ptr = StubRoutines::vector_cbrt_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_double64\";  *addr_ptr = StubRoutines::vector_hypot_double64();  break;\n+            case 128: *name_ptr = \"vector_hypot_double128\"; *addr_ptr = StubRoutines::vector_hypot_double128(); break;\n+            case 256: *name_ptr = \"vector_hypot_double256\"; *addr_ptr = StubRoutines::vector_hypot_double256(); break;\n+            case 512: *name_ptr = \"vector_hypot_double512\"; *addr_ptr = StubRoutines::vector_hypot_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_double64\";  *addr_ptr = StubRoutines::vector_pow_double64();  break;\n+            case 128: *name_ptr = \"vector_pow_double128\"; *addr_ptr = StubRoutines::vector_pow_double128(); break;\n+            case 256: *name_ptr = \"vector_pow_double256\"; *addr_ptr = StubRoutines::vector_pow_double256(); break;\n+            case 512: *name_ptr = \"vector_pow_double512\"; *addr_ptr = StubRoutines::vector_pow_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_double64\";  *addr_ptr = StubRoutines::vector_atan2_double64();  break;\n+            case 128: *name_ptr = \"vector_atan2_double128\"; *addr_ptr = StubRoutines::vector_atan2_double128(); break;\n+            case 256: *name_ptr = \"vector_atan2_double256\"; *addr_ptr = StubRoutines::vector_atan2_double256(); break;\n+            case 512: *name_ptr = \"vector_atan2_double512\"; *addr_ptr = StubRoutines::vector_atan2_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  }\n+#else\n+  *name_ptr = \"invalid\";\n+  *addr_ptr = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+}\n+\n+Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(opd1 != NULL, \"must not be null\");\n+  const TypeVect* vt = TypeVect::make(bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != NULL ? 2 : 1, vt, vt);\n+  const char* name = NULL;\n+  address addr = NULL;\n+\n+  \/\/ Get address for svml method.\n+  get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, &name, &addr);\n+\n+  if (addr == NULL) {\n+    return NULL;\n+  }\n+\n+  assert(name != NULL, \"name must not be null\");\n+  Node* operation = make_runtime_call(RC_VECTOR,\n+                                      call_type,\n+                                      addr,\n+                                      name,\n+                                      TypePtr::BOTTOM,\n+                                      opd1,\n+                                      opd2);\n+  return gvn().transform(new ProjNode(gvn().transform(operation), TypeFunc::Parms));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":539,"deletions":16,"binary":false,"changes":555,"status":"modified"},{"patch":"@@ -4099,0 +4099,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -382,0 +382,4 @@\n+  static int vector_calling_convention(VMRegPair *regs,\n+                                       uint num_bits,\n+                                       uint total_args_passed);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1528,0 +1528,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/globalDefinitions_vecApi.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -794,0 +794,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -826,0 +826,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -890,0 +890,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -778,0 +778,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -764,0 +764,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1770,11 +1756,14 @@\n-    private static\n-    boolean compareWithOp(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, byte a, byte b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Byte.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Byte.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Byte.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Byte.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2838,0 +2827,159 @@\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ByteVector zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n@@ -2964,1 +3112,1 @@\n-     * Stores this vector into an array of {@code byte}\n+     * Stores this vector into an array of type {@code byte[]}\n@@ -3080,0 +3228,168 @@\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ByteSpecies vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<Byte> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ByteSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n@@ -3186,0 +3502,16 @@\n+\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    ByteVector fromBooleanArray0Template(boolean[] a, int offset) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+\n@@ -3316,0 +3648,11 @@\n+\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":369,"deletions":26,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -762,0 +762,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -766,0 +766,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,0 +760,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -759,0 +759,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -552,31 +538,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (double) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (double) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (double) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (double) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (double) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (double) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (double) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (double) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (double) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (double) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (double) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (double) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (double) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (double) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (double) Math.log1p(a));\n-            }\n@@ -594,0 +549,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log10(a));\n@@ -596,0 +569,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log1p(a));\n@@ -642,7 +627,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (double) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (double) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (double) Math.hypot(a, b));\n-            }\n@@ -668,0 +646,8 @@\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.hypot(a, b));\n@@ -1683,11 +1669,10 @@\n-    private static\n-    boolean compareWithOp(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, double a, double b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n@@ -2745,0 +2730,2 @@\n+\n+\n@@ -2877,1 +2864,1 @@\n-     * Stores this vector into an array of {@code double}\n+     * Stores this vector into an array of type {@code double[]}\n@@ -3034,0 +3021,2 @@\n+\n+\n@@ -3140,0 +3129,2 @@\n+\n+\n@@ -3275,0 +3266,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":57,"deletions":64,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -766,0 +766,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -790,0 +790,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -762,0 +762,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -759,0 +759,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -552,31 +538,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (float) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (float) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (float) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (float) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (float) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (float) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (float) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (float) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (float) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (float) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (float) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (float) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (float) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (float) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (float) Math.log1p(a));\n-            }\n@@ -594,0 +549,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log10(a));\n@@ -596,0 +569,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log1p(a));\n@@ -642,7 +627,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (float) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (float) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (float) Math.hypot(a, b));\n-            }\n@@ -668,0 +646,8 @@\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.hypot(a, b));\n@@ -1695,11 +1681,10 @@\n-    private static\n-    boolean compareWithOp(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, float a, float b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n@@ -2751,0 +2736,2 @@\n+\n+\n@@ -2883,1 +2870,1 @@\n-     * Stores this vector into an array of {@code float}\n+     * Stores this vector into an array of type {@code float[]}\n@@ -3021,0 +3008,2 @@\n+\n+\n@@ -3127,0 +3116,2 @@\n+\n+\n@@ -3262,0 +3253,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":57,"deletions":64,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -770,0 +770,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -778,0 +778,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,0 +794,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -766,0 +766,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -775,0 +775,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1769,11 +1755,14 @@\n-    private static\n-    boolean compareWithOp(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, int a, int b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Integer.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Integer.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Integer.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Integer.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2854,0 +2843,2 @@\n+\n+\n@@ -2986,1 +2977,1 @@\n-     * Stores this vector into an array of {@code int}\n+     * Stores this vector into an array of type {@code int[]}\n@@ -3124,0 +3115,2 @@\n+\n+\n@@ -3230,0 +3223,2 @@\n+\n+\n@@ -3365,0 +3360,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -756,0 +756,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,0 +760,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -768,0 +768,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -754,0 +754,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -754,0 +754,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1687,11 +1673,14 @@\n-    private static\n-    boolean compareWithOp(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, long a, long b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Long.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Long.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Long.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Long.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2738,0 +2727,2 @@\n+\n+\n@@ -2870,1 +2861,1 @@\n-     * Stores this vector into an array of {@code long}\n+     * Stores this vector into an array of type {@code long[]}\n@@ -3027,0 +3018,2 @@\n+\n+\n@@ -3133,0 +3126,2 @@\n+\n+\n@@ -3268,0 +3263,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -778,0 +778,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -794,0 +794,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -826,0 +826,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -770,0 +770,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -764,0 +764,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1770,11 +1756,14 @@\n-    private static\n-    boolean compareWithOp(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Short.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Short.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Short.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Short.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2838,0 +2827,153 @@\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ShortVector zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Short> m) {\n+        \/\/ FIXME: optimize\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n@@ -2970,1 +3112,1 @@\n-     * Stores this vector into an array of {@code short}\n+     * Stores this vector into an array of type {@code short[]}\n@@ -3086,0 +3228,155 @@\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Short> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ShortSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Short> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+\n@@ -3192,0 +3489,16 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    ShortVector fromCharArray0Template(char[] a, int offset) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+\n@@ -3327,0 +3640,11 @@\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":350,"deletions":26,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -386,14 +386,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -572,33 +558,0 @@\n-#if[FP]\n-            if (op == SIN) {\n-                return uOp((i, a) -> ($type$) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> ($type$) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> ($type$) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> ($type$) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> ($type$) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> ($type$) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> ($type$) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> ($type$) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> ($type$) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> ($type$) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> ($type$) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> ($type$) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> ($type$) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> ($type$) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> ($type$) Math.log1p(a));\n-            }\n-#end[FP]\n@@ -617,0 +570,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log10(a));\n@@ -619,0 +590,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log1p(a));\n@@ -692,9 +675,0 @@\n-#if[FP]\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.hypot(a, b));\n-            }\n-#end[FP]\n@@ -734,0 +708,10 @@\n+#if[FP]\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.hypot(a, b));\n+#end[FP]\n@@ -2035,11 +2019,16 @@\n-    private static\n-    boolean compareWithOp(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+#if[!FP]\n+            case BT_ult -> $Boxtype$.compareUnsigned(a, b) < 0;\n+            case BT_ule -> $Boxtype$.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> $Boxtype$.compareUnsigned(a, b) > 0;\n+            case BT_uge -> $Boxtype$.compareUnsigned(a, b) >= 0;\n+#end[!FP]\n+            default -> throw new AssertionError();\n+        };\n@@ -3378,0 +3367,1 @@\n+#if[short]\n@@ -3379,14 +3369,6 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n@@ -3395,4 +3377,3 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n@@ -3400,2 +3381,1 @@\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n@@ -3406,4 +3386,3 @@\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n@@ -3411,1 +3390,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n@@ -3415,3 +3394,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n@@ -3420,31 +3398,7 @@\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * $Type$Buffer eb = bb.duplicate()\n-     *     .position(offset){#if[byte]?;}\n-#if[!byte]\n-     *     .order(bo).as$Type$Buffer();\n-#end[!byte]\n-     * $type$[] ar = new $type$[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n@@ -3453,3 +3407,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n+     * @param a the array\n+     * @param offset the offset into the array\n@@ -3457,1 +3410,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return the vector loaded from an array\n@@ -3459,2 +3412,1 @@\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n@@ -3466,4 +3418,3 @@\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<$Boxtype$> m) {\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<$Boxtype$> m) {\n@@ -3471,1 +3422,1 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n@@ -3473,2 +3424,1 @@\n-            $abstractvectortype$ v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n@@ -3478,35 +3428,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-    }\n-\n-    \/\/ Memory store operations\n-\n-    \/**\n-     * Stores this vector into an array of type {@code $type$[]}\n-     * starting at an offset.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane element at index {@code N} is stored into the array\n-     * element {@code a[offset+N]}.\n-     *\n-     * @param a the array, of type {@code $type$[]}\n-     * @param offset the offset into the array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public final\n-    void intoArray($type$[] a, int offset) {\n-        offset = checkFromIndexSize(offset, length(), a.length);\n-        $Type$Species vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, arrayAddress(a, offset),\n-            this,\n-            a, offset,\n-            (arr, off, v)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n@@ -3516,2 +3433,7 @@\n-     * Stores this vector into an array of {@code $type$}\n-     * starting at offset and using a mask.\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n@@ -3520,10 +3442,4 @@\n-     * the lane element at index {@code N} is stored into the array\n-     * element {@code a[offset+N]}.\n-     * If the mask lane at {@code N} is unset then the corresponding\n-     * array element {@code a[offset+N]} is left unchanged.\n-     * <p>\n-     * Array range checking is done for lanes where the mask is set.\n-     * Lanes where the mask is unset are not stored and do not need\n-     * to correspond to legitimate elements of {@code a}.\n-     * That is, unset lanes may correspond to array indexes less than\n-     * zero or beyond the end of the array.\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n@@ -3531,3 +3447,8 @@\n-     * @param a the array, of type {@code $type$[]}\n-     * @param offset the offset into the array\n-     * @param m the mask controlling lane storage\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n@@ -3535,1 +3456,4 @@\n-     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n@@ -3537,1 +3461,1 @@\n-     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n@@ -3540,11 +3464,7 @@\n-    public final\n-    void intoArray($type$[] a, int offset,\n-                   VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset);\n-        } else {\n-            \/\/ FIXME: optimize\n-            $Type$Species vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n-            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = v);\n-        }\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3554,1 +3474,3 @@\n-     * Scatters this vector into an array of type {@code $type$[]}\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n@@ -3562,2 +3484,3 @@\n-     * the lane element at index {@code N} is stored into the array\n-     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n@@ -3566,0 +3489,1 @@\n+     * Unset lanes in the resulting vector are set to zero.\n@@ -3567,0 +3491,1 @@\n+     * @param species species of desired vector\n@@ -3568,1 +3493,3 @@\n-     * @param offset an offset to combine with the index map offsets\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n@@ -3571,0 +3498,2 @@\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n@@ -3577,0 +3506,1 @@\n+     *         where the mask is set\n@@ -3579,9 +3509,8 @@\n-#if[byteOrShort]\n-    public final\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3590,1 +3519,22 @@\n-#else[byteOrShort]\n+#end[short]\n+\n+#if[byte]\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n@@ -3592,10 +3542,7 @@\n-    public final\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        $Type$Species vsp = vspecies();\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset]);\n-            return;\n-        }\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n@@ -3603,3 +3550,359 @@\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+#end[byte]\n+\n+    \/**\n+     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n+     * starting at an offset into the byte buffer.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n+     * fromByteBuffer()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param bb the byte buffer\n+     * @param offset the offset into the byte buffer\n+     * @param bo the intended byte order\n+     * @return a vector loaded from a byte buffer\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n+                                        ByteBuffer bb, int offset,\n+                                        ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n+     * starting at an offset into the byte buffer\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * $Type$Buffer eb = bb.duplicate()\n+     *     .position(offset){#if[byte]?;}\n+#if[!byte]\n+     *     .order(bo).as$Type$Buffer();\n+#end[!byte]\n+     * $type$[] ar = new $type$[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = eb.get(n);\n+     *     }\n+     * }\n+     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+#if[!byte]\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+#else[!byte]\n+     * The byte order argument is ignored.\n+#end[!byte]\n+     *\n+     * @param species species of desired vector\n+     * @param bb the byte buffer\n+     * @param offset the offset into the byte buffer\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from a byte buffer\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n+                                        ByteBuffer bb, int offset,\n+                                        ByteOrder bo,\n+                                        VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            $abstractvectortype$ v = zero.fromByteBuffer0(bb, offset);\n+            return zero.blend(v.maybeSwap(bo), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n+        ByteBuffer wb = wrapper(bb, bo);\n+        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n+                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code $type$[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code $type$[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code $type$[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code $type$[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code $type$[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+#if[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+#else[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        $Type$Species vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+#if[longOrDouble]\n+        if (vsp.laneCount() == 1) {\n+            intoArray(a, offset + indexMap[mapOffset]);\n+            return;\n+        }\n+\n+        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n+        IntVector vix;\n+        if (isp.laneCount() != vsp.laneCount()) {\n@@ -3632,2 +3935,99 @@\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n+            isp.vectorType(),\n+            a, arrayAddress(a, 0), vix,\n+            this,\n+            a, offset, indexMap, mapOffset,\n+            (arr, off, v, map, mo)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> {\n+                          int j = map[mo + i];\n+                          arr[off + j] = e;\n+                      }));\n+    }\n+#end[byteOrShort]\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code $type$[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+#if[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<$Boxtype$> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+#else[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset, indexMap, mapOffset);\n+        }\n+        else {\n+            \/\/ FIXME: Cannot vectorize yet, if there's a mask.\n+            stOp(a, offset, m,\n+                 (arr, off, i, e) -> {\n+                     int j = indexMap[mapOffset + i];\n+                     arr[off + j] = e;\n+                 });\n+        }\n+    }\n+#end[byteOrShort]\n+\n+#if[short]\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n@@ -3635,2 +4035,2 @@\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo)\n+            a, offset,\n+            (arr, off, v)\n@@ -3638,4 +4038,1 @@\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n@@ -3643,1 +4040,0 @@\n-#end[byteOrShort]\n@@ -3646,1 +4042,80 @@\n-     * Scatters this vector into an array of type {@code $type$[]},\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n@@ -3656,1 +4131,3 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n@@ -3675,1 +4152,0 @@\n-#if[byteOrShort]\n@@ -3678,3 +4154,4 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<$Boxtype$> m) {\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n@@ -3684,1 +4161,1 @@\n-                 arr[off + j] = e;\n+                 arr[off + j] = (char) e;\n@@ -3687,1 +4164,21 @@\n-#else[byteOrShort]\n+#end[short]\n+\n+#if[byte]\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n@@ -3690,3 +4187,46 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<$Boxtype$> m) {\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<$Boxtype$> m) {\n@@ -3694,9 +4234,6 @@\n-            intoArray(a, offset, indexMap, mapOffset);\n-        }\n-        else {\n-            \/\/ FIXME: Cannot vectorize yet, if there's a mask.\n-            stOp(a, offset, m,\n-                 (arr, off, i, e) -> {\n-                     int j = indexMap[mapOffset + i];\n-                     arr[off + j] = e;\n-                 });\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n@@ -3705,1 +4242,92 @@\n-#end[byteOrShort]\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+#end[byte]\n@@ -3813,0 +4441,34 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+#end[short]\n+\n+#if[byte]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromBooleanArray0Template(boolean[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+#end[byte]\n+\n@@ -3950,0 +4612,24 @@\n+#if[short]\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+#end[short]\n+\n+#if[byte]\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":945,"deletions":259,"binary":false,"changes":1204,"status":"modified"},{"patch":"@@ -1052,0 +1052,18 @@\n+#if[short]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[short]\n+\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}