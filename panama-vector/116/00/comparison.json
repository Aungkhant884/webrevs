{"files":[{"patch":"@@ -2406,2 +2406,0 @@\n-    case Op_LoadVectorMask:\n-    case Op_StoreVectorMask:\n@@ -2703,2 +2701,5 @@\n-  if (is_vshift_con_pattern(n, m)) { \/\/ ShiftV src (ShiftCntV con)\n-    mstack.push(m, Visit);           \/\/ m = ShiftCntV\n+  \/\/ ShiftV src (ShiftCntV con)\n+  \/\/ * (VectorStoreMask src)\n+  if (is_vshift_con_pattern(n, m) ||\n+      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask)) {\n+    mstack.push(m, Visit);\n@@ -2707,0 +2708,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1892,1 +1892,1 @@\n-\/\/ load\/store mask vector\n+\/\/ Combine LoadVector+VectorLoadMask when the vector element type is not T_BYTE\n@@ -1894,1 +1894,1 @@\n-instruct loadVMask_byte(pRegGov dst, vmemA mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -1896,23 +1896,1 @@\n-            n->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 1);\n-  match(Set dst (LoadVectorMask mem));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_ld1b $tmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $tmp, 0\\t# load vector mask (sve) (B)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ expected vector element type. Convert the vector to predicate.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($tmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmpne(as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-                 ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadVMask_non_byte(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->as_Vector()->length_in_bytes() == MaxVectorSize &&\n@@ -1920,1 +1898,1 @@\n-  match(Set dst (LoadVectorMask mem));\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n@@ -1922,1 +1900,1 @@\n-  ins_cost(5 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -1938,2 +1916,1 @@\n-instruct loadVMask_byte_partial(pRegGov dst, vmemA mem, vReg vtmp,\n-                              pRegGov ptmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV_partial(pRegGov dst, indirect mem, vReg vtmp, pRegGov ptmp, rFlagsReg cr) %{\n@@ -1941,24 +1918,2 @@\n-            n->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 1);\n-  match(Set dst (LoadVectorMask mem));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(6 * SVE_COST);\n-  format %{ \"loadVMask $dst, $mem\\t# load vector mask partial (sve) (B)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ expected vector element type. Convert the vector to predicate.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(to_vect_bt);\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmpne(as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadVMask_non_byte_partial(pRegGov dst, indirect mem, vReg vtmp,\n-                              pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n+            n->as_Vector()->length_in_bytes() > 16 &&\n+            n->as_Vector()->length_in_bytes() < MaxVectorSize &&\n@@ -1966,1 +1921,1 @@\n-  match(Set dst (LoadVectorMask mem));\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n@@ -1969,1 +1924,1 @@\n-  format %{ \"loadVMask $dst, $mem\\t# load vector mask partial (sve) (H\/S\/D)\" %}\n+  format %{ \"vloadmask_loadV $dst, $mem\\t# load vector mask partial (sve) (H\/S\/D)\" %}\n@@ -1984,21 +1939,1 @@\n-instruct storeVMask_byte(vmemA mem, pRegGov src, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->vect_type()->length_in_bytes() == MaxVectorSize &&\n-            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) == 1);\n-  match(Set mem (StoreVectorMask mem src));\n-  effect(TEMP tmp);\n-  format %{ \"sve_cpy $tmp, $src, 1\\n\\t\"\n-            \"sve_st1b $tmp, $mem\\t# store vector mask (sve) (B)\" %}\n-  ins_cost(5 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the src predicate to vector. And store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), __ elemType_to_regVariant(from_vect_bt),\n-               as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+\/\/ Combine VectorStoreMask+StoreVector when the vector element type is not T_BYTE\n@@ -2006,1 +1941,1 @@\n-instruct storeVMask_non_byte(indirect mem, pRegGov src, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pRegGov src, vReg tmp, immI_gt_1 esize) %{\n@@ -2008,3 +1943,2 @@\n-            n->as_StoreVector()->vect_type()->length_in_bytes() == MaxVectorSize &&\n-            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) > 1);\n-  match(Set mem (StoreVectorMask mem src));\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n@@ -2012,0 +1946,1 @@\n+  ins_cost(3 * SVE_COST);\n@@ -2014,1 +1949,0 @@\n-  ins_cost(5 * SVE_COST);\n@@ -2016,2 +1950,0 @@\n-    \/\/ Convert the src predicate to vector. And store the vector elements\n-    \/\/ as boolean values.\n@@ -2019,2 +1951,3 @@\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), __ elemType_to_regVariant(from_vect_bt),\n-               as_PRegister($src$$reg), 1, false);\n+    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy(as_FloatRegister($tmp$$reg), size, as_PRegister($src$$reg), 1, false);\n@@ -2028,25 +1961,2 @@\n-instruct storeVMask_byte_partial(vmemA mem, pRegGov src, vReg vtmp,\n-                               pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->vect_type()->length_in_bytes() < MaxVectorSize &&\n-            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) == 1);\n-  match(Set mem (StoreVectorMask mem src));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"storeVMask $src, $mem\\t# store vector mask partial (sve) (B)\" %}\n-  ins_cost(6 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector\n-    \/\/ elements as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeVMask_non_byte_partial(indirect mem, pRegGov src, vReg vtmp,\n-                               pRegGov ptmp, rFlagsReg cr) %{\n+instruct storeV_vstoremask_partial(indirect mem, pRegGov src, vReg vtmp,\n+                                   immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n@@ -2054,3 +1964,4 @@\n-            n->as_StoreVector()->vect_type()->length_in_bytes() < MaxVectorSize &&\n-            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) > 1);\n-  match(Set mem (StoreVectorMask mem src));\n+            n->as_StoreVector()->memory_size() > 16 &&\n+            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) > 1 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n@@ -2058,1 +1969,1 @@\n-  format %{ \"storeVMask $src, $mem\\t# store vector mask partial (sve) (H\/S\/D)\" %}\n+  format %{ \"storeV_vstoremask $src, $mem\\t# store vector mask partial (sve) (H\/S\/D)\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":25,"deletions":114,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1172,5 +1172,4 @@\n-dnl\n-dnl LOADVMASK($1,    $2  )\n-dnl LOADVMASK(esize, cond)\n-define(`LOADVMASK', `\n-instruct loadVMask_$1(pRegGov dst, ifelse($1, `byte', vmemA, indirect) mem, vReg tmp, rFlagsReg cr) %{\n+\n+\/\/ Combine LoadVector+VectorLoadMask when the vector element type is not T_BYTE\n+\n+instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -1178,3 +1177,3 @@\n-            n->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) $2);\n-  match(Set dst (LoadVectorMask mem));\n+            n->as_Vector()->length_in_bytes() == MaxVectorSize &&\n+            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n@@ -1182,1 +1181,1 @@\n-  ins_cost(5 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -1184,1 +1183,1 @@\n-            \"sve_cmpne $dst, $tmp, 0\\t# load vector mask (sve) ($3)\" %}\n+            \"sve_cmpne $dst, $tmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n@@ -1196,36 +1195,3 @@\n-%}')dnl\n-dnl\n-define(`ARGLIST',\n-`ifelse($1, `byte', vmemA, indirect) mem, pRegGov src, vReg tmp')\n-dnl\n-dnl STOREVMASK($1,    $2  )\n-dnl STOREVMASK(esize, cond)\n-define(`STOREVMASK', `\n-instruct storeVMask_$1(ARGLIST($1)) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_StoreVector()->vect_type()->length_in_bytes() == MaxVectorSize &&\n-            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) $2);\n-  match(Set mem (StoreVectorMask mem src));\n-  effect(TEMP tmp);\n-  format %{ \"sve_cpy $tmp, $src, 1\\n\\t\"\n-            \"sve_st1b $tmp, $mem\\t# store vector mask (sve) ($3)\" %}\n-  ins_cost(5 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the src predicate to vector. And store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), __ elemType_to_regVariant(from_vect_bt),\n-               as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-undefine(ARGLIST)dnl\n-dnl\n-dnl LOADVMASK_PARTIAL($1,    $2  )\n-dnl LOADVMASK_PARTIAL(esize, cond)\n-define(`LOADVMASK_PARTIAL', `\n-instruct loadVMask_$1_partial(pRegGov dst, ifelse($1, `byte', vmemA, indirect) mem, vReg vtmp,\n-                              pRegGov ptmp, rFlagsReg cr) %{\n+%}\n+\n+instruct vloadmask_loadV_partial(pRegGov dst, indirect mem, vReg vtmp, pRegGov ptmp, rFlagsReg cr) %{\n@@ -1233,3 +1199,4 @@\n-            n->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) $2);\n-  match(Set dst (LoadVectorMask mem));\n+            n->as_Vector()->length_in_bytes() > 16 &&\n+            n->as_Vector()->length_in_bytes() < MaxVectorSize &&\n+            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n@@ -1238,1 +1205,1 @@\n-  format %{ \"loadVMask $dst, $mem\\t# load vector mask partial (sve) ($3)\" %}\n+  format %{ \"vloadmask_loadV $dst, $mem\\t# load vector mask partial (sve) (H\/S\/D)\" %}\n@@ -1251,7 +1218,26 @@\n-%}')dnl\n-dnl\n-dnl STOREVMASK_PARTIAL($1,    $2  )\n-dnl STOREVMASK_PARTIAL(esize, cond)\n-define(`STOREVMASK_PARTIAL', `\n-instruct storeVMask_$1_partial(ifelse($1, `byte', vmemA, indirect) mem, pRegGov src, vReg vtmp,\n-                               pRegGov ptmp, rFlagsReg cr) %{\n+%}\n+\n+\/\/ Combine VectorStoreMask+StoreVector when the vector element type is not T_BYTE\n+\n+instruct storeV_vstoremask(indirect mem, pRegGov src, vReg tmp, immI_gt_1 esize) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cpy $tmp, $src, 1\\n\\t\"\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy(as_FloatRegister($tmp$$reg), size, as_PRegister($src$$reg), 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),\n+                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_vstoremask_partial(indirect mem, pRegGov src, vReg vtmp,\n+                                   immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n@@ -1259,3 +1245,4 @@\n-            n->as_StoreVector()->vect_type()->length_in_bytes() < MaxVectorSize &&\n-            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) $2);\n-  match(Set mem (StoreVectorMask mem src));\n+            n->as_StoreVector()->memory_size() > 16 &&\n+            type2aelembytes(n->as_StoreVector()->vect_type()->element_basic_type()) > 1 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n@@ -1263,1 +1250,1 @@\n-  format %{ \"storeVMask $src, $mem\\t# store vector mask partial (sve) ($3)\" %}\n+  format %{ \"storeV_vstoremask $src, $mem\\t# store vector mask partial (sve) (H\/S\/D)\" %}\n@@ -1277,11 +1264,1 @@\n-%}')dnl\n-dnl\n-\/\/ load\/store mask vector\n-LOADVMASK(byte, == 1, B)\n-LOADVMASK(non_byte, > 1, H\/S\/D)\n-LOADVMASK_PARTIAL(byte, == 1, B)\n-LOADVMASK_PARTIAL(non_byte, > 1, H\/S\/D)\n-STOREVMASK(byte, == 1, B)\n-STOREVMASK(non_byte, > 1, H\/S\/D)\n-STOREVMASK_PARTIAL(byte, == 1, B)\n-STOREVMASK_PARTIAL(non_byte, > 1, H\/S\/D)\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":49,"deletions":72,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  if( strcmp(opType,\"LoadVectorMask\")==0 )  return Form::idealV;\n@@ -294,1 +293,0 @@\n-  if( strcmp(opType,\"StoreVectorMask\")==0 )  return Form::idealV;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3520,1 +3520,0 @@\n-    \"LoadVectorMask\", \"StoreVectorMask\",\n@@ -4239,1 +4238,0 @@\n-    \"LoadVectorMask\", \"StoreVectorMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -420,1 +420,0 @@\n-macro(LoadVectorMask)\n@@ -422,1 +421,0 @@\n-macro(StoreVectorMask)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3433,2 +3433,0 @@\n-  case Op_LoadVectorMask:\n-  case Op_StoreVectorMask:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -705,1 +705,0 @@\n-        case Op_StoreVectorMask:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2263,0 +2263,1 @@\n+    case Op_VectorLoadMask:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -791,17 +791,0 @@\n-Node* StoreVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  \/\/ StoreVector (VectorStoreMask src)  ==>  (StoreVectorMask src).\n-  Node* value = in(MemNode::ValueIn);\n-  if (value->Opcode() == Op_VectorStoreMask) {\n-    assert(vect_type()->element_basic_type() == T_BOOLEAN, \"Invalid basic type to store mask\");\n-    const TypeVect* type = value->in(1)->bottom_type()->is_vect();\n-    if (Matcher::match_rule_supported_vector(Op_StoreVectorMask, type->length(), type->element_basic_type())) {\n-      const TypeVect* mem_type = TypeVect::make(T_BOOLEAN, type->length());\n-      return new StoreVectorMaskNode(in(MemNode::Control),\n-                                     in(MemNode::Memory),\n-                                     in(MemNode::Address),\n-                                     adr_type(), value->in(1), mem_type);\n-    }\n-  }\n-  return StoreNode::Ideal(phase, can_reshape);\n-}\n-\n@@ -1063,15 +1046,0 @@\n-Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  \/\/ (VectorLoadMask (LoadVector mem))  ==> (LoadVectorMask mem)\n-  LoadVectorNode* load = this->in(1)->isa_LoadVector();\n-  BasicType out_bt = vect_type()->element_basic_type();\n-  if (load != NULL &&\n-      Matcher::match_rule_supported_vector(Op_LoadVectorMask, length(), out_bt)) {\n-    const TypeVect* mem_type = TypeVect::make(T_BOOLEAN, length());\n-    return new LoadVectorMaskNode(load->in(MemNode::Control),\n-                                  load->in(MemNode::Memory),\n-                                  load->in(MemNode::Address),\n-                                  load->adr_type(), vect_type(), mem_type);\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -782,1 +782,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -961,44 +960,0 @@\n-class LoadVectorMaskNode : public LoadVectorNode {\n- private:\n-  \/**\n-   * The type of the accessed memory, whose basic element type is T_BOOLEAN for mask vector.\n-   * It is different with the basic element type of the node, which can be T_BYTE, T_SHORT,\n-   * T_INT, T_LONG, T_FLOAT or T_DOUBLE.\n-   **\/\n-  const TypeVect* _mem_type;\n-\n- public:\n-  LoadVectorMaskNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, const TypeVect* mt)\n-   : LoadVectorNode(c, mem, adr, at, vt), _mem_type(mt) {\n-    assert(_mem_type->element_basic_type() == T_BOOLEAN, \"Memory type must be T_BOOLEAN\");\n-    init_class_id(Class_LoadVector);\n-  }\n-\n-  virtual int Opcode() const;\n-  virtual int memory_size() const { return _mem_type->length_in_bytes(); }\n-  virtual int store_Opcode() const { return Op_StoreVectorMask; }\n-  virtual uint ideal_reg() const  { return vect_type()->ideal_reg(); }\n-  virtual uint size_of() const { return sizeof(LoadVectorMaskNode); }\n-};\n-\n-class StoreVectorMaskNode : public StoreVectorNode {\n- private:\n-  \/**\n-   * The type of the accessed memory, whose basic element type is T_BOOLEAN for mask vector.\n-   * It is different with the basic element type of the src value, which can be T_BYTE, T_SHORT,\n-   * T_INT, T_LONG, T_FLOAT or T_DOUBLE.\n-   **\/\n-  const TypeVect* _mem_type;\n-\n- public:\n-  StoreVectorMaskNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* src, const TypeVect* mt)\n-   : StoreVectorNode(c, mem, adr, at, src), _mem_type(mt) {\n-    assert(_mem_type->element_basic_type() == T_BOOLEAN, \"Memory type must be T_BOOLEAN\");\n-    init_class_id(Class_StoreVector);\n-  }\n-\n-  virtual int Opcode() const;\n-  virtual int memory_size() const { return _mem_type->length_in_bytes(); }\n-  virtual uint size_of() const { return sizeof(StoreVectorMaskNode); }\n-};\n-\n@@ -1407,1 +1362,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1829,2 +1829,0 @@\n-  declare_c2_type(LoadVectorMaskNode, LoadVectorNode)                     \\\n-  declare_c2_type(StoreVectorMaskNode, StoreVectorNode)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}