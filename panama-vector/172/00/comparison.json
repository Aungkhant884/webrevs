{"files":[{"patch":"@@ -301,1 +301,10 @@\n-        Object za = Array.newInstance(elementType(), laneCount);\n+        Object za;\n+        \/\/ FIXME: Remove following special handling for Halffloat\n+        \/\/ till Valhalla integration when Halffloat will become a\n+        \/\/ primitive class.\n+        if (elementType() == Halffloat.class)  {\n+           za = Array.newInstance(short.class, laneCount);\n+        } else {\n+           za = Array.newInstance(elementType(), laneCount);\n+        }\n+\n@@ -613,0 +622,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            s = HalffloatVector.species(shape); break;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -253,0 +253,9 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public HalffloatVector reinterpretAsHalffloats() {\n+        return (HalffloatVector) asVectorRaw(LaneType.HALFFLOAT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2880,1 +2880,2 @@\n-                   (wb_, o, i)  -> wb_.get(o + i * 1));\n+                   (wb_, o, i) ->\n+                        wb_.get(o + i * 1));\n@@ -3277,1 +3278,2 @@\n-                   (wb_, o, i)  -> wb_.get(o + i * 1));\n+                   (wb_, o, i) ->\n+                        wb_.get(o + i * 1));\n@@ -3759,1 +3761,2 @@\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n+                        (wb_, o, i) ->\n+                            wb_.get(o + i * 1));\n@@ -3778,1 +3781,2 @@\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n+                        (wb_, o, i) ->\n+                            wb_.get(o + i * 1));\n@@ -3794,1 +3798,2 @@\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                            (wb_, o, i) ->\n+                                wb_.get(o + i * 1));\n@@ -3812,1 +3817,2 @@\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                            (wb_, o, i) ->\n+                                wb_.get(o + i * 1));\n@@ -3884,1 +3890,2 @@\n-                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.put(o + i * 1, e));\n@@ -3903,1 +3910,2 @@\n-                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.put(o + i * 1, e));\n@@ -3917,1 +3925,2 @@\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.put(o + i * 1, e));\n@@ -3935,1 +3944,2 @@\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.put(o + i * 1, e));\n@@ -4126,1 +4136,0 @@\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2168,0 +2168,1 @@\n+\n@@ -2678,1 +2679,2 @@\n-                   (wb_, o, i)  -> wb_.getDouble(o + i * 8));\n+                   (wb_, o, i) ->\n+                        wb_.getDouble(o + i * 8));\n@@ -2965,1 +2967,2 @@\n-                   (wb_, o, i)  -> wb_.getDouble(o + i * 8));\n+                   (wb_, o, i) ->\n+                        wb_.getDouble(o + i * 8));\n@@ -3338,1 +3341,2 @@\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                        (wb_, o, i) ->\n+                            wb_.getDouble(o + i * 8));\n@@ -3357,1 +3361,2 @@\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                        (wb_, o, i) ->\n+                            wb_.getDouble(o + i * 8));\n@@ -3373,1 +3378,2 @@\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                            (wb_, o, i) ->\n+                                wb_.getDouble(o + i * 8));\n@@ -3391,1 +3397,2 @@\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                            (wb_, o, i) ->\n+                                wb_.getDouble(o + i * 8));\n@@ -3498,1 +3505,2 @@\n-                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putDouble(o + i * 8, e));\n@@ -3517,1 +3525,2 @@\n-                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putDouble(o + i * 8, e));\n@@ -3531,1 +3540,2 @@\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putDouble(o + i * 8, e));\n@@ -3549,1 +3559,2 @@\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putDouble(o + i * 8, e));\n@@ -3731,1 +3742,0 @@\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2180,0 +2180,1 @@\n+\n@@ -2702,1 +2703,2 @@\n-                   (wb_, o, i)  -> wb_.getFloat(o + i * 4));\n+                   (wb_, o, i) ->\n+                        wb_.getFloat(o + i * 4));\n@@ -2971,1 +2973,2 @@\n-                   (wb_, o, i)  -> wb_.getFloat(o + i * 4));\n+                   (wb_, o, i) ->\n+                        wb_.getFloat(o + i * 4));\n@@ -3307,1 +3310,2 @@\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                        (wb_, o, i) ->\n+                            wb_.getFloat(o + i * 4));\n@@ -3326,1 +3330,2 @@\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                        (wb_, o, i) ->\n+                            wb_.getFloat(o + i * 4));\n@@ -3342,1 +3347,2 @@\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                            (wb_, o, i) ->\n+                                wb_.getFloat(o + i * 4));\n@@ -3360,1 +3366,2 @@\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                            (wb_, o, i) ->\n+                                wb_.getFloat(o + i * 4));\n@@ -3448,1 +3455,2 @@\n-                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putFloat(o + i * 4, e));\n@@ -3467,1 +3475,2 @@\n-                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putFloat(o + i * 4, e));\n@@ -3481,1 +3490,2 @@\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putFloat(o + i * 4, e));\n@@ -3499,1 +3509,2 @@\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putFloat(o + i * 4, e));\n@@ -3681,1 +3692,0 @@\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 1994, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code short} values.\n+ * @author abc\n+ * @version 1.0\n+ * @since  10\/01\/2021\n+ *\/\n+@SuppressWarnings(\"cast\")\n+public final class Halffloat {\n+   \/**\n+    * Display here: {@value}\n+   *\/\n+    static final short MAX_VALUE = valueOf(0x1.fffffeP+127f);\n+    \/* Definitions for FP16 *\/\n+    static final short MIN_VALUE = valueOf(0x0.000002P-126f);\n+    \/* Definitions for FP16 *\/\n+    static final short POSITIVE_INFINITY = valueOf(1.0f\/0.0f);\n+    \/* Definitions for FP16 *\/\n+    static final short NEGATIVE_INFINITY = valueOf(-1.0f\/0.0f);\n+    \/* Definitions for FP16 *\/\n+    static final int SIZE = 16;\n+    \/* Definitions for FP16 *\/\n+    static final int BYTES = SIZE \/ Byte.SIZE;\n+    \/* Definitions for FP16 *\/\n+    private final short value;\n+\n+     \/**\n+     * Returns a new Halffloat.\n+     * @param f the species describing the element type\n+     * @return short value of float provided\n+    *\/    public static Halffloat valueOf(short f) {\n+        return new Halffloat(f);\n+    }\n+    \/**\n+     * Halffloat constructor\n+     * @param value short value assigned to halffloat\n+     *\/\n+     public Halffloat(short value) {\n+        this.value = value;\n+    }\n+     \/**\n+     * Returns floatvalue of a given short value.\n+     * @return a float value of short provided\n+     *\/\n+    public float floatValue() {\n+        int val = (int)value;\n+        float f = Float.intBitsToFloat(((val&0x8000)<<16) | (((val&0x7c00)+0x1C000)<<13) | ((val&0x03FF)<<13));\n+        return f;\n+    }\n+    \/**\n+     * Returns halffloat value of a given float.\n+     * @param f float value to be converted into halffloat\n+     * @return short value of float provided\n+    *\/\n+    public static short valueOf(float f) {\n+        int val = Float.floatToIntBits(f);\n+        val = ((((val>>16)&0x8000)|((((val&0x7f800000)-0x38000000)>>13)&0x7c00)|((val>>13)&0x03ff)));\n+        return (short)val;\n+    }\n+    \/**\n+     * Returns the size, in bits, of vectors of this shape.\n+     * @param bits the species describing the element type\n+     * @return short value of float provided\n+    *\/\n+    public static short shortBitsToHalffloat(short bits) {\n+        return bits;\n+    }\n+    \/**\n+     * Returns the size, in bits, of vectors of this shape.\n+     * @param bits the species describing the element type\n+     * @return short value of float provided\n+    *\/\n+    public static short shortToRawShortBits(short bits) {\n+        return bits;\n+    }\n+    \/**\n+     * Returns the size, in bits, of vectors of this shape.\n+     * @param bits the species describing the element type\n+     * @return short value of float provided\n+    *\/\n+    public static short shortToShortBits(short bits) {\n+        return bits;\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,919 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat128Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_128;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat128Vector> VCLASS = Halffloat128Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat128Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat128Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat128Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat128Vector ZERO = new Halffloat128Vector(new short[VLENGTH]);\n+    static final Halffloat128Vector IOTA = new Halffloat128Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(short e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(long e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat128Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle() { return Halffloat128Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat128Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat128Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat128Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat128Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat128Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector vectorFactory(short[] vec) {\n+        return new Halffloat128Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte128Vector asByteVectorRaw() {\n+        return (Byte128Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(FUnOp f) {\n+        return (Halffloat128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat128Vector)\n+            super.uOpTemplate((Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat128Vector) super.bOpTemplate((Halffloat128Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat128Vector)\n+            super.bOpTemplate((Halffloat128Vector)v, (Halffloat128Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              (Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v1, v2, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector addIndex(int scale) {\n+        return (Halffloat128Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Halffloat> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat128Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op) {\n+        return super.testTemplate(Halffloat128Mask.class, op);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v, (Halffloat128Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.blendTemplate(Halffloat128Mask.class,\n+                                (Halffloat128Vector) v,\n+                                (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.unsliceTemplate(Halffloat128Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    Halffloat128Mask.class,\n+                                    (Halffloat128Shuffle) shuffle,\n+                                    (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s,\n+                                    (Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v,\n+                                     (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat128Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat128Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat128Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat128Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat128Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat128Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat128Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat128Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat128Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask eq(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return xor(m.not());\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @ForceInline\n+        \/* package-private *\/\n+        Halffloat128Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat128Mask maskAll(boolean bit) {\n+            return VectorSupport.broadcastCoerced(Halffloat128Mask.class, short.class, VLENGTH,\n+                                                  (bit ? -1 : 0), null,\n+                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat128Mask  TRUE_MASK = new Halffloat128Mask(true);\n+        private static final Halffloat128Mask FALSE_MASK = new Halffloat128Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat128Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat128Shuffle IOTA = new Halffloat128Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat128Vector)(((AbstractShuffle<Halffloat>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat128Shuffle rearrange(VectorShuffle<Halffloat> shuffle) {\n+            Halffloat128Shuffle s = (Halffloat128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat128Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset) {\n+        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n+        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteBuffer0Template(Halffloat128Mask.class, bb, offset, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset) {\n+        super.intoByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteBuffer0Template(Halffloat128Mask.class, bb, offset, (Halffloat128Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat128Vector.java","additions":919,"deletions":0,"binary":false,"changes":919,"status":"added"},{"patch":"@@ -0,0 +1,935 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat256Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_256;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat256Vector> VCLASS = Halffloat256Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat256Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat256Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat256Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat256Vector ZERO = new Halffloat256Vector(new short[VLENGTH]);\n+    static final Halffloat256Vector IOTA = new Halffloat256Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(short e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(long e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat256Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle() { return Halffloat256Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat256Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat256Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat256Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat256Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat256Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector vectorFactory(short[] vec) {\n+        return new Halffloat256Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte256Vector asByteVectorRaw() {\n+        return (Byte256Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(FUnOp f) {\n+        return (Halffloat256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat256Vector)\n+            super.uOpTemplate((Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat256Vector) super.bOpTemplate((Halffloat256Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat256Vector)\n+            super.bOpTemplate((Halffloat256Vector)v, (Halffloat256Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              (Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v1, v2, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector addIndex(int scale) {\n+        return (Halffloat256Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Halffloat> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat256Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op) {\n+        return super.testTemplate(Halffloat256Mask.class, op);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v, (Halffloat256Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.blendTemplate(Halffloat256Mask.class,\n+                                (Halffloat256Vector) v,\n+                                (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.unsliceTemplate(Halffloat256Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    Halffloat256Mask.class,\n+                                    (Halffloat256Shuffle) shuffle,\n+                                    (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s,\n+                                    (Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v,\n+                                     (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat256Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat256Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat256Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat256Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat256Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat256Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat256Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat256Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat256Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask eq(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return xor(m.not());\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @ForceInline\n+        \/* package-private *\/\n+        Halffloat256Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat256Mask maskAll(boolean bit) {\n+            return VectorSupport.broadcastCoerced(Halffloat256Mask.class, short.class, VLENGTH,\n+                                                  (bit ? -1 : 0), null,\n+                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat256Mask  TRUE_MASK = new Halffloat256Mask(true);\n+        private static final Halffloat256Mask FALSE_MASK = new Halffloat256Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat256Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat256Shuffle IOTA = new Halffloat256Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat256Vector)(((AbstractShuffle<Halffloat>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat256Shuffle rearrange(VectorShuffle<Halffloat> shuffle) {\n+            Halffloat256Shuffle s = (Halffloat256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat256Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset) {\n+        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n+        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteBuffer0Template(Halffloat256Mask.class, bb, offset, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset) {\n+        super.intoByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteBuffer0Template(Halffloat256Mask.class, bb, offset, (Halffloat256Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat256Vector.java","additions":935,"deletions":0,"binary":false,"changes":935,"status":"added"},{"patch":"@@ -0,0 +1,935 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat512Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_512;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat512Vector> VCLASS = Halffloat512Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat512Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat512Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat512Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat512Vector ZERO = new Halffloat512Vector(new short[VLENGTH]);\n+    static final Halffloat512Vector IOTA = new Halffloat512Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(short e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(long e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat512Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle() { return Halffloat512Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat512Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat512Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat512Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat512Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat512Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector vectorFactory(short[] vec) {\n+        return new Halffloat512Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte512Vector asByteVectorRaw() {\n+        return (Byte512Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(FUnOp f) {\n+        return (Halffloat512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat512Vector)\n+            super.uOpTemplate((Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat512Vector) super.bOpTemplate((Halffloat512Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat512Vector)\n+            super.bOpTemplate((Halffloat512Vector)v, (Halffloat512Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              (Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v1, v2, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector addIndex(int scale) {\n+        return (Halffloat512Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Halffloat> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat512Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op) {\n+        return super.testTemplate(Halffloat512Mask.class, op);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v, (Halffloat512Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.blendTemplate(Halffloat512Mask.class,\n+                                (Halffloat512Vector) v,\n+                                (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.unsliceTemplate(Halffloat512Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    Halffloat512Mask.class,\n+                                    (Halffloat512Shuffle) shuffle,\n+                                    (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s,\n+                                    (Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v,\n+                                     (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat512Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat512Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat512Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat512Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat512Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat512Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat512Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat512Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat512Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask eq(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return xor(m.not());\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @ForceInline\n+        \/* package-private *\/\n+        Halffloat512Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat512Mask maskAll(boolean bit) {\n+            return VectorSupport.broadcastCoerced(Halffloat512Mask.class, short.class, VLENGTH,\n+                                                  (bit ? -1 : 0), null,\n+                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat512Mask  TRUE_MASK = new Halffloat512Mask(true);\n+        private static final Halffloat512Mask FALSE_MASK = new Halffloat512Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat512Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat512Shuffle IOTA = new Halffloat512Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat512Vector)(((AbstractShuffle<Halffloat>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat512Shuffle rearrange(VectorShuffle<Halffloat> shuffle) {\n+            Halffloat512Shuffle s = (Halffloat512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat512Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset) {\n+        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n+        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteBuffer0Template(Halffloat512Mask.class, bb, offset, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset) {\n+        super.intoByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteBuffer0Template(Halffloat512Mask.class, bb, offset, (Halffloat512Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat512Vector.java","additions":935,"deletions":0,"binary":false,"changes":935,"status":"added"},{"patch":"@@ -0,0 +1,911 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat64Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_64;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat64Vector> VCLASS = Halffloat64Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    Halffloat64Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat64Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat64Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat64Vector ZERO = new Halffloat64Vector(new short[VLENGTH]);\n+    static final Halffloat64Vector IOTA = new Halffloat64Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(short e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(long e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat64Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle() { return Halffloat64Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat64Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat64Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat64Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat64Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat64Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector vectorFactory(short[] vec) {\n+        return new Halffloat64Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte64Vector asByteVectorRaw() {\n+        return (Byte64Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(FUnOp f) {\n+        return (Halffloat64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (Halffloat64Vector)\n+            super.uOpTemplate((Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (Halffloat64Vector) super.bOpTemplate((Halffloat64Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (Halffloat64Vector)\n+            super.bOpTemplate((Halffloat64Vector)v, (Halffloat64Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              (Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v1, v2, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector addIndex(int scale) {\n+        return (Halffloat64Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Halffloat> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat64Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op) {\n+        return super.testTemplate(Halffloat64Mask.class, op);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v, (Halffloat64Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.blendTemplate(Halffloat64Mask.class,\n+                                (Halffloat64Vector) v,\n+                                (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin, Vector<Halffloat> v) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.unsliceTemplate(Halffloat64Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Halffloat> s) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    Halffloat64Mask.class,\n+                                    (Halffloat64Shuffle) shuffle,\n+                                    (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s,\n+                                    (Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Halffloat> v) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v,\n+                                     (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat64Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat64Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat64Mask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat64Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat64Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat64Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat64Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat64Mask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat64Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask eq(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return xor(m.not());\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @ForceInline\n+        \/* package-private *\/\n+        Halffloat64Mask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat64Mask maskAll(boolean bit) {\n+            return VectorSupport.broadcastCoerced(Halffloat64Mask.class, short.class, VLENGTH,\n+                                                  (bit ? -1 : 0), null,\n+                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat64Mask  TRUE_MASK = new Halffloat64Mask(true);\n+        private static final Halffloat64Mask FALSE_MASK = new Halffloat64Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat64Shuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        Halffloat64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat64Shuffle IOTA = new Halffloat64Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat64Vector)(((AbstractShuffle<Halffloat>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat64Shuffle rearrange(VectorShuffle<Halffloat> shuffle) {\n+            Halffloat64Shuffle s = (Halffloat64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat64Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset) {\n+        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n+        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteBuffer0Template(Halffloat64Mask.class, bb, offset, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset) {\n+        super.intoByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteBuffer0Template(Halffloat64Mask.class, bb, offset, (Halffloat64Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat64Vector.java","additions":911,"deletions":0,"binary":false,"changes":911,"status":"added"},{"patch":"@@ -0,0 +1,904 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class HalffloatMaxVector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<HalffloatMaxVector> VCLASS = HalffloatMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+    HalffloatMaxVector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as HalffloatMaxVector::new,\n+    \/\/ stored into species.vectorFactory.\n+    HalffloatMaxVector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final HalffloatMaxVector ZERO = new HalffloatMaxVector(new short[VLENGTH]);\n+    static final HalffloatMaxVector IOTA = new HalffloatMaxVector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Halffloat.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(short e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(long e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxMask maskFromArray(boolean[] bits) {\n+        return new HalffloatMaxMask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle() { return HalffloatMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (HalffloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, HalffloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (HalffloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, HalffloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new HalffloatMaxShuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new HalffloatMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new HalffloatMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector vectorFactory(short[] vec) {\n+        return new HalffloatMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(FUnOp f) {\n+        return (HalffloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(VectorMask<Halffloat> m, FUnOp f) {\n+        return (HalffloatMaxVector)\n+            super.uOpTemplate((HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Halffloat> v, FBinOp f) {\n+        return (HalffloatMaxVector) super.bOpTemplate((HalffloatMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Halffloat> v,\n+                     VectorMask<Halffloat> m, FBinOp f) {\n+        return (HalffloatMaxVector)\n+            super.bOpTemplate((HalffloatMaxVector)v, (HalffloatMaxMask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Halffloat> v1, Vector<Halffloat> v2,\n+                     VectorMask<Halffloat> m, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              (HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Halffloat,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Halffloat> v) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Halffloat> v1, Vector<Halffloat> v2, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v1, v2, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector addIndex(int scale) {\n+        return (HalffloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Halffloat> m) {\n+        return super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Halffloat> m) {\n+        return (long) super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Halffloat> toShuffle() {\n+        return super.toShuffleTemplate(HalffloatMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op) {\n+        return super.testTemplate(HalffloatMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Halffloat> v) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, short s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v, (HalffloatMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector blend(Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.blendTemplate(HalffloatMaxMask.class,\n+                                (HalffloatMaxVector) v,\n+                                (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin, Vector<Halffloat> v) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Halffloat> w, int part) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.unsliceTemplate(HalffloatMaxMask.class,\n+                                  origin, w, part,\n+                                  (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> s) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> shuffle,\n+                                  VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    HalffloatMaxMask.class,\n+                                    (HalffloatMaxShuffle) shuffle,\n+                                    (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Halffloat> s,\n+                                  Vector<Halffloat> v) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s,\n+                                    (HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Halffloat> v) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Halffloat> v,\n+                                   VectorMask<Halffloat> m) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v,\n+                                     (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        short bits = laneHelper(i);\n+        return Halffloat.shortBitsToHalffloat(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return (long)Halffloat.shortToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public HalffloatMaxVector withLane(int i, short e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public HalffloatMaxVector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Halffloat.shortToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = Halffloat.shortBitsToHalffloat((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class HalffloatMaxMask extends AbstractMask<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        HalffloatMaxMask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        HalffloatMaxMask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        HalffloatMaxMask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        HalffloatMaxMask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @Override\n+        HalffloatMaxMask bOp(VectorMask<Halffloat> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((HalffloatMaxMask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask eq(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return xor(m.not());\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask and(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask or(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @ForceInline\n+        \/* package-private *\/\n+        HalffloatMaxMask xor(VectorMask<Halffloat> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static HalffloatMaxMask maskAll(boolean bit) {\n+            return VectorSupport.broadcastCoerced(HalffloatMaxMask.class, short.class, VLENGTH,\n+                                                  (bit ? -1 : 0), null,\n+                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final HalffloatMaxMask  TRUE_MASK = new HalffloatMaxMask(true);\n+        private static final HalffloatMaxMask FALSE_MASK = new HalffloatMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class HalffloatMaxShuffle extends AbstractShuffle<Halffloat> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Halffloat> ETYPE = Halffloat.class; \/\/ used by the JVM\n+\n+        HalffloatMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public HalffloatMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public HalffloatMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public HalffloatMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final HalffloatMaxShuffle IOTA = new HalffloatMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, HalffloatMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((HalffloatMaxVector)(((AbstractShuffle<Halffloat>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public HalffloatMaxShuffle rearrange(VectorShuffle<Halffloat> shuffle) {\n+            HalffloatMaxShuffle s = (HalffloatMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new HalffloatMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset) {\n+        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n+        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        return super.fromByteBuffer0Template(HalffloatMaxMask.class, bb, offset, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset) {\n+        super.intoByteArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m) {\n+        super.intoByteBuffer0Template(HalffloatMaxMask.class, bb, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m) {\n+        super.intoCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatMaxVector.java","additions":904,"deletions":0,"binary":false,"changes":904,"status":"added"},{"patch":"@@ -0,0 +1,4192 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.ReadOnlyBufferException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+import static jdk.incubator.vector.VectorIntrinsics.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code short} values.\n+ *\/\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+public abstract class HalffloatVector extends AbstractVector<Halffloat> {\n+\n+    HalffloatVector(short[] vec) {\n+        super(vec);\n+    }\n+\n+    static final int FORBID_OPCODE_KIND = VO_NOFP;\n+\n+    @ForceInline\n+    static int opCode(Operator op) {\n+        return VectorOperators.opCode(op, VO_OPCODE_VALID, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static int opCode(Operator op, int requireKind) {\n+        requireKind |= VO_OPCODE_VALID;\n+        return VectorOperators.opCode(op, requireKind, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static boolean opKind(Operator op, int bit) {\n+        return VectorOperators.opKind(op, bit);\n+    }\n+\n+    \/\/ Virtualized factories and operators,\n+    \/\/ coded with portable definitions.\n+    \/\/ These are all @ForceInline in case\n+    \/\/ they need to be used performantly.\n+    \/\/ The various shape-specific subclasses\n+    \/\/ also specialize them by wrapping\n+    \/\/ them in a call like this:\n+    \/\/    return (Byte128Vector)\n+    \/\/       super.bOp((Byte128Vector) o);\n+    \/\/ The purpose of that is to forcibly inline\n+    \/\/ the generic definition from this file\n+    \/\/ into a sharply type- and size-specific\n+    \/\/ wrapper in the subclass file, so that\n+    \/\/ the JIT can specialize the code.\n+    \/\/ The code is only inlined and expanded\n+    \/\/ if it gets hot.  Think of it as a cheap\n+    \/\/ and lazy version of C++ templates.\n+\n+    \/\/ Virtualized getter\n+\n+    \/*package-private*\/\n+    abstract short[] vec();\n+\n+    \/\/ Virtualized constructors\n+\n+    \/**\n+     * Build a vector directly using my own constructor.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    abstract HalffloatVector vectorFactory(short[] vec);\n+\n+    \/**\n+     * Build a mask directly using my species.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Halffloat> maskFactory(boolean[] bits) {\n+        return vspecies().maskFactory(bits);\n+    }\n+\n+    \/\/ Constant loader (takes dummy as vector arg)\n+    interface FVOp {\n+        short apply(int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(FVOp f) {\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(VectorMask<Halffloat> m, FVOp f) {\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Unary operator\n+\n+    \/*package-private*\/\n+    interface FUnOp {\n+        short apply(int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(FUnOp f) {\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(VectorMask<Halffloat> m,\n+                             FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(VectorMask<Halffloat> m,\n+                                     FUnOp f) {\n+        if (m == null) {\n+            return uOpTemplate(f);\n+        }\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Binary operator\n+\n+    \/*package-private*\/\n+    interface FBinOp {\n+        short apply(int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Halffloat> o,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Halffloat> o,\n+                                     FBinOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Halffloat> o,\n+                             VectorMask<Halffloat> m,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Halffloat> o,\n+                                     VectorMask<Halffloat> m,\n+                                     FBinOp f) {\n+        if (m == null) {\n+            return bOpTemplate(o, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    \/*package-private*\/\n+    interface FTriOp {\n+        short apply(int i, short a, short b, short c);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Halffloat> o1,\n+                             Vector<Halffloat> o2,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Halffloat> o1,\n+                                     Vector<Halffloat> o2,\n+                                     FTriOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Halffloat> o1,\n+                             Vector<Halffloat> o2,\n+                             VectorMask<Halffloat> m,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Halffloat> o1,\n+                                     Vector<Halffloat> o2,\n+                                     VectorMask<Halffloat> m,\n+                                     FTriOp f) {\n+        if (m == null) {\n+            return tOpTemplate(o1, o2, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Reduction operator\n+\n+    \/*package-private*\/\n+    abstract\n+    short rOp(short v, VectorMask<Halffloat> m, FBinOp f);\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, VectorMask<Halffloat> m, FBinOp f) {\n+        if (m == null) {\n+            return rOpTemplate(v, f);\n+        }\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        }\n+        return v;\n+    }\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, FBinOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = f.apply(i, v, vec[i]);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Memory reference\n+\n+    \/*package-private*\/\n+    interface FLdOp<M> {\n+        short apply(M memory, int offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  FLdOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  VectorMask<Halffloat> m,\n+                                  FLdOp<M> f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    interface FStOp<M> {\n+        void apply(M memory, int offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  VectorMask<Halffloat> m,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Binary test\n+\n+    \/*package-private*\/\n+    interface FBinTest {\n+        boolean apply(int cond, int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Halffloat> bTest(int cond,\n+                                  Vector<Halffloat> o,\n+                                  FBinTest f) {\n+        short[] vec1 = vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] bits = new boolean[length()];\n+        for (int i = 0; i < length(); i++){\n+            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        }\n+        return maskFactory(bits);\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    abstract HalffloatSpecies vspecies();\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long toBits(short e) {\n+        return  Halffloat.shortToRawShortBits(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short fromBits(long bits) {\n+        return Halffloat.shortBitsToHalffloat((short)bits);\n+    }\n+\n+    \/\/ Static factories (other than memory operations)\n+\n+    \/\/ Note: A surprising behavior in javadoc\n+    \/\/ sometimes makes a lone \/** {@inheritDoc} *\/\n+    \/\/ comment drop the method altogether,\n+    \/\/ apparently if the method mentions an\n+    \/\/ parameter or return type of Vector<Halffloat>\n+    \/\/ instead of Vector<E> as originally specified.\n+    \/\/ Adding an empty HTML fragment appears to\n+    \/\/ nudge javadoc into providing the desired\n+    \/\/ inherited documentation.  We use the HTML\n+    \/\/ comment <!--workaround--> for this.\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * zero, the default primitive value.\n+     *\n+     * @param species species of the desired zero vector\n+     * @return a zero vector\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector zero(VectorSpecies<Halffloat> species) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return VectorSupport.broadcastCoerced(vsp.vectorType(), Halffloat.class, species.length(),\n+                        toBits((short)0), vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+    }\n+\n+    \/**\n+     * Returns a vector of the same species as this one\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The contents of the current vector are discarded;\n+     * only the species is relevant to this operation.\n+     *\n+     * <p> This method returns the value of this expression:\n+     * {@code HalffloatVector.broadcast(this.species(), e)}.\n+     *\n+     * @apiNote\n+     * Unlike the similar method named {@code broadcast()}\n+     * in the supertype {@code Vector}, this method does not\n+     * need to validate its argument, and cannot throw\n+     * {@code IllegalArgumentException}.  This method is\n+     * therefore preferable to the supertype method.\n+     *\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(VectorSpecies,long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    public abstract HalffloatVector broadcast(short e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Halffloat> species, short e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(short e) {\n+        HalffloatSpecies vsp = vspecies();\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #broadcast(short) the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.broadcast((short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @Override\n+    public abstract HalffloatVector broadcast(long e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The {@code long} value must be accurately representable\n+     * by the {@code ETYPE} of the vector species, so that\n+     * {@code e==(long)(ETYPE)e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @throws IllegalArgumentException\n+     *         if the given {@code long} value cannot\n+     *         be represented by the vector's {@code ETYPE}\n+     * @see #broadcast(VectorSpecies,short)\n+     * @see VectorSpecies#checkValue(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Halffloat> species, long e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(long e) {\n+        return vspecies().broadcast(e);\n+    }\n+\n+    \/\/ Unary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op);\n+\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op) {\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0));\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op,\n+                                  VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op,\n+                                          Class<? extends VectorMask<Halffloat>> maskClass,\n+                                          VectorMask<Halffloat> m) {\n+        m.check(maskClass, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0, m));\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        UN_IMPL = new ImplCache<>(Unary.class, HalffloatVector.class);\n+\n+    private static UnaryOperation<HalffloatVector, VectorMask<Halffloat>> unaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_NEG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) -a);\n+            case VECTOR_OP_ABS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.abs(a));\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.sin(a));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.cos(a));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.tan(a));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.asin(a));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.acos(a));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.atan(a));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.exp(a));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.log(a));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.log10(a));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.sqrt(a));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.cbrt(a));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.sinh(a));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.cosh(a));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.tanh(a));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.expm1(a));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.log1p(a));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ Binary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Halffloat> v);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Vector<Halffloat> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Short> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+                that = that.blend((short) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+                return this.viewAsIntegralLanes()\n+                    .lanewise(op, that.viewAsIntegralLanes())\n+                    .viewAsFloatingLanes();\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Halffloat> v,\n+                                  VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Halffloat>> maskClass,\n+                                          Vector<Halffloat> v, VectorMask<Halffloat> m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskClass, this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                return blend(lanewise(op, v), m);\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        BIN_IMPL = new ImplCache<>(Binary.class, HalffloatVector.class);\n+\n+    private static BinaryOperation<HalffloatVector, VectorMask<Halffloat>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ FIXME: Maybe all of the public final methods in this file (the\n+    \/\/ simple ones that just call lanewise) should be pushed down to\n+    \/\/ the X-VectorBits template.  They can't optimize properly at\n+    \/\/ this level, and must rely on inlining.  Does it work?\n+    \/\/ (If it works, of course keep the code here.)\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e))}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the two input vectors\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e) {\n+        return lanewise(op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e), m)}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e,m)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e, VectorMask<Halffloat> m) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1, m);\n+    }\n+\n+\n+    \/\/ Ternary lanewise support\n+\n+    \/\/ Ternary operators come in eight variations:\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2])\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2], mask)\n+\n+    \/\/ It is annoying to support all of these variations of masking\n+    \/\/ and broadcast, but it would be more surprising not to continue\n+    \/\/ the obvious pattern started by unary and binary.\n+\n+   \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                                  Vector<Halffloat> v1,\n+                                                  Vector<Halffloat> v2);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Vector<Halffloat> v1,\n+                                          Vector<Halffloat> v2) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                  Vector<Halffloat> v1,\n+                                  Vector<Halffloat> v2,\n+                                  VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Class<? extends VectorMask<Halffloat>> maskClass,\n+                                          Vector<Halffloat> v1,\n+                                          Vector<Halffloat> v2,\n+                                          VectorMask<Halffloat> m) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        m.check(maskClass, this);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        TERN_IMPL = new ImplCache<>(Ternary.class, HalffloatVector.class);\n+\n+    private static TernaryOperation<HalffloatVector, VectorMask<Halffloat>> ternaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                    Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(),\n+                    Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+            default: return null;\n+        }\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2)\n+                                  short e1,\n+                                  short e2) {\n+        return lanewise(op, broadcast(e1), broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2,m)\n+                                  short e1,\n+                                  short e2,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, broadcast(e1), broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2)\n+                                  Vector<Halffloat> v1,\n+                                  short e2) {\n+        return lanewise(op, v1, broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2,m)\n+                                  Vector<Halffloat> v1,\n+                                  short e2,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, v1, broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2)\n+                                  short e1,\n+                                  Vector<Halffloat> v2) {\n+        return lanewise(op, broadcast(e1), v2);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2, m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2,m)\n+                                  short e1,\n+                                  Vector<Halffloat> v2,\n+                                  VectorMask<Halffloat> m) {\n+        return lanewise(op, broadcast(e1), v2, m);\n+    }\n+\n+    \/\/ (Thus endeth the Great and Mighty Ternary Ogdoad.)\n+    \/\/ https:\/\/en.wikipedia.org\/wiki\/Ogdoad\n+\n+    \/\/\/ FULL-SERVICE BINARY METHODS: ADD, SUB, MUL, DIV\n+    \/\/\n+    \/\/ These include masked and non-masked versions.\n+    \/\/ This subclass adds broadcast (masked or not).\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Halffloat> v) {\n+        return lanewise(ADD, v);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector)\n+     * @see #broadcast(short)\n+     * @see #add(short,VectorMask)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector add(short e) {\n+        return lanewise(ADD, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(ADD, v, m);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #add(short)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector add(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(ADD, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Halffloat> v) {\n+        return lanewise(SUB, v);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector)\n+     * @see #broadcast(short)\n+     * @see #sub(short,VectorMask)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e) {\n+        return lanewise(SUB, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(SUB, v, m);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #sub(short)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(SUB, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Halffloat> v) {\n+        return lanewise(MUL, v);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #mul(Vector)\n+     * @see #broadcast(short)\n+     * @see #mul(short,VectorMask)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e) {\n+        return lanewise(MUL, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(MUL, v, m);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of muling each lane of this vector to the scalar\n+     * @see #mul(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #mul(short)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(MUL, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Halffloat> v) {\n+        return lanewise(DIV, v);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , e)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector)\n+     * @see #broadcast(short)\n+     * @see #div(short,VectorMask)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e) {\n+        return lanewise(DIV, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #div(short,VectorMask)\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Halffloat> v,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(DIV, v, m);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , s, m)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #div(short)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e,\n+                                          VectorMask<Halffloat> m) {\n+        return lanewise(DIV, e, m);\n+    }\n+\n+    \/\/\/ END OF FULL-SERVICE BINARY METHODS\n+\n+    \/\/\/ SECOND-TIER BINARY METHODS\n+    \/\/\n+    \/\/ There are no masked versions.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector min(Vector<Halffloat> v) {\n+        return lanewise(MIN, v);\n+    }\n+\n+    \/\/ FIXME:  \"broadcast of an input scalar\" is really wordy.  Reduce?\n+    \/**\n+     * Computes the smaller of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.min()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MIN\n+     *    MIN}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #min(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MIN\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector min(short e) {\n+        return lanewise(MIN, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector max(Vector<Halffloat> v) {\n+        return lanewise(MAX, v);\n+    }\n+\n+    \/**\n+     * Computes the larger of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.max()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MAX\n+     *    MAX}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #max(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MAX\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector max(short e) {\n+        return lanewise(MAX, e);\n+    }\n+\n+\n+    \/\/ common FP operator: pow\n+    \/**\n+     * Raises this vector to the power of a second input vector.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * <p>\n+     * This is not a full-service named operation like\n+     * {@link #add(Vector) add}.  A masked version of\n+     * this operation is not directly available\n+     * but may be obtained via the masked version of\n+     * {@code lanewise}.\n+     *\n+     * @param b a vector exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(short)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(Vector<Halffloat> b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/**\n+     * Raises this vector to a scalar power.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * @param b a scalar exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(Vector)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(short b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/\/\/ UNARY METHODS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector neg() {\n+        return lanewise(NEG);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector abs() {\n+        return lanewise(ABS);\n+    }\n+\n+\n+    \/\/ sqrt\n+    \/**\n+     * Computes the square root of this vector.\n+     *\n+     * This is a lane-wise unary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#sqrt Math.sqrt(a)}\n+     * to each lane value.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *    lanewise}{@code (}{@link VectorOperators#SQRT\n+     *    SQRT}{@code )}.\n+     *\n+     * @return the square root of this vector\n+     * @see VectorOperators#SQRT\n+     * @see #lanewise(VectorOperators.Unary,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sqrt() {\n+        return lanewise(SQRT);\n+    }\n+\n+    \/\/\/ COMPARISONS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> eq(Vector<Halffloat> v) {\n+        return compare(EQ, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is equal to an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive equals operation ({@code ==}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.Comparison.EQ, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result mask of testing if this vector\n+     *         is equal to {@code e}\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> eq(short e) {\n+        return compare(EQ, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> lt(Vector<Halffloat> v) {\n+        return compare(LT, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is less than an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive less than operation ({@code <}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.LT, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the mask result of testing if this vector\n+     *         is less than the input scalar\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> lt(short e) {\n+        return compare(LT, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> test(VectorOperators.Test op);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M testTemplate(Class<M> maskType, Test op) {\n+        HalffloatSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Halffloat.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits);\n+                } else {\n+                    m = bits.compare(EQ, infbits);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(this.vspecies()));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> test(VectorOperators.Test op,\n+                                  VectorMask<Halffloat> m) {\n+        return test(op).and(m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> compare(VectorOperators.Comparison op, Vector<Halffloat> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Halffloat> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, Halffloat.class, length(),\n+            this, that, null,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Halffloat> m\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) m;\n+                return m2;\n+            });\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Halffloat> v, M m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskType, this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, Halffloat.class, length(),\n+            this, that, m,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Halffloat> cmpM\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) cmpM.and(m1);\n+                return m2;\n+            });\n+    }\n+\n+    @ForceInline\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> Halffloat.valueOf(a).floatValue() == Halffloat.valueOf(b).floatValue();\n+            case BT_ne -> Halffloat.valueOf(a).floatValue() != Halffloat.valueOf(b).floatValue();\n+            case BT_lt -> Halffloat.valueOf(a).floatValue() < Halffloat.valueOf(b).floatValue();\n+            case BT_le -> Halffloat.valueOf(a).floatValue() <= Halffloat.valueOf(b).floatValue();\n+            case BT_gt -> Halffloat.valueOf(a).floatValue() > Halffloat.valueOf(b).floatValue();\n+            case BT_ge -> Halffloat.valueOf(a).floatValue() >= Halffloat.valueOf(b).floatValue();\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the comparison operation to each lane.\n+     * <p>\n+     * The result is the same as\n+     * {@code compare(op, broadcast(species(), e))}.\n+     * That is, the scalar may be regarded as broadcast to\n+     * a vector of the same species, and then compared\n+     * against the original vector, using the selected\n+     * comparison operation.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector)\n+     * @see #eq(short)\n+     * @see #lt(short)\n+     *\/\n+    public abstract\n+    VectorMask<Halffloat> compare(Comparison op, short e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, short e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation,\n+     * in lanes selected by a mask.\n+     *\n+     * This is a masked lane-wise binary test operation which applies\n+     * to each pair of corresponding lane values.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code compare(op,s).and(m)}.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator,\n+     *         and only in the lanes selected by the mask\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final VectorMask<Halffloat> compare(VectorOperators.Comparison op,\n+                                               short e,\n+                                               VectorMask<Halffloat> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Halffloat> compare(Comparison op, long e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    M compareTemplate(Class<M> maskType, Comparison op, long e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Halffloat> compare(Comparison op, long e, VectorMask<Halffloat> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract\n+    HalffloatVector blend(Vector<Halffloat> v, VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector\n+    blendTemplate(Class<M> maskType, HalffloatVector v, M m) {\n+        v.check(this);\n+        return VectorSupport.blend(\n+            getClass(), maskType, Halffloat.class, length(),\n+            this, v, m,\n+            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract HalffloatVector addIndex(int scale);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector addIndexTemplate(int scale) {\n+        HalffloatSpecies vsp = vspecies();\n+        \/\/ make sure VLENGTH*scale doesn't overflow:\n+        vsp.checkScale(scale);\n+        return VectorSupport.indexVector(\n+            getClass(), Halffloat.class, length(),\n+            this, scale, vsp,\n+            (v, scale_, s)\n+            -> {\n+                \/\/ If the platform doesn't support an INDEX\n+                \/\/ instruction directly, load IOTA from memory\n+                \/\/ and multiply.\n+                HalffloatVector iota = s.iota();\n+                short sc = (short) scale_;\n+                return v.add(sc == 1 ? iota : iota.mul(sc));\n+            });\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(short e,\n+                                            VectorMask<Halffloat> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(long e,\n+                                            VectorMask<Halffloat> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin, Vector<Halffloat> v1);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin, Vector<Halffloat> v1) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector slice(int origin,\n+                               Vector<Halffloat> w,\n+                               VectorMask<Halffloat> m) {\n+        return broadcast(0).blend(slice(origin, w), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Halffloat> w, int part);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin, Vector<Halffloat> w, int part) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast((short)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector\n+    unsliceTemplate(Class<M> maskType, int origin, Vector<Halffloat> w, int part, M m) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        HalffloatVector slice = that.sliceTemplate(origin, that);\n+        slice = slice.blendTemplate(maskType, this, m);\n+        return slice.unsliceTemplate(origin, w, part);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Halffloat> w, int part, VectorMask<Halffloat> m);\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Halffloat> iota = iotaShuffle();\n+        VectorMask<Halffloat> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  (broadcast((short)(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    private ArrayIndexOutOfBoundsException\n+    wrongPartForSlice(int part) {\n+        String msg = String.format(\"bad part number %d for slice operation\",\n+                                   part);\n+        return new ArrayIndexOutOfBoundsException(msg);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Halffloat>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {\n+        shuffle.checkIndexes();\n+        return VectorSupport.rearrangeOp(\n+            getClass(), shuffletype, null, Halffloat.class, length(),\n+            this, shuffle, null,\n+            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                int ei = s_.laneSource(i);\n+                return v1.lane(ei);\n+            }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Halffloat> s,\n+                                   VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Halffloat>, M extends VectorMask<Halffloat>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           Class<M> masktype,\n+                                           S shuffle,\n+                                           M m) {\n+\n+        m.check(masktype, this);\n+        VectorMask<Halffloat> valid = shuffle.laneIsValid();\n+        if (m.andNot(valid).anyTrue()) {\n+            shuffle.checkIndexes();\n+            throw new AssertionError();\n+        }\n+        return VectorSupport.rearrangeOp(\n+                   getClass(), shuffletype, masktype, Halffloat.class, length(),\n+                   this, shuffle, m,\n+                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                        int ei = s_.laneSource(i);\n+                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                   }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Halffloat> s,\n+                                   Vector<Halffloat> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Halffloat>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           S shuffle,\n+                                           HalffloatVector v) {\n+        VectorMask<Halffloat> valid = shuffle.laneIsValid();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n+        HalffloatVector r0 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, Halffloat.class, length(),\n+                this, ws, null,\n+                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                    int ei = s_.laneSource(i);\n+                    return v0.lane(ei);\n+                }));\n+        HalffloatVector r1 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, Halffloat.class, length(),\n+                v, ws, null,\n+                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                    int ei = s_.laneSource(i);\n+                    return v1.lane(ei);\n+                }));\n+        return r1.blend(r0, valid);\n+    }\n+\n+    @ForceInline\n+    private final\n+    VectorShuffle<Halffloat> toShuffle0(HalffloatSpecies dsp) {\n+        short[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Halffloat> toShuffleTemplate(Class<?> shuffleType) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), short.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     HalffloatVector::toShuffle0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Halffloat> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v) {\n+        return v.rearrange(this.toShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Halffloat> s, VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v,\n+                                                  AbstractMask<Halffloat> m) {\n+        return v.rearrange(this.toShuffle(), m);\n+    }\n+\n+    \/\/\/ Ternary operations\n+\n+\n+    \/**\n+     * Multiplies this vector by a second input vector, and sums\n+     * the result with a third.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the second input vector, supplying multiplier values\n+     * @param c the third input vector, supplying addend values\n+     * @return the product of this vector and the second input vector\n+     *         summed with the third input vector, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(short,short)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(Vector<Halffloat> b, Vector<Halffloat> c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by a scalar multiplier, and sums\n+     * the result with a scalar addend.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the scalar multiplier\n+     * @param c the scalar addend\n+     * @return the product of this vector and the scalar multiplier\n+     *         summed with scalar addend, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(Vector,Vector)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(short b, short c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/\/ Don't bother with (Vector,short) and (short,Vector) overloadings.\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    \/**\n+     * Returns a value accumulated from all the lanes of this vector.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to all the lane elements.\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @return the accumulated result\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative,VectorMask)\n+     * @see #add(Vector)\n+     * @see #mul(Vector)\n+     * @see #min(Vector)\n+     * @see #max(Vector)\n+     * @see VectorOperators#FIRST_NONZERO\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op);\n+\n+    \/**\n+     * Returns a value accumulated from selected lanes of this vector,\n+     * controlled by a mask.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to the selected lane elements.\n+     * <p>\n+     * If no elements are selected, an operation-specific identity\n+     * value is returned.\n+     * <ul>\n+     * <li>\n+     * If the operation is\n+     *  {@code ADD}\n+     * or {@code FIRST_NONZERO},\n+     * then the identity value is positive zero, the default {@code short} value.\n+     * <li>\n+     * If the operation is {@code MUL},\n+     * then the identity value is one.\n+     * <li>\n+     * If the operation is {@code MAX},\n+     * then the identity value is {@code Halffloat.NEGATIVE_INFINITY}.\n+     * <li>\n+     * If the operation is {@code MIN},\n+     * then the identity value is {@code Halffloat.POSITIVE_INFINITY}.\n+     * <\/ul>\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param m the mask controlling lane selection\n+     * @return the reduced result accumulated from the selected lane values\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative)\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op,\n+                                       VectorMask<Halffloat> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op,\n+                               Class<? extends VectorMask<Halffloat>> maskClass,\n+                               VectorMask<Halffloat> m) {\n+        m.check(maskClass, this);\n+        if (op == FIRST_NONZERO) {\n+            HalffloatVector v = reduceIdentityVector(op).blend(this, m);\n+            return v.reduceLanesTemplate(op);\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op) {\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this, and other scan ops alos.\n+            VectorMask<Short> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+            return this.lane(thisNZ.firstTrue());\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    private static final\n+    ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Halffloat>>>\n+        REDUCE_IMPL = new ImplCache<>(Associative.class, HalffloatVector.class);\n+\n+    private static ReductionOperation<HalffloatVector, VectorMask<Halffloat>> reductionOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue()))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp((short)1, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue()))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+            default: return null;\n+        }\n+    }\n+\n+    private\n+    @ForceInline\n+    HalffloatVector reduceIdentityVector(VectorOperators.Associative op) {\n+        int opc = opCode(op);\n+        UnaryOperator<HalffloatVector> fn\n+            = REDUCE_ID_IMPL.find(op, opc, (opc_) -> {\n+                switch (opc_) {\n+                case VECTOR_OP_ADD:\n+                    return v -> v.broadcast(0);\n+                case VECTOR_OP_MUL:\n+                    return v -> v.broadcast(1);\n+                case VECTOR_OP_MIN:\n+                    return v -> v.broadcast(MAX_OR_INF);\n+                case VECTOR_OP_MAX:\n+                    return v -> v.broadcast(MIN_OR_INF);\n+                default: return null;\n+                }\n+            });\n+        return fn.apply(this);\n+    }\n+    private static final\n+    ImplCache<Associative,UnaryOperator<HalffloatVector>> REDUCE_ID_IMPL\n+        = new ImplCache<>(Associative.class, HalffloatVector.class);\n+\n+    private static final short MIN_OR_INF = Halffloat.NEGATIVE_INFINITY;\n+    private static final short MAX_OR_INF = Halffloat.POSITIVE_INFINITY;\n+\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op);\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op,\n+                                                     VectorMask<Halffloat> m);\n+\n+    \/\/ Type specific accessors\n+\n+    \/**\n+     * Gets the lane element at lane index {@code i}\n+     *\n+     * @param i the lane index\n+     * @return the lane element at lane index {@code i}\n+     * @throws IllegalArgumentException if the index is is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract short lane(int i);\n+\n+    \/**\n+     * Replaces the lane element of this vector at lane index {@code i} with\n+     * value {@code e}.\n+     *\n+     * This is a cross-lane operation and behaves as if it returns the result\n+     * of blending this vector with an input vector that is the result of\n+     * broadcasting {@code e} and a mask that has only one lane set at lane\n+     * index {@code i}.\n+     *\n+     * @param i the lane index of the lane element to be replaced\n+     * @param e the value to be placed\n+     * @return the result of replacing the lane element of this vector at lane\n+     * index {@code i} with value {@code e}.\n+     * @throws IllegalArgumentException if the index is is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract HalffloatVector withLane(int i, short e);\n+\n+    \/\/ Memory load operations\n+\n+    \/**\n+     * Returns an array of type {@code short[]}\n+     * containing all the lane values.\n+     * The array length is the same as the vector length.\n+     * The array elements are stored in lane order.\n+     * <p>\n+     * This method behaves as if it stores\n+     * this vector into an allocated array\n+     * (using {@link #intoArray(short[], int) intoArray})\n+     * and returns the array as follows:\n+     * <pre>{@code\n+     *   short[] a = new short[this.length()];\n+     *   this.intoArray(a, 0);\n+     *   return a;\n+     * }<\/pre>\n+     *\n+     * @return an array containing the lane values of this vector\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final short[] toArray() {\n+        short[] a = new short[vspecies().laneCount()];\n+        intoArray(a, 0);\n+        return a;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final int[] toIntArray() {\n+        short[] a = toArray();\n+        int[] res = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = a[i];\n+            res[i] = (int) HalffloatSpecies.toIntegralChecked(e, true);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final long[] toLongArray() {\n+        short[] a = toArray();\n+        long[] res = new long[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = a[i];\n+            res[i] = HalffloatSpecies.toIntegralChecked(e, false);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     * @implNote\n+     * When this method is used on used on vectors\n+     * of type {@code HalffloatVector},\n+     * there will be no loss of precision.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final double[] toDoubleArray() {\n+        short[] a = toArray();\n+        double[] res = new double[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            res[i] = (double) a[i];\n+        }\n+        return res;\n+    }\n+\n+    \/**\n+     * Loads a vector from a byte array starting at an offset.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n+     * fromByteBuffer()} as follows:\n+     * <pre>{@code\n+     * var bb = ByteBuffer.wrap(a);\n+     * var m = species.maskAll(true);\n+     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param a the byte array\n+     * @param offset the offset into the array\n+     * @param bo the intended byte order\n+     * @return a vector loaded from a byte array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*ESIZE < 0}\n+     *         or {@code offset+(N+1)*ESIZE > a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromByteArray(VectorSpecies<Halffloat> species,\n+                                       byte[] a, int offset,\n+                                       ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a byte array starting at an offset\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n+     * fromByteBuffer()} as follows:\n+     * <pre>{@code\n+     * var bb = ByteBuffer.wrap(a);\n+     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param a the byte array\n+     * @param offset the offset into the array\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from a byte array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*ESIZE < 0}\n+     *         or {@code offset+(N+1)*ESIZE > a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromByteArray(VectorSpecies<Halffloat> species,\n+                                       byte[] a, int offset,\n+                                       ByteOrder bo,\n+                                       VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 2, a.length);\n+        ByteBuffer wb = wrapper(a, bo);\n+        return vsp.ldOp(wb, offset, (AbstractMask<Halffloat>)m,\n+                   (wb_, o, i) ->\n+                        wb_.getShort(o + i * 2));\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N} is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N} is placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset,\n+                                   VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Halffloat> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset,\n+                                   VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            return vsp.dummyVector().fromCharArray0(a, offset, m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Halffloat> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Halffloat> m) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n+    \/**\n+     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n+     * starting at an offset into the byte buffer.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n+     * fromByteBuffer()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param bb the byte buffer\n+     * @param offset the offset into the byte buffer\n+     * @param bo the intended byte order\n+     * @return a vector loaded from a byte buffer\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= bb.limit()}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromByteBuffer(VectorSpecies<Halffloat> species,\n+                                        ByteBuffer bb, int offset,\n+                                        ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n+     * starting at an offset into the byte buffer\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * HalffloatBuffer eb = bb.duplicate()\n+     *     .position(offset)\n+     *     .order(bo).asHalffloatBuffer();\n+     * short[] ar = new short[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = eb.get(n);\n+     *     }\n+     * }\n+     * HalffloatVector r = HalffloatVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param bb the byte buffer\n+     * @param offset the offset into the byte buffer\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from a byte buffer\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= bb.limit()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromByteBuffer(VectorSpecies<Halffloat> species,\n+                                        ByteBuffer bb, int offset,\n+                                        ByteOrder bo,\n+                                        VectorMask<Halffloat> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 2, bb.limit());\n+        ByteBuffer wb = wrapper(bb, bo);\n+        return vsp.ldOp(wb, offset, (AbstractMask<Halffloat>)m,\n+                   (wb_, o, i) ->\n+                        wb_.getShort(o + i * 2));\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            intoArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<Halffloat> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            intoCharArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Halffloat> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoByteArray(byte[] a, int offset,\n+                       ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, byteSize(), a.length);\n+        maybeSwap(bo).intoByteArray0(a, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoByteArray(byte[] a, int offset,\n+                       ByteOrder bo,\n+                       VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoByteArray(a, offset, bo);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 2, a.length);\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoByteBuffer(ByteBuffer bb, int offset,\n+                        ByteOrder bo) {\n+        if (ScopedMemoryAccess.isReadOnly(bb)) {\n+            throw new ReadOnlyBufferException();\n+        }\n+        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n+        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoByteBuffer(ByteBuffer bb, int offset,\n+                        ByteOrder bo,\n+                        VectorMask<Halffloat> m) {\n+        if (m.allTrue()) {\n+            intoByteBuffer(bb, offset, bo);\n+        } else {\n+            if (bb.isReadOnly()) {\n+                throw new ReadOnlyBufferException();\n+            }\n+            HalffloatSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 2, bb.limit());\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Low-level memory operations.\n+    \/\/\n+    \/\/ Note that all of these operations *must* inline into a context\n+    \/\/ where the exact species of the involved vector is a\n+    \/\/ compile-time constant.  Otherwise, the intrinsic generation\n+    \/\/ will fail and performance will suffer.\n+    \/\/\n+    \/\/ In many cases this is achieved by re-deriving a version of the\n+    \/\/ method in each concrete subclass (per species).  The re-derived\n+    \/\/ method simply calls one of these generic methods, with exact\n+    \/\/ parameters for the controlling metadata, which is either a\n+    \/\/ typed vector or constant species instance.\n+\n+    \/\/ Unchecked loading operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromCharArray0Template(char[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                a, charArrayAddress(a, offset), m,\n+                a, offset, vsp,\n+                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+\n+    @Override\n+    abstract\n+    HalffloatVector fromByteArray0(byte[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromByteArray0Template(byte[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off,\n+                        (wb_, o, i) ->\n+                            wb_.getShort(o + i * 2));\n+            });\n+    }\n+\n+    abstract\n+    HalffloatVector fromByteArray0(byte[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) ->\n+                            wb_.getShort(o + i * 2));\n+            });\n+    }\n+\n+    abstract\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) ->\n+                                wb_.getShort(o + i * 2));\n+                });\n+    }\n+\n+    abstract\n+    HalffloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    HalffloatVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) ->\n+                                wb_.getShort(o + i * 2));\n+                });\n+    }\n+\n+    \/\/ Unchecked storing operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    abstract\n+    void intoArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    void intoArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+    }\n+\n+    abstract\n+    void intoArray0(short[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+\n+\n+    abstract\n+    void intoByteArray0(byte[] a, int offset);\n+    @ForceInline\n+    final\n+    void intoByteArray0Template(byte[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, a, offset,\n+            (arr, off, v) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off,\n+                        (tb_, o, i, e) ->\n+                            tb_.putShort(o + i * 2, e));\n+            });\n+    }\n+\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) ->\n+                            tb_.putShort(o + i * 2, e));\n+            });\n+    }\n+\n+    @ForceInline\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) ->\n+                                wb_.putShort(o + i * 2, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) ->\n+                                wb_.putShort(o + i * 2, e));\n+                });\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    void intoCharArray0(char[] a, int offset, VectorMask<Halffloat> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Halffloat>>\n+    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/\/ End of low-level memory operations.\n+\n+    private static\n+    void checkMaskFromIndexSize(int offset,\n+                                HalffloatSpecies vsp,\n+                                VectorMask<Halffloat> m,\n+                                int scale,\n+                                int limit) {\n+        ((AbstractMask<Halffloat>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n+    @ForceInline\n+    private void conditionalStoreNYI(int offset,\n+                                     HalffloatSpecies vsp,\n+                                     VectorMask<Halffloat> m,\n+                                     int scale,\n+                                     int limit) {\n+        if (offset < 0 || offset + vsp.laneCount() * scale > limit) {\n+            String msg =\n+                String.format(\"unimplemented: store @%d in [0..%d), %s in %s\",\n+                              offset, limit, m, vsp);\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    final\n+    HalffloatVector maybeSwap(ByteOrder bo) {\n+        if (bo != NATIVE_ENDIAN) {\n+            return this.reinterpretAsBytes()\n+                .rearrange(swapBytesShuffle())\n+                .reinterpretAsHalffloats();\n+        }\n+        return this;\n+    }\n+\n+    static final int ARRAY_SHIFT =\n+        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+    static final long ARRAY_BASE =\n+        Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long arrayAddress(short[] a, int index) {\n+        return ARRAY_BASE + (((long)index) << ARRAY_SHIFT);\n+    }\n+\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n+\n+    @ForceInline\n+    static long byteArrayAddress(byte[] a, int index) {\n+        return Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Reinterpreting view methods:\n+    \/\/   lanewise reinterpret: viewAsXVector()\n+    \/\/   keep shape, redraw lanes: reinterpretAsEs()\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ByteVector reinterpretAsBytes() {\n+         \/\/ Going to ByteVector, pay close attention to byte order.\n+         assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);\n+         return asByteVectorRaw();\n+         \/\/return asByteVectorRaw().rearrange(swapBytesShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ShortVector viewAsIntegralLanes() {\n+        LaneType ilt = LaneType.SHORT.asIntegral();\n+        return (ShortVector) asVectorRaw(ilt);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\n+     * @implNote This method always throws\n+     * {@code UnsupportedOperationException}, because there is no floating\n+     * point type of the same size as {@code short}.  The return type\n+     * of this method is arbitrarily designated as\n+     * {@code Vector<?>}.  Future versions of this API may change the return\n+     * type if additional floating point types become available.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final\n+    HalffloatVector\n+    viewAsFloatingLanes() {\n+        return this;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Object methods: toString, equals, hashCode\n+    \/\/\n+    \/\/ Object methods are defined as if via Arrays.toString, etc.,\n+    \/\/ is applied to the array of elements.  Two equal vectors\n+    \/\/ are required to have equal species and equal lane values.\n+\n+    \/**\n+     * Returns a string representation of this vector, of the form\n+     * {@code \"[0,1,2...]\"}, reporting the lane values of this vector,\n+     * in lane order.\n+     *\n+     * The string is produced as if by a call to {@link\n+     * java.util.Arrays#toString(short[]) Arrays.toString()},\n+     * as appropriate to the {@code short} array returned by\n+     * {@link #toArray this.toArray()}.\n+     *\n+     * @return a string of the form {@code \"[0,1,2...]\"}\n+     * reporting the lane values of this vector\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    String toString() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Arrays.toString(toArray());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    boolean equals(Object obj) {\n+        if (obj instanceof Vector) {\n+            Vector<?> that = (Vector<?>) obj;\n+            if (this.species().equals(that.species())) {\n+                return this.eq(that.check(this.species())).allTrue();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    int hashCode() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Objects.hash(species(), Arrays.hashCode(toArray()));\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Species\n+\n+    \/**\n+     * Class representing {@link HalffloatVector}'s of the same {@link VectorShape VectorShape}.\n+     *\/\n+    \/*package-private*\/\n+    static final class HalffloatSpecies extends AbstractSpecies<Halffloat> {\n+        private HalffloatSpecies(VectorShape shape,\n+                Class<? extends HalffloatVector> vectorType,\n+                Class<? extends AbstractMask<Halffloat>> maskType,\n+                Function<Object, HalffloatVector> vectorFactory) {\n+            super(shape, LaneType.of(short.class),\n+                  vectorType, maskType,\n+                  vectorFactory);\n+            assert(this.elementSize() == Halffloat.SIZE);\n+        }\n+\n+        \/\/ Specializing overrides:\n+\n+        @Override\n+        @ForceInline\n+        public Class<Halffloat> elementType() {\n+            return Halffloat.class;\n+        }\n+        @Override\n+        @ForceInline\n+        final Class<Halffloat> genericElementType() {\n+            return Halffloat.class;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        @ForceInline\n+        public final Class<? extends HalffloatVector> vectorType() {\n+            return (Class<? extends HalffloatVector>) vectorType;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final long checkValue(long e) {\n+            longToElementBits(e);  \/\/ only for exception\n+            return e;\n+        }\n+\n+        \/*package-private*\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector broadcastBits(long bits) {\n+            return (HalffloatVector)\n+                VectorSupport.broadcastCoerced(\n+                    vectorType, Halffloat.class, laneCount,\n+                    bits, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        final HalffloatVector broadcast(short e) {\n+            return broadcastBits(toBits(e));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector broadcast(long e) {\n+            return broadcastBits(longToElementBits(e));\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        long longToElementBits(long value) {\n+            \/\/ Do the conversion, and then test it for failure.\n+            short e = (short) value;\n+            if ((long) e != value) {\n+                throw badElementBits(value, e);\n+            }\n+            return toBits(e);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        static long toIntegralChecked(short e, boolean convertToInt) {\n+            long value = convertToInt ? (int) e : (long) e;\n+            if ((short) value != e) {\n+                throw badArrayBits(e, convertToInt, value);\n+            }\n+            return value;\n+        }\n+\n+        \/* this non-public one is for internal conversions *\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector fromIntValues(int[] values) {\n+            VectorIntrinsics.requireLength(values.length, laneCount);\n+            short[] va = new short[laneCount()];\n+            for (int i = 0; i < va.length; i++) {\n+                int lv = values[i];\n+                short v = (short) lv;\n+                va[i] = v;\n+                if ((int)v != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+            }\n+            return dummyVector().fromArray0(va, 0);\n+        }\n+\n+        \/\/ Virtual constructors\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromArray(Object a, int offset) {\n+            \/\/ User entry point:  Be careful with inputs.\n+            return HalffloatVector\n+                .fromArray(this, (short[]) a, offset);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        HalffloatVector dummyVector() {\n+            return (HalffloatVector) super.dummyVector();\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        HalffloatVector rvOp(RVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                short bits = (short) f.apply(i);\n+                res[i] = fromBits(bits);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(FVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(VectorMask<Halffloat> m, FVOp f) {\n+            short[] res = new short[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Halffloat>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(i);\n+                }\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      VectorMask<Halffloat> m,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset, FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset,\n+                      AbstractMask<Halffloat> m,\n+                      FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, m, f);\n+        }\n+\n+        \/\/ N.B. Make sure these constant vectors and\n+        \/\/ masks load up correctly into registers.\n+        \/\/\n+        \/\/ Also, see if we can avoid all that switching.\n+        \/\/ Could we cache both vectors and both masks in\n+        \/\/ this species object?\n+\n+        \/\/ Zero and iota vector access\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector zero() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.ZERO;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.ZERO;\n+                case 128: return Halffloat128Vector.ZERO;\n+                case 256: return Halffloat256Vector.ZERO;\n+                case 512: return Halffloat512Vector.ZERO;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector iota() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.IOTA;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.IOTA;\n+                case 128: return Halffloat128Vector.IOTA;\n+                case 256: return Halffloat256Vector.IOTA;\n+                case 512: return Halffloat512Vector.IOTA;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        \/\/ Mask access\n+        @Override\n+        @ForceInline\n+        public final VectorMask<Halffloat> maskAll(boolean bit) {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.HalffloatMaxMask.maskAll(bit);\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.Halffloat64Mask.maskAll(bit);\n+                case 128: return Halffloat128Vector.Halffloat128Mask.maskAll(bit);\n+                case 256: return Halffloat256Vector.Halffloat256Mask.maskAll(bit);\n+                case 512: return Halffloat512Vector.Halffloat512Mask.maskAll(bit);\n+            }\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Finds a species for an element type of {@code short} and shape.\n+     *\n+     * @param s the shape\n+     * @return a species for an element type of {@code short} and shape\n+     * @throws IllegalArgumentException if no such species exists for the shape\n+     *\/\n+    static HalffloatSpecies species(VectorShape s) {\n+        Objects.requireNonNull(s);\n+        switch (s) {\n+            case S_64_BIT: return (HalffloatSpecies) SPECIES_64;\n+            case S_128_BIT: return (HalffloatSpecies) SPECIES_128;\n+            case S_256_BIT: return (HalffloatSpecies) SPECIES_256;\n+            case S_512_BIT: return (HalffloatSpecies) SPECIES_512;\n+            case S_Max_BIT: return (HalffloatSpecies) SPECIES_MAX;\n+            default: throw new IllegalArgumentException(\"Bad shape: \" + s);\n+        }\n+    }\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_64_BIT VectorShape.S_64_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_64\n+        = new HalffloatSpecies(VectorShape.S_64_BIT,\n+                            Halffloat64Vector.class,\n+                            Halffloat64Vector.Halffloat64Mask.class,\n+                            Halffloat64Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_128_BIT VectorShape.S_128_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_128\n+        = new HalffloatSpecies(VectorShape.S_128_BIT,\n+                            Halffloat128Vector.class,\n+                            Halffloat128Vector.Halffloat128Mask.class,\n+                            Halffloat128Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_256_BIT VectorShape.S_256_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_256\n+        = new HalffloatSpecies(VectorShape.S_256_BIT,\n+                            Halffloat256Vector.class,\n+                            Halffloat256Vector.Halffloat256Mask.class,\n+                            Halffloat256Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_512_BIT VectorShape.S_512_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_512\n+        = new HalffloatSpecies(VectorShape.S_512_BIT,\n+                            Halffloat512Vector.class,\n+                            Halffloat512Vector.Halffloat512Mask.class,\n+                            Halffloat512Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_MAX\n+        = new HalffloatSpecies(VectorShape.S_Max_BIT,\n+                            HalffloatMaxVector.class,\n+                            HalffloatMaxVector.HalffloatMaxMask.class,\n+                            HalffloatMaxVector::new);\n+\n+    \/**\n+     * Preferred species for {@link HalffloatVector}s.\n+     * A preferred species is a species of maximal bit-size for the platform.\n+     *\/\n+    public static final VectorSpecies<Halffloat> SPECIES_PREFERRED\n+        = VectorSpecies.ofPreferred(Halffloat.class);\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":4192,"deletions":0,"binary":false,"changes":4192,"status":"added"},{"patch":"@@ -2872,1 +2872,2 @@\n-                   (wb_, o, i)  -> wb_.getInt(o + i * 4));\n+                   (wb_, o, i) ->\n+                        wb_.getInt(o + i * 4));\n@@ -3141,1 +3142,2 @@\n-                   (wb_, o, i)  -> wb_.getInt(o + i * 4));\n+                   (wb_, o, i) ->\n+                        wb_.getInt(o + i * 4));\n@@ -3477,1 +3479,2 @@\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                        (wb_, o, i) ->\n+                            wb_.getInt(o + i * 4));\n@@ -3496,1 +3499,2 @@\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                        (wb_, o, i) ->\n+                            wb_.getInt(o + i * 4));\n@@ -3512,1 +3516,2 @@\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                            (wb_, o, i) ->\n+                                wb_.getInt(o + i * 4));\n@@ -3530,1 +3535,2 @@\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                            (wb_, o, i) ->\n+                                wb_.getInt(o + i * 4));\n@@ -3618,1 +3624,2 @@\n-                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putInt(o + i * 4, e));\n@@ -3637,1 +3644,2 @@\n-                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putInt(o + i * 4, e));\n@@ -3651,1 +3659,2 @@\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putInt(o + i * 4, e));\n@@ -3669,1 +3678,2 @@\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putInt(o + i * 4, e));\n@@ -3851,1 +3861,0 @@\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG);\n+    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG),\n+    HALFFLOAT(Halffloat.class, Short.class, short[].class, 'F', 11, Halffloat.SIZE, T_SHORT);\n@@ -179,7 +180,8 @@\n-        SK_FLOAT    = 1,\n-        SK_DOUBLE   = 2,\n-        SK_BYTE     = 3,\n-        SK_SHORT    = 4,\n-        SK_INT      = 5,\n-        SK_LONG     = 6,\n-        SK_LIMIT    = 7;\n+        SK_FLOAT     = 1,\n+        SK_DOUBLE    = 2,\n+        SK_BYTE      = 3,\n+        SK_SHORT     = 4,\n+        SK_INT       = 5,\n+        SK_LONG      = 6,\n+        SK_HALFFLOAT = 7,\n+        SK_LIMIT     = 8;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LaneType.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2733,1 +2733,2 @@\n-                   (wb_, o, i)  -> wb_.getLong(o + i * 8));\n+                   (wb_, o, i) ->\n+                        wb_.getLong(o + i * 8));\n@@ -3020,1 +3021,2 @@\n-                   (wb_, o, i)  -> wb_.getLong(o + i * 8));\n+                   (wb_, o, i) ->\n+                        wb_.getLong(o + i * 8));\n@@ -3393,1 +3395,2 @@\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                        (wb_, o, i) ->\n+                            wb_.getLong(o + i * 8));\n@@ -3412,1 +3415,2 @@\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                        (wb_, o, i) ->\n+                            wb_.getLong(o + i * 8));\n@@ -3428,1 +3432,2 @@\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                            (wb_, o, i) ->\n+                                wb_.getLong(o + i * 8));\n@@ -3446,1 +3451,2 @@\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                            (wb_, o, i) ->\n+                                wb_.getLong(o + i * 8));\n@@ -3553,1 +3559,2 @@\n-                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putLong(o + i * 8, e));\n@@ -3572,1 +3579,2 @@\n-                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putLong(o + i * 8, e));\n@@ -3586,1 +3594,2 @@\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putLong(o + i * 8, e));\n@@ -3604,1 +3613,2 @@\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putLong(o + i * 8, e));\n@@ -3786,1 +3796,0 @@\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2880,1 +2880,2 @@\n-                   (wb_, o, i)  -> wb_.getShort(o + i * 2));\n+                   (wb_, o, i) ->\n+                        wb_.getShort(o + i * 2));\n@@ -3276,1 +3277,2 @@\n-                   (wb_, o, i)  -> wb_.getShort(o + i * 2));\n+                   (wb_, o, i) ->\n+                        wb_.getShort(o + i * 2));\n@@ -3745,1 +3747,2 @@\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                        (wb_, o, i) ->\n+                            wb_.getShort(o + i * 2));\n@@ -3764,1 +3767,2 @@\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                        (wb_, o, i) ->\n+                            wb_.getShort(o + i * 2));\n@@ -3780,1 +3784,2 @@\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                            (wb_, o, i) ->\n+                                wb_.getShort(o + i * 2));\n@@ -3798,1 +3803,2 @@\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                            (wb_, o, i) ->\n+                                wb_.getShort(o + i * 2));\n@@ -3853,1 +3859,2 @@\n-                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putShort(o + i * 2, e));\n@@ -3872,1 +3879,2 @@\n-                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n+                        (tb_, o, i, e) ->\n+                            tb_.putShort(o + i * 2, e));\n@@ -3886,1 +3894,2 @@\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putShort(o + i * 2, e));\n@@ -3904,1 +3913,2 @@\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                            (wb_, o, i, e) ->\n+                                wb_.putShort(o + i * 2, e));\n@@ -4031,1 +4041,1 @@\n-    Vector<?>\n+    HalffloatVector\n@@ -4034,2 +4044,1 @@\n-        \/\/ asFloating() will throw UnsupportedOperationException for the unsupported type short\n-        throw new AssertionError(\"Cannot reach here\");\n+        return (HalffloatVector) asVectorRaw(flt);\n@@ -4120,1 +4129,0 @@\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2984,0 +2984,13 @@\n+    \/**\n+     * Reinterprets this vector as a vector of the same shape\n+     * and contents but a lane type of {@code halffloat},\n+     * where the lanes are assembled from successive bytes\n+     * according to little-endian order.\n+     * It is a convenience method for the expression\n+     * {@code reinterpretShape(species().withLanes(halffloat.class))}.\n+     * It may be considered an inverse to {@link Vector#reinterpretAsBytes()}.\n+     *\n+     * @return a {@code HalffloatVector} with the same shape and information content\n+     *\/\n+    public abstract HalffloatVector reinterpretAsHalffloats();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -34,0 +35,2 @@\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n@@ -114,0 +117,4 @@\n+    static <V> V maybeRebox(V v) {\n+        U.loadFence();\n+        return v;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -473,0 +473,5 @@\n+#if[short]\n+        return VectorSupport.broadcastCoerced(vsp.vectorType(), Halffloat.class, species.length(),\n+                        toBits((short)0), vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+#else[short]\n@@ -476,0 +481,1 @@\n+#end[short]\n@@ -607,0 +613,11 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));\n+#else[short]\n+            opc, getClass(), null, $type$.class, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));\n+#end[short]\n+#else[FP]\n@@ -610,0 +627,1 @@\n+#end[FP]\n@@ -639,0 +657,11 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));\n+#else[short]\n+            opc, getClass(), maskClass, $type$.class, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, $abstractvectortype$::unaryOperations));\n+#end[short]\n+#else[FP]\n@@ -642,0 +671,1 @@\n+#end[FP]\n@@ -747,0 +777,6 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+#else[short]\n@@ -750,0 +786,6 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), null, $type$.class, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+#end[FP]\n@@ -806,0 +848,7 @@\n+#if[FP]\n+#if[short]\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+#else[short]\n@@ -810,0 +859,7 @@\n+#end[short]\n+#else[FP]\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, $type$.class, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+#end[FP]\n@@ -818,0 +874,27 @@\n+#if[FP]\n+#if[short]\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+#else[short]\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+#end[short]\n+#else[FP]\n@@ -830,0 +913,1 @@\n+#end[FP]\n@@ -849,0 +933,1 @@\n+#if[!short]\n@@ -857,0 +942,1 @@\n+#end[!short]\n@@ -1029,0 +1115,6 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, e, m,\n+            BIN_INT_IMPL.find(op, opc, $abstractvectortype$::broadcastIntOperations));\n+#else[short]\n@@ -1032,0 +1124,6 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), maskClass, $type$.class, length(),\n+            this, e, m,\n+            BIN_INT_IMPL.find(op, opc, $abstractvectortype$::broadcastIntOperations));\n+#end[FP]\n@@ -1113,0 +1211,6 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));\n+#else[short]\n@@ -1116,0 +1220,6 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), null, $type$.class, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));\n+#end[FP]\n@@ -1155,0 +1265,6 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));\n+#else[short]\n@@ -1158,0 +1274,6 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), maskClass, $type$.class, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, $abstractvectortype$::ternaryOperations));\n+#end[FP]\n@@ -1167,0 +1289,5 @@\n+#if[short]\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                    Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(),\n+                    Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+#else[short]\n@@ -1169,0 +1296,1 @@\n+#end[short]\n@@ -2192,0 +2320,7 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), maskType, Halffloat.class, length(),\n+#else[short]\n+            opc, getClass(), maskType, $type$.class, length(),\n+#end[short]\n+#else[FP]\n@@ -2193,0 +2328,1 @@\n+#end[FP]\n@@ -2214,0 +2350,4 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), maskType, Halffloat.class, length(),\n+#else[short]\n@@ -2215,0 +2355,4 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), maskType, $type$.class, length(),\n+#end[FP]\n@@ -2229,0 +2373,18 @@\n+#if[FP]\n+#if[!short]\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+#end[!short]\n+#if[short]\n+            case BT_eq -> Halffloat.valueOf(a).floatValue() == Halffloat.valueOf(b).floatValue();\n+            case BT_ne -> Halffloat.valueOf(a).floatValue() != Halffloat.valueOf(b).floatValue();\n+            case BT_lt -> Halffloat.valueOf(a).floatValue() < Halffloat.valueOf(b).floatValue();\n+            case BT_le -> Halffloat.valueOf(a).floatValue() <= Halffloat.valueOf(b).floatValue();\n+            case BT_gt -> Halffloat.valueOf(a).floatValue() > Halffloat.valueOf(b).floatValue();\n+            case BT_ge -> Halffloat.valueOf(a).floatValue() >= Halffloat.valueOf(b).floatValue();\n+#end[short]\n+#else[FP]\n@@ -2235,0 +2397,1 @@\n+#end[FP]\n@@ -2349,0 +2512,4 @@\n+#if[FP]\n+#if[short]\n+            getClass(), maskType, Halffloat.class, length(),\n+#else[short]\n@@ -2350,0 +2517,4 @@\n+#end[short]\n+#else[FP]\n+            getClass(), maskType, $type$.class, length(),\n+#end[FP]\n@@ -2366,0 +2537,4 @@\n+#if[FP]\n+#if[short]\n+            getClass(), Halffloat.class, length(),\n+#else[short]\n@@ -2367,0 +2542,4 @@\n+#end[short]\n+#else[FP]\n+            getClass(), $type$.class, length(),\n+#end[FP]\n@@ -2558,0 +2737,7 @@\n+#if[FP]\n+#if[short]\n+            getClass(), shuffletype, null, Halffloat.class, length(),\n+#else[short]\n+            getClass(), shuffletype, null, $type$.class, length(),\n+#end[short]\n+#else[FP]\n@@ -2559,0 +2745,1 @@\n+#end[FP]\n@@ -2590,0 +2777,4 @@\n+#if[FP]\n+#if[short]\n+                   getClass(), shuffletype, masktype, Halffloat.class, length(),\n+#else[short]\n@@ -2591,0 +2782,4 @@\n+#end[short]\n+#else[FP]\n+                   getClass(), shuffletype, masktype, $type$.class, length(),\n+#end[FP]\n@@ -2618,0 +2813,8 @@\n+#if[FP]\n+#if[short]\n+                getClass(), shuffletype, null, Halffloat.class, length(),\n+#else[short]\n+                getClass(), shuffletype, null, $type$.class, length(),\n+\n+#end[short]\n+#else[FP]\n@@ -2619,0 +2822,1 @@\n+#end[FP]\n@@ -2626,0 +2830,4 @@\n+#if[FP]\n+#if[short]\n+                getClass(), shuffletype, null, Halffloat.class, length(),\n+#else[short]\n@@ -2627,0 +2835,4 @@\n+#end[short]\n+#else[FP]\n+                getClass(), shuffletype, null, $type$.class, length(),\n+#end[FP]\n@@ -3029,0 +3241,6 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), maskClass, Halffloat.class, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));\n+#else[short]\n@@ -3032,0 +3250,6 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), maskClass, $type$.class, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));\n+#end[FP]\n@@ -3046,0 +3270,6 @@\n+#if[FP]\n+#if[short]\n+            opc, getClass(), null, Halffloat.class, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));\n+#else[short]\n@@ -3049,0 +3279,6 @@\n+#end[short]\n+#else[FP]\n+            opc, getClass(), null, $type$.class, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, $abstractvectortype$::reductionOperations)));\n+#end[FP]\n@@ -3057,0 +3293,21 @@\n+#if[FP]\n+#if[short]\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue()))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(($type$)1, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue()))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+#else[short]\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n+#end[short]\n+#else[FP]\n@@ -3065,0 +3322,1 @@\n+#end[FP]\n@@ -3376,1 +3634,10 @@\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                   (wb_, o, i) ->\n+#if[FP]\n+#if[short]\n+                        wb_.get{#if[byte]?(:Short(}o + i * $sizeInBytes$));\n+#else[short]\n+                        wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[short]\n+#else[FP]\n+                        wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[FP]\n@@ -4010,1 +4277,10 @@\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                   (wb_, o, i) ->\n+#if[FP]\n+#if[short]\n+                        wb_.get{#if[byte]?(:Short(}o + i * $sizeInBytes$));\n+#else[short]\n+                        wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[short]\n+#else[FP]\n+                        wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[FP]\n@@ -4813,1 +5089,10 @@\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                        (wb_, o, i) ->\n+#if[FP]\n+#if[short]\n+                            wb_.get{#if[byte]?(:Short(}o + i * $sizeInBytes$));\n+#else[short]\n+                            wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[short]\n+#else[FP]\n+                            wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[FP]\n@@ -4832,1 +5117,10 @@\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                        (wb_, o, i) ->\n+#if[FP]\n+#if[short]\n+                            wb_.get{#if[byte]?(:Short(}o + i * $sizeInBytes$));\n+#else[short]\n+                            wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[short]\n+#else[FP]\n+                            wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[FP]\n@@ -4848,1 +5142,10 @@\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                            (wb_, o, i) ->\n+#if[FP]\n+#if[short]\n+                                wb_.get{#if[byte]?(:Short(}o + i * $sizeInBytes$));\n+#else[short]\n+                                wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[short]\n+#else[FP]\n+                                wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[FP]\n@@ -4866,1 +5169,10 @@\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                            (wb_, o, i) ->\n+#if[FP]\n+#if[short]\n+                                wb_.get{#if[byte]?(:Short(}o + i * $sizeInBytes$));\n+#else[short]\n+                                wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[short]\n+#else[FP]\n+                                wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+#end[FP]\n@@ -5001,1 +5313,10 @@\n-                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                        (tb_, o, i, e) ->\n+#if[FP]\n+#if[short]\n+                            tb_.put{#if[byte]?(:Short(}o + i * $sizeInBytes$, e));\n+#else[short]\n+                            tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[short]\n+#else[FP]\n+                            tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[FP]\n@@ -5020,1 +5341,10 @@\n-                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                        (tb_, o, i, e) ->\n+#if[FP]\n+#if[short]\n+                            tb_.put{#if[byte]?(:Short(}o + i * $sizeInBytes$, e));\n+#else[short]\n+                            tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[short]\n+#else[FP]\n+                            tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[FP]\n@@ -5034,1 +5364,10 @@\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                            (wb_, o, i, e) ->\n+#if[FP]\n+#if[short]\n+                                wb_.put{#if[byte]?(:Short(}o + i * $sizeInBytes$, e));\n+#else[short]\n+                                wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[short]\n+#else[FP]\n+                                wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[FP]\n@@ -5052,1 +5391,10 @@\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                            (wb_, o, i, e) ->\n+#if[FP]\n+#if[short]\n+                                wb_.put{#if[byte]?(:Short(}o + i * $sizeInBytes$, e));\n+#else[short]\n+                                wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[short]\n+#else[FP]\n+                                wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+#end[FP]\n@@ -5207,1 +5555,9 @@\n-    {#if[byteOrShort]?Vector<?>:$Fptype$Vector}\n+#if[FP]\n+#if[short]\n+    $Type$Vector\n+#else[short]\n+    $Fptype$Vector\n+#end[short]\n+#else[FP]\n+    {#if[byte]?Vector<?>:$Fptype$Vector}\n+#end[FP]\n@@ -5213,1 +5569,1 @@\n-#if[!byteOrShort]\n+#if[!byte]\n@@ -5215,1 +5571,1 @@\n-#else[!byteOrShort]\n+#else[!byte]\n@@ -5218,1 +5574,1 @@\n-#end[!byteOrShort]\n+#end[!byte]\n@@ -5301,0 +5657,2 @@\n+#if[FP]\n+#if[!short]\n@@ -5304,1 +5662,11 @@\n-\n+#end[!short]\n+#if[short]\n+        public Class<Halffloat> elementType() {\n+            return Halffloat.class;\n+        }\n+#end[short]\n+#else[FP]\n+        public final Class<$Boxtype$> elementType() {\n+            return $type$.class;\n+        }\n+#end[FP]\n@@ -5330,0 +5698,13 @@\n+#if[FP]\n+#if[short]\n+                VectorSupport.broadcastCoerced(\n+                    vectorType, Halffloat.class, laneCount,\n+                    bits, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+#else[short]\n+                VectorSupport.broadcastCoerced(\n+                    vectorType, $type$.class, laneCount,\n+                    bits, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+#end[short]\n+#else[FP]\n@@ -5334,0 +5715,1 @@\n+#end[FP]\n@@ -5580,0 +5962,10 @@\n+#if[FP]\n+#if[!short]\n+    public static final VectorSpecies<$Boxtype$> SPECIES_PREFERRED\n+        = ($Type$Species) VectorSpecies.ofPreferred($type$.class);\n+#end[!short]\n+#if[short]\n+    public static final VectorSpecies<Halffloat> SPECIES_PREFERRED\n+        = VectorSpecies.ofPreferred(Halffloat.class);\n+#end[short]\n+#else[FP]\n@@ -5582,0 +5974,1 @@\n+#end[FP]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":408,"deletions":15,"binary":false,"changes":423,"status":"modified"},{"patch":"@@ -55,0 +55,7 @@\n+#if[FP]\n+#if[short]\n+    static final Class<$Boxtype$> ETYPE = Halffloat.class; \/\/ used by the JVM\n+#else[short]\n+    static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+#end[short]\n+#else[FP]\n@@ -56,0 +63,1 @@\n+#end[FP]\n@@ -91,0 +99,8 @@\n+#if[FP]\n+#if[!short]\n+    public final Class<$Boxtype$> elementType() { return $type$.class; }\n+#end[!short]\n+#if[short]\n+    public final Class<Halffloat> elementType() { return Halffloat.class; }\n+#end[short]\n+#else[FP]\n@@ -92,0 +108,1 @@\n+#end[FP]\n@@ -804,0 +821,7 @@\n+#if[FP]\n+#if[short]\n+        static final Class<$Boxtype$> ETYPE = Halffloat.class; \/\/ used by the JVM\n+#else[short]\n+        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+#end[short]\n+#else[FP]\n@@ -805,0 +829,1 @@\n+#end[FP]\n@@ -1031,0 +1056,7 @@\n+#if[FP]\n+#if[short]\n+        static final Class<$Boxtype$> ETYPE = Halffloat.class; \/\/ used by the JVM\n+#else[short]\n+        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+#end[short]\n+#else[FP]\n@@ -1032,0 +1064,1 @@\n+#end[FP]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-for type in byte short int long float double\n+for type in byte short int long float double halffloat\n@@ -58,0 +58,1 @@\n+\n@@ -60,0 +61,8 @@\n+\n+  case $type in\n+    halffloat)\n+       type=short\n+       TYPE=SHORT\n+       ;;\n+  esac\n+\n@@ -76,2 +85,2 @@\n-  case $type in\n-    byte)\n+  case $Type in\n+    Byte)\n@@ -82,1 +91,4 @@\n-    short)\n+    Short)\n+      fptype=halffloat\n+      Fptype=Halffloat\n+      Boxfptype=Halffloat\n@@ -87,1 +99,1 @@\n-    int)\n+    Int)\n@@ -97,1 +109,1 @@\n-    long)\n+    Long)\n@@ -104,1 +116,1 @@\n-    float)\n+    Float)\n@@ -112,1 +124,1 @@\n-    double)\n+    Double)\n@@ -120,0 +132,8 @@\n+    Halffloat)\n+      kind=FP\n+      bitstype=short\n+      Bitstype=Short\n+      Boxbitstype=Short\n+      sizeInBytes=2\n+      args=\"$args -KbyteOrShort -KshortOrFP -KshortOrHalffloat\"\n+      ;;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -39,2 +40,2 @@\n-    static final VectorSpecies<Float> SPECIES =\n-            FloatVector.SPECIES_256;\n+    static final VectorSpecies<Halffloat> SPECIES =\n+            HalffloatVector.SPECIES_128;\n@@ -43,4 +44,3 @@\n-    static float[] a = new float[SIZE];\n-    static float[] b = new float[SIZE];\n-    static float[] c = new float[SIZE];\n-\n+    static short[] a = new short[SIZE];\n+    static short[] b = new short[SIZE];\n+    static short[] c = new short[SIZE];\n@@ -49,2 +49,2 @@\n-            a[i] = 1f;\n-            b[i] = 2f;\n+            a[i] = Halffloat.valueOf((float)i);\n+            b[i] = Halffloat.valueOf((float)i);\n@@ -56,2 +56,2 @@\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n@@ -62,1 +62,1 @@\n-    static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SPECIES.length()).toArray();\n+    \/*static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SPECIES.length()).toArray();\n@@ -70,1 +70,1 @@\n-    }\n+    }*\/\n@@ -77,1 +77,6 @@\n-            if (c[i] != a[i] + b[i])\n+            Halffloat hfa = new Halffloat(a[i]);\n+            Halffloat hfb = new Halffloat(b[i]);\n+            Halffloat hfc = new Halffloat(c[i]);\n+\n+            if (hfc.floatValue() != (hfa.floatValue() + hfb.floatValue())) {\n+                System.out.println(\"c[\" + i + \"] = \" + hfc.floatValue() + \" res = \" + (hfa.floatValue() + hfb.floatValue()));\n@@ -79,0 +84,1 @@\n+            }\n@@ -81,1 +87,1 @@\n-        Arrays.fill(c, 0.0f);\n+        \/*Arrays.fill(c, 0.0f);\n@@ -89,1 +95,2 @@\n-        }\n+        }*\/\n+        System.out.println(\"PASSED\");\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"}]}