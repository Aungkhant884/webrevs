{"files":[{"patch":"@@ -629,0 +629,3 @@\n+  } else if (elem_bt == T_BYTE && arr_elem_bt == T_BOOLEAN) {\n+    \/\/ Load\/store of byte vector from\/to boolean[] is supported\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -809,0 +809,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -841,0 +841,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -905,0 +905,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -793,0 +793,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -779,0 +779,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2827,0 +2827,158 @@\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ByteVector zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n@@ -3070,0 +3228,167 @@\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ByteSpecies vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<Byte> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ByteSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n@@ -3177,0 +3502,15 @@\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    ByteVector fromBooleanArray0Template(boolean[] a, int offset) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+\n@@ -3308,0 +3648,10 @@\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -777,0 +777,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -781,0 +781,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -789,0 +789,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -775,0 +775,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,0 +774,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2734,0 +2734,1 @@\n+\n@@ -3024,0 +3025,1 @@\n+\n@@ -3131,0 +3133,1 @@\n+\n@@ -3267,0 +3270,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,0 +781,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -789,0 +789,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -805,0 +805,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -777,0 +777,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,0 +774,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2740,0 +2740,1 @@\n+\n@@ -3011,0 +3012,1 @@\n+\n@@ -3118,0 +3120,1 @@\n+\n@@ -3254,0 +3257,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -785,0 +785,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -793,0 +793,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -809,0 +809,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -781,0 +781,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -790,0 +790,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2843,0 +2843,1 @@\n+\n@@ -3114,0 +3115,1 @@\n+\n@@ -3221,0 +3223,1 @@\n+\n@@ -3357,0 +3360,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -771,0 +771,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -775,0 +775,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -783,0 +783,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -769,0 +769,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -769,0 +769,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2727,0 +2727,1 @@\n+\n@@ -3017,0 +3018,1 @@\n+\n@@ -3124,0 +3126,1 @@\n+\n@@ -3260,0 +3263,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -799,0 +799,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -815,0 +815,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -847,0 +847,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -791,0 +791,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -785,0 +785,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2926,0 +2926,1 @@\n+        \/\/ FIXME: optimize\n@@ -2972,0 +2973,1 @@\n+        \/\/ FIXME: optimize\n@@ -2976,0 +2978,1 @@\n+\n@@ -3325,0 +3328,1 @@\n+        \/\/ FIXME: optimize\n@@ -3369,0 +3373,1 @@\n+        \/\/ FIXME: optimize\n@@ -3376,0 +3381,1 @@\n+\n@@ -3497,0 +3503,1 @@\n+\n@@ -3642,0 +3649,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3465,0 +3465,1 @@\n+        \/\/ FIXME: optimize\n@@ -3511,0 +3512,1 @@\n+        \/\/ FIXME: optimize\n@@ -3516,0 +3518,160 @@\n+#if[byte]\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+#end[byte]\n+\n@@ -3947,0 +4109,1 @@\n+        \/\/ FIXME: optimize\n@@ -3991,0 +4154,1 @@\n+        \/\/ FIXME: optimize\n@@ -3999,0 +4163,169 @@\n+#if[byte]\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+#end[byte]\n+\n@@ -4122,0 +4455,17 @@\n+#if[byte]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromBooleanArray0Template(boolean[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+#end[byte]\n+\n@@ -4271,0 +4621,12 @@\n+#if[byte]\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":362,"deletions":0,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -1075,0 +1075,9 @@\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -953,0 +953,88 @@\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -953,0 +953,88 @@\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -953,0 +953,88 @@\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -953,0 +953,88 @@\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -962,0 +962,88 @@\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1208,0 +1208,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1208,0 +1208,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1208,0 +1208,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1208,0 +1208,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1217,0 +1217,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1242,0 +1242,90 @@\n+\n+#if[byte]\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+#end[byte]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"}]}