{"files":[{"patch":"@@ -1363,1 +1363,1 @@\n-    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL || UseAOT)) {\n+    if (UseCompressedOops && (CompressedOops::ptrs_base() != NULL)) {\n@@ -1785,14 +1785,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input\n-\n-\/\/ the shared code plants the oop data at the start of the generated\n-\/\/ code for the safepoint node and that needs ot be at the load\n-\/\/ instruction itself. so we cannot plant a mov of the safepoint poll\n-\/\/ address followed by a load. setting this to true means the mov is\n-\/\/ scheduled as a prior instruction. that's better for scheduling\n-\/\/ anyway.\n-\n-bool SafePointNode::needs_polling_address_input()\n-{\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2845,0 +2845,45 @@\n+\/\/ ------------------------------ Vector and_not -------------------------------\n+\n+instruct vand_not2I(vecD dst, vecD src1, vecD src2, immI_M1 m1)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n+  ins_cost(INSN_COST);\n+  format %{ \"bic  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n+  ins_encode %{\n+    __ bic(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vand_not4I(vecX dst, vecX src1, vecX src2, immI_M1 m1)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n+  ins_cost(INSN_COST);\n+  format %{ \"bic  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n+  ins_encode %{\n+    __ bic(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vand_not2L(vecX dst, vecX src1, vecX src2, immL_M1 m1)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n+  ins_cost(INSN_COST);\n+  format %{ \"bic  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n+  ins_encode %{\n+    __ bic(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -3292,0 +3337,30 @@\n+\/\/ vector mask cast\n+\n+instruct vmaskcastD(vecD dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcastX(vecX dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1039,0 +1039,26 @@\n+\/\/ ------------------------------ Vector and_not -------------------------------\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n+dnl\n+define(`VECTOR_AND_NOT', `\n+instruct vand_not$1$2`'(vec$3 dst, vec$3 src1, vec$3 src2, imm$2_M1 m1)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == $4);\n+  MATCH_RULE($2)\n+  ins_cost(INSN_COST);\n+  format %{ \"bic  $dst, T$5, $src1, $src2\\t# vector ($5)\" %}\n+  ins_encode %{\n+    __ bic(as_FloatRegister($dst$$reg), __ T$5,\n+           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}')dnl\n+dnl            $1 $2 $3 $4  $5\n+VECTOR_AND_NOT(2, I, D, 8,  8B)\n+VECTOR_AND_NOT(4, I, X, 16, 16B)\n+VECTOR_AND_NOT(2, L, X, 16, 16B)\n+undefine(MATCH_RULE)\n@@ -1093,1 +1119,1 @@\n-dnl                $1   $2   $3    $4\n+dnl                 $1   $2   $3    $4\n@@ -1235,0 +1261,21 @@\n+\/\/ vector mask cast\n+dnl\n+define(`VECTOR_MASK_CAST', `\n+instruct vmaskcast$1`'(vec$1 dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n+            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}')dnl\n+dnl              $1 $2\n+VECTOR_MASK_CAST(D, 8)\n+VECTOR_MASK_CAST(X, 16)\n+dnl\n+\n@@ -1875,1 +1922,1 @@\n-dnl  $1      $2  $3 $4 $5\n+dnl   $1     $2  $3 $4 $5\n@@ -1916,1 +1963,1 @@\n-dnl     $1    $2    $3   $4   $5  $6 $7\n+dnl      $1   $2    $3   $4   $5  $6 $7\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -674,0 +674,60 @@\n+\/\/ vector not\n+\n+instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (XorV src (ReplicateB m1)));\n+  match(Set dst (XorV src (ReplicateS m1)));\n+  match(Set dst (XorV src (ReplicateI m1)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_not $dst, $src\\t# vector (sve) B\/H\/S\" %}\n+  ins_encode %{\n+    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n+               ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL(vReg dst, vReg src, immL_M1 m1) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (XorV src (ReplicateL m1)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_not $dst, $src\\t# vector (sve) D\" %}\n+  ins_encode %{\n+    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n+               ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ vector and_not\n+\n+instruct vand_notI(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) B\/H\/S\" %}\n+  ins_encode %{\n+    __ sve_bic(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg),\n+               as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL(vReg dst, vReg src1, vReg src2, immL_M1 m1) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) D\" %}\n+  ins_encode %{\n+    __ sve_bic(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg),\n+               as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n@@ -4116,0 +4176,15 @@\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n+            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -473,0 +473,51 @@\n+\n+\/\/ vector not\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (XorV src (ReplicateB m1)));\n+  match(Set dst (XorV src (ReplicateS m1)));\n+  match(Set dst (XorV src (ReplicateI m1)));',\n+`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n+dnl\n+define(`VECTOR_NOT', `\n+instruct vnot$1`'(vReg dst, vReg src, imm$1_M1 m1) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  MATCH_RULE($1)\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_not $dst, $src\\t# vector (sve) $2\" %}\n+  ins_encode %{\n+    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n+               ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl        $1,$2\n+VECTOR_NOT(I, B\/H\/S)\n+VECTOR_NOT(L, D)\n+undefine(MATCH_RULE)\n+\n+\/\/ vector and_not\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n+dnl\n+define(`VECTOR_AND_NOT', `\n+instruct vand_not$1`'(vReg dst, vReg src1, vReg src2, imm$1_M1 m1) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  MATCH_RULE($1)\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) $2\" %}\n+  ins_encode %{\n+    __ sve_bic(as_FloatRegister($dst$$reg),\n+               as_FloatRegister($src1$$reg),\n+               as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl            $1,$2\n+VECTOR_AND_NOT(I, B\/H\/S)\n+VECTOR_AND_NOT(L, D)\n+undefine(MATCH_RULE)\n@@ -2397,0 +2448,15 @@\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n+            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2395,0 +2395,1 @@\n+  INSN(uqsubv, 1, 0b001011, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2409,0 +2410,1 @@\n+  INSN(cmhi,   1, 0b001101, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2429,0 +2431,1 @@\n+  INSN(umaxv,  1, 0b110000101010, 1); \/\/ accepted arrangements: T8B, T16B, T4H, T8H,      T4S\n@@ -3063,0 +3066,1 @@\n+  INSN(sve_bic, 0b11);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -596,1 +597,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2186,1 +2187,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2261,1 +2262,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2387,1 +2388,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2550,1 +2551,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -149,6 +149,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input.\n-\/\/ Since ARM does not have absolute addressing, it does.\n-bool SafePointNode::needs_polling_address_input() {\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1158,1 +1158,10 @@\n-\/\/ Currently not used on this platform.\n+\/\/ Add nop if a prefixed (two-word) instruction is going to cross a 64-byte boundary.\n+\/\/ (See Section 1.6 of Power ISA Version 3.1)\n+static int compute_prefix_padding(int current_offset) {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 bytes\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64)) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n@@ -1160,1 +1169,3 @@\n-\/\/=============================================================================\n+int loadConI32Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n@@ -1162,4 +1173,2 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input.\n-bool SafePointNode::needs_polling_address_input() {\n-  \/\/ The address is loaded from thread by a seperate node.\n-  return true;\n+int loadConL34Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n@@ -1168,0 +1177,17 @@\n+int addI_reg_imm32Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+int addL_reg_imm34Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+int addP_reg_imm34Node::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+int cmprb_Whitespace_reg_reg_prefixedNode::compute_padding(int current_offset) const {\n+  return compute_prefix_padding(current_offset);\n+}\n+\n+\n@@ -1904,1 +1930,1 @@\n-  st->print(\"NOP \\t\/\/ %d nops to pad for loops.\", _count);\n+  st->print(\"NOP \\t\/\/ %d nops to pad for loops or prefixed instructions.\", _count);\n@@ -4045,0 +4071,9 @@\n+\/\/ Integer Immediate: 32-bit immediate for prefixed addi and load\/store.\n+operand immI32() %{\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  op_cost(0);\n+  match(ConI);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4286,0 +4321,9 @@\n+\/\/ Long Immediate: 34-bit, immediate field in prefixed addi and load\/store.\n+operand immL34() %{\n+  predicate(PowerArchitecturePPC64 >= 10 && Assembler::is_simm(n->get_long(), 34));\n+  match(ConL);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -5820,0 +5864,17 @@\n+instruct loadConI32(iRegIdst dst, immI32 src) %{\n+  match(Set dst src);\n+  \/\/ This macro is valid only in Power 10 and up, but adding the following predicate here\n+  \/\/ caused a build error, so we comment it out for now.\n+  \/\/ predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PLI     $dst, $src\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -5891,0 +5952,18 @@\n+\/\/ Load 34-bit long constant using prefixed addi. No constant pool entries required.\n+instruct loadConL34(iRegLdst dst, immL34 src) %{\n+  match(Set dst src);\n+  \/\/ This macro is valid only in Power 10 and up, but adding the following predicate here\n+  \/\/ caused a build error, so we comment it out for now.\n+  \/\/ predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PLI     $dst, $src \\t\/\/ long\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -8503,0 +8582,15 @@\n+\/\/ Immediate Addition using prefixed addi\n+instruct addI_reg_imm32(iRegIdst dst, iRegIsrc src1, immI32 src2) %{\n+  match(Set dst (AddI src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+  format %{ \"PADDI   $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -8577,0 +8671,17 @@\n+\/\/ Long Immediate Addition using prefixed addi\n+\/\/ No constant pool entries required.\n+instruct addL_reg_imm34(iRegLdst dst, iRegLsrc src1, immL34 src2) %{\n+  match(Set dst (AddL src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PADDI   $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -8614,0 +8725,17 @@\n+\/\/ Pointer Immediate Addition using prefixed addi\n+\/\/ No constant pool entries required.\n+instruct addP_reg_imm34(iRegPdst dst, iRegP_N2P src1, immL34 src2) %{\n+  match(Set dst (AddP src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PADDI    $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n@@ -11916,0 +12044,1 @@\n+  predicate(PowerArchitecturePPC64 <= 9);\n@@ -11935,0 +12064,23 @@\n+\/\/ Power 10 version, using prefixed addi to load 32-bit constant\n+instruct cmprb_Whitespace_reg_reg_prefixed(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{\n+  match(Set dst (Whitespace src1));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  effect(TEMP src2, TEMP crx);\n+  ins_cost(3 * DEFAULT_COST);\n+\n+  format %{ \"PLI     $src2, 0x201C0D09\\n\\t\"\n+            \"CMPRB   $crx, 1, $src1, $src2\\n\\t\"\n+            \"SETB    $dst, $crx\" %}\n+  size(16);\n+  ins_encode %{\n+    \/\/ 0x09 to 0x0D, 0x1C to 0x20\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($src2$$Register, 0x201C0D09);\n+    \/\/ compare src with ranges 0x09 to 0x0D and 0x1C to 0x20\n+    __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);\n+    __ setb($dst$$Register, $crx$$CondRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(2);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":159,"deletions":7,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -674,6 +674,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input.\n-\/\/ Since z\/Architecture does not have absolute addressing, it does.\n-bool SafePointNode::needs_polling_address_input() {\n-  return true;\n-}\n-\n@@ -966,1 +960,1 @@\n-    __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));\n+    __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::polling_page_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"interpreter\/bytecodeHistogram.hpp\"\n@@ -2810,1 +2811,1 @@\n-    cmpptr(in_nmethod ? rsp : rbp, Address(thread_reg, Thread::polling_word_offset()));\n+    cmpptr(in_nmethod ? rsp : rbp, Address(thread_reg, JavaThread::polling_word_offset()));\n@@ -2814,1 +2815,1 @@\n-  testb(Address(thread_reg, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  testb(Address(thread_reg, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1417,1 +1417,1 @@\n-      Assembler::vinserti32x4(dst, dst, src, imm8);\n+      Assembler::vinserti32x4(dst, nds, src, imm8);\n@@ -1428,1 +1428,1 @@\n-      Assembler::vinserti32x4(dst, dst, src, imm8);\n+      Assembler::vinserti32x4(dst, nds, src, imm8);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -861,1 +862,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2675,1 +2676,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2749,1 +2750,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -2864,1 +2865,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n@@ -3027,1 +3028,1 @@\n-  if (EnableJVMCI || UseAOT) {\n+  if (EnableJVMCI) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7600,0 +7600,12 @@\n+instruct vmaskcast(vec dst) %{\n+  predicate((vector_length(n) == vector_length(n->in(1))) &&\n+            (vector_length_in_bytes(n) == vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vector_mask_cast $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2251,3 +2251,0 @@\n-#if INCLUDE_AOT\n-      CompiledStaticCall::emit_to_aot_stub(cbuf, mark);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4205,1 +4205,2 @@\n-    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\"\n+    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\",\n+    \"VectorMaskCast\"\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -488,2 +488,0 @@\n-  static  bool           needs_polling_address_input();\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,0 +450,1 @@\n+macro(VectorMaskCast)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -290,7 +290,0 @@\n-static inline bool not_a_node(const Node* n) {\n-  if (n == NULL)                   return true;\n-  if (((intptr_t)n & 1) != 0)      return true;  \/\/ uninitialized, etc.\n-  if (*(address*)n == badAddress)  return true;  \/\/ kill by Node::destruct\n-  return false;\n-}\n-\n@@ -556,0 +549,1 @@\n+                  _igv_idx(0),\n@@ -862,0 +856,1 @@\n+    _igv_idx(0),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1394,1 +1394,1 @@\n-  for(uint i4 = 0; i4 < block->_num_succs; i4++ ) {\n+  for (uint i4 = 0; i4 < block->_num_succs; i4++) {\n@@ -1397,2 +1397,4 @@\n-    \/\/ Remove any newly created, but dead, nodes.\n-    for( uint j = new_cnt; j > 0; j-- ) {\n+    \/\/ Remove any newly created, but dead, nodes by traversing their schedule\n+    \/\/ backwards. Here, a dead node is a node whose only outputs (if any) are\n+    \/\/ unused projections.\n+    for (uint j = new_cnt; j > 0; j--) {\n@@ -1400,2 +1402,26 @@\n-      if (n->outcnt() == 0 &&\n-          (!n->is_Proj() || n->as_Proj()->in(0)->outcnt() == 1) ){\n+      \/\/ Individual projections are examined together with all siblings when\n+      \/\/ their parent is visited.\n+      if (n->is_Proj()) {\n+        continue;\n+      }\n+      bool dead = true;\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* out = n->fast_out(i);\n+        \/\/ n is live if it has a non-projection output or a used projection.\n+        if (!out->is_Proj() || out->outcnt() > 0) {\n+          dead = false;\n+          break;\n+        }\n+      }\n+      if (dead) {\n+        \/\/ n's only outputs (if any) are unused projections scheduled next to n\n+        \/\/ (see PhaseCFG::select()). Remove these projections backwards.\n+        for (uint k = j + n->outcnt(); k > j; k--) {\n+          Node* proj = sb->get_node(k);\n+          assert(proj->is_Proj() && proj->in(0) == n,\n+                 \"projection should correspond to dead node\");\n+          proj->disconnect_inputs(C);\n+          sb->remove_node(k);\n+          new_cnt--;\n+        }\n+        \/\/ Now remove the node itself.\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,1 @@\n+  bool inline_math_pow();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -77,1 +77,2 @@\n-#endif\n+  _reused(C->comp_arena()),\n+#endif \/\/ !PRODUCT\n@@ -1101,3 +1102,1 @@\n-#ifdef ASSERT\n-              _new2old_map.map(m->_idx, n);\n-#endif\n+              NOT_PRODUCT(record_new2old(m, n);)\n@@ -1108,3 +1107,1 @@\n-#ifdef ASSERT\n-              _new2old_map.map(m->_idx, n);\n-#endif\n+              NOT_PRODUCT(record_new2old(m, n);)\n@@ -1168,3 +1165,1 @@\n-#ifdef ASSERT\n-          _new2old_map.map(m->_idx, n);\n-#endif\n+          NOT_PRODUCT(record_new2old(m, n));\n@@ -1513,4 +1508,2 @@\n-#ifdef ASSERT\n-  _old2new_map.map(n->_idx, m);\n-  _new2old_map.map(m->_idx, (Node*)n);\n-#endif\n+  \/\/ New-to-old mapping is done in ReduceInst, to cover complex instructions.\n+  NOT_PRODUCT(_old2new_map.map(n->_idx, m);)\n@@ -1773,0 +1766,1 @@\n+  NOT_PRODUCT(record_new2old(mach, leaf);)\n@@ -1841,3 +1835,1 @@\n-#ifdef ASSERT\n-    _new2old_map.map(ex->_idx, s->_leaf);\n-#endif\n+    NOT_PRODUCT(record_new2old(ex, s->_leaf);)\n@@ -2441,1 +2433,11 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n+void Matcher::record_new2old(Node* newn, Node* old) {\n+  _new2old_map.map(newn->_idx, old);\n+  if (!_reused.test_set(old->_igv_idx)) {\n+    \/\/ Reuse the Ideal-level IGV identifier so that the node can be tracked\n+    \/\/ across matching. If there are multiple machine nodes expanded from the\n+    \/\/ same Ideal node, only one will reuse its IGV identifier.\n+    newn->_igv_idx = old->_igv_idx;\n+  }\n+}\n+\n@@ -2446,1 +2448,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -138,2 +138,5 @@\n-  debug_only(Node_Array _old2new_map;)   \/\/ Map roots of ideal-trees to machine-roots\n-  debug_only(Node_Array _new2old_map;)   \/\/ Maps machine nodes back to ideal\n+#ifndef PRODUCT\n+  Node_Array _old2new_map;    \/\/ Map roots of ideal-trees to machine-roots\n+  Node_Array _new2old_map;    \/\/ Maps machine nodes back to ideal\n+  VectorSet _reused;          \/\/ Ideal IGV identifiers reused by machine nodes\n+#endif \/\/ !PRODUCT\n@@ -569,1 +572,4 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n+  \/\/ Record mach-to-Ideal mapping, reusing the Ideal IGV identifier if possible.\n+  void record_new2old(Node* newn, Node* old);\n+\n@@ -575,1 +581,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* current))\n@@ -205,1 +205,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -210,1 +210,1 @@\n-    Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -219,1 +219,1 @@\n-    Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -221,1 +221,1 @@\n-    thread->set_vm_result(result);\n+    current->set_vm_result(result);\n@@ -229,1 +229,1 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n@@ -233,1 +233,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -238,1 +238,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread* current))\n@@ -243,1 +243,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -257,1 +257,1 @@\n-    Handle holder(THREAD, array_type->klass_holder()); \/\/ keep the array klass alive\n+    Handle holder(current, array_type->klass_holder()); \/\/ keep the array klass alive\n@@ -266,2 +266,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(result);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(result);\n@@ -271,1 +271,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -275,1 +275,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread* current))\n@@ -280,1 +280,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -294,2 +294,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(result);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(result);\n@@ -300,1 +300,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -302,1 +302,1 @@\n-  oop result = thread->vm_result();\n+  oop result = current->vm_result();\n@@ -304,1 +304,1 @@\n-      is_deoptimized_caller_frame(thread)) {\n+      is_deoptimized_caller_frame(current)) {\n@@ -324,1 +324,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread* current))\n@@ -328,1 +328,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -333,1 +333,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -335,2 +335,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -340,1 +340,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread* current))\n@@ -344,1 +344,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -350,1 +350,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -352,2 +352,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -357,1 +357,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread* current))\n@@ -361,1 +361,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -368,1 +368,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -370,2 +370,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -375,1 +375,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread* current))\n@@ -379,1 +379,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -387,1 +387,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -389,2 +389,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -393,2 +393,2 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread *thread))\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread* current))\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -405,1 +405,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -407,2 +407,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -411,1 +411,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread* current))\n@@ -418,1 +418,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, false)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, false)) {\n@@ -428,1 +428,1 @@\n-  Handle h_obj(THREAD, obj);\n+  Handle h_obj(current, obj);\n@@ -433,1 +433,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread* current))\n@@ -436,1 +436,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, true)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, true)) {\n@@ -446,1 +446,1 @@\n-  Handle h_obj(THREAD, obj);\n+  Handle h_obj(current, obj);\n@@ -1256,1 +1256,1 @@\n-JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* thread, nmethod* &nm))\n+JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* current, nmethod* &nm))\n@@ -1261,1 +1261,1 @@\n-  assert(thread->exception_oop() != NULL, \"exception oop is found\");\n+  assert(current->exception_oop() != NULL, \"exception oop is found\");\n@@ -1264,2 +1264,2 @@\n-  Handle exception(thread, thread->exception_oop());\n-  address pc = thread->exception_pc();\n+  Handle exception(current, current->exception_oop());\n+  address pc = current->exception_pc();\n@@ -1271,1 +1271,1 @@\n-  thread->clear_exception_oop_and_pc();\n+  current->clear_exception_oop_and_pc();\n@@ -1307,1 +1307,1 @@\n-      deoptimize_caller_frame(thread);\n+      deoptimize_caller_frame(current);\n@@ -1314,1 +1314,1 @@\n-    bool force_unwind = !thread->stack_overflow_state()->reguard_stack();\n+    bool force_unwind = !current->stack_overflow_state()->reguard_stack();\n@@ -1318,2 +1318,2 @@\n-      RegisterMap map(thread, false);\n-      frame deoptee = thread->last_frame().sender(&map);\n+      RegisterMap map(current, false);\n+      frame deoptee = current->last_frame().sender(&map);\n@@ -1356,2 +1356,2 @@\n-    thread->set_exception_pc(pc);\n-    thread->set_exception_handler_pc(handler_address);\n+    current->set_exception_pc(pc);\n+    current->set_exception_handler_pc(handler_address);\n@@ -1360,1 +1360,1 @@\n-    thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -1364,1 +1364,1 @@\n-  thread->set_exception_oop(exception());\n+  current->set_exception_oop(exception());\n@@ -1376,1 +1376,1 @@\n-address OptoRuntime::handle_exception_C(JavaThread* thread) {\n+address OptoRuntime::handle_exception_C(JavaThread* current) {\n@@ -1390,1 +1390,1 @@\n-    handler_address = handle_exception_C_helper(thread, nm);\n+    handler_address = handle_exception_C_helper(current, nm);\n@@ -1399,2 +1399,2 @@\n-    RegisterMap map(thread, false);\n-    frame caller = thread->last_frame().sender(&map);\n+    RegisterMap map(current, false \/* update_map *\/, false \/* process_frames *\/);\n+    frame caller = current->last_frame().sender(&map);\n@@ -1556,1 +1556,1 @@\n-JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* thread))\n+JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* current))\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-  static void new_instance_C(Klass* instance_klass, JavaThread *thread);\n+  static void new_instance_C(Klass* instance_klass, JavaThread* current);\n@@ -161,2 +161,2 @@\n-  static void new_array_C(Klass* array_klass, int len, JavaThread *thread);\n-  static void new_array_nozero_C(Klass* array_klass, int len, JavaThread *thread);\n+  static void new_array_C(Klass* array_klass, int len, JavaThread* current);\n+  static void new_array_nozero_C(Klass* array_klass, int len, JavaThread* current);\n@@ -166,5 +166,5 @@\n-  static void multianewarray2_C(Klass* klass, int len1, int len2, JavaThread *thread);\n-  static void multianewarray3_C(Klass* klass, int len1, int len2, int len3, JavaThread *thread);\n-  static void multianewarray4_C(Klass* klass, int len1, int len2, int len3, int len4, JavaThread *thread);\n-  static void multianewarray5_C(Klass* klass, int len1, int len2, int len3, int len4, int len5, JavaThread *thread);\n-  static void multianewarrayN_C(Klass* klass, arrayOopDesc* dims, JavaThread *thread);\n+  static void multianewarray2_C(Klass* klass, int len1, int len2, JavaThread* current);\n+  static void multianewarray3_C(Klass* klass, int len1, int len2, int len3, JavaThread* current);\n+  static void multianewarray4_C(Klass* klass, int len1, int len2, int len3, int len4, JavaThread* current);\n+  static void multianewarray5_C(Klass* klass, int len1, int len2, int len3, int len4, int len5, JavaThread* current);\n+  static void multianewarrayN_C(Klass* klass, arrayOopDesc* dims, JavaThread* current);\n@@ -177,2 +177,2 @@\n-  static void monitor_notify_C(oopDesc* obj, JavaThread* thread);\n-  static void monitor_notifyAll_C(oopDesc* obj, JavaThread* thread);\n+  static void monitor_notify_C(oopDesc* obj, JavaThread* current);\n+  static void monitor_notifyAll_C(oopDesc* obj, JavaThread* current);\n@@ -186,2 +186,2 @@\n-  static address handle_exception_C       (JavaThread* thread);\n-  static address handle_exception_C_helper(JavaThread* thread, nmethod*& nm);\n+  static address handle_exception_C       (JavaThread* current);\n+  static address handle_exception_C_helper(JavaThread* current, nmethod*& nm);\n@@ -199,1 +199,1 @@\n-  static void register_finalizer(oopDesc* obj, JavaThread* thread);\n+  static void register_finalizer(oopDesc* obj, JavaThread* current);\n@@ -306,8 +306,0 @@\n-  \/\/ leaf on stack replacement interpreter accessor types\n-  static const TypeFunc* fetch_int_Type();\n-  static const TypeFunc* fetch_long_Type();\n-  static const TypeFunc* fetch_float_Type();\n-  static const TypeFunc* fetch_double_Type();\n-  static const TypeFunc* fetch_oop_Type();\n-  static const TypeFunc* fetch_monitor_Type();\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":14,"deletions":22,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1244,0 +1244,11 @@\n+class VectorMaskCastNode : public VectorNode {\n+ public:\n+  VectorMaskCastNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    const TypeVect* in_vt = in->bottom_type()->is_vect();\n+    assert(in_vt->length() == vt->length(), \"vector length must match\");\n+    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()), \"element size must match\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/filemap.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"memory\/filemap.hpp\"\n@@ -50,1 +50,1 @@\n-#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -524,0 +524,2 @@\n+  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -541,0 +543,2 @@\n+  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -807,1 +811,1 @@\n-  if (JVMFlagAccess::boolAtPut(flag, &value, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::set_bool(flag, &value, origin) == JVMFlag::SUCCESS) {\n@@ -822,1 +826,1 @@\n-  if (JVMFlagAccess::doubleAtPut(flag, &v, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::set_double(flag, &v, origin) == JVMFlag::SUCCESS) {\n@@ -854,1 +858,1 @@\n-    return JVMFlagAccess::intAtPut(flag, &int_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_int(flag, &int_v, origin) == JVMFlag::SUCCESS;\n@@ -857,1 +861,1 @@\n-    return JVMFlagAccess::uintAtPut(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uint(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n@@ -863,1 +867,1 @@\n-    return JVMFlagAccess::intxAtPut(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_intx(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n@@ -866,1 +870,1 @@\n-    return JVMFlagAccess::uintxAtPut(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uintx(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n@@ -869,1 +873,1 @@\n-    return JVMFlagAccess::uint64_tAtPut(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uint64_t(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n@@ -872,1 +876,1 @@\n-    return JVMFlagAccess::size_tAtPut(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_size_t(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n@@ -875,1 +879,1 @@\n-    return JVMFlagAccess::doubleAtPut(flag, &double_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_double(flag, &double_v, origin) == JVMFlag::SUCCESS;\n@@ -882,1 +886,1 @@\n-  if (JVMFlagAccess::ccstrAtPut(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::set_ccstr(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n@@ -890,1 +894,1 @@\n-  if (JVMFlagAccess::ccstrAt(flag, &old_value) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::get_ccstr(flag, &old_value) != JVMFlag::SUCCESS) return false;\n@@ -907,1 +911,1 @@\n-  (void) JVMFlagAccess::ccstrAtPut(flag, &value, origin);\n+  (void) JVMFlagAccess::set_ccstr(flag, &value, origin);\n@@ -3117,1 +3121,8 @@\n-  if (ArchiveClassesAtExit == NULL) {\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+    log_info(cds)(\"RecordDynamicDumpInfo is for jcmd only, could not set with -XX:ArchiveClassesAtExit.\");\n+    return JNI_ERR;\n+  }\n+\n+  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n@@ -3119,0 +3130,2 @@\n+  } else {\n+    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n@@ -3120,0 +3133,1 @@\n+\n@@ -3128,15 +3142,0 @@\n-#if !INCLUDE_AOT\n-  UNSUPPORTED_OPTION(UseAOT);\n-  UNSUPPORTED_OPTION(PrintAOT);\n-  UNSUPPORTED_OPTION(UseAOTStrictLoading);\n-  UNSUPPORTED_OPTION_NULL(AOTLibrary);\n-\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTInvocationThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTMinInvocationThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTCompileThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier3AOTBackEdgeThreshold, 0);\n-#ifndef PRODUCT\n-  UNSUPPORTED_OPTION(PrintAOTStatistics);\n-#endif\n-#endif\n-\n@@ -3500,0 +3499,5 @@\n+  } else {\n+    if (SharedDynamicArchivePath != nullptr) {\n+      os::free(SharedDynamicArchivePath);\n+      SharedDynamicArchivePath = nullptr;\n+    }\n@@ -3970,0 +3974,6 @@\n+  if (TraceDependencies && VerifyDependencies) {\n+    if (!FLAG_IS_DEFAULT(TraceDependencies)) {\n+      warning(\"TraceDependencies results may be inflated by VerifyDependencies\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"interpreter\/bytecodeHistogram.hpp\"\n+#include \"code\/vmreg.hpp\"\n@@ -55,3 +55,1 @@\n-  static methodHandle resolve_sub_helper(JavaThread *thread,\n-                                         bool is_virtual,\n-                                         bool is_optimized, TRAPS);\n+  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS);\n@@ -186,2 +184,2 @@\n-  static address raw_exception_handler_for_return_address(JavaThread* thread, address return_address);\n-  static address exception_handler_for_return_address(JavaThread* thread, address return_address);\n+  static address raw_exception_handler_for_return_address(JavaThread* current, address return_address);\n+  static address exception_handler_for_return_address(JavaThread* current, address return_address);\n@@ -197,9 +195,9 @@\n-  static void    throw_AbstractMethodError(JavaThread* thread);\n-  static void    throw_IncompatibleClassChangeError(JavaThread* thread);\n-  static void    throw_ArithmeticException(JavaThread* thread);\n-  static void    throw_NullPointerException(JavaThread* thread);\n-  static void    throw_NullPointerException_at_call(JavaThread* thread);\n-  static void    throw_StackOverflowError(JavaThread* thread);\n-  static void    throw_delayed_StackOverflowError(JavaThread* thread);\n-  static void    throw_StackOverflowError_common(JavaThread* thread, bool delayed);\n-  static address continuation_for_implicit_exception(JavaThread* thread,\n+  static void    throw_AbstractMethodError(JavaThread* current);\n+  static void    throw_IncompatibleClassChangeError(JavaThread* current);\n+  static void    throw_ArithmeticException(JavaThread* current);\n+  static void    throw_NullPointerException(JavaThread* current);\n+  static void    throw_NullPointerException_at_call(JavaThread* current);\n+  static void    throw_StackOverflowError(JavaThread* current);\n+  static void    throw_delayed_StackOverflowError(JavaThread* current);\n+  static void    throw_StackOverflowError_common(JavaThread* current, bool delayed);\n+  static address continuation_for_implicit_exception(JavaThread* current,\n@@ -211,1 +209,1 @@\n-  static void on_slowpath_allocation_exit(JavaThread* thread);\n+  static void on_slowpath_allocation_exit(JavaThread* current);\n@@ -213,2 +211,2 @@\n-  static void enable_stack_reserved_zone(JavaThread* thread);\n-  static frame look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr);\n+  static void enable_stack_reserved_zone(JavaThread* current);\n+  static frame look_for_reserved_stack_annotated_method(JavaThread* current, frame fr);\n@@ -262,2 +260,2 @@\n-  static void throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception);\n-  static void throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message = NULL);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Handle h_exception);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = NULL);\n@@ -319,3 +317,1 @@\n-  static methodHandle resolve_helper(JavaThread *thread,\n-                                     bool is_virtual,\n-                                     bool is_optimized, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, TRAPS);\n@@ -335,1 +331,1 @@\n-  static methodHandle reresolve_call_site(JavaThread *thread, TRAPS);\n+  static methodHandle reresolve_call_site(TRAPS);\n@@ -339,1 +335,1 @@\n-  static methodHandle handle_ic_miss_helper(JavaThread* thread, TRAPS);\n+  static methodHandle handle_ic_miss_helper(TRAPS);\n@@ -342,1 +338,1 @@\n-  static methodHandle find_callee_method(JavaThread* thread, TRAPS);\n+  static methodHandle find_callee_method(TRAPS);\n@@ -349,7 +345,2 @@\n-  static Handle find_callee_info(JavaThread* thread,\n-                                 Bytecodes::Code& bc,\n-                                 CallInfo& callinfo, TRAPS);\n-  static Handle find_callee_info_helper(JavaThread* thread,\n-                                        vframeStream& vfst,\n-                                        Bytecodes::Code& bc,\n-                                        CallInfo& callinfo, TRAPS);\n+  static Handle find_callee_info(Bytecodes::Code& bc, CallInfo& callinfo, TRAPS);\n+  static Handle find_callee_info_helper(vframeStream& vfst, Bytecodes::Code& bc, CallInfo& callinfo, TRAPS);\n@@ -501,2 +492,2 @@\n-  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n+  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n+  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n@@ -505,3 +496,3 @@\n-  static address resolve_static_call_C     (JavaThread *thread);\n-  static address resolve_virtual_call_C    (JavaThread *thread);\n-  static address resolve_opt_virtual_call_C(JavaThread *thread);\n+  static address resolve_static_call_C     (JavaThread* current);\n+  static address resolve_virtual_call_C    (JavaThread* current);\n+  static address resolve_opt_virtual_call_C(JavaThread* current);\n@@ -516,3 +507,3 @@\n-  static address handle_wrong_method(JavaThread* thread);\n-  static address handle_wrong_method_abstract(JavaThread* thread);\n-  static address handle_wrong_method_ic_miss(JavaThread* thread);\n+  static address handle_wrong_method(JavaThread* current);\n+  static address handle_wrong_method_abstract(JavaThread* current);\n+  static address handle_wrong_method_ic_miss(JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":32,"deletions":41,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/filemap.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"classfile\/compactHashtable.hpp\"\n@@ -61,1 +61,0 @@\n-#include \"memory\/filemap.hpp\"\n@@ -303,1 +302,0 @@\n-  AOT_ONLY(nonstatic_field(MethodCounters,     _method,                                       Method*))                              \\\n@@ -1882,0 +1880,1 @@\n+  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n@@ -2148,2 +2147,0 @@\n-  declare_constant(Thread::_external_suspend)                             \\\n-  declare_constant(Thread::_ext_suspended)                                \\\n@@ -2308,1 +2305,0 @@\n-  declare_constant(InstanceKlass::_misc_has_passed_fingerprint_check)     \\\n@@ -2499,1 +2495,0 @@\n-  declare_constant(CompLevel_aot)                                         \\\n@@ -2916,0 +2911,3 @@\n+#ifdef VM_INT_CPU_FEATURE_CONSTANTS\n+  VM_INT_CPU_FEATURE_CONSTANTS\n+#endif\n@@ -2949,0 +2947,3 @@\n+#ifdef VM_LONG_CPU_FEATURE_CONSTANTS\n+  VM_LONG_CPU_FEATURE_CONSTANTS\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -919,1 +919,1 @@\n-        elif not self._isPredicated and (name == \"and\" or name == \"eor\" or name == \"orr\"):\n+        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\"]):\n@@ -1677,0 +1677,1 @@\n+                       [\"bic\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -968,0 +968,1 @@\n+<<<<<<< HEAD\n@@ -981,0 +982,14 @@\n+=======\n+    __ sve_bic(z8, z20, z16);                          \/\/       bic     z8.d, z20.d, z16.d\n+\n+\/\/ SVEReductionOp\n+    __ sve_andv(v15, __ S, p1, z4);                    \/\/       andv s15, p1, z4.s\n+    __ sve_orv(v8, __ B, p1, z29);                     \/\/       orv b8, p1, z29.b\n+    __ sve_eorv(v28, __ D, p4, z29);                   \/\/       eorv d28, p4, z29.d\n+    __ sve_smaxv(v9, __ H, p3, z2);                    \/\/       smaxv h9, p3, z2.h\n+    __ sve_sminv(v28, __ B, p0, z7);                   \/\/       sminv b28, p0, z7.b\n+    __ sve_fminv(v26, __ S, p5, z17);                  \/\/       fminv s26, p5, z17.s\n+    __ sve_fmaxv(v8, __ D, p4, z21);                   \/\/       fmaxv d8, p4, z21.d\n+    __ sve_fadda(v5, __ D, p5, z21);                   \/\/       fadda d5, p5, d5, z21.d\n+    __ sve_uaddv(v22, __ S, p4, z29);                  \/\/       uaddv d22, p4, z29.s\n+>>>>>>> master\n@@ -999,0 +1014,1 @@\n+<<<<<<< HEAD\n@@ -1006,0 +1022,9 @@\n+=======\n+    0x14000000,     0x17ffffd7,     0x140002e1,     0x94000000,\n+    0x97ffffd4,     0x940002de,     0x3400000a,     0x34fffa2a,\n+    0x34005b6a,     0x35000008,     0x35fff9c8,     0x35005b08,\n+    0xb400000b,     0xb4fff96b,     0xb4005aab,     0xb500001d,\n+    0xb5fff91d,     0xb5005a5d,     0x10000013,     0x10fff8b3,\n+    0x100059f3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305976,     0x3758000c,     0x375ff7cc,     0x3758590c,\n+>>>>>>> master\n@@ -1010,0 +1035,1 @@\n+<<<<<<< HEAD\n@@ -1023,0 +1049,15 @@\n+=======\n+    0x540056e0,     0x54000001,     0x54fff541,     0x54005681,\n+    0x54000002,     0x54fff4e2,     0x54005622,     0x54000002,\n+    0x54fff482,     0x540055c2,     0x54000003,     0x54fff423,\n+    0x54005563,     0x54000003,     0x54fff3c3,     0x54005503,\n+    0x54000004,     0x54fff364,     0x540054a4,     0x54000005,\n+    0x54fff305,     0x54005445,     0x54000006,     0x54fff2a6,\n+    0x540053e6,     0x54000007,     0x54fff247,     0x54005387,\n+    0x54000008,     0x54fff1e8,     0x54005328,     0x54000009,\n+    0x54fff189,     0x540052c9,     0x5400000a,     0x54fff12a,\n+    0x5400526a,     0x5400000b,     0x54fff0cb,     0x5400520b,\n+    0x5400000c,     0x54fff06c,     0x540051ac,     0x5400000d,\n+    0x54fff00d,     0x5400514d,     0x5400000e,     0x54ffefae,\n+    0x540050ee,     0x5400000f,     0x54ffef4f,     0x5400508f,\n+>>>>>>> master\n@@ -1054,0 +1095,1 @@\n+<<<<<<< HEAD\n@@ -1055,0 +1097,3 @@\n+=======\n+    0xbd1b1869,     0x580040db,     0x1800000b,     0xf8945060,\n+>>>>>>> master\n@@ -1196,0 +1241,1 @@\n+<<<<<<< HEAD\n@@ -1200,0 +1246,5 @@\n+=======\n+    0x04613176,     0x04f03288,     0x049a248f,     0x041827a8,\n+    0x04d933bc,     0x04482c49,     0x040a20fc,     0x6587363a,\n+    0x65c632a8,     0x65d836a5,     0x048133b6,\n+>>>>>>> master\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"}]}