{"files":[{"patch":"@@ -2438,1 +2438,1 @@\n-const bool Matcher::match_rule_supported_masked_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -992,1 +992,1 @@\n-const bool Matcher::match_rule_supported_masked_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2155,1 +2155,1 @@\n-const bool Matcher::match_rule_supported_masked_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1545,1 +1545,1 @@\n-const bool Matcher::match_rule_supported_masked_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1819,1 +1819,1 @@\n-const bool Matcher::match_rule_supported_masked_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -821,4 +821,4 @@\n-  do_intrinsic(_VectorBinaryMaskOp, jdk_internal_vm_vector_VectorSupport, vector_binary_mask_op_name, vector_binary_mask_op_sig, F_S)          \\\n-   do_signature(vector_binary_mask_op_sig, \"(ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljava\/lang\/Object;\"        \\\n-                                            \"Ljava\/lang\/Object;Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryMaskOperation;)Ljava\/lang\/Object;\") \\\n-   do_name(vector_binary_mask_op_name,     \"binaryMaskOp\")                                                                                     \\\n+  do_intrinsic(_VectorBinaryMaskedOp, jdk_internal_vm_vector_VectorSupport, vector_binary_masked_op_name, vector_binary_masked_op_sig, F_S)    \\\n+   do_signature(vector_binary_masked_op_sig, \"(ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljava\/lang\/Object;\"      \\\n+                                            \"Ljava\/lang\/Object;Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryMaskedOperation;)Ljava\/lang\/Object;\") \\\n+   do_name(vector_binary_masked_op_name,     \"binaryMaskedOp\")                                                                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -663,1 +663,1 @@\n-  case vmIntrinsics::_VectorBinaryMaskOp:\n+  case vmIntrinsics::_VectorBinaryMaskedOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -636,2 +636,2 @@\n-  case vmIntrinsics::_VectorBinaryMaskOp:\n-    return inline_vector_nary_mask_operation(2);\n+  case vmIntrinsics::_VectorBinaryMaskedOp:\n+    return inline_vector_nary_masked_operation(2);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  bool inline_vector_nary_mask_operation(int n);\n+  bool inline_vector_nary_masked_operation(int n);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-  static const bool match_rule_supported_masked_vector(int opcode, int vlen, BasicType bt);\n+  static const bool match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,3 +381,3 @@\n-\/\/ V binaryMaskOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<?> elementType,\n-\/\/                int length, V v1, V v2, M m,\n-\/\/                BinaryMaskOperation<V, M> defaultImpl) {\n+\/\/ V binaryMaskedOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<?> elementType,\n+\/\/                  int length, V v1, V v2, M m,\n+\/\/                  BinaryMaskedOperation<V, M> defaultImpl) {\n@@ -392,3 +392,3 @@\n-\/\/ V unaryMaskOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<?> elementType,\n-\/\/               int length, V v, M m,\n-\/\/               UnaryMaskOperation<V, M> defaultImpl) {\n+\/\/ V unaryMaskedOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<?> elementType,\n+\/\/                 int length, V v, M m,\n+\/\/                 UnaryMaskedOperation<V, M> defaultImpl) {\n@@ -398,3 +398,3 @@\n-\/\/ V ternaryMaskOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<?> elementType,\n-\/\/                 int length, V v1, V v2, V v3, M m,\n-\/\/                 TernaryMaskOperation<V, M> defaultImpl) {\n+\/\/ V ternaryMaskedOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<?> elementType,\n+\/\/                   int length, V v1, V v2, V v3, M m,\n+\/\/                   TernaryMaskedOperation<V, M> defaultImpl) {\n@@ -402,1 +402,1 @@\n-bool LibraryCallKit::inline_vector_nary_mask_operation(int n) {\n+bool LibraryCallKit::inline_vector_nary_masked_operation(int n) {\n@@ -551,1 +551,1 @@\n-    use_predicate = sopc != 0 && Matcher::match_rule_supported_masked_vector(sopc, num_elem, elem_bt);\n+    use_predicate = sopc != 0 && Matcher::match_rule_supported_vector_masked(sopc, num_elem, elem_bt);\n@@ -1085,1 +1085,1 @@\n-      !Matcher::match_rule_supported_masked_vector(sopc, num_elem, elem_bt)) {\n+      !Matcher::match_rule_supported_vector_masked(sopc, num_elem, elem_bt)) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n-  return StoreNode::Ideal(phase, can_reshape);\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,3 +272,3 @@\n-    V binaryMaskOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass,\n-                   Class<?> elementType, int length, V v1, V v2, M m,\n-                   BinaryMaskOperation<V, M> defaultImpl) {\n+    V binaryMaskedOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass,\n+                     Class<?> elementType, int length, V v1, V v2, M m,\n+                     BinaryMaskedOperation<V, M> defaultImpl) {\n@@ -279,1 +279,1 @@\n-    public interface BinaryMaskOperation<V, M> {\n+    public interface BinaryMaskedOperation<V, M> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -602,11 +602,27 @@\n-        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n-            ByteVector neg = that.lanewise(NEG);\n-            ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-            ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-            return hi.lanewise(OR, lo);\n-        }\n-\n-        if (op == DIV) {\n-            VectorMask<Byte> eqz = that.eq((byte)0);\n-            if (eqz.anyTrue()) {\n-                throw that.divZeroException();\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Byte> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (byte) 0);\n+                that = that.blend((byte) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+            }\n+            if (opKind(op, VO_SHIFT)) {\n+                \/\/ As per shift specification for Java, mask the shift count.\n+                \/\/ This allows the JIT to ignore some ISA details.\n+                that = that.lanewise(AND, SHIFT_MASK);\n+            }\n+            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n+                ByteVector neg = that.lanewise(NEG);\n+                ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+                ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+                return hi.lanewise(OR, lo);\n+            } else if (op == AND_NOT) {\n+                \/\/ FIXME: Support this in the JIT.\n+                that = that.lanewise(NOT);\n+                op = AND;\n+            } else if (op == DIV) {\n+                VectorMask<Byte> eqz = that.eq((byte) 0);\n+                if (eqz.anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n@@ -628,4 +644,0 @@\n-        if (op == ROR || op == ROL) {\n-            return blend(lanewise(op, v), m);\n-        }\n-\n@@ -634,7 +646,4 @@\n-        if (op == DIV) {\n-            VectorMask<Byte> eqz = that.eq((byte)0);\n-            if (eqz.and(m).anyTrue()) {\n-                throw that.divZeroException();\n-            }\n-            \/\/ suppress div\/0 exceptions in unset lanes\n-            that = that.lanewise(NOT, eqz);\n+        VectorSpecies<Byte> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<Byte>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n@@ -642,2 +651,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -645,11 +652,1 @@\n-    abstract\n-    ByteVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Byte> v,\n-                                   VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    ByteVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Byte>> maskType,\n-                                           Vector<Byte> v, VectorMask<Byte> m) {\n-        ByteVector that = (ByteVector) v;\n-        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n@@ -668,1 +665,3 @@\n-            if (op == AND_NOT) {\n+            if (op == ROR || op == ROL) {\n+                return blend(lanewise(op, v), m);\n+            } else if (op == AND_NOT) {\n@@ -672,0 +671,7 @@\n+            } else if (op == DIV) {\n+                VectorMask<Byte> eqz = that.eq((byte)0);\n+                if (eqz.and(m).anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n+                \/\/ suppress div\/0 exceptions in unset lanes\n+                that = that.lanewise(NOT, eqz);\n@@ -674,0 +680,13 @@\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    ByteVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Byte> v,\n+                                   VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    ByteVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Byte>> maskClass,\n+                                           Vector<Byte> v, VectorMask<Byte> m) {\n+        ByteVector that = (ByteVector) v;\n@@ -675,2 +694,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, byte.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, byte.class, length(),\n@@ -678,1 +697,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -708,2 +727,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<ByteVector, VectorMask<Byte>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, ByteVector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<ByteVector, VectorMask<Byte>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, ByteVector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":60,"deletions":41,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -628,10 +628,12 @@\n-        if (op == FIRST_NONZERO) {\n-            \/\/ FIXME: Support this in the JIT.\n-            VectorMask<Long> thisNZ\n-                = this.viewAsIntegralLanes().compare(NE, (long) 0);\n-            that = that.blend((double) 0, thisNZ.cast(vspecies()));\n-            op = OR_UNCHECKED;\n-            \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n-            return this.viewAsIntegralLanes()\n-                .lanewise(op, that.viewAsIntegralLanes())\n-                .viewAsFloatingLanes();\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Long> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (long) 0);\n+                that = that.blend((double) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+                return this.viewAsIntegralLanes()\n+                    .lanewise(op, that.viewAsIntegralLanes())\n+                    .viewAsFloatingLanes();\n+            }\n@@ -652,4 +654,0 @@\n-        if (op == FIRST_NONZERO) {\n-            return blend(lanewise(op, v), m);\n-        }\n-\n@@ -658,0 +656,11 @@\n+        VectorSpecies<Double> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<Double>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n+        }\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                return blend(lanewise(op, v), m);\n+            }\n+        }\n@@ -668,1 +677,1 @@\n-                                           Class<? extends VectorMask<Double>> maskType,\n+                                           Class<? extends VectorMask<Double>> maskClass,\n@@ -672,2 +681,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, double.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, double.class, length(),\n@@ -675,1 +684,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -701,2 +710,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<DoubleVector, VectorMask<Double>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, DoubleVector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<DoubleVector, VectorMask<Double>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, DoubleVector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -628,10 +628,12 @@\n-        if (op == FIRST_NONZERO) {\n-            \/\/ FIXME: Support this in the JIT.\n-            VectorMask<Integer> thisNZ\n-                = this.viewAsIntegralLanes().compare(NE, (int) 0);\n-            that = that.blend((float) 0, thisNZ.cast(vspecies()));\n-            op = OR_UNCHECKED;\n-            \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n-            return this.viewAsIntegralLanes()\n-                .lanewise(op, that.viewAsIntegralLanes())\n-                .viewAsFloatingLanes();\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Integer> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (int) 0);\n+                that = that.blend((float) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+                return this.viewAsIntegralLanes()\n+                    .lanewise(op, that.viewAsIntegralLanes())\n+                    .viewAsFloatingLanes();\n+            }\n@@ -652,4 +654,0 @@\n-        if (op == FIRST_NONZERO) {\n-            return blend(lanewise(op, v), m);\n-        }\n-\n@@ -658,0 +656,11 @@\n+        VectorSpecies<Float> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<Float>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n+        }\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                return blend(lanewise(op, v), m);\n+            }\n+        }\n@@ -668,1 +677,1 @@\n-                                           Class<? extends VectorMask<Float>> maskType,\n+                                           Class<? extends VectorMask<Float>> maskClass,\n@@ -672,2 +681,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, float.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, float.class, length(),\n@@ -675,1 +684,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -701,2 +710,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<FloatVector, VectorMask<Float>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, FloatVector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<FloatVector, VectorMask<Float>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, FloatVector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -602,11 +602,27 @@\n-        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n-            IntVector neg = that.lanewise(NEG);\n-            IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-            IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-            return hi.lanewise(OR, lo);\n-        }\n-\n-        if (op == DIV) {\n-            VectorMask<Integer> eqz = that.eq((int)0);\n-            if (eqz.anyTrue()) {\n-                throw that.divZeroException();\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Integer> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (int) 0);\n+                that = that.blend((int) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+            }\n+            if (opKind(op, VO_SHIFT)) {\n+                \/\/ As per shift specification for Java, mask the shift count.\n+                \/\/ This allows the JIT to ignore some ISA details.\n+                that = that.lanewise(AND, SHIFT_MASK);\n+            }\n+            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n+                IntVector neg = that.lanewise(NEG);\n+                IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+                IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+                return hi.lanewise(OR, lo);\n+            } else if (op == AND_NOT) {\n+                \/\/ FIXME: Support this in the JIT.\n+                that = that.lanewise(NOT);\n+                op = AND;\n+            } else if (op == DIV) {\n+                VectorMask<Integer> eqz = that.eq((int) 0);\n+                if (eqz.anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n@@ -628,4 +644,0 @@\n-        if (op == ROR || op == ROL) {\n-            return blend(lanewise(op, v), m);\n-        }\n-\n@@ -634,7 +646,4 @@\n-        if (op == DIV) {\n-            VectorMask<Integer> eqz = that.eq((int)0);\n-            if (eqz.and(m).anyTrue()) {\n-                throw that.divZeroException();\n-            }\n-            \/\/ suppress div\/0 exceptions in unset lanes\n-            that = that.lanewise(NOT, eqz);\n+        VectorSpecies<Integer> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<Integer>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n@@ -642,2 +651,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -645,11 +652,1 @@\n-    abstract\n-    IntVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Integer> v,\n-                                   VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    IntVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Integer>> maskType,\n-                                           Vector<Integer> v, VectorMask<Integer> m) {\n-        IntVector that = (IntVector) v;\n-        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n@@ -668,1 +665,3 @@\n-            if (op == AND_NOT) {\n+            if (op == ROR || op == ROL) {\n+                return blend(lanewise(op, v), m);\n+            } else if (op == AND_NOT) {\n@@ -672,0 +671,7 @@\n+            } else if (op == DIV) {\n+                VectorMask<Integer> eqz = that.eq((int)0);\n+                if (eqz.and(m).anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n+                \/\/ suppress div\/0 exceptions in unset lanes\n+                that = that.lanewise(NOT, eqz);\n@@ -674,0 +680,13 @@\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    IntVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Integer> v,\n+                                   VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    IntVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Integer>> maskClass,\n+                                           Vector<Integer> v, VectorMask<Integer> m) {\n+        IntVector that = (IntVector) v;\n@@ -675,2 +694,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, int.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, int.class, length(),\n@@ -678,1 +697,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -708,2 +727,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<IntVector, VectorMask<Integer>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, IntVector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<IntVector, VectorMask<Integer>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, IntVector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":60,"deletions":41,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -560,11 +560,27 @@\n-        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n-            LongVector neg = that.lanewise(NEG);\n-            LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-            LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-            return hi.lanewise(OR, lo);\n-        }\n-\n-        if (op == DIV) {\n-            VectorMask<Long> eqz = that.eq((long)0);\n-            if (eqz.anyTrue()) {\n-                throw that.divZeroException();\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Long> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (long) 0);\n+                that = that.blend((long) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+            }\n+            if (opKind(op, VO_SHIFT)) {\n+                \/\/ As per shift specification for Java, mask the shift count.\n+                \/\/ This allows the JIT to ignore some ISA details.\n+                that = that.lanewise(AND, SHIFT_MASK);\n+            }\n+            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n+                LongVector neg = that.lanewise(NEG);\n+                LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+                LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+                return hi.lanewise(OR, lo);\n+            } else if (op == AND_NOT) {\n+                \/\/ FIXME: Support this in the JIT.\n+                that = that.lanewise(NOT);\n+                op = AND;\n+            } else if (op == DIV) {\n+                VectorMask<Long> eqz = that.eq((long) 0);\n+                if (eqz.anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n@@ -586,4 +602,0 @@\n-        if (op == ROR || op == ROL) {\n-            return blend(lanewise(op, v), m);\n-        }\n-\n@@ -592,7 +604,4 @@\n-        if (op == DIV) {\n-            VectorMask<Long> eqz = that.eq((long)0);\n-            if (eqz.and(m).anyTrue()) {\n-                throw that.divZeroException();\n-            }\n-            \/\/ suppress div\/0 exceptions in unset lanes\n-            that = that.lanewise(NOT, eqz);\n+        VectorSpecies<Long> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<Long>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n@@ -600,2 +609,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -603,11 +610,1 @@\n-    abstract\n-    LongVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Long> v,\n-                                   VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    LongVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Long>> maskType,\n-                                           Vector<Long> v, VectorMask<Long> m) {\n-        LongVector that = (LongVector) v;\n-        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n@@ -626,1 +623,3 @@\n-            if (op == AND_NOT) {\n+            if (op == ROR || op == ROL) {\n+                return blend(lanewise(op, v), m);\n+            } else if (op == AND_NOT) {\n@@ -630,0 +629,7 @@\n+            } else if (op == DIV) {\n+                VectorMask<Long> eqz = that.eq((long)0);\n+                if (eqz.and(m).anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n+                \/\/ suppress div\/0 exceptions in unset lanes\n+                that = that.lanewise(NOT, eqz);\n@@ -632,0 +638,13 @@\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    LongVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Long> v,\n+                                   VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    LongVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Long>> maskClass,\n+                                           Vector<Long> v, VectorMask<Long> m) {\n+        LongVector that = (LongVector) v;\n@@ -633,2 +652,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, long.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, long.class, length(),\n@@ -636,1 +655,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -666,2 +685,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<LongVector, VectorMask<Long>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, LongVector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<LongVector, VectorMask<Long>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, LongVector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":60,"deletions":41,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -602,11 +602,27 @@\n-        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n-            ShortVector neg = that.lanewise(NEG);\n-            ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-            ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-            return hi.lanewise(OR, lo);\n-        }\n-\n-        if (op == DIV) {\n-            VectorMask<Short> eqz = that.eq((short)0);\n-            if (eqz.anyTrue()) {\n-                throw that.divZeroException();\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<Short> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+                that = that.blend((short) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n+            }\n+            if (opKind(op, VO_SHIFT)) {\n+                \/\/ As per shift specification for Java, mask the shift count.\n+                \/\/ This allows the JIT to ignore some ISA details.\n+                that = that.lanewise(AND, SHIFT_MASK);\n+            }\n+            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n+                ShortVector neg = that.lanewise(NEG);\n+                ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+                ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+                return hi.lanewise(OR, lo);\n+            } else if (op == AND_NOT) {\n+                \/\/ FIXME: Support this in the JIT.\n+                that = that.lanewise(NOT);\n+                op = AND;\n+            } else if (op == DIV) {\n+                VectorMask<Short> eqz = that.eq((short) 0);\n+                if (eqz.anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n@@ -628,4 +644,0 @@\n-        if (op == ROR || op == ROL) {\n-            return blend(lanewise(op, v), m);\n-        }\n-\n@@ -634,7 +646,4 @@\n-        if (op == DIV) {\n-            VectorMask<Short> eqz = that.eq((short)0);\n-            if (eqz.and(m).anyTrue()) {\n-                throw that.divZeroException();\n-            }\n-            \/\/ suppress div\/0 exceptions in unset lanes\n-            that = that.lanewise(NOT, eqz);\n+        VectorSpecies<Short> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<Short>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n@@ -642,2 +651,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -645,11 +652,1 @@\n-    abstract\n-    ShortVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Short> v,\n-                                   VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    ShortVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Short>> maskType,\n-                                           Vector<Short> v, VectorMask<Short> m) {\n-        ShortVector that = (ShortVector) v;\n-        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n@@ -668,1 +665,3 @@\n-            if (op == AND_NOT) {\n+            if (op == ROR || op == ROL) {\n+                return blend(lanewise(op, v), m);\n+            } else if (op == AND_NOT) {\n@@ -672,0 +671,7 @@\n+            } else if (op == DIV) {\n+                VectorMask<Short> eqz = that.eq((short)0);\n+                if (eqz.and(m).anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n+                \/\/ suppress div\/0 exceptions in unset lanes\n+                that = that.lanewise(NOT, eqz);\n@@ -674,0 +680,13 @@\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    ShortVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Short> v,\n+                                   VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    ShortVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Short>> maskClass,\n+                                           Vector<Short> v, VectorMask<Short> m) {\n+        ShortVector that = (ShortVector) v;\n@@ -675,2 +694,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, short.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, short.class, length(),\n@@ -678,1 +697,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -708,2 +727,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<ShortVector, VectorMask<Short>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, ShortVector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<ShortVector, VectorMask<Short>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, ShortVector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":60,"deletions":41,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -650,0 +650,7 @@\n+        if (opKind(op, VO_SPECIAL {#if[!FP]? | VO_SHIFT})) {\n+            if (op == FIRST_NONZERO) {\n+                \/\/ FIXME: Support this in the JIT.\n+                VectorMask<$Boxbitstype$> thisNZ\n+                    = this.viewAsIntegralLanes().compare(NE, ($bitstype$) 0);\n+                that = that.blend(($type$) 0, thisNZ.cast(vspecies()));\n+                op = OR_UNCHECKED;\n@@ -651,11 +658,4 @@\n-        if (op == FIRST_NONZERO) {\n-            \/\/ FIXME: Support this in the JIT.\n-            VectorMask<$Boxbitstype$> thisNZ\n-                = this.viewAsIntegralLanes().compare(NE, ($bitstype$) 0);\n-            that = that.blend(($type$) 0, thisNZ.cast(vspecies()));\n-            op = OR_UNCHECKED;\n-            \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n-            return this.viewAsIntegralLanes()\n-                .lanewise(op, that.viewAsIntegralLanes())\n-                .viewAsFloatingLanes();\n-        }\n+                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+                return this.viewAsIntegralLanes()\n+                    .lanewise(op, that.viewAsIntegralLanes())\n+                    .viewAsFloatingLanes();\n@@ -663,0 +663,1 @@\n+            }\n@@ -664,11 +665,21 @@\n-        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n-            $abstractvectortype$ neg = that.lanewise(NEG);\n-            $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-            $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-            return hi.lanewise(OR, lo);\n-        }\n-\n-        if (op == DIV) {\n-            VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n-            if (eqz.anyTrue()) {\n-                throw that.divZeroException();\n+#if[!FP]\n+            if (opKind(op, VO_SHIFT)) {\n+                \/\/ As per shift specification for Java, mask the shift count.\n+                \/\/ This allows the JIT to ignore some ISA details.\n+                that = that.lanewise(AND, SHIFT_MASK);\n+            }\n+#end[!FP]\n+            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n+                $abstractvectortype$ neg = that.lanewise(NEG);\n+                $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+                $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+                return hi.lanewise(OR, lo);\n+            } else if (op == AND_NOT) {\n+                \/\/ FIXME: Support this in the JIT.\n+                that = that.lanewise(NOT);\n+                op = AND;\n+            } else if (op == DIV) {\n+                VectorMask<$Boxtype$> eqz = that.eq(($type$) 0);\n+                if (eqz.anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n@@ -676,1 +687,0 @@\n-        }\n@@ -678,0 +688,1 @@\n+        }\n@@ -691,11 +702,0 @@\n-#if[BITWISE]\n-        if (op == ROR || op == ROL) {\n-            return blend(lanewise(op, v), m);\n-        }\n-#end[BITWISE]\n-#if[FP]\n-        if (op == FIRST_NONZERO) {\n-            return blend(lanewise(op, v), m);\n-        }\n-#end[FP]\n-\n@@ -704,8 +704,4 @@\n-#if[BITWISE]\n-        if (op == DIV) {\n-            VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n-            if (eqz.and(m).anyTrue()) {\n-                throw that.divZeroException();\n-            }\n-            \/\/ suppress div\/0 exceptions in unset lanes\n-            that = that.lanewise(NOT, eqz);\n+        VectorSpecies<$Boxtype$> maskSpecies =\n+            ((jdk.incubator.vector.VectorMask<$Boxtype$>) m).vectorSpecies();\n+        if (maskSpecies != vspecies()) {\n+            throw AbstractSpecies.checkFailed(maskSpecies, vspecies());\n@@ -713,3 +709,0 @@\n-#end[BITWISE]\n-        return lanewise0(op, that, m);\n-    }\n@@ -717,13 +710,1 @@\n-    abstract\n-    $abstractvectortype$ lanewise0(VectorOperators.Binary op,\n-                                   Vector<$Boxtype$> v,\n-                                   VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    $abstractvectortype$ lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<$Boxtype$>> maskType,\n-                                           Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n-        $abstractvectortype$ that = ($abstractvectortype$) v;\n-#if[BITWISE]\n-        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n-#if[!FP]\n+        if (opKind(op, VO_SPECIAL {#if[!FP]? | VO_SHIFT})) {\n@@ -731,0 +712,3 @@\n+#if[FP]\n+                return blend(lanewise(op, v), m);\n+#else[FP]\n@@ -736,0 +720,1 @@\n+#end[FP]\n@@ -737,0 +722,2 @@\n+#if[BITWISE]\n+#if[!FP]\n@@ -743,1 +730,3 @@\n-            if (op == AND_NOT) {\n+            if (op == ROR || op == ROL) {\n+                return blend(lanewise(op, v), m);\n+            } else if (op == AND_NOT) {\n@@ -747,0 +736,7 @@\n+            } else if (op == DIV) {\n+                VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n+                if (eqz.and(m).anyTrue()) {\n+                    throw that.divZeroException();\n+                }\n+                \/\/ suppress div\/0 exceptions in unset lanes\n+                that = that.lanewise(NOT, eqz);\n@@ -748,1 +744,0 @@\n-        }\n@@ -750,0 +745,14 @@\n+        }\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    $abstractvectortype$ lanewise0(VectorOperators.Binary op,\n+                                   Vector<$Boxtype$> v,\n+                                   VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<$Boxtype$>> maskClass,\n+                                           Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        $abstractvectortype$ that = ($abstractvectortype$) v;\n@@ -751,2 +760,2 @@\n-        return VectorSupport.binaryMaskOp(\n-            opc, getClass(), maskType, $type$.class, length(),\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, $type$.class, length(),\n@@ -754,1 +763,1 @@\n-            BIN_MASK_IMPL.find(op, opc, (opc_) -> {\n+            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n@@ -796,2 +805,2 @@\n-    ImplCache<Binary, BinaryMaskOperation<$abstractvectortype$, VectorMask<$Boxtype$>>> BIN_MASK_IMPL\n-        = new ImplCache<>(Binary.class, $Type$Vector.class);\n+    ImplCache<Binary, BinaryMaskedOperation<$abstractvectortype$, VectorMask<$Boxtype$>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, $Type$Vector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":74,"deletions":65,"binary":false,"changes":139,"status":"modified"}]}