{"files":[{"patch":"@@ -278,2 +278,2 @@\n-    public Byte128Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte128Vector) super.lanewiseTemplate(op, Byte128Mask.class, v, (Byte128Mask) m);  \/\/ specialize\n+    Byte128Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte128Vector) super.lanewise0Template(op, Byte128Mask.class, v, (Byte128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Byte256Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte256Vector) super.lanewiseTemplate(op, Byte256Mask.class, v, (Byte256Mask) m);  \/\/ specialize\n+    Byte256Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte256Vector) super.lanewise0Template(op, Byte256Mask.class, v, (Byte256Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Byte512Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte512Vector) super.lanewiseTemplate(op, Byte512Mask.class, v, (Byte512Mask) m);  \/\/ specialize\n+    Byte512Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte512Vector) super.lanewise0Template(op, Byte512Mask.class, v, (Byte512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Byte64Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte64Vector) super.lanewiseTemplate(op, Byte64Mask.class, v, (Byte64Mask) m);  \/\/ specialize\n+    Byte64Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte64Vector) super.lanewise0Template(op, Byte64Mask.class, v, (Byte64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v, (ByteMaxMask) m);  \/\/ specialize\n+    ByteMaxVector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (ByteMaxVector) super.lanewise0Template(op, ByteMaxMask.class, v, (ByteMaxMask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -595,0 +595,1 @@\n+    @Override\n@@ -599,1 +600,16 @@\n-        return lanewise(op, v, null);\n+        ByteVector that = (ByteVector) v;\n+        that.check(this);\n+        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n+            ByteVector neg = that.lanewise(NEG);\n+            ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+            ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+            return hi.lanewise(OR, lo);\n+        }\n+\n+        if (op == DIV) {\n+            VectorMask<Byte> eqz = that.eq((byte)0);\n+            if (eqz.anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+        }\n+        return lanewise0(op, that, null);\n@@ -607,1 +623,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -610,1 +627,4 @@\n-                                  VectorMask<Byte> m);\n+                                  VectorMask<Byte> m) {\n+        if (op == ROR || op == ROL) {\n+            return blend(lanewise(op, v), m);\n+        }\n@@ -612,0 +632,17 @@\n+        ByteVector that = (ByteVector) v;\n+        that.check(this);\n+        if (op == DIV) {\n+            VectorMask<Byte> eqz = that.eq((byte)0);\n+            if (eqz.and(m).anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+            \/\/ suppress div\/0 exceptions in unset lanes\n+            that = that.lanewise(NOT, eqz);\n+        }\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    ByteVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Byte> v,\n+                                   VectorMask<Byte> m);\n@@ -614,3 +651,3 @@\n-    ByteVector lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<Byte>> maskType,\n-                                          Vector<Byte> v, VectorMask<Byte> m) {\n+    ByteVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Byte>> maskType,\n+                                           Vector<Byte> v, VectorMask<Byte> m) {\n@@ -618,2 +655,1 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n@@ -632,6 +668,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ByteVector neg = that.lanewise(NEG);\n-                ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return m != null ? blend(hi.lanewise(OR, lo), m) : hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -641,13 +672,0 @@\n-            } else if (op == DIV) {\n-                VectorMask<Byte> eqz = that.eq((byte)0);\n-                if (m != null) {\n-                    if (eqz.and(m).anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                    \/\/ suppress div\/0 exceptions in unset lanes\n-                    that = that.lanewise(NOT, eqz);\n-                } else {\n-                    if (eqz.anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                }\n@@ -721,1 +739,7 @@\n-        return lanewise(op, e, null);\n+        if (opKind(op, VO_SHIFT) && (byte)(int)e == e) {\n+            return lanewiseShift(op, (int) e);\n+        }\n+        if (op == AND_NOT) {\n+            op = AND; e = (byte) ~e;\n+        }\n+        return lanewise(op, broadcast(e));\n@@ -750,2 +774,2 @@\n-            ByteVector shift = lanewiseShift(op, (int) e);\n-            return m != null ? blend(shift, m) : shift;\n+            \/\/ TODO: calls masked lanewiseShift() once it is supported\n+            return blend(lanewise(op, e), m);\n@@ -773,1 +797,8 @@\n-        return lanewise(op, e, null);\n+        byte e1 = (byte) e;\n+        if ((long)e1 != e\n+            \/\/ allow shift ops to clip down their int parameters\n+            && !(opKind(op, VO_SHIFT) && (int)e1 == e)\n+            ) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":62,"deletions":31,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Double128Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double128Vector) super.lanewiseTemplate(op, Double128Mask.class, v, (Double128Mask) m);  \/\/ specialize\n+    Double128Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double128Vector) super.lanewise0Template(op, Double128Mask.class, v, (Double128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Double256Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double256Vector) super.lanewiseTemplate(op, Double256Mask.class, v, (Double256Mask) m);  \/\/ specialize\n+    Double256Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double256Vector) super.lanewise0Template(op, Double256Mask.class, v, (Double256Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Double512Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double512Vector) super.lanewiseTemplate(op, Double512Mask.class, v, (Double512Mask) m);  \/\/ specialize\n+    Double512Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double512Vector) super.lanewise0Template(op, Double512Mask.class, v, (Double512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Double64Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double64Vector) super.lanewiseTemplate(op, Double64Mask.class, v, (Double64Mask) m);  \/\/ specialize\n+    Double64Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double64Vector) super.lanewise0Template(op, Double64Mask.class, v, (Double64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  \/\/ specialize\n+    DoubleMaxVector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (DoubleMaxVector) super.lanewise0Template(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+    @Override\n@@ -625,1 +626,14 @@\n-        return lanewise(op, v, null);\n+        DoubleVector that = (DoubleVector) v;\n+        that.check(this);\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME: Support this in the JIT.\n+            VectorMask<Long> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (long) 0);\n+            that = that.blend((double) 0, thisNZ.cast(vspecies()));\n+            op = OR_UNCHECKED;\n+            \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+            return this.viewAsIntegralLanes()\n+                .lanewise(op, that.viewAsIntegralLanes())\n+                .viewAsFloatingLanes();\n+        }\n+        return lanewise0(op, that, null);\n@@ -633,1 +647,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -636,1 +651,4 @@\n-                                  VectorMask<Double> m);\n+                                  VectorMask<Double> m) {\n+        if (op == FIRST_NONZERO) {\n+            return blend(lanewise(op, v), m);\n+        }\n@@ -638,0 +656,9 @@\n+        DoubleVector that = (DoubleVector) v;\n+        that.check(this);\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    DoubleVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Double> v,\n+                                   VectorMask<Double> m);\n@@ -640,3 +667,3 @@\n-    DoubleVector lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<Double>> maskType,\n-                                          Vector<Double> v, VectorMask<Double> m) {\n+    DoubleVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Double>> maskType,\n+                                           Vector<Double> v, VectorMask<Double> m) {\n@@ -644,15 +671,0 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL )) {\n-            if (op == FIRST_NONZERO) {\n-                \/\/ FIXME: Support this in the JIT.\n-                VectorMask<Long> thisNZ\n-                    = this.viewAsIntegralLanes().compare(NE, (long) 0);\n-                that = that.blend((double) 0, thisNZ.cast(vspecies()));\n-                op = OR_UNCHECKED;\n-                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n-                that = this.viewAsIntegralLanes()\n-                    .lanewise(op, that.viewAsIntegralLanes())\n-                    .viewAsFloatingLanes();\n-                return m != null ? blend(that, m) : that;\n-            }\n-        }\n@@ -720,1 +732,1 @@\n-        return lanewise(op, e, null);\n+        return lanewise(op, broadcast(e));\n@@ -765,1 +777,6 @@\n-        return lanewise(op, e, null);\n+        double e1 = (double) e;\n+        if ((long)e1 != e\n+            ) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Float128Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float128Vector) super.lanewiseTemplate(op, Float128Mask.class, v, (Float128Mask) m);  \/\/ specialize\n+    Float128Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float128Vector) super.lanewise0Template(op, Float128Mask.class, v, (Float128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Float256Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float256Vector) super.lanewiseTemplate(op, Float256Mask.class, v, (Float256Mask) m);  \/\/ specialize\n+    Float256Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float256Vector) super.lanewise0Template(op, Float256Mask.class, v, (Float256Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Float512Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float512Vector) super.lanewiseTemplate(op, Float512Mask.class, v, (Float512Mask) m);  \/\/ specialize\n+    Float512Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float512Vector) super.lanewise0Template(op, Float512Mask.class, v, (Float512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Float64Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float64Vector) super.lanewiseTemplate(op, Float64Mask.class, v, (Float64Mask) m);  \/\/ specialize\n+    Float64Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float64Vector) super.lanewise0Template(op, Float64Mask.class, v, (Float64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public FloatMaxVector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v, (FloatMaxMask) m);  \/\/ specialize\n+    FloatMaxVector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (FloatMaxVector) super.lanewise0Template(op, FloatMaxMask.class, v, (FloatMaxMask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+    @Override\n@@ -625,1 +626,14 @@\n-        return lanewise(op, v, null);\n+        FloatVector that = (FloatVector) v;\n+        that.check(this);\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME: Support this in the JIT.\n+            VectorMask<Integer> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (int) 0);\n+            that = that.blend((float) 0, thisNZ.cast(vspecies()));\n+            op = OR_UNCHECKED;\n+            \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+            return this.viewAsIntegralLanes()\n+                .lanewise(op, that.viewAsIntegralLanes())\n+                .viewAsFloatingLanes();\n+        }\n+        return lanewise0(op, that, null);\n@@ -633,1 +647,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -636,1 +651,4 @@\n-                                  VectorMask<Float> m);\n+                                  VectorMask<Float> m) {\n+        if (op == FIRST_NONZERO) {\n+            return blend(lanewise(op, v), m);\n+        }\n@@ -638,0 +656,9 @@\n+        FloatVector that = (FloatVector) v;\n+        that.check(this);\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    FloatVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Float> v,\n+                                   VectorMask<Float> m);\n@@ -640,3 +667,3 @@\n-    FloatVector lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<Float>> maskType,\n-                                          Vector<Float> v, VectorMask<Float> m) {\n+    FloatVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Float>> maskType,\n+                                           Vector<Float> v, VectorMask<Float> m) {\n@@ -644,15 +671,0 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL )) {\n-            if (op == FIRST_NONZERO) {\n-                \/\/ FIXME: Support this in the JIT.\n-                VectorMask<Integer> thisNZ\n-                    = this.viewAsIntegralLanes().compare(NE, (int) 0);\n-                that = that.blend((float) 0, thisNZ.cast(vspecies()));\n-                op = OR_UNCHECKED;\n-                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n-                that = this.viewAsIntegralLanes()\n-                    .lanewise(op, that.viewAsIntegralLanes())\n-                    .viewAsFloatingLanes();\n-                return m != null ? blend(that, m) : that;\n-            }\n-        }\n@@ -720,1 +732,1 @@\n-        return lanewise(op, e, null);\n+        return lanewise(op, broadcast(e));\n@@ -765,1 +777,6 @@\n-        return lanewise(op, e, null);\n+        float e1 = (float) e;\n+        if ((long)e1 != e\n+            ) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Int128Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int128Vector) super.lanewiseTemplate(op, Int128Mask.class, v, (Int128Mask) m);  \/\/ specialize\n+    Int128Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int128Vector) super.lanewise0Template(op, Int128Mask.class, v, (Int128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Int256Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int256Vector) super.lanewiseTemplate(op, Int256Mask.class, v, (Int256Mask) m);  \/\/ specialize\n+    Int256Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int256Vector) super.lanewise0Template(op, Int256Mask.class, v, (Int256Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Int512Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int512Vector) super.lanewiseTemplate(op, Int512Mask.class, v, (Int512Mask) m);  \/\/ specialize\n+    Int512Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int512Vector) super.lanewise0Template(op, Int512Mask.class, v, (Int512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Int64Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int64Vector) super.lanewiseTemplate(op, Int64Mask.class, v, (Int64Mask) m);  \/\/ specialize\n+    Int64Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int64Vector) super.lanewise0Template(op, Int64Mask.class, v, (Int64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public IntMaxVector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v, (IntMaxMask) m);  \/\/ specialize\n+    IntMaxVector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (IntMaxVector) super.lanewise0Template(op, IntMaxMask.class, v, (IntMaxMask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -595,0 +595,1 @@\n+    @Override\n@@ -599,1 +600,16 @@\n-        return lanewise(op, v, null);\n+        IntVector that = (IntVector) v;\n+        that.check(this);\n+        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n+            IntVector neg = that.lanewise(NEG);\n+            IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+            IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+            return hi.lanewise(OR, lo);\n+        }\n+\n+        if (op == DIV) {\n+            VectorMask<Integer> eqz = that.eq((int)0);\n+            if (eqz.anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+        }\n+        return lanewise0(op, that, null);\n@@ -607,1 +623,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -610,1 +627,17 @@\n-                                  VectorMask<Integer> m);\n+                                  VectorMask<Integer> m) {\n+        if (op == ROR || op == ROL) {\n+            return blend(lanewise(op, v), m);\n+        }\n+\n+        IntVector that = (IntVector) v;\n+        that.check(this);\n+        if (op == DIV) {\n+            VectorMask<Integer> eqz = that.eq((int)0);\n+            if (eqz.and(m).anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+            \/\/ suppress div\/0 exceptions in unset lanes\n+            that = that.lanewise(NOT, eqz);\n+        }\n+        return lanewise0(op, that, m);\n+    }\n@@ -612,0 +645,4 @@\n+    abstract\n+    IntVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Integer> v,\n+                                   VectorMask<Integer> m);\n@@ -614,3 +651,3 @@\n-    IntVector lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<Integer>> maskType,\n-                                          Vector<Integer> v, VectorMask<Integer> m) {\n+    IntVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Integer>> maskType,\n+                                           Vector<Integer> v, VectorMask<Integer> m) {\n@@ -618,2 +655,1 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n@@ -632,6 +668,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                IntVector neg = that.lanewise(NEG);\n-                IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return m != null ? blend(hi.lanewise(OR, lo), m) : hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -641,13 +672,0 @@\n-            } else if (op == DIV) {\n-                VectorMask<Integer> eqz = that.eq((int)0);\n-                if (m != null) {\n-                    if (eqz.and(m).anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                    \/\/ suppress div\/0 exceptions in unset lanes\n-                    that = that.lanewise(NOT, eqz);\n-                } else {\n-                    if (eqz.anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                }\n@@ -721,1 +739,7 @@\n-        return lanewise(op, e, null);\n+        if (opKind(op, VO_SHIFT) && (int)(int)e == e) {\n+            return lanewiseShift(op, (int) e);\n+        }\n+        if (op == AND_NOT) {\n+            op = AND; e = (int) ~e;\n+        }\n+        return lanewise(op, broadcast(e));\n@@ -750,2 +774,2 @@\n-            IntVector shift = lanewiseShift(op, (int) e);\n-            return m != null ? blend(shift, m) : shift;\n+            \/\/ TODO: calls masked lanewiseShift() once it is supported\n+            return blend(lanewise(op, e), m);\n@@ -773,1 +797,8 @@\n-        return lanewise(op, e, null);\n+        int e1 = (int) e;\n+        if ((long)e1 != e\n+            \/\/ allow shift ops to clip down their int parameters\n+            && !(opKind(op, VO_SHIFT) && (int)e1 == e)\n+            ) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":62,"deletions":31,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-    public Long128Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long128Vector) super.lanewiseTemplate(op, Long128Mask.class, v, (Long128Mask) m);  \/\/ specialize\n+    Long128Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long128Vector) super.lanewise0Template(op, Long128Mask.class, v, (Long128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-    public Long256Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long256Vector) super.lanewiseTemplate(op, Long256Mask.class, v, (Long256Mask) m);  \/\/ specialize\n+    Long256Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long256Vector) super.lanewise0Template(op, Long256Mask.class, v, (Long256Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-    public Long512Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long512Vector) super.lanewiseTemplate(op, Long512Mask.class, v, (Long512Mask) m);  \/\/ specialize\n+    Long512Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long512Vector) super.lanewise0Template(op, Long512Mask.class, v, (Long512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-    public Long64Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long64Vector) super.lanewiseTemplate(op, Long64Mask.class, v, (Long64Mask) m);  \/\/ specialize\n+    Long64Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long64Vector) super.lanewise0Template(op, Long64Mask.class, v, (Long64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-    public LongMaxVector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v, (LongMaxMask) m);  \/\/ specialize\n+    LongMaxVector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (LongMaxVector) super.lanewise0Template(op, LongMaxMask.class, v, (LongMaxMask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -553,0 +553,1 @@\n+    @Override\n@@ -557,1 +558,16 @@\n-        return lanewise(op, v, null);\n+        LongVector that = (LongVector) v;\n+        that.check(this);\n+        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n+            LongVector neg = that.lanewise(NEG);\n+            LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+            LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+            return hi.lanewise(OR, lo);\n+        }\n+\n+        if (op == DIV) {\n+            VectorMask<Long> eqz = that.eq((long)0);\n+            if (eqz.anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+        }\n+        return lanewise0(op, that, null);\n@@ -565,1 +581,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -568,1 +585,4 @@\n-                                  VectorMask<Long> m);\n+                                  VectorMask<Long> m) {\n+        if (op == ROR || op == ROL) {\n+            return blend(lanewise(op, v), m);\n+        }\n@@ -570,0 +590,17 @@\n+        LongVector that = (LongVector) v;\n+        that.check(this);\n+        if (op == DIV) {\n+            VectorMask<Long> eqz = that.eq((long)0);\n+            if (eqz.and(m).anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+            \/\/ suppress div\/0 exceptions in unset lanes\n+            that = that.lanewise(NOT, eqz);\n+        }\n+        return lanewise0(op, that, m);\n+    }\n+\n+    abstract\n+    LongVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Long> v,\n+                                   VectorMask<Long> m);\n@@ -572,3 +609,3 @@\n-    LongVector lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<Long>> maskType,\n-                                          Vector<Long> v, VectorMask<Long> m) {\n+    LongVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Long>> maskType,\n+                                           Vector<Long> v, VectorMask<Long> m) {\n@@ -576,2 +613,1 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n@@ -590,6 +626,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                LongVector neg = that.lanewise(NEG);\n-                LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return m != null ? blend(hi.lanewise(OR, lo), m) : hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -599,13 +630,0 @@\n-            } else if (op == DIV) {\n-                VectorMask<Long> eqz = that.eq((long)0);\n-                if (m != null) {\n-                    if (eqz.and(m).anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                    \/\/ suppress div\/0 exceptions in unset lanes\n-                    that = that.lanewise(NOT, eqz);\n-                } else {\n-                    if (eqz.anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                }\n@@ -679,1 +697,7 @@\n-        return lanewise(op, e, null);\n+        if (opKind(op, VO_SHIFT) && (long)(int)e == e) {\n+            return lanewiseShift(op, (int) e);\n+        }\n+        if (op == AND_NOT) {\n+            op = AND; e = (long) ~e;\n+        }\n+        return lanewise(op, broadcast(e));\n@@ -708,2 +732,2 @@\n-            LongVector shift = lanewiseShift(op, (int) e);\n-            return m != null ? blend(shift, m) : shift;\n+            \/\/ TODO: calls masked lanewiseShift() once it is supported\n+            return blend(lanewise(op, e), m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":54,"deletions":30,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Short128Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short128Vector) super.lanewiseTemplate(op, Short128Mask.class, v, (Short128Mask) m);  \/\/ specialize\n+    Short128Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short128Vector) super.lanewise0Template(op, Short128Mask.class, v, (Short128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Short256Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short256Vector) super.lanewiseTemplate(op, Short256Mask.class, v, (Short256Mask) m);  \/\/ specialize\n+    Short256Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short256Vector) super.lanewise0Template(op, Short256Mask.class, v, (Short256Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Short512Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short512Vector) super.lanewiseTemplate(op, Short512Mask.class, v, (Short512Mask) m);  \/\/ specialize\n+    Short512Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short512Vector) super.lanewise0Template(op, Short512Mask.class, v, (Short512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public Short64Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short64Vector) super.lanewiseTemplate(op, Short64Mask.class, v, (Short64Mask) m);  \/\/ specialize\n+    Short64Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short64Vector) super.lanewise0Template(op, Short64Mask.class, v, (Short64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-    public ShortMaxVector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v, (ShortMaxMask) m);  \/\/ specialize\n+    ShortMaxVector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (ShortMaxVector) super.lanewise0Template(op, ShortMaxMask.class, v, (ShortMaxMask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -595,0 +595,1 @@\n+    @Override\n@@ -599,1 +600,16 @@\n-        return lanewise(op, v, null);\n+        ShortVector that = (ShortVector) v;\n+        that.check(this);\n+        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n+            ShortVector neg = that.lanewise(NEG);\n+            ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+            ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+            return hi.lanewise(OR, lo);\n+        }\n+\n+        if (op == DIV) {\n+            VectorMask<Short> eqz = that.eq((short)0);\n+            if (eqz.anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+        }\n+        return lanewise0(op, that, null);\n@@ -607,1 +623,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -610,1 +627,17 @@\n-                                  VectorMask<Short> m);\n+                                  VectorMask<Short> m) {\n+        if (op == ROR || op == ROL) {\n+            return blend(lanewise(op, v), m);\n+        }\n+\n+        ShortVector that = (ShortVector) v;\n+        that.check(this);\n+        if (op == DIV) {\n+            VectorMask<Short> eqz = that.eq((short)0);\n+            if (eqz.and(m).anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+            \/\/ suppress div\/0 exceptions in unset lanes\n+            that = that.lanewise(NOT, eqz);\n+        }\n+        return lanewise0(op, that, m);\n+    }\n@@ -612,0 +645,4 @@\n+    abstract\n+    ShortVector lanewise0(VectorOperators.Binary op,\n+                                   Vector<Short> v,\n+                                   VectorMask<Short> m);\n@@ -614,3 +651,3 @@\n-    ShortVector lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<Short>> maskType,\n-                                          Vector<Short> v, VectorMask<Short> m) {\n+    ShortVector lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<Short>> maskType,\n+                                           Vector<Short> v, VectorMask<Short> m) {\n@@ -618,2 +655,1 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL  | VO_SHIFT)) {\n+        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n@@ -632,6 +668,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ShortVector neg = that.lanewise(NEG);\n-                ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return m != null ? blend(hi.lanewise(OR, lo), m) : hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -641,13 +672,0 @@\n-            } else if (op == DIV) {\n-                VectorMask<Short> eqz = that.eq((short)0);\n-                if (m != null) {\n-                    if (eqz.and(m).anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                    \/\/ suppress div\/0 exceptions in unset lanes\n-                    that = that.lanewise(NOT, eqz);\n-                } else {\n-                    if (eqz.anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                }\n@@ -721,1 +739,7 @@\n-        return lanewise(op, e, null);\n+        if (opKind(op, VO_SHIFT) && (short)(int)e == e) {\n+            return lanewiseShift(op, (int) e);\n+        }\n+        if (op == AND_NOT) {\n+            op = AND; e = (short) ~e;\n+        }\n+        return lanewise(op, broadcast(e));\n@@ -750,2 +774,2 @@\n-            ShortVector shift = lanewiseShift(op, (int) e);\n-            return m != null ? blend(shift, m) : shift;\n+            \/\/ TODO: calls masked lanewiseShift() once it is supported\n+            return blend(lanewise(op, e), m);\n@@ -773,1 +797,8 @@\n-        return lanewise(op, e, null);\n+        short e1 = (short) e;\n+        if ((long)e1 != e\n+            \/\/ allow shift ops to clip down their int parameters\n+            && !(opKind(op, VO_SHIFT) && (int)e1 == e)\n+            ) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":62,"deletions":31,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -643,0 +643,1 @@\n+    @Override\n@@ -647,1 +648,31 @@\n-        return lanewise(op, v, null);\n+        $abstractvectortype$ that = ($abstractvectortype$) v;\n+        that.check(this);\n+#if[FP]\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME: Support this in the JIT.\n+            VectorMask<$Boxbitstype$> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, ($bitstype$) 0);\n+            that = that.blend(($type$) 0, thisNZ.cast(vspecies()));\n+            op = OR_UNCHECKED;\n+            \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n+            return this.viewAsIntegralLanes()\n+                .lanewise(op, that.viewAsIntegralLanes())\n+                .viewAsFloatingLanes();\n+        }\n+#end[FP]\n+#if[BITWISE]\n+        if (op == ROR || op == ROL) { \/\/ FIXME: JIT should do this\n+            $abstractvectortype$ neg = that.lanewise(NEG);\n+            $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n+            $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n+            return hi.lanewise(OR, lo);\n+        }\n+\n+        if (op == DIV) {\n+            VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n+            if (eqz.anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+        }\n+#end[BITWISE]\n+        return lanewise0(op, that, null);\n@@ -655,1 +686,2 @@\n-    public abstract\n+    @ForceInline\n+    public final\n@@ -658,1 +690,26 @@\n-                                  VectorMask<$Boxtype$> m);\n+                                  VectorMask<$Boxtype$> m) {\n+#if[BITWISE]\n+        if (op == ROR || op == ROL) {\n+            return blend(lanewise(op, v), m);\n+        }\n+#end[BITWISE]\n+#if[FP]\n+        if (op == FIRST_NONZERO) {\n+            return blend(lanewise(op, v), m);\n+        }\n+#end[FP]\n+\n+        $abstractvectortype$ that = ($abstractvectortype$) v;\n+        that.check(this);\n+#if[BITWISE]\n+        if (op == DIV) {\n+            VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n+            if (eqz.and(m).anyTrue()) {\n+                throw that.divZeroException();\n+            }\n+            \/\/ suppress div\/0 exceptions in unset lanes\n+            that = that.lanewise(NOT, eqz);\n+        }\n+#end[BITWISE]\n+        return lanewise0(op, that, m);\n+    }\n@@ -660,0 +717,4 @@\n+    abstract\n+    $abstractvectortype$ lanewise0(VectorOperators.Binary op,\n+                                   Vector<$Boxtype$> v,\n+                                   VectorMask<$Boxtype$> m);\n@@ -662,3 +723,3 @@\n-    $abstractvectortype$ lanewiseTemplate(VectorOperators.Binary op,\n-                                          Class<? extends VectorMask<$Boxtype$>> maskType,\n-                                          Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+    $abstractvectortype$ lanewise0Template(VectorOperators.Binary op,\n+                                           Class<? extends VectorMask<$Boxtype$>> maskType,\n+                                           Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n@@ -666,2 +727,3 @@\n-        that.check(this);\n-        if (opKind(op, VO_SPECIAL {#if[!FP]? | VO_SHIFT})) {\n+#if[BITWISE]\n+        if (opKind(op, VO_SPECIAL | VO_SHIFT)) {\n+#if[!FP]\n@@ -674,7 +736,0 @@\n-#if[FP]\n-                \/\/ FIXME: Support OR_UNCHECKED on float\/double also!\n-                that = this.viewAsIntegralLanes()\n-                    .lanewise(op, that.viewAsIntegralLanes())\n-                    .viewAsFloatingLanes();\n-                return m != null ? blend(that, m) : that;\n-#end[FP]\n@@ -682,2 +737,0 @@\n-#if[BITWISE]\n-#if[!FP]\n@@ -690,6 +743,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                $abstractvectortype$ neg = that.lanewise(NEG);\n-                $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return m != null ? blend(hi.lanewise(OR, lo), m) : hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -699,13 +747,0 @@\n-            } else if (op == DIV) {\n-                VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n-                if (m != null) {\n-                    if (eqz.and(m).anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                    \/\/ suppress div\/0 exceptions in unset lanes\n-                    that = that.lanewise(NOT, eqz);\n-                } else {\n-                    if (eqz.anyTrue()) {\n-                        throw that.divZeroException();\n-                    }\n-                }\n@@ -713,1 +748,0 @@\n-#end[BITWISE]\n@@ -715,0 +749,1 @@\n+#end[BITWISE]\n@@ -792,1 +827,9 @@\n-        return lanewise(op, e, null);\n+#if[BITWISE]\n+        if (opKind(op, VO_SHIFT) && ($type$)(int)e == e) {\n+            return lanewiseShift(op, (int) e);\n+        }\n+        if (op == AND_NOT) {\n+            op = AND; e = ($type$) ~e;\n+        }\n+#end[BITWISE]\n+        return lanewise(op, broadcast(e));\n@@ -822,2 +865,2 @@\n-            $abstractvectortype$ shift = lanewiseShift(op, (int) e);\n-            return m != null ? blend(shift, m) : shift;\n+            \/\/ TODO: calls masked lanewiseShift() once it is supported\n+            return blend(lanewise(op, e), m);\n@@ -847,1 +890,10 @@\n-        return lanewise(op, e, null);\n+        $type$ e1 = ($type$) e;\n+        if ((long)e1 != e\n+#if[BITWISE]\n+            \/\/ allow shift ops to clip down their int parameters\n+            && !(opKind(op, VO_SHIFT) && (int)e1 == e)\n+#end[BITWISE]\n+            ) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":93,"deletions":41,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -280,2 +280,2 @@\n-    public $vectortype$ lanewise(Binary op, Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n-        return ($vectortype$) super.lanewiseTemplate(op, $masktype$.class, v, ($masktype$) m);  \/\/ specialize\n+    $vectortype$ lanewise0(Binary op, Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        return ($vectortype$) super.lanewise0Template(op, $masktype$.class, v, ($masktype$) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}