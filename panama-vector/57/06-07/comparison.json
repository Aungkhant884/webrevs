{"files":[{"patch":"@@ -117,0 +117,18 @@\n+    @Override\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public\n+    <F> VectorMask<F> check(Class<? extends VectorMask<F>> maskClass, Vector<F> vector) {\n+        if (!sameSpecies(maskClass, vector)) {\n+            throw AbstractSpecies.checkFailed(this, vector);\n+        }\n+        return (VectorMask<F>) this;\n+    }\n+\n+    @ForceInline\n+    private <F> boolean sameSpecies(Class<? extends VectorMask<F>> maskClass, Vector<F> vector) {\n+        boolean same = getClass() == maskClass;\n+        assert (same == (vectorSpecies() == vector.species())) : same;\n+        return same;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -130,11 +130,0 @@\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    \/*package-private*\/ final\n-    <F> AbstractVector<F> check(VectorMask<F> mask) {\n-        VectorSpecies<F> maskSpecies = mask.vectorSpecies();\n-        if (maskSpecies != vspecies()) {\n-            throw AbstractSpecies.checkFailed(mask, this);\n-        }\n-        return (AbstractVector<F>) this;\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Byte128Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte128Vector) super.lanewise0Template(op, Byte128Mask.class, v, (Byte128Mask) m);  \/\/ specialize\n+    public Byte128Vector lanewise(Binary op, Vector<Byte> v) {\n+        return (Byte128Vector) super.lanewiseTemplate(op, Byte128Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte128Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte128Vector) super.lanewiseTemplate(op, Byte128Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Byte256Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte256Vector) super.lanewise0Template(op, Byte256Mask.class, v, (Byte256Mask) m);  \/\/ specialize\n+    public Byte256Vector lanewise(Binary op, Vector<Byte> v) {\n+        return (Byte256Vector) super.lanewiseTemplate(op, Byte256Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte256Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte256Vector) super.lanewiseTemplate(op, Byte256Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Byte512Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte512Vector) super.lanewise0Template(op, Byte512Mask.class, v, (Byte512Mask) m);  \/\/ specialize\n+    public Byte512Vector lanewise(Binary op, Vector<Byte> v) {\n+        return (Byte512Vector) super.lanewiseTemplate(op, Byte512Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte512Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte512Vector) super.lanewiseTemplate(op, Byte512Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Byte64Vector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (Byte64Vector) super.lanewise0Template(op, Byte64Mask.class, v, (Byte64Mask) m);  \/\/ specialize\n+    public Byte64Vector lanewise(Binary op, Vector<Byte> v) {\n+        return (Byte64Vector) super.lanewiseTemplate(op, Byte64Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte64Vector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (Byte64Vector) super.lanewiseTemplate(op, Byte64Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    ByteMaxVector lanewise0(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewise0Template(op, ByteMaxMask.class, v, (ByteMaxMask) m);  \/\/ specialize\n+    public ByteMaxVector lanewise(Binary op, Vector<Byte> v) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -596,2 +596,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -599,1 +598,6 @@\n-                                  Vector<Byte> v) {\n+                                  Vector<Byte> v);\n+    @ForceInline\n+    final\n+    ByteVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Byte>> maskClass,\n+                                          Vector<Byte> v) {\n@@ -602,0 +606,1 @@\n+\n@@ -631,1 +636,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, byte.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, ByteVector::binaryOperations));\n@@ -639,2 +649,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -643,1 +652,6 @@\n-                                  VectorMask<Byte> m) {\n+                                  VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    ByteVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Byte>> maskClass,\n+                                          Vector<Byte> v, VectorMask<Byte> m) {\n@@ -646,1 +660,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -676,2 +690,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -679,10 +691,0 @@\n-    abstract\n-    ByteVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Byte> v,\n-                                   VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    ByteVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Byte>> maskClass,\n-                                           Vector<Byte> v, VectorMask<Byte> m) {\n-        ByteVector that = (ByteVector) v;\n@@ -693,28 +695,1 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n-                case VECTOR_OP_AND: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a & b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a | b));\n-                case VECTOR_OP_XOR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (byte)(a ^ b));\n-                case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (byte)(a << n));\n-                case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (byte)(a >> n));\n-                case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n-                default: return null;\n-                }}));\n+            BIN_MASKED_IMPL.find(op, opc, ByteVector::binaryOperations));\n@@ -722,0 +697,1 @@\n+\n@@ -726,0 +702,30 @@\n+    private static BinaryMaskedOperation<ByteVector, VectorMask<Byte>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (byte)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (byte)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+            default: return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":54,"deletions":48,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Double128Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double128Vector) super.lanewise0Template(op, Double128Mask.class, v, (Double128Mask) m);  \/\/ specialize\n+    public Double128Vector lanewise(Binary op, Vector<Double> v) {\n+        return (Double128Vector) super.lanewiseTemplate(op, Double128Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double128Vector) super.lanewiseTemplate(op, Double128Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Double256Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double256Vector) super.lanewise0Template(op, Double256Mask.class, v, (Double256Mask) m);  \/\/ specialize\n+    public Double256Vector lanewise(Binary op, Vector<Double> v) {\n+        return (Double256Vector) super.lanewiseTemplate(op, Double256Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double256Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double256Vector) super.lanewiseTemplate(op, Double256Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Double512Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double512Vector) super.lanewise0Template(op, Double512Mask.class, v, (Double512Mask) m);  \/\/ specialize\n+    public Double512Vector lanewise(Binary op, Vector<Double> v) {\n+        return (Double512Vector) super.lanewiseTemplate(op, Double512Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double512Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double512Vector) super.lanewiseTemplate(op, Double512Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Double64Vector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (Double64Vector) super.lanewise0Template(op, Double64Mask.class, v, (Double64Mask) m);  \/\/ specialize\n+    public Double64Vector lanewise(Binary op, Vector<Double> v) {\n+        return (Double64Vector) super.lanewiseTemplate(op, Double64Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double64Vector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (Double64Vector) super.lanewiseTemplate(op, Double64Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    DoubleMaxVector lanewise0(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewise0Template(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  \/\/ specialize\n+    public DoubleMaxVector lanewise(Binary op, Vector<Double> v) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -622,2 +622,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -625,1 +624,6 @@\n-                                  Vector<Double> v) {\n+                                  Vector<Double> v);\n+    @ForceInline\n+    final\n+    DoubleVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Double>> maskClass,\n+                                          Vector<Double> v) {\n@@ -628,0 +632,1 @@\n+\n@@ -641,1 +646,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, double.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, DoubleVector::binaryOperations));\n@@ -649,2 +659,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -653,1 +662,6 @@\n-                                  VectorMask<Double> m) {\n+                                  VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    DoubleVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Double>> maskClass,\n+                                          Vector<Double> v, VectorMask<Double> m) {\n@@ -656,1 +670,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -663,2 +677,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -666,10 +678,0 @@\n-    abstract\n-    DoubleVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Double> v,\n-                                   VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    DoubleVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Double>> maskClass,\n-                                           Vector<Double> v, VectorMask<Double> m) {\n-        DoubleVector that = (DoubleVector) v;\n@@ -680,24 +682,1 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n-                case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n-                case VECTOR_OP_POW: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n-                case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n-                default: return null;\n-                }}));\n+            BIN_MASKED_IMPL.find(op, opc, DoubleVector::binaryOperations));\n@@ -705,0 +684,1 @@\n+\n@@ -709,0 +689,26 @@\n+    private static BinaryMaskedOperation<DoubleVector, VectorMask<Double>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n+            default: return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":50,"deletions":44,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Float128Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float128Vector) super.lanewise0Template(op, Float128Mask.class, v, (Float128Mask) m);  \/\/ specialize\n+    public Float128Vector lanewise(Binary op, Vector<Float> v) {\n+        return (Float128Vector) super.lanewiseTemplate(op, Float128Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float128Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float128Vector) super.lanewiseTemplate(op, Float128Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Float256Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float256Vector) super.lanewise0Template(op, Float256Mask.class, v, (Float256Mask) m);  \/\/ specialize\n+    public Float256Vector lanewise(Binary op, Vector<Float> v) {\n+        return (Float256Vector) super.lanewiseTemplate(op, Float256Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float256Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float256Vector) super.lanewiseTemplate(op, Float256Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Float512Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float512Vector) super.lanewise0Template(op, Float512Mask.class, v, (Float512Mask) m);  \/\/ specialize\n+    public Float512Vector lanewise(Binary op, Vector<Float> v) {\n+        return (Float512Vector) super.lanewiseTemplate(op, Float512Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float512Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float512Vector) super.lanewiseTemplate(op, Float512Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Float64Vector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (Float64Vector) super.lanewise0Template(op, Float64Mask.class, v, (Float64Mask) m);  \/\/ specialize\n+    public Float64Vector lanewise(Binary op, Vector<Float> v) {\n+        return (Float64Vector) super.lanewiseTemplate(op, Float64Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float64Vector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (Float64Vector) super.lanewiseTemplate(op, Float64Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    FloatMaxVector lanewise0(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewise0Template(op, FloatMaxMask.class, v, (FloatMaxMask) m);  \/\/ specialize\n+    public FloatMaxVector lanewise(Binary op, Vector<Float> v) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -622,2 +622,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -625,1 +624,6 @@\n-                                  Vector<Float> v) {\n+                                  Vector<Float> v);\n+    @ForceInline\n+    final\n+    FloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Float>> maskClass,\n+                                          Vector<Float> v) {\n@@ -628,0 +632,1 @@\n+\n@@ -641,1 +646,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, float.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, FloatVector::binaryOperations));\n@@ -649,2 +659,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -653,1 +662,6 @@\n-                                  VectorMask<Float> m) {\n+                                  VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    FloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Float>> maskClass,\n+                                          Vector<Float> v, VectorMask<Float> m) {\n@@ -656,1 +670,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -663,2 +677,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -666,10 +678,0 @@\n-    abstract\n-    FloatVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Float> v,\n-                                   VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    FloatVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Float>> maskClass,\n-                                           Vector<Float> v, VectorMask<Float> m) {\n-        FloatVector that = (FloatVector) v;\n@@ -680,24 +682,1 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n-                case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n-                case VECTOR_OP_POW: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n-                case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n-                default: return null;\n-                }}));\n+            BIN_MASKED_IMPL.find(op, opc, FloatVector::binaryOperations));\n@@ -705,0 +684,1 @@\n+\n@@ -709,0 +689,26 @@\n+    private static BinaryMaskedOperation<FloatVector, VectorMask<Float>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n+            default: return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":50,"deletions":44,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Int128Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int128Vector) super.lanewise0Template(op, Int128Mask.class, v, (Int128Mask) m);  \/\/ specialize\n+    public Int128Vector lanewise(Binary op, Vector<Integer> v) {\n+        return (Int128Vector) super.lanewiseTemplate(op, Int128Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int128Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int128Vector) super.lanewiseTemplate(op, Int128Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Int256Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int256Vector) super.lanewise0Template(op, Int256Mask.class, v, (Int256Mask) m);  \/\/ specialize\n+    public Int256Vector lanewise(Binary op, Vector<Integer> v) {\n+        return (Int256Vector) super.lanewiseTemplate(op, Int256Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int256Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int256Vector) super.lanewiseTemplate(op, Int256Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Int512Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int512Vector) super.lanewise0Template(op, Int512Mask.class, v, (Int512Mask) m);  \/\/ specialize\n+    public Int512Vector lanewise(Binary op, Vector<Integer> v) {\n+        return (Int512Vector) super.lanewiseTemplate(op, Int512Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int512Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int512Vector) super.lanewiseTemplate(op, Int512Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Int64Vector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (Int64Vector) super.lanewise0Template(op, Int64Mask.class, v, (Int64Mask) m);  \/\/ specialize\n+    public Int64Vector lanewise(Binary op, Vector<Integer> v) {\n+        return (Int64Vector) super.lanewiseTemplate(op, Int64Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int64Vector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (Int64Vector) super.lanewiseTemplate(op, Int64Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    IntMaxVector lanewise0(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewise0Template(op, IntMaxMask.class, v, (IntMaxMask) m);  \/\/ specialize\n+    public IntMaxVector lanewise(Binary op, Vector<Integer> v) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -596,2 +596,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -599,1 +598,6 @@\n-                                  Vector<Integer> v) {\n+                                  Vector<Integer> v);\n+    @ForceInline\n+    final\n+    IntVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Integer>> maskClass,\n+                                          Vector<Integer> v) {\n@@ -602,0 +606,1 @@\n+\n@@ -631,1 +636,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, int.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, IntVector::binaryOperations));\n@@ -639,2 +649,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -643,1 +652,6 @@\n-                                  VectorMask<Integer> m) {\n+                                  VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    IntVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Integer>> maskClass,\n+                                          Vector<Integer> v, VectorMask<Integer> m) {\n@@ -646,1 +660,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -676,2 +690,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -679,10 +691,0 @@\n-    abstract\n-    IntVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Integer> v,\n-                                   VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    IntVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Integer>> maskClass,\n-                                           Vector<Integer> v, VectorMask<Integer> m) {\n-        IntVector that = (IntVector) v;\n@@ -693,28 +695,1 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n-                case VECTOR_OP_AND: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a & b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a | b));\n-                case VECTOR_OP_XOR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (int)(a ^ b));\n-                case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (int)(a << n));\n-                case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (int)(a >> n));\n-                case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n-                default: return null;\n-                }}));\n+            BIN_MASKED_IMPL.find(op, opc, IntVector::binaryOperations));\n@@ -722,0 +697,1 @@\n+\n@@ -726,0 +702,30 @@\n+    private static BinaryMaskedOperation<IntVector, VectorMask<Integer>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (int)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (int)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+            default: return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":54,"deletions":48,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -273,2 +273,8 @@\n-    Long128Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long128Vector) super.lanewise0Template(op, Long128Mask.class, v, (Long128Mask) m);  \/\/ specialize\n+    public Long128Vector lanewise(Binary op, Vector<Long> v) {\n+        return (Long128Vector) super.lanewiseTemplate(op, Long128Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long128Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long128Vector) super.lanewiseTemplate(op, Long128Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,2 +273,8 @@\n-    Long256Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long256Vector) super.lanewise0Template(op, Long256Mask.class, v, (Long256Mask) m);  \/\/ specialize\n+    public Long256Vector lanewise(Binary op, Vector<Long> v) {\n+        return (Long256Vector) super.lanewiseTemplate(op, Long256Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long256Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long256Vector) super.lanewiseTemplate(op, Long256Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,2 +273,8 @@\n-    Long512Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long512Vector) super.lanewise0Template(op, Long512Mask.class, v, (Long512Mask) m);  \/\/ specialize\n+    public Long512Vector lanewise(Binary op, Vector<Long> v) {\n+        return (Long512Vector) super.lanewiseTemplate(op, Long512Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long512Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long512Vector) super.lanewiseTemplate(op, Long512Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,2 +273,8 @@\n-    Long64Vector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (Long64Vector) super.lanewise0Template(op, Long64Mask.class, v, (Long64Mask) m);  \/\/ specialize\n+    public Long64Vector lanewise(Binary op, Vector<Long> v) {\n+        return (Long64Vector) super.lanewiseTemplate(op, Long64Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long64Vector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (Long64Vector) super.lanewiseTemplate(op, Long64Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,2 +273,8 @@\n-    LongMaxVector lanewise0(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewise0Template(op, LongMaxMask.class, v, (LongMaxMask) m);  \/\/ specialize\n+    public LongMaxVector lanewise(Binary op, Vector<Long> v) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -554,2 +554,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -557,1 +556,6 @@\n-                                  Vector<Long> v) {\n+                                  Vector<Long> v);\n+    @ForceInline\n+    final\n+    LongVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Long>> maskClass,\n+                                          Vector<Long> v) {\n@@ -560,0 +564,1 @@\n+\n@@ -589,1 +594,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, long.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, LongVector::binaryOperations));\n@@ -597,2 +607,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -601,1 +610,6 @@\n-                                  VectorMask<Long> m) {\n+                                  VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    LongVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Long>> maskClass,\n+                                          Vector<Long> v, VectorMask<Long> m) {\n@@ -604,1 +618,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -634,2 +648,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -637,10 +649,0 @@\n-    abstract\n-    LongVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Long> v,\n-                                   VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    LongVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Long>> maskClass,\n-                                           Vector<Long> v, VectorMask<Long> m) {\n-        LongVector that = (LongVector) v;\n@@ -651,28 +653,1 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n-                case VECTOR_OP_AND: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a & b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a | b));\n-                case VECTOR_OP_XOR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (long)(a ^ b));\n-                case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (long)(a << n));\n-                case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (long)(a >> n));\n-                case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n-                default: return null;\n-                }}));\n+            BIN_MASKED_IMPL.find(op, opc, LongVector::binaryOperations));\n@@ -680,0 +655,1 @@\n+\n@@ -684,0 +660,30 @@\n+    private static BinaryMaskedOperation<LongVector, VectorMask<Long>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (long)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (long)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+            default: return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":54,"deletions":48,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Short128Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short128Vector) super.lanewise0Template(op, Short128Mask.class, v, (Short128Mask) m);  \/\/ specialize\n+    public Short128Vector lanewise(Binary op, Vector<Short> v) {\n+        return (Short128Vector) super.lanewiseTemplate(op, Short128Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short128Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short128Vector) super.lanewiseTemplate(op, Short128Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Short256Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short256Vector) super.lanewise0Template(op, Short256Mask.class, v, (Short256Mask) m);  \/\/ specialize\n+    public Short256Vector lanewise(Binary op, Vector<Short> v) {\n+        return (Short256Vector) super.lanewiseTemplate(op, Short256Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short256Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short256Vector) super.lanewiseTemplate(op, Short256Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Short512Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short512Vector) super.lanewise0Template(op, Short512Mask.class, v, (Short512Mask) m);  \/\/ specialize\n+    public Short512Vector lanewise(Binary op, Vector<Short> v) {\n+        return (Short512Vector) super.lanewiseTemplate(op, Short512Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short512Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short512Vector) super.lanewiseTemplate(op, Short512Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    Short64Vector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (Short64Vector) super.lanewise0Template(op, Short64Mask.class, v, (Short64Mask) m);  \/\/ specialize\n+    public Short64Vector lanewise(Binary op, Vector<Short> v) {\n+        return (Short64Vector) super.lanewiseTemplate(op, Short64Mask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (Short64Vector) super.lanewiseTemplate(op, Short64Mask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -278,2 +278,8 @@\n-    ShortMaxVector lanewise0(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewise0Template(op, ShortMaxMask.class, v, (ShortMaxMask) m);  \/\/ specialize\n+    public ShortMaxVector lanewise(Binary op, Vector<Short> v) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -596,2 +596,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -599,1 +598,6 @@\n-                                  Vector<Short> v) {\n+                                  Vector<Short> v);\n+    @ForceInline\n+    final\n+    ShortVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Short>> maskClass,\n+                                          Vector<Short> v) {\n@@ -602,0 +606,1 @@\n+\n@@ -631,1 +636,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, short.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, ShortVector::binaryOperations));\n@@ -639,2 +649,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -643,1 +652,6 @@\n-                                  VectorMask<Short> m) {\n+                                  VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    ShortVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Short>> maskClass,\n+                                          Vector<Short> v, VectorMask<Short> m) {\n@@ -646,1 +660,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -676,2 +690,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -679,10 +691,0 @@\n-    abstract\n-    ShortVector lanewise0(VectorOperators.Binary op,\n-                                   Vector<Short> v,\n-                                   VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    ShortVector lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<Short>> maskClass,\n-                                           Vector<Short> v, VectorMask<Short> m) {\n-        ShortVector that = (ShortVector) v;\n@@ -693,28 +695,1 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n-                case VECTOR_OP_AND: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a & b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a | b));\n-                case VECTOR_OP_XOR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> (short)(a ^ b));\n-                case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (short)(a << n));\n-                case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (short)(a >> n));\n-                case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n-                default: return null;\n-                }}));\n+            BIN_MASKED_IMPL.find(op, opc, ShortVector::binaryOperations));\n@@ -722,0 +697,1 @@\n+\n@@ -726,0 +702,30 @@\n+    private static BinaryMaskedOperation<ShortVector, VectorMask<Short>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (short)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (short)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+            default: return null;\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":54,"deletions":48,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -556,0 +556,18 @@\n+    \/**\n+     * Checks that this mask has the same class with the given mask class,\n+     * and it has the same species with given vector's species,\n+     * and returns this mask unchanged.\n+     * The effect is similar to this pseudocode:\n+     * {@code getClass() == maskClass &&\n+     *        vectorSpecies() == vector.species()\n+     *        ? this\n+     *        : throw new ClassCastException()}.\n+     *\n+     * @param maskClass the class required for this mask\n+     * @param vector its species required for this mask\n+     * @param <F> the boxed element type of the required species\n+     * @return the same mask\n+     * @throws ClassCastException if the species is wrong\n+     *\/\n+    public abstract <F> VectorMask<F> check(Class<? extends VectorMask<F>> maskClass, Vector<F> vector);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -644,2 +644,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -647,1 +646,6 @@\n-                                  Vector<$Boxtype$> v) {\n+                                  Vector<$Boxtype$> v);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<$Boxtype$>> maskClass,\n+                                          Vector<$Boxtype$> v) {\n@@ -650,0 +654,1 @@\n+\n@@ -689,1 +694,6 @@\n-        return lanewise0(op, that, null);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryMaskedOp(\n+            opc, getClass(), maskClass, $type$.class, length(),\n+            this, that, null,\n+            BIN_MASKED_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n@@ -697,2 +707,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -701,1 +710,6 @@\n-                                  VectorMask<$Boxtype$> m) {\n+                                  VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<$Boxtype$>> maskClass,\n+                                          Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n@@ -704,1 +718,1 @@\n-        check(m);\n+        m.check(maskClass, this);\n@@ -742,2 +756,0 @@\n-        return lanewise0(op, that, m);\n-    }\n@@ -745,10 +757,0 @@\n-    abstract\n-    $abstractvectortype$ lanewise0(VectorOperators.Binary op,\n-                                   Vector<$Boxtype$> v,\n-                                   VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    $abstractvectortype$ lanewise0Template(VectorOperators.Binary op,\n-                                           Class<? extends VectorMask<$Boxtype$>> maskClass,\n-                                           Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n-        $abstractvectortype$ that = ($abstractvectortype$) v;\n@@ -759,14 +761,21 @@\n-            BIN_MASKED_IMPL.find(op, opc, (opc_) -> {\n-              switch (opc_) {\n-                case VECTOR_OP_ADD: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n-                case VECTOR_OP_SUB: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n-                case VECTOR_OP_MUL: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n-                case VECTOR_OP_DIV: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n-                case VECTOR_OP_MAX: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n-                case VECTOR_OP_MIN: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+            BIN_MASKED_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Binary, BinaryMaskedOperation<$abstractvectortype$, VectorMask<$Boxtype$>>>\n+        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, $Type$Vector.class);\n+\n+    private static BinaryMaskedOperation<$abstractvectortype$, VectorMask<$Boxtype$>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n@@ -774,12 +783,12 @@\n-                case VECTOR_OP_AND: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a & b));\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a | b));\n-                case VECTOR_OP_XOR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n-                case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> ($type$)(a << n));\n-                case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> ($type$)(a >> n));\n-                case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -788,8 +797,8 @@\n-                case VECTOR_OP_OR: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n-                case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n-                case VECTOR_OP_POW: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n-                case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n-                        v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n@@ -797,2 +806,2 @@\n-                default: return null;\n-                }}));\n+            default: return null;\n+        }\n@@ -800,3 +809,0 @@\n-    private static final\n-    ImplCache<Binary, BinaryMaskedOperation<$abstractvectortype$, VectorMask<$Boxtype$>>>\n-        BIN_MASKED_IMPL = new ImplCache<>(Binary.class, $Type$Vector.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":65,"deletions":59,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -280,2 +280,8 @@\n-    $vectortype$ lanewise0(Binary op, Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n-        return ($vectortype$) super.lanewise0Template(op, $masktype$.class, v, ($masktype$) m);  \/\/ specialize\n+    public $vectortype$ lanewise(Binary op, Vector<$Boxtype$> v) {\n+        return ($vectortype$) super.lanewiseTemplate(op, $masktype$.class, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public $vectortype$ lanewise(Binary op, Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        return ($vectortype$) super.lanewiseTemplate(op, $masktype$.class, v, m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}