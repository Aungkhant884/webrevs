{"files":[{"patch":"@@ -4861,1 +4861,27 @@\n-void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_bitalg(), \"must support avx512bitalg feature\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x54, (0xC0 | encode));\n+}\n+\n+void Assembler::evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_bitalg(), \"must support avx512bitalg feature\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x54, (0xC0 | encode));\n+}\n+\n+void Assembler::evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4863,1 +4889,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4865,0 +4892,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -4869,1 +4900,1 @@\n-void Assembler::vpopcntq(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4871,1 +4902,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4873,0 +4905,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1868,2 +1868,4 @@\n-  void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpopcntq(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4436,0 +4436,10 @@\n+void C2_MacroAssembler::vbroadcastd(XMMRegister dst, int imm32, Register rtmp, int vec_enc) {\n+  if (VM_Version::supports_avx512vl()) {\n+    movl(rtmp, imm32);\n+    evpbroadcastd(dst, rtmp, vec_enc);\n+  } else {\n+    movl(rtmp, imm32);\n+    movdl(dst, rtmp);\n+    vpbroadcastd(dst, dst, vec_enc);\n+  }\n+}\n@@ -4466,0 +4476,14 @@\n+\n+void C2_MacroAssembler::vector_popcount_byte(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                             XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n+  vbroadcastd(xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n+  vpsrlw(dst, src, 4, vec_enc);\n+  vpand(dst, dst, xtmp1, vec_enc);\n+  vpand(xtmp1, src, xtmp1, vec_enc);\n+  vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp, vec_enc);\n+  vpshufb(xtmp1, xtmp2, xtmp1, vec_enc);\n+  vpshufb(dst, xtmp2, dst, vec_enc);\n+  vpaddb(dst, dst, xtmp1, vec_enc);\n+}\n+\n@@ -4467,52 +4491,44 @@\n-                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                                            int vec_enc) {\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntd(dst, src, vec_enc);\n-  } else {\n-    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp1, rtmp);\n-    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n-    if (Assembler::AVX_512bit == vec_enc) {\n-      evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), false, vec_enc, rtmp);\n-    } else {\n-      vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp);\n-    }\n-    vpand(xtmp3, src, xtmp1, vec_enc);\n-    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpand(dst, dst, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n-    vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n-    vpunpckhdq(dst, xtmp3, xtmp1, vec_enc);\n-    vpsadbw(dst, dst, xtmp1, vec_enc);\n-    vpunpckldq(xtmp2, xtmp3, xtmp1, vec_enc);\n-    vpsadbw(xtmp2, xtmp2, xtmp1, vec_enc);\n-    vpackuswb(dst, xtmp2, dst, vec_enc);\n-  }\n-}\n-\n-void C2_MacroAssembler::vector_popcount_long(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                             XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntq(dst, src, vec_enc);\n-  } else if (vec_enc == Assembler::AVX_512bit) {\n-    assert(VM_Version::supports_avx512bw(), \"\");\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp1, rtmp);\n-    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n-    evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), true, vec_enc, rtmp);\n-    vpandq(xtmp3, src, xtmp1, vec_enc);\n-    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpandq(dst, dst, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n-    vpxorq(xtmp1, xtmp1, xtmp1, vec_enc);\n-    vpsadbw(dst, xtmp3, xtmp1, vec_enc);\n-  } else {\n-    \/\/ We do not see any performance benefit of running\n-    \/\/ above instruction sequence on 256 bit vector which\n-    \/\/ can operate over maximum 4 long elements.\n-    ShouldNotReachHere();\n+                                            XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  \/\/ Following code is as per steps e,f,g and h of above algorithm.\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpunpckhdq(dst, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(dst, dst, xtmp2, vec_enc);\n+  vpunpckldq(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpackuswb(dst, xtmp1, dst, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_short(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                              XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  \/\/ Add the popcount of upper and lower bytes of word.\n+  vbroadcastd(xtmp2, 0x00FF00FF, rtmp, vec_enc);\n+  vpsrlw(dst, xtmp1, 8, vec_enc);\n+  vpand(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpaddw(dst, dst, xtmp1, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_long(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                             XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpsadbw(dst, xtmp1, xtmp2, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_integral(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                 XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  switch(bt) {\n+    case T_INT:\n+      vector_popcount_int(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      vector_popcount_short(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      vector_popcount_byte(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -4520,2 +4536,27 @@\n-  if (bt == T_INT) {\n-    evpmovqd(dst, dst, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                      KRegister mask, bool merge, int vec_enc) {\n+  assert(VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit, \"\");\n+  assert(UsePopCountInstruction, \"\");\n+  switch(bt) {\n+    case T_LONG:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntb(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":95,"deletions":54,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -333,2 +333,1 @@\n-                           XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                           int vec_enc);\n+                           XMMRegister xtmp2, Register rtmp, int vec_enc);\n@@ -336,2 +335,16 @@\n-  void vector_popcount_long(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+  void vector_popcount_long(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                            XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_short(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                             XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_byte(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                            XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_integral(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                     KRegister mask, bool merge, int vec_enc);\n+\n+  void vbroadcastd(XMMRegister dst, int imm32, Register rtmp, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -190,2 +190,5 @@\n-      case Op_PopCountVI: return VM_Version::supports_avx512_vpopcntdq() ? 0 : 50;\n-      case Op_PopCountVL: return VM_Version::supports_avx512_vpopcntdq() ? 0 : 40;\n+      case Op_PopCountVI:\n+        return ((ety == T_INT && VM_Version::supports_avx512_vpopcntdq()) ||\n+           (is_subword_type(ety) && VM_Version::supports_avx512_bitalg())) ? 0 : 50;\n+      case Op_PopCountVL:\n+        return VM_Version::supports_avx512_vpopcntdq() ? 0 : 40;\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4127,1 +4127,1 @@\n-    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+    if (VM_Version::supports_avx2() && (!VM_Version::supports_avx512_vpopcntdq() || !UsePopCountInstruction)) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7795,1 +7795,1 @@\n-    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+    if (VM_Version::supports_avx2() && (!VM_Version::supports_avx512_vpopcntdq() || !UsePopCountInstruction)) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -925,0 +925,1 @@\n+    _features &= ~CPU_AVX512_BITALG;\n@@ -955,0 +956,1 @@\n+      _features &= ~CPU_AVX512_BITALG;\n@@ -1703,1 +1705,1 @@\n-  if (supports_popcnt()) {\n+  if (supports_popcnt() || supports_avx512_vpopcntdq() || supports_avx512_bitalg()) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -365,1 +365,2 @@\n-    decl(GFNI,              \"gfni\",              48) \/* Vector GFNI instructions *\/\n+    decl(GFNI,              \"gfni\",              48) \/* Vector GFNI instructions *\/ \\\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     49) \/* Vector sub-word popcount and bit gather instructions *\/\n@@ -599,0 +600,2 @@\n+        if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_bitalg != 0)\n+          result |= CPU_AVX512_BITALG;\n@@ -905,0 +908,1 @@\n+  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1408,1 +1408,1 @@\n-      if (!UsePopCountInstruction || (UseAVX < 2)) {\n+      if (UseAVX < 2) {\n@@ -1413,1 +1413,1 @@\n-      if (!UsePopCountInstruction || (UseAVX <= 2)) {\n+      if (UseAVX < 2) {\n@@ -1644,0 +1644,5 @@\n+static inline bool is_pop_count_instr_target(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n@@ -1897,9 +1902,5 @@\n-      if (!VM_Version::supports_avx512_vpopcntdq() &&\n-          (vlen == 16) && !VM_Version::supports_avx512bw()) {\n-        return false;\n-      }\n-      break;\n-    case Op_PopCountVL:\n-      if (!VM_Version::supports_avx512_vpopcntdq() &&\n-          ((vlen <= 4) || ((vlen == 8) && !VM_Version::supports_avx512bw()))) {\n-        return false;\n+    case Op_PopCountVL: {\n+        if (!is_pop_count_instr_target(bt) &&\n+            (size_in_bits == 512) && !VM_Version::supports_avx512bw()) {\n+          return false;\n+        }\n@@ -2057,0 +2058,7 @@\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!is_pop_count_instr_target(bt)) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -8622,3 +8630,6 @@\n-\n-instruct vpopcountI_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n+instruct vpopcount_integral_reg_evex(vec dst, vec src) %{\n+  predicate(UsePopCountInstruction &&\n+            ((is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_bitalg()) ||\n+             (is_non_subword_integral_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_vpopcntdq())));\n@@ -8626,1 +8637,3 @@\n-  format %{ \"vector_popcount_int $dst, $src\\t! vector popcount packedI\" %}\n+  match(Set dst (PopCountVL src));\n+  ins_cost(400);\n+  format %{ \"vector_popcount_integral_evex $dst, $src\" %}\n@@ -8628,3 +8641,10 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, k0, true, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n@@ -8635,5 +8655,9 @@\n-instruct vpopcountI(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n-  predicate(!VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVI src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n-  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+instruct vpopcount_integral_reg_evex_masked(vec dst, vec src, kReg mask) %{\n+  predicate(UsePopCountInstruction &&\n+            ((is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_bitalg()) ||\n+             (is_non_subword_integral_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_vpopcntdq())));\n+  match(Set dst (PopCountVI src mask));\n+  match(Set dst (PopCountVL src mask));\n+  format %{ \"vector_popcount_integral_evex_masked $dst, $src, $mask\" %}\n@@ -8641,4 +8665,5 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n-                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, true, vlen_enc);\n@@ -8649,4 +8674,7 @@\n-instruct vpopcountL_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVL src));\n-  format %{ \"vector_popcount_long  $dst, $src\\t! vector popcount packedL\" %}\n+instruct vpopcountI_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp) %{\n+  predicate(!UsePopCountInstruction ||\n+            (!VM_Version::supports_avx512_vpopcntdq() && Matcher::vector_element_basic_type(n->in(1)) == T_INT) ||\n+            (!VM_Version::supports_avx512_bitalg() && is_subword_type(Matcher::vector_element_basic_type(n->in(1)))));\n+  match(Set dst (PopCountVI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n@@ -8654,2 +8682,0 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this, $src);\n@@ -8657,1 +8683,3 @@\n-    __ vector_popcount_long(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_popcount_integral(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                $xtmp2$$XMMRegister, $rtmp$$Register, vlen_enc);\n@@ -8662,2 +8690,2 @@\n-instruct vpopcountL(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n-  predicate(!VM_Version::supports_avx512_vpopcntdq());\n+instruct vpopcountL_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n+  predicate(!UsePopCountInstruction || !VM_Version::supports_avx512_vpopcntdq());\n@@ -8665,1 +8693,1 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n@@ -8668,1 +8696,0 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n@@ -8671,2 +8698,14 @@\n-    __ vector_popcount_long(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n-                            $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                            $xtmp2$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (bt == T_INT) {\n+      if (VM_Version::supports_avx512vl()) {\n+        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else {\n+        assert(VM_Version::supports_avx2(), \"\");\n+        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":79,"deletions":40,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -154,3 +154,1 @@\n-    \/\/ Unimplemented for subword types since bit count changes\n-    \/\/ depending on size of lane (and sign bit).\n-    return (bt == T_INT ? Op_PopCountVI : 0);\n+    return Op_PopCountVI;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -724,0 +724,4 @@\n+inline bool is_non_subword_integral_type(BasicType t) {\n+  return t == T_INT || t == T_LONG;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+        AVX512_BITALG,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}