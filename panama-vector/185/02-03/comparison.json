{"files":[{"patch":"@@ -4864,1 +4864,1 @@\n-void Assembler::vpopcntb(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4866,1 +4866,3 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n@@ -4868,0 +4870,3 @@\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -4872,1 +4877,1 @@\n-void Assembler::vpopcntw(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4874,1 +4879,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4876,0 +4882,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -4880,1 +4890,1 @@\n-void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4882,1 +4892,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4884,0 +4895,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -4888,1 +4903,1 @@\n-void Assembler::vpopcntq(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4890,1 +4905,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4892,0 +4908,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1868,4 +1868,4 @@\n-  void vpopcntb(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpopcntw(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpopcntq(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4436,0 +4436,10 @@\n+void C2_MacroAssembler::vbroadcastd(XMMRegister dst, Register rtmp, int imm32, int vec_enc) {\n+  if (VM_Version::supports_avx512vl()) {\n+    movl(rtmp, imm32);\n+    evpbroadcastd(dst, rtmp, vec_enc);\n+  } else {\n+    movl(rtmp, imm32);\n+    movdl(dst, rtmp);\n+    vpbroadcastd(dst, dst, vec_enc);\n+  }\n+}\n@@ -4466,0 +4476,1 @@\n+\n@@ -4468,22 +4479,7 @@\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntd(dst, src, vec_enc);\n-  } else {\n-    vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n-    vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n-    vpunpckhdq(dst, xtmp1, xtmp2, vec_enc);\n-    vpsadbw(dst, dst, xtmp2, vec_enc);\n-    vpunpckldq(xtmp1, xtmp1, xtmp2, vec_enc);\n-    vpsadbw(xtmp1, xtmp1, xtmp2, vec_enc);\n-    vpackuswb(dst, xtmp1, dst, vec_enc);\n-  }\n-}\n-\n-void C2_MacroAssembler::vbroadcastd(XMMRegister dst, Register rtmp, int imm32, int vec_enc) {\n-  if (VM_Version::supports_avx512vl()) {\n-    movl(rtmp, imm32);\n-    evpbroadcastd(dst, rtmp, vec_enc);\n-  } else {\n-    movl(rtmp, imm32);\n-    movdl(dst, rtmp);\n-    vpbroadcastd(dst, dst, vec_enc);\n-  }\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpunpckhdq(dst, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(dst, dst, xtmp2, vec_enc);\n+  vpunpckldq(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpackuswb(dst, xtmp1, dst, vec_enc);\n@@ -4494,10 +4490,5 @@\n-  if (VM_Version::supports_avx512_bitalg()) {\n-    vpopcntw(dst, src, vec_enc);\n-  } else {\n-    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n-    vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n-    vbroadcastd(xtmp2, rtmp, 0x00FF00FF, vec_enc);\n-    vpsrlw(dst, xtmp1, 8, vec_enc);\n-    vpand(xtmp1, xtmp1, xtmp2, vec_enc);\n-    vpaddw(dst, dst, xtmp1, vec_enc);\n-  }\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  vbroadcastd(xtmp2, rtmp, 0x00FF00FF, vec_enc);\n+  vpsrlw(dst, xtmp1, 8, vec_enc);\n+  vpand(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpaddw(dst, dst, xtmp1, vec_enc);\n@@ -4508,16 +4499,12 @@\n-  if (VM_Version::supports_avx512_bitalg()) {\n-    vpopcntb(dst, src, vec_enc);\n-  } else {\n-    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n-    vbroadcastd(xtmp1, rtmp, 0x0F0F0F0F, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpand(dst, dst, xtmp1, vec_enc);\n-    vpand(xtmp1, src, xtmp1, vec_enc);\n-    vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp, vec_enc);\n-    vpshufb(xtmp1, xtmp2, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(dst, dst, xtmp1, vec_enc);\n-  }\n-}\n-\n-void C2_MacroAssembler::vector_popcount_long(BasicType rbt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+  assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n+  vbroadcastd(xtmp1, rtmp, 0x0F0F0F0F, vec_enc);\n+  vpsrlw(dst, src, 4, vec_enc);\n+  vpand(dst, dst, xtmp1, vec_enc);\n+  vpand(xtmp1, src, xtmp1, vec_enc);\n+  vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp, vec_enc);\n+  vpshufb(xtmp1, xtmp2, xtmp1, vec_enc);\n+  vpshufb(dst, xtmp2, dst, vec_enc);\n+  vpaddb(dst, dst, xtmp1, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_long(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n@@ -4525,3 +4512,1 @@\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntq(dst, src, vec_enc);\n-  } else if (vec_enc == Assembler::AVX_512bit) {\n+  if (vec_enc == Assembler::AVX_512bit) {\n@@ -4537,3 +4522,0 @@\n-  if (rbt == T_INT) {\n-    evpmovqd(dst, dst, vec_enc);\n-  }\n@@ -4560,0 +4542,25 @@\n+void C2_MacroAssembler::vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                      KRegister mask, bool merge, int vec_enc) {\n+  assert(VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit, \"\");\n+  switch(bt) {\n+    case T_LONG:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_SHORT:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_BYTE:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntb(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":61,"deletions":54,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-  void vector_popcount_long(BasicType rbt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+  void vector_popcount_long(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n@@ -339,0 +339,3 @@\n+  void vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                     KRegister mask, bool merge, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2053,0 +2053,13 @@\n+    case Op_PopCountVI:\n+      if ((is_subword_type(bt) && !VM_Version::supports_avx512_bitalg()) ||\n+          ((bt == T_INT) && !VM_Version::supports_avx512_vpopcntdq())) {\n+        return false;\n+      }\n+      return true;\n+\n+    case Op_PopCountVL:\n+      if ((bt == T_LONG) && !VM_Version::supports_avx512_vpopcntdq()) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -8619,3 +8632,6 @@\n-instruct vpopcountI_popcntd(vec dst, vec src) %{\n-  predicate((VM_Version::supports_avx512_vpopcntdq() && Matcher::vector_element_basic_type(n->in(1)) == T_INT) ||\n-            (VM_Version::supports_avx512_bitalg() && is_subword_type(Matcher::vector_element_basic_type(n->in(1)))));\n+instruct vpopcount_integral_reg_evex(vec dst, vec src) %{\n+  predicate((((Matcher::vector_element_basic_type(n->in(1)) == T_INT ||\n+               Matcher::vector_element_basic_type(n->in(1)) == T_LONG)) &&\n+             VM_Version::supports_avx512_vpopcntdq()) ||\n+            (is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+             VM_Version::supports_avx512_bitalg()));\n@@ -8623,1 +8639,3 @@\n-  format %{ \"vector_popcount_int $dst, $src\\t! vector popcount packedI\" %}\n+  match(Set dst (PopCountVL src));\n+  ins_cost(400);\n+  format %{ \"vector_popcount_integral_evex $dst, $src\" %}\n@@ -8626,3 +8644,36 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_integral(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, noreg, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, k0, true, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vpopcount_integral_reg_evex_masked(vec dst, vec src, kReg mask) %{\n+  predicate((((Matcher::vector_element_basic_type(n->in(1)) == T_INT ||\n+               Matcher::vector_element_basic_type(n->in(1)) == T_LONG)) &&\n+             VM_Version::supports_avx512_vpopcntdq()) ||\n+            (is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+             VM_Version::supports_avx512_bitalg()));\n+  match(Set dst (PopCountVI src mask));\n+  match(Set dst (PopCountVL src mask));\n+  format %{ \"vector_popcount_integral_evex_masked $dst, $src, $mask\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"not enabled\");\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, true, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n@@ -8633,1 +8684,1 @@\n-instruct vpopcountI(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp, rFlagsReg cc) %{\n+instruct vpopcountI_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp, rFlagsReg cc) %{\n@@ -8649,14 +8700,1 @@\n-instruct vpopcountL_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVL src));\n-  format %{ \"vector_popcount_long  $dst, $src\\t! vector popcount packedL\" %}\n-  ins_encode %{\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this, $src);\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n-    __ vector_popcount_long(rbt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, noreg, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vpopcountL(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n+instruct vpopcountL_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n@@ -8670,2 +8708,2 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n-    __ vector_popcount_long(rbt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n@@ -8673,0 +8711,6 @@\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (bt == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":68,"deletions":24,"binary":false,"changes":92,"status":"modified"}]}