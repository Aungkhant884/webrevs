{"files":[{"patch":"@@ -2388,21 +2388,32 @@\n-  if (EnableVectorReboxing && can_reshape && progress == NULL) {\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-    bool all_inputs_are_equiv_vboxes = true;\n-    for (uint i = 1; i < req(); ++i) {\n-      Node* n = in(i);\n-      if (in(i)->Opcode() != Op_VectorBox) {\n-        all_inputs_are_equiv_vboxes = false;\n-        break;\n-      }\n-      \/\/ Check that vector type of vboxes is equivalent\n-      if (i != 1) {\n-        if (Type::cmp(in(i-0)->in(VectorBoxNode::Value)->bottom_type(),\n-                      in(i-1)->in(VectorBoxNode::Value)->bottom_type()) != 0) {\n-          all_inputs_are_equiv_vboxes = false;\n-          break;\n-        }\n-        if (Type::cmp(in(i-0)->in(VectorBoxNode::Box)->bottom_type(),\n-                      in(i-1)->in(VectorBoxNode::Box)->bottom_type()) != 0) {\n-          all_inputs_are_equiv_vboxes = false;\n-          break;\n+  if (EnableVectorReboxing && can_reshape && progress == NULL && type()->isa_oopptr()) {\n+    progress = merge_through_phi(this, phase->is_IterGVN());\n+  }\n+\n+  return progress;              \/\/ Return any progress\n+}\n+\n+Node* PhiNode::clone_through_phi(Node* root_phi, const Type* t, uint c, PhaseIterGVN* igvn) {\n+  Node_Stack stack(1);\n+  VectorSet  visited;\n+  Node_List  node_map;\n+\n+  stack.push(root_phi, 1); \/\/ ignore control\n+  visited.set(root_phi->_idx);\n+\n+  Node* new_phi = new PhiNode(root_phi->in(0), t);\n+  node_map.map(root_phi->_idx, new_phi);\n+\n+  while (stack.is_nonempty()) {\n+    Node* n   = stack.node();\n+    uint  idx = stack.index();\n+    assert(n->is_Phi(), \"not a phi\");\n+    if (idx < n->req()) {\n+      stack.set_index(idx + 1);\n+      Node* def = n->in(idx);\n+      if (def == NULL) {\n+        continue; \/\/ ignore dead path\n+      } else if (def->is_Phi()) { \/\/ inner node\n+        Node* new_phi = node_map[n->_idx];\n+        if (!visited.test_set(def->_idx)) { \/\/ not visited yet\n+          node_map.map(def->_idx, new PhiNode(def->in(0), t));\n+          stack.push(def, 1); \/\/ ignore control\n@@ -2410,0 +2421,9 @@\n+        Node* new_in = node_map[def->_idx];\n+        new_phi->set_req(idx, new_in);\n+      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+        assert(n->is_Phi(), \"not a phi\");\n+        Node* new_phi = node_map[n->_idx];\n+        new_phi->set_req(idx, def->in(c));\n+      } else {\n+        assert(false, \"not optimizeable\");\n+        return NULL;\n@@ -2411,0 +2431,4 @@\n+    } else {\n+      Node* new_phi = node_map[n->_idx];\n+      igvn->register_new_node_with_optimizer(new_phi, n);\n+      stack.pop();\n@@ -2412,0 +2436,3 @@\n+  }\n+  return new_phi;\n+}\n@@ -2413,8 +2440,34 @@\n-    if (all_inputs_are_equiv_vboxes) {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(in(1));\n-      PhiNode* new_vbox_phi = new PhiNode(r, vbox->box_type());\n-      PhiNode* new_vect_phi = new PhiNode(r, vbox->vec_type());\n-      for (uint i = 1; i < req(); ++i) {\n-        VectorBoxNode* old_vbox = static_cast<VectorBoxNode*>(in(i));\n-        new_vbox_phi->set_req(i, old_vbox->in(VectorBoxNode::Box));\n-        new_vect_phi->set_req(i, old_vbox->in(VectorBoxNode::Value));\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+  Node_Stack stack(1);\n+  VectorSet  visited;\n+\n+  stack.push(root_phi, 1); \/\/ ignore control\n+  visited.set(root_phi->_idx);\n+\n+  VectorBoxNode* cached_vbox = NULL;\n+  while (stack.is_nonempty()) {\n+    Node* n   = stack.node();\n+    uint  idx = stack.index();\n+    if (idx < n->req()) {\n+      stack.set_index(idx + 1);\n+      Node* in = n->in(idx);\n+      if (in == NULL) {\n+        continue; \/\/ ignore dead path\n+      } else if (in->isa_Phi()) {\n+        if (!visited.test_set(in->_idx)) {\n+          stack.push(in, 1); \/\/ ignore control\n+        }\n+      } else if (in->Opcode() == Op_VectorBox) {\n+        VectorBoxNode* vbox = static_cast<VectorBoxNode*>(in);\n+        if (cached_vbox == NULL) {\n+          cached_vbox = vbox;\n+        } else if (vbox->vec_type() != cached_vbox->vec_type()) {\n+          \/\/ TODO: vector type mismatch can be handled with additional reinterpret casts\n+          assert(Type::cmp(vbox->vec_type(), cached_vbox->vec_type()) != 0, \"inconsistent\");\n+          return NULL; \/\/ not optimizable: vector type mismatch\n+        } else if (vbox->box_type() != cached_vbox->box_type()) {\n+          assert(Type::cmp(vbox->box_type(), cached_vbox->box_type()) != 0, \"inconsistent\");\n+          return NULL; \/\/ not optimizable: box type mismatch\n+        }\n+      } else {\n+        return NULL; \/\/ not optimizable: neither Phi nor VectorBox\n@@ -2422,3 +2475,2 @@\n-      igvn->register_new_node_with_optimizer(new_vbox_phi, this);\n-      igvn->register_new_node_with_optimizer(new_vect_phi, this);\n-      progress = new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, vbox->box_type(), vbox->vec_type());\n+    } else {\n+      stack.pop();\n@@ -2427,2 +2479,6 @@\n-\n-  return progress;              \/\/ Return any progress\n+  assert(cached_vbox != NULL, \"sanity\");\n+  const TypeInstPtr* btype = cached_vbox->box_type();\n+  const TypeVect*    vtype = cached_vbox->vec_type();\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n+  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n+  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":90,"deletions":34,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+  static Node* clone_through_phi(Node* root_phi, const Type* t, uint c, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}